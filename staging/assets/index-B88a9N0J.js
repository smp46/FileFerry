(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function t(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(s){if(s.ep)return;s.ep=!0;const i=t(s);fetch(s.href,i)}})();const gh=Symbol.for("@libp2p/connection"),ra=Symbol.for("@libp2p/content-routing"),na=Symbol.for("@libp2p/peer-discovery"),uo=Symbol.for("@libp2p/peer-id");function yl(r){return!!r?.[uo]}const sa=Symbol.for("@libp2p/peer-routing"),ho="keep-alive",fo=Symbol.for("@libp2p/transport");var $r;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})($r||($r={}));let Kt=class extends Error{static name="AbortError";constructor(e="The operation was aborted"){super(e),this.name="AbortError"}};class mh extends Error{static name="UnexpectedPeerError";constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}}let yh=class extends Error{static name="InvalidCryptoExchangeError";constructor(e="Invalid crypto exchange"){super(e),this.name="InvalidCryptoExchangeError"}};class W extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}}class wl extends Error{static name="InvalidPublicKeyError";constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}}class wh extends Error{static name="ConnectionClosingError";constructor(e="The connection is closing"){super(e),this.name="ConnectionClosingError"}}class bl extends Error{static name="ConnectionClosedError";constructor(e="The connection is closed"){super(e),this.name="ConnectionClosedError"}}class vl extends Error{static name="ConnectionFailedError";constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}}class Tr extends Error{static name="MuxerClosedError";constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}}class bh extends Error{static name="StreamResetError";constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}}class Pi extends Error{static name="StreamStateError";constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}}let ki=class extends Error{static name="NotFoundError";constructor(e="Not found"){super(e),this.name="NotFoundError"}};class El extends Error{static name="InvalidPeerIdError";constructor(e="Invalid PeerID"){super(e),this.name="InvalidPeerIdError"}}class po extends Error{static name="InvalidMultiaddrError";constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}}class vh extends Error{static name="InvalidCIDError";constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}}class Eh extends Error{static name="InvalidMultihashError";constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}}class go extends Error{static name="UnsupportedProtocolError";constructor(e="Unsupported protocol error"){super(e),this.name="UnsupportedProtocolError"}}class it extends Error{static name="InvalidMessageError";constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}}class Sh extends Error{static name="ProtocolError";constructor(e="Protocol error"){super(e),this.name="ProtocolError"}}let mo=class extends Error{static name="TimeoutError";constructor(e="Timed out"){super(e),this.name="TimeoutError"}};class $n extends Error{static name="NotStartedError";constructor(e="Not started"){super(e),this.name="NotStartedError"}}class Or extends Error{static name="DialError";constructor(e="Dial error"){super(e),this.name="DialError"}}class _i extends Error{static name="ListenError";constructor(e="Listen error"){super(e),this.name="ListenError"}}class Sl extends Error{static name="LimitedConnectionError";constructor(e="Limited connection"){super(e),this.name="LimitedConnectionError"}}class xh extends Error{static name="TooManyInboundProtocolStreamsError";constructor(e="Too many inbound protocol streams"){super(e),this.name="TooManyInboundProtocolStreamsError"}}class xl extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}}class yo extends Error{static name="UnsupportedKeyTypeError";constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}}class _t extends EventTarget{#e=new Map;constructor(){super()}listenerCount(e){const t=this.#e.get(e);return t==null?0:t.length}addEventListener(e,t,n){super.addEventListener(e,t,n);let s=this.#e.get(e);s==null&&(s=[],this.#e.set(e,s)),s.push({callback:t,once:(n!==!0&&n!==!1&&n?.once)??!1})}removeEventListener(e,t,n){super.removeEventListener(e.toString(),t??null,n);let s=this.#e.get(e);s!=null&&(s=s.filter(({callback:i})=>i!==t),this.#e.set(e,s))}dispatchEvent(e){const t=super.dispatchEvent(e);let n=this.#e.get(e.type);return n==null||(n=n.filter(({once:s})=>!s),this.#e.set(e.type,n)),t}safeDispatchEvent(e,t={}){return this.dispatchEvent(new CustomEvent(e,t))}}function wo(r){return r!=null&&typeof r.start=="function"&&typeof r.stop=="function"}async function Al(...r){const e=[];for(const t of r)wo(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStart!=null&&await t.beforeStart()})),await Promise.all(e.map(async t=>{await t.start()})),await Promise.all(e.map(async t=>{t.afterStart!=null&&await t.afterStart()}))}async function Cl(...r){const e=[];for(const t of r)wo(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStop!=null&&await t.beforeStop()})),await Promise.all(e.map(async t=>{await t.stop()})),await Promise.all(e.map(async t=>{t.afterStop!=null&&await t.afterStop()}))}const et=Symbol.for("@libp2p/service-capabilities"),zn=Symbol.for("@libp2p/service-dependencies");function Ah(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function Ss(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function Ch(r){return new TextEncoder().encode(r)}function Ih(r){return new TextDecoder().decode(r)}function Th(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var s=0;s<r.length;s++){var i=r.charAt(s),o=i.charCodeAt(0);if(t[o]!==255)throw new TypeError(i+" is ambiguous");t[o]=s}var a=r.length,c=r.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function d(f){if(f instanceof Uint8Array||(ArrayBuffer.isView(f)?f=new Uint8Array(f.buffer,f.byteOffset,f.byteLength):Array.isArray(f)&&(f=Uint8Array.from(f))),!(f instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(f.length===0)return"";for(var g=0,m=0,v=0,P=f.length;v!==P&&f[v]===0;)v++,g++;for(var b=(P-v)*u+1>>>0,w=new Uint8Array(b);v!==P;){for(var E=f[v],_=0,x=b-1;(E!==0||_<m)&&x!==-1;x--,_++)E+=256*w[x]>>>0,w[x]=E%a>>>0,E=E/a>>>0;if(E!==0)throw new Error("Non-zero carry");m=_,v++}for(var k=b-m;k!==b&&w[k]===0;)k++;for(var L=c.repeat(g);k<b;++k)L+=r.charAt(w[k]);return L}function h(f){if(typeof f!="string")throw new TypeError("Expected String");if(f.length===0)return new Uint8Array;var g=0;if(f[g]!==" "){for(var m=0,v=0;f[g]===c;)m++,g++;for(var P=(f.length-g)*l+1>>>0,b=new Uint8Array(P);f[g];){var w=t[f.charCodeAt(g)];if(w===255)return;for(var E=0,_=P-1;(w!==0||E<v)&&_!==-1;_--,E++)w+=a*b[_]>>>0,b[_]=w%256>>>0,w=w/256>>>0;if(w!==0)throw new Error("Non-zero carry");v=E,g++}if(f[g]!==" "){for(var x=P-v;x!==P&&b[x]===0;)x++;for(var k=new Uint8Array(m+(P-x)),L=m;x!==P;)k[L++]=b[x++];return k}}}function p(f){var g=h(f);if(g)return g;throw new Error(`Non-${e} character`)}return{encode:d,decodeUnsafe:h,decode:p}}var Ph=Th,kh=Ph;class _h{name;prefix;baseEncode;constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}let Dh=class{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,n){this.name=e,this.prefix=t;const s=t.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return Il(this,e)}};class Lh{decoders;constructor(e){this.decoders=e}or(e){return Il(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n!=null)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function Il(r,e){return new Lh({...r.decoders??{[r.prefix]:r},...e.decoders??{[e.prefix]:e}})}class Rh{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,n,s){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=s,this.encoder=new _h(e,t,n),this.decoder=new Dh(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function xs({name:r,prefix:e,encode:t,decode:n}){return new Rh(r,e,t,n)}function tn({name:r,prefix:e,alphabet:t}){const{encode:n,decode:s}=kh(t,r);return xs({prefix:e,name:r,encode:n,decode:i=>Ss(s(i))})}function Mh(r,e,t,n){let s=r.length;for(;r[s-1]==="=";)--s;const i=new Uint8Array(s*t/8|0);let o=0,a=0,c=0;for(let l=0;l<s;++l){const u=e[r[l]];if(u===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<t|u,o+=t,o>=8&&(o-=8,i[c++]=255&a>>o)}if(o>=t||(255&a<<8-o)!==0)throw new SyntaxError("Unexpected end of data");return i}function Oh(r,e,t){const n=e[e.length-1]==="=",s=(1<<t)-1;let i="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>t;)o-=t,i+=e[s&a>>o];if(o!==0&&(i+=e[s&a<<t-o]),n)for(;(i.length*t&7)!==0;)i+="=";return i}function Nh(r){const e={};for(let t=0;t<r.length;++t)e[r[t]]=t;return e}function Ce({name:r,prefix:e,bitsPerChar:t,alphabet:n}){const s=Nh(n);return xs({prefix:e,name:r,encode(i){return Oh(i,n,t)},decode(i){return Mh(i,s,t,r)}})}const me=tn({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Fh=tn({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),Uh=Object.freeze(Object.defineProperty({__proto__:null,base58btc:me,base58flickr:Fh},Symbol.toStringTag,{value:"Module"})),mt=Ce({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Bh=Ce({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),$h=Ce({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),zh=Ce({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Kh=Ce({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),qh=Ce({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Wh=Ce({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Hh=Ce({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Vh=Ce({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),Gh=Object.freeze(Object.defineProperty({__proto__:null,base32:mt,base32hex:Kh,base32hexpad:Wh,base32hexpadupper:Hh,base32hexupper:qh,base32pad:$h,base32padupper:zh,base32upper:Bh,base32z:Vh},Symbol.toStringTag,{value:"Module"})),Fn=tn({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Yh=tn({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),Xh=Object.freeze(Object.defineProperty({__proto__:null,base36:Fn,base36upper:Yh},Symbol.toStringTag,{value:"Module"}));var Qh=Tl,ia=128,jh=-128,Zh=Math.pow(2,31);function Tl(r,e,t){e=e||[],t=t||0;for(var n=t;r>=Zh;)e[t++]=r&255|ia,r/=128;for(;r&jh;)e[t++]=r&255|ia,r>>>=7;return e[t]=r|0,Tl.bytes=t-n+1,e}var Jh=Di,ef=128,oa=127;function Di(r,n){var t=0,n=n||0,s=0,i=n,o,a=r.length;do{if(i>=a)throw Di.bytes=0,new RangeError("Could not decode varint");o=r[i++],t+=s<28?(o&oa)<<s:(o&oa)*Math.pow(2,s),s+=7}while(o>=ef);return Di.bytes=i-n,t}var tf=Math.pow(2,7),rf=Math.pow(2,14),nf=Math.pow(2,21),sf=Math.pow(2,28),of=Math.pow(2,35),af=Math.pow(2,42),cf=Math.pow(2,49),lf=Math.pow(2,56),uf=Math.pow(2,63),df=function(r){return r<tf?1:r<rf?2:r<nf?3:r<sf?4:r<of?5:r<af?6:r<cf?7:r<lf?8:r<uf?9:10},hf={encode:Qh,decode:Jh,encodingLength:df},Kn=hf;function Li(r,e=0){return[Kn.decode(r,e),Kn.decode.bytes]}function qn(r,e,t=0){return Kn.encode(r,e,t),e}function Wn(r){return Kn.encodingLength(r)}function zr(r,e){const t=e.byteLength,n=Wn(r),s=n+Wn(t),i=new Uint8Array(s+t);return qn(r,i,0),qn(t,i,n),i.set(e,s),new bo(r,t,e,i)}function Vt(r){const e=Ss(r),[t,n]=Li(e),[s,i]=Li(e.subarray(n)),o=e.subarray(n+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new bo(t,s,o,e)}function ff(r,e){if(r===e)return!0;{const t=e;return r.code===t.code&&r.size===t.size&&t.bytes instanceof Uint8Array&&Ah(r.bytes,t.bytes)}}class bo{code;size;digest;bytes;constructor(e,t,n,s){this.code=e,this.size=t,this.digest=n,this.bytes=s}}function aa(r,e){const{bytes:t,version:n}=r;switch(n){case 0:return gf(t,Ri(r),e??me.encoder);default:return mf(t,Ri(r),e??mt.encoder)}}const ca=new WeakMap;function Ri(r){const e=ca.get(r);if(e==null){const t=new Map;return ca.set(r,t),t}return e}class oe{code;version;multihash;bytes;"/";constructor(e,t,n,s){this.code=t,this.version=e,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==Pr)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==yf)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return oe.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=zr(e,t);return oe.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return oe.equals(this,e)}static equals(e,t){const n=t;return n!=null&&e.code===n.code&&e.version===n.version&&ff(e.multihash,n.multihash)}toString(e){return aa(this,e)}toJSON(){return{"/":aa(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof oe)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:n,code:s,multihash:i,bytes:o}=t;return new oe(n,s,i,o??la(n,s,i.bytes))}else if(t[wf]===!0){const{version:n,multihash:s,code:i}=t,o=Vt(s);return oe.create(n,i,o)}else return null}static create(e,t,n){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==Pr)throw new Error(`Version 0 CID must use dag-pb (code: ${Pr}) block encoding`);return new oe(e,t,n,n.bytes)}case 1:{const s=la(e,t,n.bytes);return new oe(e,t,n,s)}default:throw new Error("Invalid version")}}static createV0(e){return oe.create(0,Pr,e)}static createV1(e,t){return oe.create(1,e,t)}static decode(e){const[t,n]=oe.decodeFirst(e);if(n.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=oe.inspectBytes(e),n=t.size-t.multihashSize,s=Ss(e.subarray(n,n+t.multihashSize));if(s.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=s.subarray(t.multihashSize-t.digestSize),o=new bo(t.multihashCode,t.digestSize,i,s);return[t.version===0?oe.createV0(o):oe.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[d,h]=Li(e.subarray(t));return t+=h,d};let s=n(),i=Pr;if(s===18?(s=0,t=0):i=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=t,a=n(),c=n(),l=t+c,u=l-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:u,size:l}}static parse(e,t){const[n,s]=pf(e,t),i=oe.decode(s);if(i.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Ri(i).set(n,e),i}}function pf(r,e){switch(r[0]){case"Q":{const t=e??me;return[me.prefix,t.decode(`${me.prefix}${r}`)]}case me.prefix:{const t=e??me;return[me.prefix,t.decode(r)]}case mt.prefix:{const t=e??mt;return[mt.prefix,t.decode(r)]}case Fn.prefix:{const t=e??Fn;return[Fn.prefix,t.decode(r)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],e.decode(r)]}}}function gf(r,e,t){const{prefix:n}=t;if(n!==me.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const s=e.get(n);if(s==null){const i=t.encode(r).slice(1);return e.set(n,i),i}else return s}function mf(r,e,t){const{prefix:n}=t,s=e.get(n);if(s==null){const i=t.encode(r);return e.set(n,i),i}else return s}const Pr=112,yf=18;function la(r,e,t){const n=Wn(r),s=n+Wn(e),i=new Uint8Array(s+t.byteLength);return qn(r,i,0),qn(e,i,n),i.set(t,s),i}const wf=Symbol.for("@ipld/js-cid/CID"),Pl=0,bf="identity",kl=Ss;function vf(r){return zr(Pl,kl(r))}const rn={code:Pl,name:bf,encode:kl,digest:vf};function De(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function ne(r=0){return new Uint8Array(r)}function ct(r=0){return new Uint8Array(r)}function tt(r,e){e==null&&(e=r.reduce((s,i)=>s+i.length,0));const t=ct(e);let n=0;for(const s of r)t.set(s,n),n+=s.length;return t}const _l=Symbol.for("@achingbrain/uint8arraylist");function ua(r,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(const n of r){const s=t+n.byteLength;if(e<s)return{buf:n,index:e-t};t=s}throw new RangeError("index is out of bounds")}function gn(r){return!!r?.[_l]}class j{bufs;length;[_l]=!0;constructor(...e){this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const n of e)if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.push(n);else if(gn(n))t+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const n of e.reverse())if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.unshift(n);else if(gn(n))t+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){const t=ua(this.bufs,e);return t.buf[t.index]}set(e,t){const n=ua(this.bufs,e);n.buf[n.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let n=0;n<e.length;n++)this.set(t+n,e[n]);else if(gn(e))for(let n=0;n<e.length;n++)this.set(t+n,e.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){const{bufs:n,length:s}=this._subList(e,t);return tt(n,s)}subarray(e,t){const{bufs:n,length:s}=this._subList(e,t);return n.length===1?n[0]:tt(n,s)}sublist(e,t){const{bufs:n,length:s}=this._subList(e,t),i=new j;return i.length=s,i.bufs=[...n],i}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};const n=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],a=s,c=a+o.byteLength;if(s=c,e>=c)continue;const l=e>=a&&e<c,u=t>a&&t<=c;if(l&&u){if(e===a&&t===c){n.push(o);break}const d=e-a;n.push(o.subarray(d,d+(t-e)));break}if(l){if(e===0){n.push(o);continue}n.push(o.subarray(e-a));continue}if(u){if(t===c){n.push(o);break}n.push(o.subarray(0,t-a));break}n.push(o)}return{bufs:n,length:t-e}}indexOf(e,t=0){if(!gn(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const n=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const s=n.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let d=0;d<i;d++)o[d]=-1;for(let d=0;d<s;d++)o[n[d]]=d;const a=o,c=this.byteLength-n.byteLength,l=n.byteLength-1;let u;for(let d=t;d<=c;d+=u){u=0;for(let h=l;h>=0;h--){const p=this.get(d+h);if(n[h]!==p){u=Math.max(1,h-a[p]);break}}if(u===0)return d}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const n=ct(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,t),this.write(n,e)}getInt16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,t)}setInt16(e,t,n){const s=ne(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,t,n),this.write(s,e)}getInt32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,t)}setInt32(e,t,n){const s=ne(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,t,n),this.write(s,e)}getBigInt64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,t)}setBigInt64(e,t,n){const s=ne(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,t,n),this.write(s,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const n=ct(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,t),this.write(n,e)}getUint16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,t)}setUint16(e,t,n){const s=ne(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,t,n),this.write(s,e)}getUint32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,t)}setUint32(e,t,n){const s=ne(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,t,n),this.write(s,e)}getBigUint64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,t)}setBigUint64(e,t,n){const s=ne(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,t,n),this.write(s,e)}getFloat32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,t)}setFloat32(e,t,n){const s=ne(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,t,n),this.write(s,e)}getFloat64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,t)}setFloat64(e,t,n){const s=ne(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,t,n),this.write(s,e)}equals(e){if(e==null||!(e instanceof j)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!De(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const n=new j;return n.bufs=e,t==null&&(t=e.reduce((s,i)=>s+i.byteLength,0)),n.length=t,n}}const Ef=tn({prefix:"9",name:"base10",alphabet:"0123456789"}),Sf=Object.freeze(Object.defineProperty({__proto__:null,base10:Ef},Symbol.toStringTag,{value:"Module"})),xf=Ce({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Af=Ce({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),Cf=Object.freeze(Object.defineProperty({__proto__:null,base16:xf,base16upper:Af},Symbol.toStringTag,{value:"Module"})),If=Ce({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),Tf=Object.freeze(Object.defineProperty({__proto__:null,base2:If},Symbol.toStringTag,{value:"Module"})),Dl=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),Pf=Dl.reduce((r,e,t)=>(r[t]=e,r),[]),kf=Dl.reduce((r,e,t)=>{const n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);return r[n]=t,r},[]);function _f(r){return r.reduce((e,t)=>(e+=Pf[t],e),"")}function Df(r){const e=[];for(const t of r){const n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);const s=kf[n];if(s==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(s)}return new Uint8Array(e)}const Lf=xs({prefix:"🚀",name:"base256emoji",encode:_f,decode:Df}),Rf=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:Lf},Symbol.toStringTag,{value:"Module"})),Ll=Ce({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Mf=Ce({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Rl=Ce({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Of=Ce({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),Nf=Object.freeze(Object.defineProperty({__proto__:null,base64:Ll,base64pad:Mf,base64url:Rl,base64urlpad:Of},Symbol.toStringTag,{value:"Module"})),Ff=Ce({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),Uf=Object.freeze(Object.defineProperty({__proto__:null,base8:Ff},Symbol.toStringTag,{value:"Module"})),Bf=xs({prefix:"\0",name:"identity",encode:r=>Ih(r),decode:r=>Ch(r)}),$f=Object.freeze(Object.defineProperty({__proto__:null,identity:Bf},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;function zf({name:r,code:e,encode:t}){return new Kf(r,e,t)}class Kf{name;code;encode;constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?zr(this.code,t):t.then(n=>zr(this.code,n))}else throw Error("Unknown type, must be binary type")}}function qf(r){return async e=>new Uint8Array(await crypto.subtle.digest(r,e))}const Ml=zf({name:"sha2-256",code:18,encode:qf("SHA-256")}),Mi={...$f,...Tf,...Uf,...Sf,...Cf,...Gh,...Xh,...Uh,...Nf,...Rf};function Ol(r,e,t,n){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:n}}}const da=Ol("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),Us=Ol("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);const e=ct(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),Nl={utf8:da,"utf-8":da,hex:Mi.base16,latin1:Us,ascii:Us,binary:Us,...Mi};function K(r,e="utf8"){const t=Nl[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${r}`)}function G(r,e="utf8"){const t=Nl[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(r).substring(1)}const Wf=parseInt("11111",2),Oi=parseInt("10000000",2),Hf=parseInt("01111111",2),ha={0:kr,1:kr,2:Vf,3:Xf,4:Qf,5:Yf,6:Gf,16:kr,22:kr,48:kr};function As(r,e={offset:0}){const t=r[e.offset]&Wf;if(e.offset++,ha[t]!=null)return ha[t](r,e);throw new Error("No decoder for tag "+t)}function nn(r,e){let t=0;if((r[e.offset]&Oi)===Oi){const n=r[e.offset]&Hf;let s="0x";e.offset++;for(let i=0;i<n;i++,e.offset++)s+=r[e.offset].toString(16).padStart(2,"0");t=parseInt(s,16)}else t=r[e.offset],e.offset++;return t}function kr(r,e){nn(r,e);const t=[];for(;!(e.offset>=r.byteLength);){const n=As(r,e);if(n===null)break;t.push(n)}return t}function Vf(r,e){const t=nn(r,e),n=e.offset,s=e.offset+t,i=[];for(let o=n;o<s;o++)o===n&&r[o]===0||i.push(r[o]);return e.offset+=t,Uint8Array.from(i)}function Gf(r,e){const t=nn(r,e),n=e.offset+t,s=r[e.offset];e.offset++;let i=0,o=0;s<40?(i=0,o=s):s<80?(i=1,o=s-40):(i=2,o=s-80);let a=`${i}.${o}`,c=[];for(;e.offset<n;){const l=r[e.offset];if(e.offset++,c.push(l&127),l<128){c.reverse();let u=0;for(let d=0;d<c.length;d++)u+=c[d]<<d*7;a+=`.${u}`,c=[]}}return a}function Yf(r,e){return e.offset++,null}function Xf(r,e){const t=nn(r,e),n=r[e.offset];e.offset++;const s=r.subarray(e.offset,e.offset+t-1);if(e.offset+=t,n!==0)throw new Error("Unused bits in bit string is unimplemented");return s}function Qf(r,e){const t=nn(r,e),n=r.subarray(e.offset,e.offset+t);return e.offset+=t,n}function jf(r){let e=r.toString(16);e.length%2===1&&(e="0"+e);const t=new j;for(let n=0;n<e.length;n+=2)t.append(Uint8Array.from([parseInt(`${e[n]}${e[n+1]}`,16)]));return t}function vo(r){if(r.byteLength<128)return Uint8Array.from([r.byteLength]);const e=jf(r.byteLength);return new j(Uint8Array.from([e.byteLength|Oi]),e)}function Ni(r){const e=new j,t=128;return(r.subarray()[0]&t)===t&&e.append(Uint8Array.from([0])),e.append(r),new j(Uint8Array.from([2]),vo(e),e)}function Fl(r){const e=Uint8Array.from([0]),t=new j(e,r);return new j(Uint8Array.from([3]),vo(t),t)}function Nr(r,e=48){const t=new j;for(const n of r)t.append(n);return new j(Uint8Array.from([e]),vo(t),t)}async function Zf(r,e,t){const n=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv??"P-256"},!1,["verify"]);return crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},n,e,t.subarray())}const Jf=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),ep=Uint8Array.from([6,5,43,129,4,0,34]),tp=Uint8Array.from([6,5,43,129,4,0,35]),rp={ext:!0,kty:"EC",crv:"P-256"},np={ext:!0,kty:"EC",crv:"P-384"},sp={ext:!0,kty:"EC",crv:"P-521"},Bs=32,$s=48,zs=66;function Ul(r){const e=As(r);return ip(e)}function ip(r){const e=r[1][1][0],t=1;let n,s;if(e.byteLength===Bs*2+1)return n=G(e.subarray(t,t+Bs),"base64url"),s=G(e.subarray(t+Bs),"base64url"),new Ks({...rp,key_ops:["verify"],x:n,y:s});if(e.byteLength===$s*2+1)return n=G(e.subarray(t,t+$s),"base64url"),s=G(e.subarray(t+$s),"base64url"),new Ks({...np,key_ops:["verify"],x:n,y:s});if(e.byteLength===zs*2+1)return n=G(e.subarray(t,t+zs),"base64url"),s=G(e.subarray(t+zs),"base64url"),new Ks({...sp,key_ops:["verify"],x:n,y:s});throw new W(`coordinates were wrong length, got ${e.byteLength}, expected 65, 97 or 133`)}function op(r){return Nr([Ni(Uint8Array.from([1])),Nr([ap(r.crv)],160),Nr([Fl(new j(Uint8Array.from([4]),K(r.x??"","base64url"),K(r.y??"","base64url")))],161)]).subarray()}function ap(r){if(r==="P-256")return Jf;if(r==="P-384")return ep;if(r==="P-521")return tp;throw new W(`Invalid curve ${r}`)}class Ks{type="ECDSA";jwk;_raw;constructor(e){this.jwk=e}get raw(){return this._raw==null&&(this._raw=op(this.jwk)),this._raw}toMultihash(){return rn.digest(yt(this))}toCID(){return oe.createV1(114,this.toMultihash())}toString(){return me.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:De(this.raw,e.raw)}async verify(e,t){return Zf(this.jwk,t,e)}}const Yt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function cp(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Hn(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function sn(r,...e){if(!cp(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function Eo(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");Hn(r.outputLen),Hn(r.blockLen)}function Vn(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function lp(r,e){sn(r);const t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function qt(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function qs(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function rt(r,e){return r<<32-e|r>>>e}function up(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}function Kr(r){return typeof r=="string"&&(r=up(r)),sn(r),r}function dp(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];sn(s),e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const i=r[n];t.set(i,s),s+=i.length}return t}class Bl{}function $l(r){const e=n=>r().update(Kr(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function Cs(r=32){if(Yt&&typeof Yt.getRandomValues=="function")return Yt.getRandomValues(new Uint8Array(r));if(Yt&&typeof Yt.randomBytes=="function")return Uint8Array.from(Yt.randomBytes(r));throw new Error("crypto.getRandomValues must be defined")}function hp(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const s=BigInt(32),i=BigInt(4294967295),o=Number(t>>s&i),a=Number(t&i),c=n?4:0,l=n?0:4;r.setUint32(e+c,o,n),r.setUint32(e+l,a,n)}function fp(r,e,t){return r&e^~r&t}function pp(r,e,t){return r&e^r&t^e&t}class zl extends Bl{constructor(e,t,n,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=s,this.buffer=new Uint8Array(e),this.view=qs(this.buffer)}update(e){Vn(this),e=Kr(e),sn(e);const{view:t,buffer:n,blockLen:s}=this,i=e.length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a===s){const c=qs(e);for(;s<=i-o;o+=s)this.process(c,o);continue}n.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Vn(this),lp(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:s,isLE:i}=this;let{pos:o}=this;t[o++]=128,qt(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(n,0),o=0);for(let d=o;d<s;d++)t[d]=0;hp(n,s-8,BigInt(this.length*8),i),this.process(n,0);const a=qs(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=c/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<l;d++)a.setUint32(4*d,u[d],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:s,finished:i,destroyed:o,pos:a}=this;return e.destroyed=o,e.finished=i,e.length=s,e.pos=a,s%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}}const Et=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Te=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),mn=BigInt(2**32-1),fa=BigInt(32);function gp(r,e=!1){return e?{h:Number(r&mn),l:Number(r>>fa&mn)}:{h:Number(r>>fa&mn)|0,l:Number(r&mn)|0}}function mp(r,e=!1){const t=r.length;let n=new Uint32Array(t),s=new Uint32Array(t);for(let i=0;i<t;i++){const{h:o,l:a}=gp(r[i],e);[n[i],s[i]]=[o,a]}return[n,s]}const pa=(r,e,t)=>r>>>t,ga=(r,e,t)=>r<<32-t|e>>>t,Xt=(r,e,t)=>r>>>t|e<<32-t,Qt=(r,e,t)=>r<<32-t|e>>>t,yn=(r,e,t)=>r<<64-t|e>>>t-32,wn=(r,e,t)=>r>>>t-32|e<<64-t;function ut(r,e,t,n){const s=(e>>>0)+(n>>>0);return{h:r+t+(s/2**32|0)|0,l:s|0}}const yp=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),wp=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,bp=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),vp=(r,e,t,n,s)=>e+t+n+s+(r/2**32|0)|0,Ep=(r,e,t,n,s)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(s>>>0),Sp=(r,e,t,n,s,i)=>e+t+n+s+i+(r/2**32|0)|0,xp=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),St=new Uint32Array(64);class Ap extends zl{constructor(e=32){super(64,e,8,!1),this.A=Et[0]|0,this.B=Et[1]|0,this.C=Et[2]|0,this.D=Et[3]|0,this.E=Et[4]|0,this.F=Et[5]|0,this.G=Et[6]|0,this.H=Et[7]|0}get(){const{A:e,B:t,C:n,D:s,E:i,F:o,G:a,H:c}=this;return[e,t,n,s,i,o,a,c]}set(e,t,n,s,i,o,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let d=0;d<16;d++,t+=4)St[d]=e.getUint32(t,!1);for(let d=16;d<64;d++){const h=St[d-15],p=St[d-2],f=rt(h,7)^rt(h,18)^h>>>3,g=rt(p,17)^rt(p,19)^p>>>10;St[d]=g+St[d-7]+f+St[d-16]|0}let{A:n,B:s,C:i,D:o,E:a,F:c,G:l,H:u}=this;for(let d=0;d<64;d++){const h=rt(a,6)^rt(a,11)^rt(a,25),p=u+h+fp(a,c,l)+xp[d]+St[d]|0,g=(rt(n,2)^rt(n,13)^rt(n,22))+pp(n,s,i)|0;u=l,l=c,c=a,a=o+p|0,o=i,i=s,s=n,n=p+g|0}n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(n,s,i,o,a,c,l,u)}roundClean(){qt(St)}destroy(){this.set(0,0,0,0,0,0,0,0),qt(this.buffer)}}const Kl=mp(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Cp=Kl[0],Ip=Kl[1],xt=new Uint32Array(80),At=new Uint32Array(80);class Tp extends zl{constructor(e=64){super(128,e,16,!1),this.Ah=Te[0]|0,this.Al=Te[1]|0,this.Bh=Te[2]|0,this.Bl=Te[3]|0,this.Ch=Te[4]|0,this.Cl=Te[5]|0,this.Dh=Te[6]|0,this.Dl=Te[7]|0,this.Eh=Te[8]|0,this.El=Te[9]|0,this.Fh=Te[10]|0,this.Fl=Te[11]|0,this.Gh=Te[12]|0,this.Gl=Te[13]|0,this.Hh=Te[14]|0,this.Hl=Te[15]|0}get(){const{Ah:e,Al:t,Bh:n,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:l,El:u,Fh:d,Fl:h,Gh:p,Gl:f,Hh:g,Hl:m}=this;return[e,t,n,s,i,o,a,c,l,u,d,h,p,f,g,m]}set(e,t,n,s,i,o,a,c,l,u,d,h,p,f,g,m){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=d|0,this.Fl=h|0,this.Gh=p|0,this.Gl=f|0,this.Hh=g|0,this.Hl=m|0}process(e,t){for(let b=0;b<16;b++,t+=4)xt[b]=e.getUint32(t),At[b]=e.getUint32(t+=4);for(let b=16;b<80;b++){const w=xt[b-15]|0,E=At[b-15]|0,_=Xt(w,E,1)^Xt(w,E,8)^pa(w,E,7),x=Qt(w,E,1)^Qt(w,E,8)^ga(w,E,7),k=xt[b-2]|0,L=At[b-2]|0,F=Xt(k,L,19)^yn(k,L,61)^pa(k,L,6),D=Qt(k,L,19)^wn(k,L,61)^ga(k,L,6),N=bp(x,D,At[b-7],At[b-16]),R=vp(N,_,F,xt[b-7],xt[b-16]);xt[b]=R|0,At[b]=N|0}let{Ah:n,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:l,Dl:u,Eh:d,El:h,Fh:p,Fl:f,Gh:g,Gl:m,Hh:v,Hl:P}=this;for(let b=0;b<80;b++){const w=Xt(d,h,14)^Xt(d,h,18)^yn(d,h,41),E=Qt(d,h,14)^Qt(d,h,18)^wn(d,h,41),_=d&p^~d&g,x=h&f^~h&m,k=Ep(P,E,x,Ip[b],At[b]),L=Sp(k,v,w,_,Cp[b],xt[b]),F=k|0,D=Xt(n,s,28)^yn(n,s,34)^yn(n,s,39),N=Qt(n,s,28)^wn(n,s,34)^wn(n,s,39),R=n&i^n&a^i&a,B=s&o^s&c^o&c;v=g|0,P=m|0,g=p|0,m=f|0,p=d|0,f=h|0,{h:d,l:h}=ut(l|0,u|0,L|0,F|0),l=a|0,u=c|0,a=i|0,c=o|0,i=n|0,o=s|0;const C=yp(F,N,B);n=wp(C,L,D,R),s=C|0}({h:n,l:s}=ut(this.Ah|0,this.Al|0,n|0,s|0)),{h:i,l:o}=ut(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=ut(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:u}=ut(this.Dh|0,this.Dl|0,l|0,u|0),{h:d,l:h}=ut(this.Eh|0,this.El|0,d|0,h|0),{h:p,l:f}=ut(this.Fh|0,this.Fl|0,p|0,f|0),{h:g,l:m}=ut(this.Gh|0,this.Gl|0,g|0,m|0),{h:v,l:P}=ut(this.Hh|0,this.Hl|0,v|0,P|0),this.set(n,s,i,o,a,c,l,u,d,h,p,f,g,m,v,P)}roundClean(){qt(xt,At)}destroy(){qt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const ql=$l(()=>new Ap),Pp=$l(()=>new Tp);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const So=BigInt(0),Fi=BigInt(1);function on(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function xo(r){if(!on(r))throw new Error("Uint8Array expected")}function Tt(r,e){if(typeof e!="boolean")throw new Error(r+" boolean expected, got "+e)}function bn(r){const e=r.toString(16);return e.length&1?"0"+e:e}function Wl(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?So:BigInt("0x"+r)}const Hl=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",kp=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function ar(r){if(xo(r),Hl)return r.toHex();let e="";for(let t=0;t<r.length;t++)e+=kp[r[t]];return e}const dt={_0:48,_9:57,A:65,F:70,a:97,f:102};function ma(r){if(r>=dt._0&&r<=dt._9)return r-dt._0;if(r>=dt.A&&r<=dt.F)return r-(dt.A-10);if(r>=dt.a&&r<=dt.f)return r-(dt.a-10)}function Gn(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(Hl)return Uint8Array.fromHex(r);const e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let s=0,i=0;s<t;s++,i+=2){const o=ma(r.charCodeAt(i)),a=ma(r.charCodeAt(i+1));if(o===void 0||a===void 0){const c=r[i]+r[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}n[s]=o*16+a}return n}function Bt(r){return Wl(ar(r))}function $t(r){return xo(r),Wl(ar(Uint8Array.from(r).reverse()))}function an(r,e){return Gn(r.toString(16).padStart(e*2,"0"))}function qr(r,e){return an(r,e).reverse()}function ue(r,e,t){let n;if(typeof e=="string")try{n=Gn(e)}catch(i){throw new Error(r+" must be hex string or Uint8Array, cause: "+i)}else if(on(e))n=Uint8Array.from(e);else throw new Error(r+" must be hex string or Uint8Array");const s=n.length;if(typeof t=="number"&&s!==t)throw new Error(r+" of length "+t+" expected, got "+s);return n}function cr(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];xo(s),e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const i=r[n];t.set(i,s),s+=i.length}return t}const Ws=r=>typeof r=="bigint"&&So<=r;function Ao(r,e,t){return Ws(r)&&Ws(e)&&Ws(t)&&e<=r&&r<t}function qe(r,e,t,n){if(!Ao(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function _p(r){let e;for(e=0;r>So;r>>=Fi,e+=1);return e}const Is=r=>(Fi<<BigInt(r))-Fi,Hs=r=>new Uint8Array(r),ya=r=>Uint8Array.from(r);function Dp(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=Hs(r),s=Hs(r),i=0;const o=()=>{n.fill(1),s.fill(0),i=0},a=(...d)=>t(s,n,...d),c=(d=Hs(0))=>{s=a(ya([0]),d),n=a(),d.length!==0&&(s=a(ya([1]),d),n=a())},l=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let d=0;const h=[];for(;d<e;){n=a();const p=n.slice();h.push(p),d+=n.length}return cr(...h)};return(d,h)=>{o(),c(d);let p;for(;!(p=h(l()));)c();return o(),p}}const Lp={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||on(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function Sr(r,e,t={}){const n=(s,i,o)=>{const a=Lp[i];if(typeof a!="function")throw new Error("invalid validator function");const c=r[s];if(!(o&&c===void 0)&&!a(c,r))throw new Error("param "+String(s)+" is invalid. Expected "+i+", got "+c)};for(const[s,i]of Object.entries(e))n(s,i,!1);for(const[s,i]of Object.entries(t))n(s,i,!0);return r}function Yn(r){const e=new WeakMap;return(t,...n)=>{const s=e.get(t);if(s!==void 0)return s;const i=r(t,...n);return e.set(t,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const $e=BigInt(0),Ae=BigInt(1),Nt=BigInt(2),Rp=BigInt(3),Vl=BigInt(4),Gl=BigInt(5),Yl=BigInt(8);function ae(r,e){const t=r%e;return t>=$e?t:e+t}function le(r,e,t){let n=r;for(;e-- >$e;)n*=n,n%=t;return n}function Ui(r,e){if(r===$e)throw new Error("invert: expected non-zero number");if(e<=$e)throw new Error("invert: expected positive modulus, got "+e);let t=ae(r,e),n=e,s=$e,i=Ae;for(;t!==$e;){const a=n/t,c=n%t,l=s-i*a;n=t,t=c,s=i,i=l}if(n!==Ae)throw new Error("invert: does not exist");return ae(s,e)}function Xl(r,e){const t=(r.ORDER+Ae)/Vl,n=r.pow(e,t);if(!r.eql(r.sqr(n),e))throw new Error("Cannot find square root");return n}function Mp(r,e){const t=(r.ORDER-Gl)/Yl,n=r.mul(e,Nt),s=r.pow(n,t),i=r.mul(e,s),o=r.mul(r.mul(i,Nt),s),a=r.mul(i,r.sub(o,r.ONE));if(!r.eql(r.sqr(a),e))throw new Error("Cannot find square root");return a}function Op(r){if(r<BigInt(3))throw new Error("sqrt is not defined for small field");let e=r-Ae,t=0;for(;e%Nt===$e;)e/=Nt,t++;let n=Nt;const s=cn(r);for(;wa(s,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return Xl;let i=s.pow(n,e);const o=(e+Ae)/Nt;return function(c,l){if(c.is0(l))return l;if(wa(c,l)!==1)throw new Error("Cannot find square root");let u=t,d=c.mul(c.ONE,i),h=c.pow(l,e),p=c.pow(l,o);for(;!c.eql(h,c.ONE);){if(c.is0(h))return c.ZERO;let f=1,g=c.sqr(h);for(;!c.eql(g,c.ONE);)if(f++,g=c.sqr(g),f===u)throw new Error("Cannot find square root");const m=Ae<<BigInt(u-f-1),v=c.pow(d,m);u=f,d=c.sqr(v),h=c.mul(h,d),p=c.mul(p,v)}return p}}function Np(r){return r%Vl===Rp?Xl:r%Yl===Gl?Mp:Op(r)}const Fp=(r,e)=>(ae(r,e)&Ae)===Ae,Up=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Bp(r){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Up.reduce((n,s)=>(n[s]="function",n),e);return Sr(r,t)}function $p(r,e,t){if(t<$e)throw new Error("invalid exponent, negatives unsupported");if(t===$e)return r.ONE;if(t===Ae)return e;let n=r.ONE,s=e;for(;t>$e;)t&Ae&&(n=r.mul(n,s)),s=r.sqr(s),t>>=Ae;return n}function Co(r,e,t=!1){const n=new Array(e.length).fill(t?r.ZERO:void 0),s=e.reduce((o,a,c)=>r.is0(a)?o:(n[c]=o,r.mul(o,a)),r.ONE),i=r.inv(s);return e.reduceRight((o,a,c)=>r.is0(a)?o:(n[c]=r.mul(o,n[c]),r.mul(o,a)),i),n}function wa(r,e){const t=(r.ORDER-Ae)/Nt,n=r.pow(e,t),s=r.eql(n,r.ONE),i=r.eql(n,r.ZERO),o=r.eql(n,r.neg(r.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function Ql(r,e){e!==void 0&&Hn(e);const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function cn(r,e,t=!1,n={}){if(r<=$e)throw new Error("invalid field: expected ORDER > 0, got "+r);const{nBitLength:s,nByteLength:i}=Ql(r,e);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const a=Object.freeze({ORDER:r,isLE:t,BITS:s,BYTES:i,MASK:Is(s),ZERO:$e,ONE:Ae,create:c=>ae(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return $e<=c&&c<r},is0:c=>c===$e,isOdd:c=>(c&Ae)===Ae,neg:c=>ae(-c,r),eql:(c,l)=>c===l,sqr:c=>ae(c*c,r),add:(c,l)=>ae(c+l,r),sub:(c,l)=>ae(c-l,r),mul:(c,l)=>ae(c*l,r),pow:(c,l)=>$p(a,c,l),div:(c,l)=>ae(c*Ui(l,r),r),sqrN:c=>c*c,addN:(c,l)=>c+l,subN:(c,l)=>c-l,mulN:(c,l)=>c*l,inv:c=>Ui(c,r),sqrt:n.sqrt||(c=>(o||(o=Np(r)),o(a,c))),toBytes:c=>t?qr(c,i):an(c,i),fromBytes:c=>{if(c.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+c.length);return t?$t(c):Bt(c)},invertBatch:c=>Co(a,c),cmov:(c,l,u)=>u?l:c});return Object.freeze(a)}function jl(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function Zl(r){const e=jl(r);return e+Math.ceil(e/2)}function zp(r,e,t=!1){const n=r.length,s=jl(e),i=Zl(e);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);const o=t?$t(r):Bt(r),a=ae(o,e-Ae)+Ae;return t?qr(a,s):an(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ba=BigInt(0),Bi=BigInt(1);function Vs(r,e){const t=e.negate();return r?t:e}function Jl(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function Gs(r,e){Jl(r,e);const t=Math.ceil(e/r)+1,n=2**(r-1),s=2**r,i=Is(r),o=BigInt(r);return{windows:t,windowSize:n,mask:i,maxNumber:s,shiftBy:o}}function va(r,e,t){const{windowSize:n,mask:s,maxNumber:i,shiftBy:o}=t;let a=Number(r&s),c=r>>o;a>n&&(a-=i,c+=Bi);const l=e*n,u=l+Math.abs(a)-1,d=a===0,h=a<0,p=e%2!==0;return{nextN:c,offset:u,isZero:d,isNeg:h,isNegF:p,offsetF:l}}function Kp(r,e){if(!Array.isArray(r))throw new Error("array expected");r.forEach((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)})}function qp(r,e){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)})}const Ys=new WeakMap,eu=new WeakMap;function Xs(r){return eu.get(r)||1}function tu(r,e){return{constTimeNegate:Vs,hasPrecomputes(t){return Xs(t)!==1},unsafeLadder(t,n,s=r.ZERO){let i=t;for(;n>ba;)n&Bi&&(s=s.add(i)),i=i.double(),n>>=Bi;return s},precomputeWindow(t,n){const{windows:s,windowSize:i}=Gs(n,e),o=[];let a=t,c=a;for(let l=0;l<s;l++){c=a,o.push(c);for(let u=1;u<i;u++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(t,n,s){let i=r.ZERO,o=r.BASE;const a=Gs(t,e);for(let c=0;c<a.windows;c++){const{nextN:l,offset:u,isZero:d,isNeg:h,isNegF:p,offsetF:f}=va(s,c,a);s=l,d?o=o.add(Vs(p,n[f])):i=i.add(Vs(h,n[u]))}return{p:i,f:o}},wNAFUnsafe(t,n,s,i=r.ZERO){const o=Gs(t,e);for(let a=0;a<o.windows&&s!==ba;a++){const{nextN:c,offset:l,isZero:u,isNeg:d}=va(s,a,o);if(s=c,!u){const h=n[l];i=i.add(d?h.negate():h)}}return i},getPrecomputes(t,n,s){let i=Ys.get(n);return i||(i=this.precomputeWindow(n,t),t!==1&&Ys.set(n,s(i))),i},wNAFCached(t,n,s){const i=Xs(t);return this.wNAF(i,this.getPrecomputes(i,t,s),n)},wNAFCachedUnsafe(t,n,s,i){const o=Xs(t);return o===1?this.unsafeLadder(t,n,i):this.wNAFUnsafe(o,this.getPrecomputes(o,t,s),n,i)},setWindowSize(t,n){Jl(n,e),eu.set(t,n),Ys.delete(t)}}}function ru(r,e,t,n){Kp(t,r),qp(n,e);const s=t.length,i=n.length;if(s!==i)throw new Error("arrays of points and scalars must have equal length");const o=r.ZERO,a=_p(BigInt(s));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const l=Is(c),u=new Array(Number(l)+1).fill(o),d=Math.floor((e.BITS-1)/c)*c;let h=o;for(let p=d;p>=0;p-=c){u.fill(o);for(let g=0;g<i;g++){const m=n[g],v=Number(m>>BigInt(p)&l);u[v]=u[v].add(t[g])}let f=o;for(let g=u.length-1,m=o;g>0;g--)m=m.add(u[g]),f=f.add(m);if(h=h.add(f),p!==0)for(let g=0;g<c;g++)h=h.double()}return h}function Io(r){return Bp(r.Fp),Sr(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ql(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const nt=BigInt(0),Le=BigInt(1),Ea=BigInt(2),Wp=BigInt(8),Hp={zip215:!0};function Vp(r){const e=Io(r);return Sr(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function Gp(r){const e=Vp(r),{Fp:t,n,prehash:s,hash:i,randomBytes:o,nByteLength:a,h:c}=e,l=Ea<<BigInt(a*8)-Le,u=t.create,d=cn(e.n,e.nBitLength);function h(A,y){const S=t.sqr(A),T=t.sqr(y),O=t.add(t.mul(e.a,S),T),U=t.add(t.ONE,t.mul(e.d,t.mul(S,T)));return t.eql(O,U)}if(!h(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const p=e.uvRatio||((A,y)=>{try{return{isValid:!0,value:t.sqrt(A*t.inv(y))}}catch{return{isValid:!1,value:nt}}}),f=e.adjustScalarBytes||(A=>A),g=e.domain||((A,y,S)=>{if(Tt("phflag",S),y.length||S)throw new Error("Contexts/pre-hash are not supported");return A});function m(A,y,S=!1){const T=S?Le:nt;qe("coordinate "+A,y,T,l)}function v(A){if(!(A instanceof w))throw new Error("ExtendedPoint expected")}const P=Yn((A,y)=>{const{ex:S,ey:T,ez:O}=A,U=A.is0();y==null&&(y=U?Wp:t.inv(O));const $=u(S*y),z=u(T*y),q=u(O*y);if(U)return{x:nt,y:Le};if(q!==Le)throw new Error("invZ was invalid");return{x:$,y:z}}),b=Yn(A=>{const{a:y,d:S}=e;if(A.is0())throw new Error("bad point: ZERO");const{ex:T,ey:O,ez:U,et:$}=A,z=u(T*T),q=u(O*O),H=u(U*U),ee=u(H*H),J=u(z*y),ve=u(H*u(J+q)),Ne=u(ee+u(S*u(z*q)));if(ve!==Ne)throw new Error("bad point: equation left != right (1)");const we=u(T*O),Ie=u(U*$);if(we!==Ie)throw new Error("bad point: equation left != right (2)");return!0});class w{constructor(y,S,T,O){m("x",y),m("y",S),m("z",T,!0),m("t",O),this.ex=y,this.ey=S,this.ez=T,this.et=O,Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(y){if(y instanceof w)throw new Error("extended point not allowed");const{x:S,y:T}=y||{};return m("x",S),m("y",T),new w(S,T,Le,u(S*T))}static normalizeZ(y){const S=Co(t,y.map(T=>T.ez));return y.map((T,O)=>T.toAffine(S[O])).map(w.fromAffine)}static msm(y,S){return ru(w,d,y,S)}_setWindowSize(y){x.setWindowSize(this,y)}assertValidity(){b(this)}equals(y){v(y);const{ex:S,ey:T,ez:O}=this,{ex:U,ey:$,ez:z}=y,q=u(S*z),H=u(U*O),ee=u(T*z),J=u($*O);return q===H&&ee===J}is0(){return this.equals(w.ZERO)}negate(){return new w(u(-this.ex),this.ey,this.ez,u(-this.et))}double(){const{a:y}=e,{ex:S,ey:T,ez:O}=this,U=u(S*S),$=u(T*T),z=u(Ea*u(O*O)),q=u(y*U),H=S+T,ee=u(u(H*H)-U-$),J=q+$,ve=J-z,Ne=q-$,we=u(ee*ve),Ie=u(J*Ne),ze=u(ee*Ne),Xe=u(ve*J);return new w(we,Ie,Xe,ze)}add(y){v(y);const{a:S,d:T}=e,{ex:O,ey:U,ez:$,et:z}=this,{ex:q,ey:H,ez:ee,et:J}=y,ve=u(O*q),Ne=u(U*H),we=u(z*T*J),Ie=u($*ee),ze=u((O+U)*(q+H)-ve-Ne),Xe=Ie-we,Ir=Ie+we,ta=u(Ne-S*ve),dh=u(ze*Xe),hh=u(Ir*ta),fh=u(ze*ta),ph=u(Xe*Ir);return new w(dh,hh,ph,fh)}subtract(y){return this.add(y.negate())}wNAF(y){return x.wNAFCached(this,y,w.normalizeZ)}multiply(y){const S=y;qe("scalar",S,Le,n);const{p:T,f:O}=this.wNAF(S);return w.normalizeZ([T,O])[0]}multiplyUnsafe(y,S=w.ZERO){const T=y;return qe("scalar",T,nt,n),T===nt?_:this.is0()||T===Le?this:x.wNAFCachedUnsafe(this,T,w.normalizeZ,S)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return x.unsafeLadder(this,n).is0()}toAffine(y){return P(this,y)}clearCofactor(){const{h:y}=e;return y===Le?this:this.multiplyUnsafe(y)}static fromHex(y,S=!1){const{d:T,a:O}=e,U=t.BYTES;y=ue("pointHex",y,U),Tt("zip215",S);const $=y.slice(),z=y[U-1];$[U-1]=z&-129;const q=$t($),H=S?l:t.ORDER;qe("pointHex.y",q,nt,H);const ee=u(q*q),J=u(ee-Le),ve=u(T*ee-O);let{isValid:Ne,value:we}=p(J,ve);if(!Ne)throw new Error("Point.fromHex: invalid y coordinate");const Ie=(we&Le)===Le,ze=(z&128)!==0;if(!S&&we===nt&&ze)throw new Error("Point.fromHex: x=0 and x_0=1");return ze!==Ie&&(we=u(-we)),w.fromAffine({x:we,y:q})}static fromPrivateKey(y){const{scalar:S}=F(y);return E.multiply(S)}toRawBytes(){const{x:y,y:S}=this.toAffine(),T=qr(S,t.BYTES);return T[T.length-1]|=y&Le?128:0,T}toHex(){return ar(this.toRawBytes())}}w.BASE=new w(e.Gx,e.Gy,Le,u(e.Gx*e.Gy)),w.ZERO=new w(nt,Le,Le,nt);const{BASE:E,ZERO:_}=w,x=tu(w,a*8);function k(A){return ae(A,n)}function L(A){return k($t(A))}function F(A){const y=t.BYTES;A=ue("private key",A,y);const S=ue("hashed private key",i(A),2*y),T=f(S.slice(0,y)),O=S.slice(y,2*y),U=L(T);return{head:T,prefix:O,scalar:U}}function D(A){const{head:y,prefix:S,scalar:T}=F(A),O=E.multiply(T),U=O.toRawBytes();return{head:y,prefix:S,scalar:T,point:O,pointBytes:U}}function N(A){return D(A).pointBytes}function R(A=Uint8Array.of(),...y){const S=cr(...y);return L(i(g(S,ue("context",A),!!s)))}function B(A,y,S={}){A=ue("message",A),s&&(A=s(A));const{prefix:T,scalar:O,pointBytes:U}=D(y),$=R(S.context,T,A),z=E.multiply($).toRawBytes(),q=R(S.context,z,U,A),H=k($+q*O);qe("signature.s",H,nt,n);const ee=cr(z,qr(H,t.BYTES));return ue("result",ee,t.BYTES*2)}const C=Hp;function I(A,y,S,T=C){const{context:O,zip215:U}=T,$=t.BYTES;A=ue("signature",A,2*$),y=ue("message",y),S=ue("publicKey",S,$),U!==void 0&&Tt("zip215",U),s&&(y=s(y));const z=$t(A.slice($,2*$));let q,H,ee;try{q=w.fromHex(S,U),H=w.fromHex(A.slice(0,$),U),ee=E.multiplyUnsafe(z)}catch{return!1}if(!U&&q.isSmallOrder())return!1;const J=R(O,H.toRawBytes(),q.toRawBytes(),y);return H.add(q.multiplyUnsafe(J)).subtract(ee).clearCofactor().equals(w.ZERO)}return E._setWindowSize(8),{CURVE:e,getPublicKey:N,sign:B,verify:I,ExtendedPoint:w,utils:{getExtendedPublicKey:D,randomPrivateKey:()=>o(t.BYTES),precompute(A=8,y=w.BASE){return y._setWindowSize(A),y.multiply(BigInt(3)),y}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _r=BigInt(0),jt=BigInt(1),vn=BigInt(2);function Yp(r){return Sr(r,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...r})}function Xp(r){const e=Yp(r),{P:t,type:n,adjustScalarBytes:s,powPminus2:i}=e,o=n==="x25519";if(!o&&n!=="x448")throw new Error("invalid type");const a=o?255:448,c=o?32:56,l=BigInt(o?9:5),u=BigInt(o?121665:39081),d=o?vn**BigInt(254):vn**BigInt(447),h=o?BigInt(8)*vn**BigInt(251)-jt:BigInt(4)*vn**BigInt(445)-jt,p=d+h+jt,f=x=>ae(x,t),g=m(l);function m(x){return qr(f(x),c)}function v(x){const k=ue("u coordinate",x,c);return o&&(k[31]&=127),f($t(k))}function P(x){return $t(s(ue("scalar",x,c)))}function b(x,k){const L=_(v(k),P(x));if(L===_r)throw new Error("invalid private or public key received");return m(L)}function w(x){return b(x,g)}function E(x,k,L){const F=f(x*(k-L));return k=f(k-F),L=f(L+F),{x_2:k,x_3:L}}function _(x,k){qe("u",x,_r,t),qe("scalar",k,d,p);const L=k,F=x;let D=jt,N=_r,R=x,B=jt,C=_r;for(let M=BigInt(a-1);M>=_r;M--){const A=L>>M&jt;C^=A,{x_2:D,x_3:R}=E(C,D,R),{x_2:N,x_3:B}=E(C,N,B),C=A;const y=D+N,S=f(y*y),T=D-N,O=f(T*T),U=S-O,$=R+B,z=R-B,q=f(z*y),H=f($*T),ee=q+H,J=q-H;R=f(ee*ee),B=f(F*f(J*J)),D=f(S*O),N=f(U*(S+f(u*U)))}({x_2:D,x_3:R}=E(C,D,R)),{x_2:N,x_3:B}=E(C,N,B);const I=i(N);return f(D*I)}return{scalarMult:b,scalarMultBase:w,getSharedSecret:(x,k)=>b(x,k),getPublicKey:x=>w(x),utils:{randomPrivateKey:()=>e.randomBytes(c)},GuBytes:g.slice()}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Wr=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Sa=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const Qp=BigInt(1),xa=BigInt(2),jp=BigInt(3),Zp=BigInt(5),Jp=BigInt(8);function nu(r){const e=BigInt(10),t=BigInt(20),n=BigInt(40),s=BigInt(80),i=Wr,a=r*r%i*r%i,c=le(a,xa,i)*a%i,l=le(c,Qp,i)*r%i,u=le(l,Zp,i)*l%i,d=le(u,e,i)*u%i,h=le(d,t,i)*d%i,p=le(h,n,i)*h%i,f=le(p,s,i)*p%i,g=le(f,s,i)*p%i,m=le(g,e,i)*u%i;return{pow_p_5_8:le(m,xa,i)*r%i,b2:a}}function su(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function eg(r,e){const t=Wr,n=ae(e*e*e,t),s=ae(n*n*e,t),i=nu(r*s).pow_p_5_8;let o=ae(r*n*i,t);const a=ae(e*o*o,t),c=o,l=ae(o*Sa,t),u=a===r,d=a===ae(-r,t),h=a===ae(-r*Sa,t);return u&&(o=c),(d||h)&&(o=l),Fp(o,t)&&(o=ae(-o,t)),{isValid:u||d,value:o}}const Aa=cn(Wr,void 0,!0),tg={a:Aa.create(BigInt(-1)),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Aa,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Jp,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Pp,randomBytes:Cs,adjustScalarBytes:su,uvRatio:eg},Xn=Gp(tg),En=Xp({P:Wr,type:"x25519",powPminus2:r=>{const e=Wr,{pow_p_5_8:t,b2:n}=nu(r);return ae(le(t,jp,e)*n,e)},adjustScalarBytes:su,randomBytes:Cs}),iu=32,ou=64,$i=32;function rg(){const r=Xn.utils.randomPrivateKey(),e=Xn.getPublicKey(r);return{privateKey:ig(r,e),publicKey:e}}function ng(r,e){const t=r.subarray(0,$i);return Xn.sign(e instanceof Uint8Array?e:e.subarray(),t)}function sg(r,e,t){return Xn.verify(e,t instanceof Uint8Array?t:t.subarray(),r)}function ig(r,e){const t=new Uint8Array(ou);for(let n=0;n<$i;n++)t[n]=r[n],t[$i+n]=e[n];return t}class au{type="Ed25519";raw;constructor(e){this.raw=To(e,iu)}toMultihash(){return rn.digest(yt(this))}toCID(){return oe.createV1(114,this.toMultihash())}toString(){return me.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:De(this.raw,e.raw)}verify(e,t){return sg(this.raw,t,e)}}class og{type="Ed25519";raw;publicKey;constructor(e,t){this.raw=To(e,ou),this.publicKey=new au(t)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:De(this.raw,e.raw)}sign(e){return ng(this.raw,e)}}function cu(r){return r=To(r,iu),new au(r)}async function ag(){const{privateKey:r,publicKey:e}=rg();return new og(r,e)}function To(r,e){if(r=Uint8Array.from(r??[]),r.length!==e)throw new W(`Key must be a Uint8Array of length ${e}, got ${r.length}`);return r}const cg=Math.pow(2,7),lg=Math.pow(2,14),ug=Math.pow(2,21),Po=Math.pow(2,28),ko=Math.pow(2,35),_o=Math.pow(2,42),Do=Math.pow(2,49),te=128,Pe=127;function Se(r){if(r<cg)return 1;if(r<lg)return 2;if(r<ug)return 3;if(r<Po)return 4;if(r<ko)return 5;if(r<_o)return 6;if(r<Do)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function lu(r,e,t=0){switch(Se(r)){case 8:e[t++]=r&255|te,r/=128;case 7:e[t++]=r&255|te,r/=128;case 6:e[t++]=r&255|te,r/=128;case 5:e[t++]=r&255|te,r/=128;case 4:e[t++]=r&255|te,r>>>=7;case 3:e[t++]=r&255|te,r>>>=7;case 2:e[t++]=r&255|te,r>>>=7;case 1:{e[t++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return e}function dg(r,e,t=0){switch(Se(r)){case 8:e.set(t++,r&255|te),r/=128;case 7:e.set(t++,r&255|te),r/=128;case 6:e.set(t++,r&255|te),r/=128;case 5:e.set(t++,r&255|te),r/=128;case 4:e.set(t++,r&255|te),r>>>=7;case 3:e.set(t++,r&255|te),r>>>=7;case 2:e.set(t++,r&255|te),r>>>=7;case 1:{e.set(t++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return e}function uu(r,e){let t=r[e],n=0;if(n+=t&Pe,t<te||(t=r[e+1],n+=(t&Pe)<<7,t<te)||(t=r[e+2],n+=(t&Pe)<<14,t<te)||(t=r[e+3],n+=(t&Pe)<<21,t<te)||(t=r[e+4],n+=(t&Pe)*Po,t<te)||(t=r[e+5],n+=(t&Pe)*ko,t<te)||(t=r[e+6],n+=(t&Pe)*_o,t<te)||(t=r[e+7],n+=(t&Pe)*Do,t<te))return n;throw new RangeError("Could not decode varint")}function hg(r,e){let t=r.get(e),n=0;if(n+=t&Pe,t<te||(t=r.get(e+1),n+=(t&Pe)<<7,t<te)||(t=r.get(e+2),n+=(t&Pe)<<14,t<te)||(t=r.get(e+3),n+=(t&Pe)<<21,t<te)||(t=r.get(e+4),n+=(t&Pe)*Po,t<te)||(t=r.get(e+5),n+=(t&Pe)*ko,t<te)||(t=r.get(e+6),n+=(t&Pe)*_o,t<te)||(t=r.get(e+7),n+=(t&Pe)*Do,t<te))return n;throw new RangeError("Could not decode varint")}function ot(r,e,t=0){return e==null&&(e=ct(Se(r))),e instanceof Uint8Array?lu(r,e,t):dg(r,e,t)}function Gt(r,e=0){return r instanceof Uint8Array?uu(r,e):hg(r,e)}const Lo=new Float32Array([-0]),Ct=new Uint8Array(Lo.buffer);function fg(r,e,t){Lo[0]=r,e[t]=Ct[0],e[t+1]=Ct[1],e[t+2]=Ct[2],e[t+3]=Ct[3]}function pg(r,e){return Ct[0]=r[e],Ct[1]=r[e+1],Ct[2]=r[e+2],Ct[3]=r[e+3],Lo[0]}const Ro=new Float64Array([-0]),ke=new Uint8Array(Ro.buffer);function gg(r,e,t){Ro[0]=r,e[t]=ke[0],e[t+1]=ke[1],e[t+2]=ke[2],e[t+3]=ke[3],e[t+4]=ke[4],e[t+5]=ke[5],e[t+6]=ke[6],e[t+7]=ke[7]}function mg(r,e){return ke[0]=r[e],ke[1]=r[e+1],ke[2]=r[e+2],ke[3]=r[e+3],ke[4]=r[e+4],ke[5]=r[e+5],ke[6]=r[e+6],ke[7]=r[e+7],Ro[0]}const yg=BigInt(Number.MAX_SAFE_INTEGER),wg=BigInt(Number.MIN_SAFE_INTEGER);class _e{lo;hi;constructor(e,t){this.lo=e|0,this.hi=t|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(t+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(BigInt(t)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?t===0?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:n<128?9:10}static fromBigInt(e){if(e===0n)return zt;if(e<yg&&e>wg)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let n=e>>32n,s=e-(n<<32n);return t&&(n=~n|0n,s=~s|0n,++s>Ca&&(s=0n,++n>Ca&&(n=0n))),new _e(Number(s),Number(n))}static fromNumber(e){if(e===0)return zt;const t=e<0;t&&(e=-e);let n=e>>>0,s=(e-n)/4294967296>>>0;return t&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new _e(n,s)}static from(e){return typeof e=="number"?_e.fromNumber(e):typeof e=="bigint"?_e.fromBigInt(e):typeof e=="string"?_e.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new _e(e.low>>>0,e.high>>>0):zt}}const zt=new _e(0,0);zt.toBigInt=function(){return 0n};zt.zzEncode=zt.zzDecode=function(){return this};zt.length=function(){return 1};const Ca=4294967296n;function bg(r){let e=0,t=0;for(let n=0;n<r.length;++n)t=r.charCodeAt(n),t<128?e+=1:t<2048?e+=2:(t&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,e+=4):e+=3;return e}function vg(r,e,t){if(t-e<1)return"";let s;const i=[];let o=0,a;for(;e<t;)a=r[e++],a<128?i[o++]=a:a>191&&a<224?i[o++]=(a&31)<<6|r[e++]&63:a>239&&a<365?(a=((a&7)<<18|(r[e++]&63)<<12|(r[e++]&63)<<6|r[e++]&63)-65536,i[o++]=55296+(a>>10),i[o++]=56320+(a&1023)):i[o++]=(a&15)<<12|(r[e++]&63)<<6|r[e++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function du(r,e,t){const n=t;let s,i;for(let o=0;o<r.length;++o)s=r.charCodeAt(o),s<128?e[t++]=s:s<2048?(e[t++]=s>>6|192,e[t++]=s&63|128):(s&64512)===55296&&((i=r.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,e[t++]=s>>18|240,e[t++]=s>>12&63|128,e[t++]=s>>6&63|128,e[t++]=s&63|128):(e[t++]=s>>12|224,e[t++]=s>>6&63|128,e[t++]=s&63|128);return t-n}function Qe(r,e){return RangeError(`index out of range: ${r.pos} + ${e??1} > ${r.len}`)}function Sn(r,e){return(r[e-4]|r[e-3]<<8|r[e-2]<<16|r[e-1]<<24)>>>0}class Eg{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(e){this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,Qe(this,10);return e}int32(){return this.uint32()|0}sint32(){const e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw Qe(this,4);return Sn(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw Qe(this,4);return Sn(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw Qe(this,4);const e=pg(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw Qe(this,4);const e=mg(this.buf,this.pos);return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,n=this.pos+e;if(n>this.len)throw Qe(this,e);return this.pos+=e,t===n?new Uint8Array(0):this.buf.subarray(t,n)}string(){const e=this.bytes();return vg(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw Qe(this,e);this.pos+=e}else do if(this.pos>=this.len)throw Qe(this);while((this.buf[this.pos++]&128)!==0);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new _e(0,0);let t=0;if(this.len-this.pos>4){for(;t<4;++t)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw Qe(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,e}if(this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw Qe(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw Qe(this,8);const e=Sn(this.buf,this.pos+=4),t=Sn(this.buf,this.pos+=4);return new _e(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=uu(this.buf,this.pos);return this.pos+=Se(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function Sg(r){return new Eg(r instanceof Uint8Array?r:r.subarray())}function fe(r,e,t){const n=Sg(r);return e.decode(n,void 0,t)}function xg(r){let n,s=8192;return function(o){if(o<1||o>4096)return ct(o);s+o>8192&&(n=ct(8192),s=0);const a=n.subarray(s,s+=o);return(s&7)!==0&&(s=(s|7)+1),a}}class Rr{fn;len;next;val;constructor(e,t,n){this.fn=e,this.len=t,this.next=void 0,this.val=n}}function Qs(){}class Ag{head;tail;len;next;constructor(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}}const Cg=xg();function Ig(r){return globalThis.Buffer!=null?ct(r):Cg(r)}class zi{len;head;tail;states;constructor(){this.len=0,this.head=new Rr(Qs,0,0),this.tail=this.head,this.states=null}_push(e,t,n){return this.tail=this.tail.next=new Rr(e,t,n),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new Pg((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(xn,10,_e.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=_e.fromBigInt(e);return this._push(xn,t.length(),t)}uint64Number(e){return this._push(lu,Se(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=_e.fromBigInt(e).zzEncode();return this._push(xn,t.length(),t)}sint64Number(e){const t=_e.fromNumber(e).zzEncode();return this._push(xn,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(js,1,e?1:0)}fixed32(e){return this._push(Dr,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=_e.fromBigInt(e);return this._push(Dr,4,t.lo)._push(Dr,4,t.hi)}fixed64Number(e){const t=_e.fromNumber(e);return this._push(Dr,4,t.lo)._push(Dr,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(fg,4,e)}double(e){return this._push(gg,8,e)}bytes(e){const t=e.length>>>0;return t===0?this._push(js,1,0):this.uint32(t)._push(kg,t,e)}string(e){const t=bg(e);return t!==0?this.uint32(t)._push(du,t,e):this._push(js,1,0)}fork(){return this.states=new Ag(this),this.head=this.tail=new Rr(Qs,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Rr(Qs,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=e.next,this.tail=t,this.len+=n),this}finish(){let e=this.head.next;const t=Ig(this.len);let n=0;for(;e!=null;)e.fn(e.val,t,n),n+=e.len,e=e.next;return t}}function js(r,e,t){e[t]=r&255}function Tg(r,e,t){for(;r>127;)e[t++]=r&127|128,r>>>=7;e[t]=r}class Pg extends Rr{next;constructor(e,t){super(Tg,e,t),this.next=void 0}}function xn(r,e,t){for(;r.hi!==0;)e[t++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)e[t++]=r.lo&127|128,r.lo=r.lo>>>7;e[t++]=r.lo}function Dr(r,e,t){e[t]=r&255,e[t+1]=r>>>8&255,e[t+2]=r>>>16&255,e[t+3]=r>>>24}function kg(r,e,t){e.set(r,t)}globalThis.Buffer!=null&&(zi.prototype.bytes=function(r){const e=r.length>>>0;return this.uint32(e),e>0&&this._push(_g,e,r),this},zi.prototype.string=function(r){const e=globalThis.Buffer.byteLength(r);return this.uint32(e),e>0&&this._push(Dg,e,r),this});function _g(r,e,t){e.set(r,t)}function Dg(r,e,t){r.length<40?du(r,e,t):e.utf8Write!=null?e.utf8Write(r,t):e.set(K(r),t)}function Lg(){return new zi}function pe(r,e){const t=Lg();return e.encode(r,t,{lengthDelimited:!1}),t.finish()}var Qn;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(Qn||(Qn={}));function hu(r,e,t,n){return{name:r,type:e,encode:t,decode:n}}function xr(r){function e(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}const t=function(i,o){const a=e(i);o.int32(a)},n=function(i){const o=i.int32();return e(o)};return hu("enum",Qn.VARINT,t,n)}function ge(r,e){return hu("message",Qn.LENGTH_DELIMITED,r,e)}class bt extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"}class Ia extends Error{code="ERR_MAX_SIZE";name="MaxSizeError"}var xe;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1",r.ECDSA="ECDSA"})(xe||(xe={}));var Ki;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1",r[r.ECDSA=3]="ECDSA"})(Ki||(Ki={}));(function(r){r.codec=()=>xr(Ki)})(xe||(xe={}));var lr;(function(r){let e;r.codec=()=>(e==null&&(e=ge((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),xe.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.Type=xe.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>pe(t,r.codec()),r.decode=(t,n)=>fe(t,r.codec(),n)})(lr||(lr={}));var Ta;(function(r){let e;r.codec=()=>(e==null&&(e=ge((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),xe.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.Type=xe.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>pe(t,r.codec()),r.decode=(t,n)=>fe(t,r.codec(),n)})(Ta||(Ta={}));function Mo(r){if(isNaN(r)||r<=0)throw new W("random bytes length must be a Number bigger than 0");return Cs(r)}class Pa extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}}class Rg extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}}const ka={get(r=globalThis){const e=r.crypto;if(e?.subtle==null)throw new Rg("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return e}},Un=ql;class Mg{type="RSA";jwk;_raw;_multihash;constructor(e,t){this.jwk=e,this._multihash=t}get raw(){return this._raw==null&&(this._raw=Bg(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return oe.createV1(114,this._multihash)}toString(){return me.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:De(this.raw,e.raw)}verify(e,t){return Kg(this.jwk,t,e)}}const Og=18,Ng=1062,Fg=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function Ug(r){const e=As(r[1],{offset:0});return{kty:"RSA",n:G(e[0],"base64url"),e:G(e[1],"base64url")}}function Bg(r){if(r.n==null||r.e==null)throw new W("JWK was missing components");return Nr([Fg,Fl(Nr([Ni(K(r.n,"base64url")),Ni(K(r.e,"base64url"))]))]).subarray()}function $g(r,e){if(r.byteLength>=Ng)throw new wl("Key size is too large");const t=As(r,{offset:0});return zg(t,r,e)}function zg(r,e,t){const n=Ug(r);if(t==null){const s=Un(lr.encode({Type:xe.RSA,Data:e}));t=zr(Og,s)}return new Mg(n,t)}async function Kg(r,e,t){const n=await ka.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);return ka.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},n,e,t instanceof Uint8Array?t:t.subarray())}class fu extends Bl{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Eo(e);const n=Kr(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(n.length>s?e.create().update(n).digest():n);for(let o=0;o<i.length;o++)i[o]^=54;this.iHash.update(i),this.oHash=e.create();for(let o=0;o<i.length;o++)i[o]^=106;this.oHash.update(i),qt(i)}update(e){return Vn(this),this.iHash.update(e),this}digestInto(e){Vn(this),sn(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=i,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ts=(r,e,t)=>new fu(r,e).update(t).digest();Ts.create=(r,e)=>new fu(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function _a(r){r.lowS!==void 0&&Tt("lowS",r.lowS),r.prehash!==void 0&&Tt("prehash",r.prehash)}function qg(r){const e=Io(r);Sr(e,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:t,Fp:n,a:s}=e;if(t){if(!n.eql(s,n.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...e})}class Wg extends Error{constructor(e=""){super(e)}}const pt={Err:Wg,_tlv:{encode:(r,e)=>{const{Err:t}=pt;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const n=e.length/2,s=bn(n);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const i=n>127?bn(s.length/2|128):"";return bn(r)+i+s+e},decode(r,e){const{Err:t}=pt;let n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");const s=e[n++],i=!!(s&128);let o=0;if(!i)o=s;else{const c=s&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const l=e.subarray(n,n+c);if(l.length!==c)throw new t("tlv.decode: length bytes not complete");if(l[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const u of l)o=o<<8|u;if(n+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(n,n+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+o)}}},_int:{encode(r){const{Err:e}=pt;if(r<gt)throw new e("integer: negative integers are not allowed");let t=bn(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(r){const{Err:e}=pt;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return Bt(r)}},toSig(r){const{Err:e,_int:t,_tlv:n}=pt,s=ue("signature",r),{v:i,l:o}=n.decode(48,s);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,i),{v:l,l:u}=n.decode(2,c);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(l)}},hexFromSig(r){const{_tlv:e,_int:t}=pt,n=e.encode(2,t.encode(r.r)),s=e.encode(2,t.encode(r.s)),i=n+s;return e.encode(48,i)}};function Zs(r,e){return ar(an(r,e))}const gt=BigInt(0),be=BigInt(1);BigInt(2);const Js=BigInt(3),Hg=BigInt(4);function Vg(r){const e=qg(r),{Fp:t}=e,n=cn(e.n,e.nBitLength),s=e.toBytes||((b,w,E)=>{const _=w.toAffine();return cr(Uint8Array.from([4]),t.toBytes(_.x),t.toBytes(_.y))}),i=e.fromBytes||(b=>{const w=b.subarray(1),E=t.fromBytes(w.subarray(0,t.BYTES)),_=t.fromBytes(w.subarray(t.BYTES,2*t.BYTES));return{x:E,y:_}});function o(b){const{a:w,b:E}=e,_=t.sqr(b),x=t.mul(_,b);return t.add(t.add(x,t.mul(b,w)),E)}function a(b,w){const E=t.sqr(w),_=o(b);return t.eql(E,_)}if(!a(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const c=t.mul(t.pow(e.a,Js),Hg),l=t.mul(t.sqr(e.b),BigInt(27));if(t.is0(t.add(c,l)))throw new Error("bad curve params: a or b");function u(b){return Ao(b,be,e.n)}function d(b){const{allowedPrivateKeyLengths:w,nByteLength:E,wrapPrivateKey:_,n:x}=e;if(w&&typeof b!="bigint"){if(on(b)&&(b=ar(b)),typeof b!="string"||!w.includes(b.length))throw new Error("invalid private key");b=b.padStart(E*2,"0")}let k;try{k=typeof b=="bigint"?b:Bt(ue("private key",b,E))}catch{throw new Error("invalid private key, expected hex or "+E+" bytes, got "+typeof b)}return _&&(k=ae(k,x)),qe("private key",k,be,x),k}function h(b){if(!(b instanceof g))throw new Error("ProjectivePoint expected")}const p=Yn((b,w)=>{const{px:E,py:_,pz:x}=b;if(t.eql(x,t.ONE))return{x:E,y:_};const k=b.is0();w==null&&(w=k?t.ONE:t.inv(x));const L=t.mul(E,w),F=t.mul(_,w),D=t.mul(x,w);if(k)return{x:t.ZERO,y:t.ZERO};if(!t.eql(D,t.ONE))throw new Error("invZ was invalid");return{x:L,y:F}}),f=Yn(b=>{if(b.is0()){if(e.allowInfinityPoint&&!t.is0(b.py))return;throw new Error("bad point: ZERO")}const{x:w,y:E}=b.toAffine();if(!t.isValid(w)||!t.isValid(E))throw new Error("bad point: x or y not FE");if(!a(w,E))throw new Error("bad point: equation left != right");if(!b.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(w,E,_){if(w==null||!t.isValid(w))throw new Error("x required");if(E==null||!t.isValid(E)||t.is0(E))throw new Error("y required");if(_==null||!t.isValid(_))throw new Error("z required");this.px=w,this.py=E,this.pz=_,Object.freeze(this)}static fromAffine(w){const{x:E,y:_}=w||{};if(!w||!t.isValid(E)||!t.isValid(_))throw new Error("invalid affine point");if(w instanceof g)throw new Error("projective point not allowed");const x=k=>t.eql(k,t.ZERO);return x(E)&&x(_)?g.ZERO:new g(E,_,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(w){const E=Co(t,w.map(_=>_.pz));return w.map((_,x)=>_.toAffine(E[x])).map(g.fromAffine)}static fromHex(w){const E=g.fromAffine(i(ue("pointHex",w)));return E.assertValidity(),E}static fromPrivateKey(w){return g.BASE.multiply(d(w))}static msm(w,E){return ru(g,n,w,E)}_setWindowSize(w){P.setWindowSize(this,w)}assertValidity(){f(this)}hasEvenY(){const{y:w}=this.toAffine();if(t.isOdd)return!t.isOdd(w);throw new Error("Field doesn't support isOdd")}equals(w){h(w);const{px:E,py:_,pz:x}=this,{px:k,py:L,pz:F}=w,D=t.eql(t.mul(E,F),t.mul(k,x)),N=t.eql(t.mul(_,F),t.mul(L,x));return D&&N}negate(){return new g(this.px,t.neg(this.py),this.pz)}double(){const{a:w,b:E}=e,_=t.mul(E,Js),{px:x,py:k,pz:L}=this;let F=t.ZERO,D=t.ZERO,N=t.ZERO,R=t.mul(x,x),B=t.mul(k,k),C=t.mul(L,L),I=t.mul(x,k);return I=t.add(I,I),N=t.mul(x,L),N=t.add(N,N),F=t.mul(w,N),D=t.mul(_,C),D=t.add(F,D),F=t.sub(B,D),D=t.add(B,D),D=t.mul(F,D),F=t.mul(I,F),N=t.mul(_,N),C=t.mul(w,C),I=t.sub(R,C),I=t.mul(w,I),I=t.add(I,N),N=t.add(R,R),R=t.add(N,R),R=t.add(R,C),R=t.mul(R,I),D=t.add(D,R),C=t.mul(k,L),C=t.add(C,C),R=t.mul(C,I),F=t.sub(F,R),N=t.mul(C,B),N=t.add(N,N),N=t.add(N,N),new g(F,D,N)}add(w){h(w);const{px:E,py:_,pz:x}=this,{px:k,py:L,pz:F}=w;let D=t.ZERO,N=t.ZERO,R=t.ZERO;const B=e.a,C=t.mul(e.b,Js);let I=t.mul(E,k),M=t.mul(_,L),A=t.mul(x,F),y=t.add(E,_),S=t.add(k,L);y=t.mul(y,S),S=t.add(I,M),y=t.sub(y,S),S=t.add(E,x);let T=t.add(k,F);return S=t.mul(S,T),T=t.add(I,A),S=t.sub(S,T),T=t.add(_,x),D=t.add(L,F),T=t.mul(T,D),D=t.add(M,A),T=t.sub(T,D),R=t.mul(B,S),D=t.mul(C,A),R=t.add(D,R),D=t.sub(M,R),R=t.add(M,R),N=t.mul(D,R),M=t.add(I,I),M=t.add(M,I),A=t.mul(B,A),S=t.mul(C,S),M=t.add(M,A),A=t.sub(I,A),A=t.mul(B,A),S=t.add(S,A),I=t.mul(M,S),N=t.add(N,I),I=t.mul(T,S),D=t.mul(y,D),D=t.sub(D,I),I=t.mul(y,M),R=t.mul(T,R),R=t.add(R,I),new g(D,N,R)}subtract(w){return this.add(w.negate())}is0(){return this.equals(g.ZERO)}wNAF(w){return P.wNAFCached(this,w,g.normalizeZ)}multiplyUnsafe(w){const{endo:E,n:_}=e;qe("scalar",w,gt,_);const x=g.ZERO;if(w===gt)return x;if(this.is0()||w===be)return this;if(!E||P.hasPrecomputes(this))return P.wNAFCachedUnsafe(this,w,g.normalizeZ);let{k1neg:k,k1:L,k2neg:F,k2:D}=E.splitScalar(w),N=x,R=x,B=this;for(;L>gt||D>gt;)L&be&&(N=N.add(B)),D&be&&(R=R.add(B)),B=B.double(),L>>=be,D>>=be;return k&&(N=N.negate()),F&&(R=R.negate()),R=new g(t.mul(R.px,E.beta),R.py,R.pz),N.add(R)}multiply(w){const{endo:E,n:_}=e;qe("scalar",w,be,_);let x,k;if(E){const{k1neg:L,k1:F,k2neg:D,k2:N}=E.splitScalar(w);let{p:R,f:B}=this.wNAF(F),{p:C,f:I}=this.wNAF(N);R=P.constTimeNegate(L,R),C=P.constTimeNegate(D,C),C=new g(t.mul(C.px,E.beta),C.py,C.pz),x=R.add(C),k=B.add(I)}else{const{p:L,f:F}=this.wNAF(w);x=L,k=F}return g.normalizeZ([x,k])[0]}multiplyAndAddUnsafe(w,E,_){const x=g.BASE,k=(F,D)=>D===gt||D===be||!F.equals(x)?F.multiplyUnsafe(D):F.multiply(D),L=k(this,E).add(k(w,_));return L.is0()?void 0:L}toAffine(w){return p(this,w)}isTorsionFree(){const{h:w,isTorsionFree:E}=e;if(w===be)return!0;if(E)return E(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:w,clearCofactor:E}=e;return w===be?this:E?E(g,this):this.multiplyUnsafe(e.h)}toRawBytes(w=!0){return Tt("isCompressed",w),this.assertValidity(),s(g,this,w)}toHex(w=!0){return Tt("isCompressed",w),ar(this.toRawBytes(w))}}g.BASE=new g(e.Gx,e.Gy,t.ONE),g.ZERO=new g(t.ZERO,t.ONE,t.ZERO);const{endo:m,nBitLength:v}=e,P=tu(g,m?Math.ceil(v/2):v);return{CURVE:e,ProjectivePoint:g,normPrivateKeyToScalar:d,weierstrassEquation:o,isWithinCurveOrder:u}}function Gg(r){const e=Io(r);return Sr(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Yg(r){const e=Gg(r),{Fp:t,n,nByteLength:s,nBitLength:i}=e,o=t.BYTES+1,a=2*t.BYTES+1;function c(C){return ae(C,n)}function l(C){return Ui(C,n)}const{ProjectivePoint:u,normPrivateKeyToScalar:d,weierstrassEquation:h,isWithinCurveOrder:p}=Vg({...e,toBytes(C,I,M){const A=I.toAffine(),y=t.toBytes(A.x),S=cr;return Tt("isCompressed",M),M?S(Uint8Array.from([I.hasEvenY()?2:3]),y):S(Uint8Array.from([4]),y,t.toBytes(A.y))},fromBytes(C){const I=C.length,M=C[0],A=C.subarray(1);if(I===o&&(M===2||M===3)){const y=Bt(A);if(!Ao(y,be,t.ORDER))throw new Error("Point is not on curve");const S=h(y);let T;try{T=t.sqrt(S)}catch($){const z=$ instanceof Error?": "+$.message:"";throw new Error("Point is not on curve"+z)}const O=(T&be)===be;return(M&1)===1!==O&&(T=t.neg(T)),{x:y,y:T}}else if(I===a&&M===4){const y=t.fromBytes(A.subarray(0,t.BYTES)),S=t.fromBytes(A.subarray(t.BYTES,2*t.BYTES));return{x:y,y:S}}else{const y=o,S=a;throw new Error("invalid Point, expected length of "+y+", or uncompressed "+S+", got "+I)}}});function f(C){const I=n>>be;return C>I}function g(C){return f(C)?c(-C):C}const m=(C,I,M)=>Bt(C.slice(I,M));class v{constructor(I,M,A){qe("r",I,be,n),qe("s",M,be,n),this.r=I,this.s=M,A!=null&&(this.recovery=A),Object.freeze(this)}static fromCompact(I){const M=s;return I=ue("compactSignature",I,M*2),new v(m(I,0,M),m(I,M,2*M))}static fromDER(I){const{r:M,s:A}=pt.toSig(ue("DER",I));return new v(M,A)}assertValidity(){}addRecoveryBit(I){return new v(this.r,this.s,I)}recoverPublicKey(I){const{r:M,s:A,recovery:y}=this,S=x(ue("msgHash",I));if(y==null||![0,1,2,3].includes(y))throw new Error("recovery id invalid");const T=y===2||y===3?M+e.n:M;if(T>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const O=(y&1)===0?"02":"03",U=u.fromHex(O+Zs(T,t.BYTES)),$=l(T),z=c(-S*$),q=c(A*$),H=u.BASE.multiplyAndAddUnsafe(U,z,q);if(!H)throw new Error("point at infinify");return H.assertValidity(),H}hasHighS(){return f(this.s)}normalizeS(){return this.hasHighS()?new v(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return Gn(this.toDERHex())}toDERHex(){return pt.hexFromSig(this)}toCompactRawBytes(){return Gn(this.toCompactHex())}toCompactHex(){const I=s;return Zs(this.r,I)+Zs(this.s,I)}}const P={isValidPrivateKey(C){try{return d(C),!0}catch{return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{const C=Zl(e.n);return zp(e.randomBytes(C),e.n)},precompute(C=8,I=u.BASE){return I._setWindowSize(C),I.multiply(BigInt(3)),I}};function b(C,I=!0){return u.fromPrivateKey(C).toRawBytes(I)}function w(C){if(typeof C=="bigint")return!1;if(C instanceof u)return!0;const M=ue("key",C).length,A=t.BYTES,y=A+1,S=2*A+1;if(!(e.allowedPrivateKeyLengths||s===y))return M===y||M===S}function E(C,I,M=!0){if(w(C)===!0)throw new Error("first arg must be private key");if(w(I)===!1)throw new Error("second arg must be public key");return u.fromHex(I).multiply(d(C)).toRawBytes(M)}const _=e.bits2int||function(C){if(C.length>8192)throw new Error("input is too large");const I=Bt(C),M=C.length*8-i;return M>0?I>>BigInt(M):I},x=e.bits2int_modN||function(C){return c(_(C))},k=Is(i);function L(C){return qe("num < 2^"+i,C,gt,k),an(C,s)}function F(C,I,M=D){if(["recovered","canonical"].some(J=>J in M))throw new Error("sign() legacy options not supported");const{hash:A,randomBytes:y}=e;let{lowS:S,prehash:T,extraEntropy:O}=M;S==null&&(S=!0),C=ue("msgHash",C),_a(M),T&&(C=ue("prehashed msgHash",A(C)));const U=x(C),$=d(I),z=[L($),L(U)];if(O!=null&&O!==!1){const J=O===!0?y(t.BYTES):O;z.push(ue("extraEntropy",J))}const q=cr(...z),H=U;function ee(J){const ve=_(J);if(!p(ve))return;const Ne=l(ve),we=u.BASE.multiply(ve).toAffine(),Ie=c(we.x);if(Ie===gt)return;const ze=c(Ne*c(H+Ie*$));if(ze===gt)return;let Xe=(we.x===Ie?0:2)|Number(we.y&be),Ir=ze;return S&&f(ze)&&(Ir=g(ze),Xe^=1),new v(Ie,Ir,Xe)}return{seed:q,k2sig:ee}}const D={lowS:e.lowS,prehash:!1},N={lowS:e.lowS,prehash:!1};function R(C,I,M=D){const{seed:A,k2sig:y}=F(C,I,M),S=e;return Dp(S.hash.outputLen,S.nByteLength,S.hmac)(A,y)}u.BASE._setWindowSize(8);function B(C,I,M,A=N){const y=C;I=ue("msgHash",I),M=ue("publicKey",M);const{lowS:S,prehash:T,format:O}=A;if(_a(A),"strict"in A)throw new Error("options.strict was renamed to lowS");if(O!==void 0&&O!=="compact"&&O!=="der")throw new Error("format must be compact or der");const U=typeof y=="string"||on(y),$=!U&&!O&&typeof y=="object"&&y!==null&&typeof y.r=="bigint"&&typeof y.s=="bigint";if(!U&&!$)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let z,q;try{if($&&(z=new v(y.r,y.s)),U){try{O!=="compact"&&(z=v.fromDER(y))}catch(Xe){if(!(Xe instanceof pt.Err))throw Xe}!z&&O!=="der"&&(z=v.fromCompact(y))}q=u.fromHex(M)}catch{return!1}if(!z||S&&z.hasHighS())return!1;T&&(I=e.hash(I));const{r:H,s:ee}=z,J=x(I),ve=l(ee),Ne=c(J*ve),we=c(H*ve),Ie=u.BASE.multiplyAndAddUnsafe(q,Ne,we)?.toAffine();return Ie?c(Ie.x)===H:!1}return{CURVE:e,getPublicKey:b,getSharedSecret:E,sign:R,verify:B,ProjectivePoint:u,Signature:v,utils:P}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Xg(r){return{hash:r,hmac:(e,...t)=>Ts(r,e,dp(...t)),randomBytes:Cs}}function Qg(r,e){const t=n=>Yg({...r,...Xg(n)});return{...t(e),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const pu=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Da=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),jg=BigInt(0),Zg=BigInt(1),qi=BigInt(2),La=(r,e)=>(r+e/qi)/e;function Jg(r){const e=pu,t=BigInt(3),n=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),l=r*r*r%e,u=l*l*r%e,d=le(u,t,e)*u%e,h=le(d,t,e)*u%e,p=le(h,qi,e)*l%e,f=le(p,s,e)*p%e,g=le(f,i,e)*f%e,m=le(g,a,e)*g%e,v=le(m,c,e)*m%e,P=le(v,a,e)*g%e,b=le(P,t,e)*u%e,w=le(b,o,e)*f%e,E=le(w,n,e)*l%e,_=le(E,qi,e);if(!Wi.eql(Wi.sqr(_),r))throw new Error("Cannot find square root");return _}const Wi=cn(pu,void 0,void 0,{sqrt:Jg}),jn=Qg({a:jg,b:BigInt(7),Fp:Wi,n:Da,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{const e=Da,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Zg*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=t,o=BigInt("0x100000000000000000000000000000000"),a=La(i*r,e),c=La(-n*r,e);let l=ae(r-a*t-c*s,e),u=ae(-a*n-c*i,e);const d=l>o,h=u>o;if(d&&(l=e-l),h&&(u=e-u),l>o||u>o)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:d,k1:l,k2neg:h,k2:u}}}},ql);function em(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}function tm(r,e,t){const n=Ml.digest(t instanceof Uint8Array?t:t.subarray());if(em(n))return n.then(({digest:s})=>jn.verify(e,s,r)).catch(s=>{throw new Pa(String(s))});try{return jn.verify(e,n.digest,r)}catch(s){throw new Pa(String(s))}}class rm{type="secp256k1";raw;_key;constructor(e){this._key=sm(e),this.raw=nm(this._key)}toMultihash(){return rn.digest(yt(this))}toCID(){return oe.createV1(114,this.toMultihash())}toString(){return me.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:De(this.raw,e.raw)}verify(e,t){return tm(this._key,t,e)}}function gu(r){return new rm(r)}function nm(r){return jn.ProjectivePoint.fromHex(r).toRawBytes(!0)}function sm(r){try{return jn.ProjectivePoint.fromHex(r),r}catch(e){throw new wl(String(e))}}async function im(r,e){return ag()}function Dt(r,e){const{Type:t,Data:n}=lr.decode(r),s=n??new Uint8Array;switch(t){case xe.RSA:return $g(s,e);case xe.Ed25519:return cu(s);case xe.secp256k1:return gu(s);case xe.ECDSA:return Ul(s);default:throw new yo}}function om(r){const{Type:e,Data:t}=lr.decode(r.digest),n=t??new Uint8Array;switch(e){case xe.Ed25519:return cu(n);case xe.secp256k1:return gu(n);case xe.ECDSA:return Ul(n);default:throw new yo}}function yt(r){return lr.encode({Type:xe[r.type],Data:r.raw})}const mu=Symbol.for("nodejs.util.inspect.custom"),am=114;class Oo{type;multihash;publicKey;string;constructor(e){this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[uo]=!0;toString(){return this.string==null&&(this.string=me.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return oe.createV1(am,this.multihash)}toJSON(){return this.toString()}equals(e){if(e==null)return!1;if(e instanceof Uint8Array)return De(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(e?.toMultihash()?.bytes!=null)return De(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[mu](){return`PeerId(${this.toString()})`}}class yu extends Oo{type="RSA";publicKey;constructor(e){super({...e,type:"RSA"}),this.publicKey=e.publicKey}}class wu extends Oo{type="Ed25519";publicKey;constructor(e){super({...e,type:"Ed25519"}),this.publicKey=e.publicKey}}class bu extends Oo{type="secp256k1";publicKey;constructor(e){super({...e,type:"secp256k1"}),this.publicKey=e.publicKey}}const cm=2336;class vu{type="url";multihash;publicKey;url;constructor(e){this.url=e.toString(),this.multihash=rn.digest(K(this.url))}[mu](){return`PeerId(${this.url})`}[uo]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return oe.createV1(cm,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=G(e)),e.toString()===this.toString())}}const lm=114,Ra=2336;function lt(r,e){let t;if(r.charAt(0)==="1"||r.charAt(0)==="Q")t=Vt(me.decode(`z${r}`));else{if(r.startsWith("k51qzi5uqu5")||r.startsWith("kzwfwjn5ji4")||r.startsWith("k2k4r8")||r.startsWith("bafz"))return un(oe.parse(r));throw new W('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return ln(t)}function Hr(r){if(r.type==="Ed25519")return new wu({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new bu({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new yu({multihash:r.toCID().multihash,publicKey:r});throw new yo}function um(r){return Hr(r.publicKey)}function ln(r){if(hm(r))return new yu({multihash:r});if(dm(r))try{const e=om(r);if(e.type==="Ed25519")return new wu({multihash:r,publicKey:e});if(e.type==="secp256k1")return new bu({multihash:r,publicKey:e})}catch{const t=G(r.digest);return new vu(new URL(t))}throw new Eh("Supplied PeerID Multihash is invalid")}function un(r){if(r?.multihash==null||r.version==null||r.version===1&&r.code!==lm&&r.code!==Ra)throw new vh("Supplied PeerID CID is invalid");if(r.code===Ra){const e=G(r.multihash.digest);return new vu(new URL(e))}return ln(r.multihash)}function dm(r){return r.code===rn.code}function hm(r){return r.code===Ml.code}const fm=8,No=1024*1024*4;let pm=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},Eu=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},gm=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"},Ma=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};function Su(r){return r[Symbol.asyncIterator]!=null}function xu(r,e){if(r.byteLength>e)throw new Eu("Message length too long")}const Ps=r=>{const e=Se(r),t=ct(e);return ot(r,t),Ps.bytes=e,t};Ps.bytes=0;function Zn(r,e){e=e??{};const t=e.lengthEncoder??Ps,n=e?.maxDataLength??No;function*s(i){xu(i,n);const o=t(i.byteLength);o instanceof Uint8Array?yield o:yield*o,i instanceof Uint8Array?yield i:yield*i}return Su(r)?async function*(){for await(const i of r)yield*s(i)}():function*(){for(const i of r)yield*s(i)}()}Zn.single=(r,e)=>{e=e??{};const t=e.lengthEncoder??Ps,n=e?.maxDataLength??No;return xu(r,n),new j(t(r.byteLength),r)};var Ot;(function(r){r[r.LENGTH=0]="LENGTH",r[r.DATA=1]="DATA"})(Ot||(Ot={}));const Fo=r=>{const e=Gt(r);return Fo.bytes=Se(e),e};Fo.bytes=0;function Jn(r,e){const t=new j;let n=Ot.LENGTH,s=-1;const i=e?.lengthDecoder??Fo,o=e?.maxLengthLength??fm,a=e?.maxDataLength??No;function*c(){for(;t.byteLength>0;){if(n===Ot.LENGTH)try{if(s=i(t),s<0)throw new pm("Invalid message length");if(s>a)throw new Eu("Message length too long");const l=i.bytes;t.consume(l),e?.onLength!=null&&e.onLength(s),n=Ot.DATA}catch(l){if(l instanceof RangeError){if(t.byteLength>o)throw new gm("Message length length too long");break}throw l}if(n===Ot.DATA){if(t.byteLength<s)break;const l=t.sublist(0,s);t.consume(s),e?.onData!=null&&e.onData(l),yield l,n=Ot.LENGTH}}}return Su(r)?async function*(){for await(const l of r)t.append(l),yield*c();if(t.byteLength>0)throw new Ma("Unexpected end of input")}():function*(){for(const l of r)t.append(l),yield*c();if(t.byteLength>0)throw new Ma("Unexpected end of input")}()}Jn.fromReader=(r,e)=>{let t=1;const n=async function*(){for(;;)try{const{done:i,value:o}=await r.next(t);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{t=1}}();return Jn(n,{...e??{},onLength:i=>{t=i}})};function de(){const r={};return r.promise=new Promise((e,t)=>{r.resolve=e,r.reject=t}),r}let Oa=class extends Error{type;code;constructor(e,t,n){super(e??"The operation was aborted"),this.type="aborted",this.name=n??"AbortError",this.code=t??"ABORT_ERR"}};async function Ye(r,e,t){if(e==null)return r;if(e.aborted)return r.catch(()=>{}),Promise.reject(new Oa(t?.errorMessage,t?.errorCode,t?.errorName));let n;const s=new Oa(t?.errorMessage,t?.errorCode,t?.errorName);try{return await Promise.race([r,new Promise((i,o)=>{n=()=>{o(s)},e.addEventListener("abort",n)})])}finally{n!=null&&e.removeEventListener("abort",n)}}class mm{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=de(),this.haveNext=de()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=de(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=de(),await Ye(this.readNext.promise,t?.signal,t)}}function Au(){return new mm}class ym extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"}function es(r,e){const t=Au();r.sink(t).catch(async o=>{await t.end(o)}),r.sink=async o=>{for await(const a of o)await t.push(a);await t.end()};let n=r.source;r.source[Symbol.iterator]!=null?n=r.source[Symbol.iterator]():r.source[Symbol.asyncIterator]!=null&&(n=r.source[Symbol.asyncIterator]());const s=new j;return{read:async o=>{if(o?.signal?.throwIfAborted(),o?.bytes==null){const{done:c,value:l}=await Ye(n.next(),o?.signal);return c===!0?null:l}for(;s.byteLength<o.bytes;){const{value:c,done:l}=await Ye(n.next(),o?.signal);if(l===!0)throw new ym("unexpected end of input");s.append(c)}const a=s.sublist(0,o.bytes);return s.consume(o.bytes),a},write:async(o,a)=>{a?.signal?.throwIfAborted(),o instanceof Uint8Array?await t.push(o,a):await t.push(o.subarray(),a)},unwrap:()=>{if(s.byteLength>0){const o=r.source;r.source=async function*(){e?.yieldBytes===!1?yield s:yield*s,yield*o}()}return r}}}class wm extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"}class bm extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"}class vm extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"}function ur(r,e={}){const t=es(r,e);e.maxDataLength!=null&&e.maxLengthLength==null&&(e.maxLengthLength=Se(e.maxDataLength));const n=e?.lengthDecoder??Gt,s=e?.lengthEncoder??ot;return{read:async o=>{let a=-1;const c=new j;for(;;){c.append(await t.read({...o,bytes:1}));try{a=n(c)}catch(l){if(l instanceof RangeError)continue;throw l}if(a<0)throw new wm("Invalid message length");if(e?.maxLengthLength!=null&&c.byteLength>e.maxLengthLength)throw new vm("message length length too long");if(a>-1)break}if(e?.maxDataLength!=null&&a>e.maxDataLength)throw new bm("message length too long");return t.read({...o,bytes:a})},write:async(o,a)=>{await t.write(new j(s(o.byteLength),o),a)},writeV:async(o,a)=>{const c=new j(...o.flatMap(l=>[s(l.byteLength),l]));await t.write(c,a)},unwrap:()=>t.unwrap()}}function Na(){const r=de();let e=!1;return{sink:async t=>{if(e)throw new Error("already piped");e=!0,r.resolve(t)},source:async function*(){yield*await r.promise}()}}function Em(){const r=Na(),e=Na();return[{source:r.source,sink:e.sink},{source:e.source,sink:r.sink}]}class Fa{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||(e-1&e)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}}class ei{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new Fa(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return e?.byteLength!=null?e.byteLength:1}push(e){if(e?.value!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new Fa(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return e?.value!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}let Sm=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}};function dn(r={}){return xm(t=>{const n=t.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function xm(r,e){e=e??{};let t=e.onEnd,n=new ei,s,i,o,a=de();const c=async()=>{try{return n.isEmpty()?o?{done:!0}:await new Promise((m,v)=>{i=P=>{i=null,n.push(P);try{m(r(n))}catch(b){v(b)}return s}}):r(n)}finally{n.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=de()})}},l=m=>i!=null?i(m):(n.push(m),s),u=m=>(n=new ei,i!=null?i({error:m}):(n.push({error:m}),s)),d=m=>{if(o)return s;if(e?.objectMode!==!0&&m?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:m})},h=m=>o?s:(o=!0,m!=null?u(m):l({done:!0})),p=()=>(n=new ei,h(),{done:!0}),f=m=>(h(m),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:c,return:p,throw:f,push:d,end:h,get readableLength(){return n.size},onEmpty:async m=>{const v=m?.signal;if(v?.throwIfAborted(),n.isEmpty())return;let P,b;v!=null&&(P=new Promise((w,E)=>{b=()=>{E(new Sm)},v.addEventListener("abort",b)}));try{await Promise.race([a.promise,P])}finally{b!=null&&v!=null&&v?.removeEventListener("abort",b)}}},t==null)return s;const g=s;return s={[Symbol.asyncIterator](){return this},next(){return g.next()},throw(m){return g.throw(m),t!=null&&(t(m),t=void 0),{done:!0}},return(){return g.return(),t!=null&&(t(),t=void 0),{done:!0}},push:d,end(m){return g.end(m),t!=null&&(t(m),t=void 0),s},get readableLength(){return g.readableLength},onEmpty:m=>g.onEmpty(m)},s}function Am(r){return r[Symbol.asyncIterator]!=null}async function Cm(r,e,t){try{await Promise.all(r.map(async n=>{for await(const s of n)await e.push(s,{signal:t}),t.throwIfAborted()})),await e.end(void 0,{signal:t})}catch(n){await e.end(n,{signal:t}).catch(()=>{})}}async function*Im(r){const e=new AbortController,t=Au();Cm(r,t,e.signal).catch(()=>{});try{yield*t}finally{e.abort()}}function*Tm(r){for(const e of r)yield*e}function ts(...r){const e=[];for(const t of r)Am(t)||e.push(t);return e.length===r.length?Tm(e):Im(r)}function Uo(r,...e){if(r==null)throw new Error("Empty pipeline");if(ti(r)){const n=r;r=()=>n.source}else if(Iu(r)||Cu(r)){const n=r;r=()=>n}const t=[r,...e];if(t.length>1&&ti(t[t.length-1])&&(t[t.length-1]=t[t.length-1].sink),t.length>2)for(let n=1;n<t.length-1;n++)ti(t[n])&&(t[n]=km(t[n]));return Pm(...t)}const Pm=(...r)=>{let e;for(;r.length>0;)e=r.shift()(e);return e},Cu=r=>r?.[Symbol.asyncIterator]!=null,Iu=r=>r?.[Symbol.iterator]!=null,ti=r=>r==null?!1:r.sink!=null&&r.source!=null,km=r=>e=>{const t=r.sink(e);if(t?.then!=null){const n=dn({objectMode:!0});t.then(()=>{n.end()},o=>{n.end(o)});let s;const i=r.source;if(Cu(i))s=async function*(){yield*i,n.end()};else if(Iu(i))s=function*(){yield*i,n.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return ts(n,s())}return r.source};var _m={};const Vr=65535,Ua=Vr-16,hn=!!_m?.DUMP_SESSION_KEYS;/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function Tu(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Hi(r){if(typeof r!="boolean")throw new Error(`boolean expected, not ${r}`)}function ri(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function Ue(r,...e){if(!Tu(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function Ba(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Dm(r,e){Ue(r);const t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function Pt(r){return new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength/4))}function dr(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function Lm(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}const Rm=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Mm(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}function Vi(r){if(typeof r=="string")r=Mm(r);else if(Tu(r))r=Gi(r);else throw new Error("Uint8Array expected, got "+typeof r);return r}function Om(r,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(r,e)}function Nm(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}const Fm=(r,e)=>{function t(n,...s){if(Ue(n),!Rm)throw new Error("Non little-endian hardware is not yet supported");if(r.nonceLength!==void 0){const u=s[0];if(!u)throw new Error("nonce / iv required");r.varSizeNonce?Ue(u):Ue(u,r.nonceLength)}const i=r.tagLength;i&&s[1]!==void 0&&Ue(s[1]);const o=e(n,...s),a=(u,d)=>{if(d!==void 0){if(u!==2)throw new Error("cipher output not supported");Ue(d)}};let c=!1;return{encrypt(u,d){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,Ue(u),a(o.encrypt.length,d),o.encrypt(u,d)},decrypt(u,d){if(Ue(u),i&&u.length<i)throw new Error("invalid ciphertext length: smaller than tagLength="+i);return a(o.decrypt.length,d),o.decrypt(u,d)}}}return Object.assign(t,r),t};function $a(r,e,t=!0){if(e===void 0)return new Uint8Array(r);if(e.length!==r)throw new Error("invalid output length, expected "+r+", got: "+e.length);if(t&&!Bm(e))throw new Error("invalid output, must be aligned");return e}function za(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const s=BigInt(32),i=BigInt(4294967295),o=Number(t>>s&i),a=Number(t&i),c=4,l=0;r.setUint32(e+c,o,n),r.setUint32(e+l,a,n)}function Um(r,e,t){Hi(t);const n=new Uint8Array(16),s=Lm(n);return za(s,0,BigInt(e),t),za(s,8,BigInt(r),t),n}function Bm(r){return r.byteOffset%4===0}function Gi(r){return Uint8Array.from(r)}const Pu=r=>Uint8Array.from(r.split("").map(e=>e.charCodeAt(0))),$m=Pu("expand 16-byte k"),zm=Pu("expand 32-byte k"),Km=Pt($m),qm=Pt(zm);function Z(r,e){return r<<e|r>>>32-e}function Yi(r){return r.byteOffset%4===0}const An=64,Wm=16,ku=2**32-1,Ka=new Uint32Array;function Hm(r,e,t,n,s,i,o,a){const c=s.length,l=new Uint8Array(An),u=Pt(l),d=Yi(s)&&Yi(i),h=d?Pt(s):Ka,p=d?Pt(i):Ka;for(let f=0;f<c;o++){if(r(e,t,n,u,o,a),o>=ku)throw new Error("arx: counter overflow");const g=Math.min(An,c-f);if(d&&g===An){const m=f/4;if(f%4!==0)throw new Error("arx: invalid block position");for(let v=0,P;v<Wm;v++)P=m+v,p[P]=h[P]^u[v];f+=An;continue}for(let m=0,v;m<g;m++)v=f+m,i[v]=s[v]^l[m];f+=g}}function Vm(r,e){const{allowShortKeys:t,extendNonceFn:n,counterLength:s,counterRight:i,rounds:o}=Om({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof r!="function")throw new Error("core must be a function");return ri(s),ri(o),Hi(i),Hi(t),(a,c,l,u,d=0)=>{Ue(a),Ue(c),Ue(l);const h=l.length;if(u===void 0&&(u=new Uint8Array(h)),Ue(u),ri(d),d<0||d>=ku)throw new Error("arx: counter overflow");if(u.length<h)throw new Error(`arx: output (${u.length}) is shorter than data (${h})`);const p=[];let f=a.length,g,m;if(f===32)p.push(g=Gi(a)),m=qm;else if(f===16&&t)g=new Uint8Array(32),g.set(a),g.set(a,16),m=Km,p.push(g);else throw new Error(`arx: invalid 32-byte key, got length=${f}`);Yi(c)||p.push(c=Gi(c));const v=Pt(g);if(n){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");n(m,v,Pt(c.subarray(0,16)),v),c=c.subarray(16)}const P=16-s;if(P!==c.length)throw new Error(`arx: nonce must be ${P} or 16 bytes`);if(P!==12){const w=new Uint8Array(12);w.set(c,i?0:12-c.length),c=w,p.push(c)}const b=Pt(c);return Hm(r,m,v,b,l,u,d,o),dr(...p),u}}const Ee=(r,e)=>r[e++]&255|(r[e++]&255)<<8;class Gm{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=Vi(e),Ue(e,32);const t=Ee(e,0),n=Ee(e,2),s=Ee(e,4),i=Ee(e,6),o=Ee(e,8),a=Ee(e,10),c=Ee(e,12),l=Ee(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|n<<3)&8191,this.r[2]=(n>>>10|s<<6)&7939,this.r[3]=(s>>>7|i<<9)&8191,this.r[4]=(i>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|l<<8)&8191,this.r[9]=l>>>5&127;for(let u=0;u<8;u++)this.pad[u]=Ee(e,16+2*u)}process(e,t,n=!1){const s=n?0:2048,{h:i,r:o}=this,a=o[0],c=o[1],l=o[2],u=o[3],d=o[4],h=o[5],p=o[6],f=o[7],g=o[8],m=o[9],v=Ee(e,t+0),P=Ee(e,t+2),b=Ee(e,t+4),w=Ee(e,t+6),E=Ee(e,t+8),_=Ee(e,t+10),x=Ee(e,t+12),k=Ee(e,t+14);let L=i[0]+(v&8191),F=i[1]+((v>>>13|P<<3)&8191),D=i[2]+((P>>>10|b<<6)&8191),N=i[3]+((b>>>7|w<<9)&8191),R=i[4]+((w>>>4|E<<12)&8191),B=i[5]+(E>>>1&8191),C=i[6]+((E>>>14|_<<2)&8191),I=i[7]+((_>>>11|x<<5)&8191),M=i[8]+((x>>>8|k<<8)&8191),A=i[9]+(k>>>5|s),y=0,S=y+L*a+F*(5*m)+D*(5*g)+N*(5*f)+R*(5*p);y=S>>>13,S&=8191,S+=B*(5*h)+C*(5*d)+I*(5*u)+M*(5*l)+A*(5*c),y+=S>>>13,S&=8191;let T=y+L*c+F*a+D*(5*m)+N*(5*g)+R*(5*f);y=T>>>13,T&=8191,T+=B*(5*p)+C*(5*h)+I*(5*d)+M*(5*u)+A*(5*l),y+=T>>>13,T&=8191;let O=y+L*l+F*c+D*a+N*(5*m)+R*(5*g);y=O>>>13,O&=8191,O+=B*(5*f)+C*(5*p)+I*(5*h)+M*(5*d)+A*(5*u),y+=O>>>13,O&=8191;let U=y+L*u+F*l+D*c+N*a+R*(5*m);y=U>>>13,U&=8191,U+=B*(5*g)+C*(5*f)+I*(5*p)+M*(5*h)+A*(5*d),y+=U>>>13,U&=8191;let $=y+L*d+F*u+D*l+N*c+R*a;y=$>>>13,$&=8191,$+=B*(5*m)+C*(5*g)+I*(5*f)+M*(5*p)+A*(5*h),y+=$>>>13,$&=8191;let z=y+L*h+F*d+D*u+N*l+R*c;y=z>>>13,z&=8191,z+=B*a+C*(5*m)+I*(5*g)+M*(5*f)+A*(5*p),y+=z>>>13,z&=8191;let q=y+L*p+F*h+D*d+N*u+R*l;y=q>>>13,q&=8191,q+=B*c+C*a+I*(5*m)+M*(5*g)+A*(5*f),y+=q>>>13,q&=8191;let H=y+L*f+F*p+D*h+N*d+R*u;y=H>>>13,H&=8191,H+=B*l+C*c+I*a+M*(5*m)+A*(5*g),y+=H>>>13,H&=8191;let ee=y+L*g+F*f+D*p+N*h+R*d;y=ee>>>13,ee&=8191,ee+=B*u+C*l+I*c+M*a+A*(5*m),y+=ee>>>13,ee&=8191;let J=y+L*m+F*g+D*f+N*p+R*h;y=J>>>13,J&=8191,J+=B*d+C*u+I*l+M*c+A*a,y+=J>>>13,J&=8191,y=(y<<2)+y|0,y=y+S|0,S=y&8191,y=y>>>13,T+=y,i[0]=S,i[1]=T,i[2]=O,i[3]=U,i[4]=$,i[5]=z,i[6]=q,i[7]=H,i[8]=ee,i[9]=J}finalize(){const{h:e,pad:t}=this,n=new Uint16Array(10);let s=e[1]>>>13;e[1]&=8191;for(let a=2;a<10;a++)e[a]+=s,s=e[a]>>>13,e[a]&=8191;e[0]+=s*5,s=e[0]>>>13,e[0]&=8191,e[1]+=s,s=e[1]>>>13,e[1]&=8191,e[2]+=s,n[0]=e[0]+5,s=n[0]>>>13,n[0]&=8191;for(let a=1;a<10;a++)n[a]=e[a]+s,s=n[a]>>>13,n[a]&=8191;n[9]-=8192;let i=(s^1)-1;for(let a=0;a<10;a++)n[a]&=i;i=~i;for(let a=0;a<10;a++)e[a]=e[a]&i|n[a];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let o=e[0]+t[0];e[0]=o&65535;for(let a=1;a<8;a++)o=(e[a]+t[a]|0)+(o>>>16)|0,e[a]=o&65535;dr(n)}update(e){Ba(this),e=Vi(e),Ue(e);const{buffer:t,blockLen:n}=this,s=e.length;for(let i=0;i<s;){const o=Math.min(n-this.pos,s-i);if(o===n){for(;n<=s-i;i+=n)this.process(e,i);continue}t.set(e.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===n&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){dr(this.h,this.r,this.buffer,this.pad)}digestInto(e){Ba(this),Dm(e,this),this.finished=!0;const{buffer:t,h:n}=this;let{pos:s}=this;if(s){for(t[s++]=1;s<16;s++)t[s]=0;this.process(t,0,!0)}this.finalize();let i=0;for(let o=0;o<8;o++)e[i++]=n[o]>>>0,e[i++]=n[o]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}}function Ym(r){const e=(n,s)=>r(s).update(Vi(n)).digest(),t=r(new Uint8Array(32));return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=n=>r(n),e}const Xm=Ym(r=>new Gm(r));function Qm(r,e,t,n,s,i=20){let o=r[0],a=r[1],c=r[2],l=r[3],u=e[0],d=e[1],h=e[2],p=e[3],f=e[4],g=e[5],m=e[6],v=e[7],P=s,b=t[0],w=t[1],E=t[2],_=o,x=a,k=c,L=l,F=u,D=d,N=h,R=p,B=f,C=g,I=m,M=v,A=P,y=b,S=w,T=E;for(let U=0;U<i;U+=2)_=_+F|0,A=Z(A^_,16),B=B+A|0,F=Z(F^B,12),_=_+F|0,A=Z(A^_,8),B=B+A|0,F=Z(F^B,7),x=x+D|0,y=Z(y^x,16),C=C+y|0,D=Z(D^C,12),x=x+D|0,y=Z(y^x,8),C=C+y|0,D=Z(D^C,7),k=k+N|0,S=Z(S^k,16),I=I+S|0,N=Z(N^I,12),k=k+N|0,S=Z(S^k,8),I=I+S|0,N=Z(N^I,7),L=L+R|0,T=Z(T^L,16),M=M+T|0,R=Z(R^M,12),L=L+R|0,T=Z(T^L,8),M=M+T|0,R=Z(R^M,7),_=_+D|0,T=Z(T^_,16),I=I+T|0,D=Z(D^I,12),_=_+D|0,T=Z(T^_,8),I=I+T|0,D=Z(D^I,7),x=x+N|0,A=Z(A^x,16),M=M+A|0,N=Z(N^M,12),x=x+N|0,A=Z(A^x,8),M=M+A|0,N=Z(N^M,7),k=k+R|0,y=Z(y^k,16),B=B+y|0,R=Z(R^B,12),k=k+R|0,y=Z(y^k,8),B=B+y|0,R=Z(R^B,7),L=L+F|0,S=Z(S^L,16),C=C+S|0,F=Z(F^C,12),L=L+F|0,S=Z(S^L,8),C=C+S|0,F=Z(F^C,7);let O=0;n[O++]=o+_|0,n[O++]=a+x|0,n[O++]=c+k|0,n[O++]=l+L|0,n[O++]=u+F|0,n[O++]=d+D|0,n[O++]=h+N|0,n[O++]=p+R|0,n[O++]=f+B|0,n[O++]=g+C|0,n[O++]=m+I|0,n[O++]=v+M|0,n[O++]=P+A|0,n[O++]=b+y|0,n[O++]=w+S|0,n[O++]=E+T|0}const jm=Vm(Qm,{counterRight:!1,counterLength:4,allowShortKeys:!1}),Zm=new Uint8Array(16),qa=(r,e)=>{r.update(e);const t=e.length%16;t&&r.update(Zm.subarray(t))},Jm=new Uint8Array(32);function Wa(r,e,t,n,s){const i=r(e,t,Jm),o=Xm.create(i);s&&qa(o,s),qa(o,n);const a=Um(n.length,s?s.length:0,!0);o.update(a);const c=o.digest();return dr(i,a),c}const ey=r=>(e,t,n)=>({encrypt(i,o){const a=i.length;o=$a(a+16,o,!1),o.set(i);const c=o.subarray(0,-16);r(e,t,c,c,1);const l=Wa(r,e,t,c,n);return o.set(l,a),dr(l),o},decrypt(i,o){o=$a(i.length-16,o,!1);const a=i.subarray(0,-16),c=i.subarray(-16),l=Wa(r,e,t,a,n);if(!Nm(c,l))throw new Error("invalid tag");return o.set(i.subarray(0,-16)),r(e,t,o,o,1),dr(l),o}}),Ha=Fm({blockSize:64,nonceLength:12,tagLength:16},ey(jm));function ty(r,e,t){return Eo(r),t===void 0&&(t=new Uint8Array(r.outputLen)),Ts(r,Kr(t),Kr(e))}const ni=Uint8Array.from([0]),Va=Uint8Array.of();function ry(r,e,t,n=32){Eo(r),Hn(n);const s=r.outputLen;if(n>255*s)throw new Error("Length should be <= 255*HashLen");const i=Math.ceil(n/s);t===void 0&&(t=Va);const o=new Uint8Array(i*s),a=Ts.create(r,e),c=a._cloneInto(),l=new Uint8Array(a.outputLen);for(let u=0;u<i;u++)ni[0]=u+1,c.update(u===0?Va:l).update(t).update(ni).digestInto(l),o.set(l,s*u),a._cloneInto(c);return a.destroy(),c.destroy(),qt(l,ni),o.slice(0,n)}const ny={hashSHA256(r){return Un(r.subarray())},getHKDF(r,e){const t=ty(Un,e,r),s=ry(Un,t,void 0,96),i=s.subarray(0,32),o=s.subarray(32,64),a=s.subarray(64,96);return[i,o,a]},generateX25519KeyPair(){const r=En.utils.randomPrivateKey();return{publicKey:En.getPublicKey(r),privateKey:r}},generateX25519KeyPairFromSeed(r){return{publicKey:En.getPublicKey(r),privateKey:r}},generateX25519SharedKey(r,e){return En.getSharedSecret(r.subarray(),e.subarray())},chaCha20Poly1305Encrypt(r,e,t,n){return Ha(n,e,t).encrypt(r.subarray())},chaCha20Poly1305Decrypt(r,e,t,n,s){return Ha(n,e,t).decrypt(r.subarray(),s)}},sy=ny;function iy(r){return{generateKeypair:r.generateX25519KeyPair,dh:(e,t)=>r.generateX25519SharedKey(e.privateKey,t).subarray(0,32),encrypt:r.chaCha20Poly1305Encrypt,decrypt:r.chaCha20Poly1305Decrypt,hash:r.hashSHA256,hkdf:r.getHKDF}}const rs=r=>{const e=ct(2);return e[0]=r>>8,e[1]=r,e};rs.bytes=2;const Bn=r=>{if(r.length<2)throw RangeError("Could not decode int16BE");if(r instanceof Uint8Array){let e=0;return e+=r[0]<<8,e+=r[1],e}return r.getUint16(0)};Bn.bytes=2;function oy(r){return{xxHandshakeSuccesses:r.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:r.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:r.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:r.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:r.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}function _u(r,e){!e.enabled||!hn||(r?(e(`LOCAL_STATIC_PUBLIC_KEY ${G(r.publicKey,"hex")}`),e(`LOCAL_STATIC_PRIVATE_KEY ${G(r.privateKey,"hex")}`)):e("Missing local static keys."))}function Du(r,e){!e.enabled||!hn||(r?(e(`LOCAL_PUBLIC_EPHEMERAL_KEY ${G(r.publicKey,"hex")}`),e(`LOCAL_PRIVATE_EPHEMERAL_KEY ${G(r.privateKey,"hex")}`)):e("Missing local ephemeral keys."))}function ay(r,e){!e.enabled||!hn||e(r?`REMOTE_STATIC_PUBLIC_KEY ${G(r.subarray(),"hex")}`:"Missing remote static public key.")}function Lu(r,e){!e.enabled||!hn||e(r?`REMOTE_EPHEMERAL_PUBLIC_KEY ${G(r.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function Ru(r,e,t){!t.enabled||!hn||(t(`CIPHER_STATE_1 ${r.n.getUint64()} ${r.k&&G(r.k,"hex")}`),t(`CIPHER_STATE_2 ${e.n.getUint64()} ${e.k&&G(e.k,"hex")}`))}class Fr extends Error{code;constructor(e="Invalid crypto exchange"){super(e),this.code=Fr.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"}const cy=0,ly=4294967295,uy="Cipherstate has reached maximum n, a new handshake must be performed";class dy{n;bytes;view;constructor(e=cy){this.n=e,this.bytes=ne(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,e,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>ly)throw new Error(uy)}}const nr=ne(0);class Cn{k;n;crypto;constructor(e,t=void 0,n=0){this.crypto=e,this.k=t,this.n=new dy(n)}hasKey(){return!!this.k}encryptWithAd(e,t){if(!this.hasKey())return t;this.n.assertValue();const n=this.crypto.encrypt(t,this.n.getBytes(),e,this.k);return this.n.increment(),n}decryptWithAd(e,t,n){if(!this.hasKey())return t;this.n.assertValue();const s=this.crypto.decrypt(t,this.n.getBytes(),e,this.k,n);return this.n.increment(),s}}class hy{cs;ck;h;crypto;constructor(e,t){this.crypto=e;const n=K(t,"utf-8");this.h=py(e,n),this.ck=this.h,this.cs=new Cn(e)}mixKey(e){const[t,n]=this.crypto.hkdf(this.ck,e);this.ck=t,this.cs=new Cn(this.crypto,n)}mixHash(e){this.h=this.crypto.hash(new j(this.h,e))}encryptAndHash(e){const t=this.cs.encryptWithAd(this.h,e);return this.mixHash(t),t}decryptAndHash(e){const t=this.cs.decryptWithAd(this.h,e);return this.mixHash(e),t}split(){const[e,t]=this.crypto.hkdf(this.ck,nr);return[new Cn(this.crypto,e),new Cn(this.crypto,t)]}}class fy{ss;s;e;rs;re;initiator;crypto;constructor(e){const{crypto:t,protocolName:n,prologue:s,initiator:i,s:o,e:a,rs:c,re:l}=e;this.crypto=t,this.ss=new hy(t,n),this.ss.mixHash(s),this.initiator=i,this.s=o,this.e=a,this.rs=c,this.re=l}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const e=this.crypto.generateKeypair();return this.ss.mixHash(e.publicKey),this.e=e,e.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(e,t=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(e.byteLength<t+32)throw new Error("message is not long enough");this.re=e.sublist(t,t+32),this.ss.mixHash(this.re)}readS(e,t=0){if(this.rs)throw new Error("remote static public key is already set");const n=32+(this.ss.cs.hasKey()?16:0);if(e.byteLength<t+n)throw new Error("message is not long enough");const s=e.sublist(t,t+n);return this.rs=this.ss.decryptAndHash(s),n}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class Mu extends fy{writeMessageA(e){return new j(this.writeE(),this.ss.encryptAndHash(e))}writeMessageB(e){const t=this.writeE();this.writeEE();const n=this.writeS();return this.writeES(),new j(t,n,this.ss.encryptAndHash(e))}writeMessageC(e){const t=this.writeS();return this.writeSE(),new j(t,this.ss.encryptAndHash(e))}readMessageA(e){try{return this.readE(e),this.ss.decryptAndHash(e.sublist(32))}catch(t){throw new Fr(`handshake stage 0 validation fail: ${t.message}`)}}readMessageB(e){try{this.readE(e),this.readEE();const t=this.readS(e,32);return this.readES(),this.ss.decryptAndHash(e.sublist(32+t))}catch(t){throw new Fr(`handshake stage 1 validation fail: ${t.message}`)}}readMessageC(e){try{const t=this.readS(e);return this.readSE(),this.ss.decryptAndHash(e.sublist(t))}catch(t){throw new Fr(`handshake stage 2 validation fail: ${t.message}`)}}}function py(r,e){if(e.length<=32){const t=ne(32);return t.set(e),t}else return r.hash(e)}var ns;(function(r){let e;r.codec=()=>(e==null&&(e=ge((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.webtransportCerthashes!=null)for(const i of t.webtransportCerthashes)n.uint32(10),n.bytes(i);if(t.streamMuxers!=null)for(const i of t.streamMuxers)n.uint32(18),n.string(i);s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={webtransportCerthashes:[],streamMuxers:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(s.limits?.webtransportCerthashes!=null&&i.webtransportCerthashes.length===s.limits.webtransportCerthashes)throw new bt('Decode error - map field "webtransportCerthashes" had too many elements');i.webtransportCerthashes.push(t.bytes());break}case 2:{if(s.limits?.streamMuxers!=null&&i.streamMuxers.length===s.limits.streamMuxers)throw new bt('Decode error - map field "streamMuxers" had too many elements');i.streamMuxers.push(t.string());break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>pe(t,r.codec()),r.decode=(t,n)=>fe(t,r.codec(),n)})(ns||(ns={}));var ss;(function(r){let e;r.codec=()=>(e==null&&(e=ge((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.identityKey!=null&&t.identityKey.byteLength>0&&(n.uint32(10),n.bytes(t.identityKey)),t.identitySig!=null&&t.identitySig.byteLength>0&&(n.uint32(18),n.bytes(t.identitySig)),t.extensions!=null&&(n.uint32(34),ns.codec().encode(t.extensions,n)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={identityKey:ne(0),identitySig:ne(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.identityKey=t.bytes();break}case 2:{i.identitySig=t.bytes();break}case 4:{i.extensions=ns.codec().decode(t,t.uint32(),{limits:s.limits?.extensions});break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>pe(t,r.codec()),r.decode=(t,n)=>fe(t,r.codec(),n)})(ss||(ss={}));async function Ou(r,e,t){const n=await r.sign(Fu(e));return ss.encode({identityKey:yt(r.publicKey),identitySig:n,extensions:t})}async function Nu(r,e,t){try{const n=ss.decode(r),s=Dt(n.identityKey);if(t?.equals(s)===!1)throw new Error(`Payload identity key ${s} does not match expected remote identity key ${t}`);if(!e)throw new Error("Remote static does not exist");const i=Fu(e);if(!await s.verify(i,n.identitySig))throw new Error("Invalid payload signature");return n}catch(n){throw new mh(n.message)}}function Fu(r){const e=K("noise-libp2p-static-key:");return r instanceof Uint8Array?tt([e,r],e.length+r.length):(r.prepend(e),r)}async function gy(r,e){const{log:t,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=r,u=await Ou(i,a.publicKey,l),d=new Mu({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});_u(d.s,t),t.trace("Stage 0 - Initiator starting to send first message."),await n.write(d.writeMessageA(nr),e),t.trace("Stage 0 - Initiator finished sending first message."),Du(d.e,t),t.trace("Stage 1 - Initiator waiting to receive first message from responder...");const h=d.readMessageB(await n.read(e));t.trace("Stage 1 - Initiator received the message."),Lu(d.re,t),ay(d.rs,t),t.trace("Initiator going to check remote's signature...");const p=await Nu(h,d.rs,c);t.trace("All good with the signature!"),t.trace("Stage 2 - Initiator sending third handshake message."),await n.write(d.writeMessageC(u),e),t.trace("Stage 2 - Initiator sent message with signed payload.");const[f,g]=d.ss.split();return Ru(f,g,t),{payload:p,encrypt:m=>f.encryptWithAd(nr,m),decrypt:(m,v)=>g.decryptWithAd(nr,m,v)}}async function my(r,e){const{log:t,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=r,u=await Ou(i,a.publicKey,l),d=new Mu({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});_u(d.s,t),t.trace("Stage 0 - Responder waiting to receive first message."),d.readMessageA(await n.read(e)),t.trace("Stage 0 - Responder received first message."),Lu(d.re,t),t.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await n.write(d.writeMessageB(u),e),t.trace("Stage 1 - Responder sent the second handshake message with signed payload."),Du(d.e,t),t.trace("Stage 2 - Responder waiting for third handshake message...");const h=d.readMessageC(await n.read(e));t.trace("Stage 2 - Responder received the message, finished handshake.");const p=await Nu(h,d.rs,c),[f,g]=d.ss.split();return Ru(f,g,t),{payload:p,encrypt:m=>g.encryptWithAd(nr,m),decrypt:(m,v)=>f.decryptWithAd(nr,m,v)}}const Ga=16;function yy(r,e){return async function*(t){for await(const n of t)for(let s=0;s<n.length;s+=Ua){let i=s+Ua;i>n.length&&(i=n.length);let o;n instanceof Uint8Array?o=r.encrypt(n.subarray(s,i)):o=r.encrypt(n.sublist(s,i)),e?.encryptedPackets.increment(),yield new j(rs(o.byteLength),o)}}}function wy(r,e){return async function*(t){for await(const n of t)for(let s=0;s<n.length;s+=Vr){let i=s+Vr;if(i>n.length&&(i=n.length),i-Ga<s)throw new Error("Invalid chunk");const o=n.sublist(s,i),a=n.subarray(s,i-Ga);try{const c=r.decrypt(o,a);e?.decryptedPackets.increment(),yield c}catch(c){throw e?.decryptErrors.increment(),c}}}}class by{protocol="/noise";crypto;prologue;staticKey;extensions;metrics;components;constructor(e,t={}){const{staticNoiseKey:n,extensions:s,crypto:i,prologueBytes:o}=t,{metrics:a}=e;this.components=e;const c=i??sy;this.crypto=iy(c),this.extensions={webtransportCerthashes:[],...s},this.metrics=a?oy(a):void 0,n?this.staticKey=c.generateX25519KeyPairFromSeed(n):this.staticKey=c.generateX25519KeyPair(),this.prologue=o??ne(0)}[Symbol.toStringTag]="@chainsafe/libp2p-noise";[et]=["@libp2p/connection-encryption","@chainsafe/libp2p-noise"];async secureOutbound(e,t){const n=ur(e,{lengthEncoder:rs,lengthDecoder:Bn,maxDataLength:Vr}),s=await this.performHandshakeInitiator(n,this.components.privateKey,t?.remotePeer?.publicKey,t),i=await this.createSecureConnection(n,s);e.source=i.source,e.sink=i.sink;const o=Dt(s.payload.identityKey);return{conn:e,remoteExtensions:s.payload.extensions,remotePeer:Hr(o),streamMuxer:t?.skipStreamMuxerNegotiation===!0?void 0:this.getStreamMuxer(s.payload.extensions?.streamMuxers)}}getStreamMuxer(e){if(e==null||e.length===0)return;const t=this.components.upgrader.getStreamMuxers();if(t!=null)for(const n of e){const s=t.get(n);if(s!=null)return s}if(e.length)throw new yh("Early muxer negotiation was requested but the initiator and responder had no common muxers")}async secureInbound(e,t){const n=ur(e,{lengthEncoder:rs,lengthDecoder:Bn,maxDataLength:Vr}),s=await this.performHandshakeResponder(n,this.components.privateKey,t?.remotePeer?.publicKey,t),i=await this.createSecureConnection(n,s);e.source=i.source,e.sink=i.sink;const o=Dt(s.payload.identityKey);return{conn:e,remoteExtensions:s.payload.extensions,remotePeer:Hr(o),streamMuxer:t?.skipStreamMuxerNegotiation===!0?void 0:this.getStreamMuxer(s.payload.extensions?.streamMuxers)}}async performHandshakeInitiator(e,t,n,s){let i;const o=s?.skipStreamMuxerNegotiation===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{i=await gy({connection:e,privateKey:t,remoteIdentityKey:n,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:o,webtransportCerthashes:[],...this.extensions}},s),this.metrics?.xxHandshakeSuccesses.increment()}catch(a){throw this.metrics?.xxHandshakeErrors.increment(),a}return i}async performHandshakeResponder(e,t,n,s){let i;const o=s?.skipStreamMuxerNegotiation===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{i=await my({connection:e,privateKey:t,remoteIdentityKey:n,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:o,webtransportCerthashes:[],...this.extensions}},s),this.metrics?.xxHandshakeSuccesses.increment()}catch(a){throw this.metrics?.xxHandshakeErrors.increment(),a}return i}async createSecureConnection(e,t){const[n,s]=Em(),i=e.unwrap();return await Uo(n,yy(t,this.metrics),i,o=>Jn(o,{lengthDecoder:Bn}),wy(t,this.metrics),n),s}}function vy(r={}){return e=>new by(e,r)}function Uu(r){if(r!=null){if(typeof r[Symbol.iterator]=="function")return r[Symbol.iterator]();if(typeof r[Symbol.asyncIterator]=="function")return r[Symbol.asyncIterator]();if(typeof r.next=="function")return r}throw new Error("argument is not an iterator or iterable")}class tr extends Error{static name="InvalidFrameError";constructor(e="The frame was invalid"){super(e),this.name="InvalidFrameError"}}class Bu extends Error{static name="UnrequestedPingError";constructor(e="Unrequested ping error"){super(e),this.name="UnrequestedPingError"}}class $u extends Error{static name="NotMatchingPingError";constructor(e="Unrequested ping error"){super(e),this.name="NotMatchingPingError"}}class Ey extends Error{static name="InvalidStateError";constructor(e="Invalid state"){super(e),this.name="InvalidStateError"}}class Sy extends Error{static name="StreamAlreadyExistsError";constructor(e="Strean already exists"){super(e),this.name="StreamAlreadyExistsError"}}class xy extends Error{static name="DecodeInvalidVersionError";constructor(e="Decode invalid version"){super(e),this.name="DecodeInvalidVersionError"}}class Ay extends Error{static name="BothClientsError";constructor(e="Both clients"){super(e),this.name="BothClientsError"}}class zu extends Error{static name="ReceiveWindowExceededError";constructor(e="Receive window exceeded"){super(e),this.name="ReceiveWindowExceededError"}}const Cy=new Set([tr.name,Bu.name,$u.name,Sy.name,xy.name,Ay.name,zu.name]),Bo=256*1024,Iy=16*1024*1024,Ty={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:Bo,maxStreamWindowSize:Iy,maxMessageSize:64*1024};function Py(r){if(r.keepAliveInterval<=0)throw new W("keep-alive interval must be positive");if(r.maxInboundStreams<0)throw new W("max inbound streams must be larger or equal 0");if(r.maxOutboundStreams<0)throw new W("max outbound streams must be larger or equal 0");if(r.initialStreamWindowSize<Bo)throw new W("InitialStreamWindowSize must be larger or equal 256 kB");if(r.maxStreamWindowSize<r.initialStreamWindowSize)throw new W("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(r.maxStreamWindowSize>2**32-1)throw new W("MaxStreamWindowSize must be less than equal MAX_UINT32");if(r.maxMessageSize<1024)throw new W("MaxMessageSize must be greater than a kilobyte")}var ye;(function(r){r[r.Data=0]="Data",r[r.WindowUpdate=1]="WindowUpdate",r[r.Ping=2]="Ping",r[r.GoAway=3]="GoAway"})(ye||(ye={}));var he;(function(r){r[r.SYN=1]="SYN",r[r.ACK=2]="ACK",r[r.FIN=4]="FIN",r[r.RST=8]="RST"})(he||(he={}));Object.values(he).filter(r=>typeof r!="string");const ky=0;var st;(function(r){r[r.NormalTermination=0]="NormalTermination",r[r.ProtocolError=1]="ProtocolError",r[r.InternalError=2]="InternalError"})(st||(st={}));const Ur=12,Ya=2**24;function _y(r){if(r[0]!==ky)throw new tr("Invalid frame version");return{type:r[1],flag:(r[2]<<8)+r[3],streamID:r[4]*Ya+(r[5]<<16)+(r[6]<<8)+r[7],length:r[8]*Ya+(r[9]<<16)+(r[10]<<8)+r[11]}}class Dy{source;buffer;frameInProgress;constructor(e){this.source=Ly(e),this.buffer=new j,this.frameInProgress=!1}async*emitFrames(){for await(const e of this.source)for(this.buffer.append(e);;){const t=this.readHeader();if(t===void 0)break;const{type:n,length:s}=t;n===ye.Data?(this.frameInProgress=!0,yield{header:t,readData:this.readBytes.bind(this,s)}):yield{header:t}}}readHeader(){if(this.frameInProgress)throw new Ey("decoding frame already in progress");if(this.buffer.length<Ur)return;const e=_y(this.buffer.subarray(0,Ur));return this.buffer.consume(Ur),e}async readBytes(e){if(this.buffer.length<e){for await(const n of this.source)if(this.buffer.append(n),this.buffer.length>=e)break}const t=this.buffer.sublist(0,e);return this.buffer.consume(e),this.frameInProgress=!1,t}}function Ly(r){if(r[Symbol.iterator]!==void 0){const e=r[Symbol.iterator]();return e.return=void 0,{[Symbol.iterator](){return e}}}else if(r[Symbol.asyncIterator]!==void 0){const e=r[Symbol.asyncIterator]();return e.return=void 0,{[Symbol.asyncIterator](){return e}}}else throw new Error("a source must be either an iterable or an async iterable")}function Xa(r){const e=new Uint8Array(Ur);return e[1]=r.type,e[2]=r.flag>>>8,e[3]=r.flag,e[4]=r.streamID>>>24,e[5]=r.streamID>>>16,e[6]=r.streamID>>>8,e[7]=r.streamID,e[8]=r.length>>>24,e[9]=r.length>>>16,e[10]=r.length>>>8,e[11]=r.length,e}function Ry(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}function My(r,e){const t=Uu(r).return?.();Ry(t)&&t.catch(n=>{e.error("could not cause iterator to return",n)})}const Oy=5e3;function si(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class Ku{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;sendingData;constructor(e){this.sinkController=new AbortController,this.sinkEnd=de(),this.closed=de(),this.log=e.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=e.id,this.metadata=e.metadata??{},this.direction=e.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=e.sendCloseWriteTimeout??Oy,this.onEnd=e.onEnd,this.onCloseRead=e.onCloseRead,this.onCloseWrite=e.onCloseWrite,this.onReset=e.onReset,this.onAbort=e.onAbort,this.source=this.streamSource=dn({onEnd:t=>{t!=null?this.log.trace("source ended with error",t):this.log.trace("source ended"),this.onSourceEnd(t)}}),this.sink=this.sink.bind(this)}async sink(e){if(this.writeStatus!=="ready")throw new Pi(`writable end state is "${this.writeStatus}" not "ready"`);try{this.writeStatus="writing";const t={signal:this.sinkController.signal};if(this.direction==="outbound"){const s=this.sendNewStream(t);si(s)&&await s}const n=()=>{My(e,this.log)};try{this.sinkController.signal.addEventListener("abort",n),this.log.trace("sink reading from source");for await(let s of e){s=s instanceof Uint8Array?new j(s):s;const i=this.sendData(s,t);si(i)&&(this.sendingData=de(),await i,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",n)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),this.writeStatus==="writing"&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(t){throw this.log.trace("sink ended with error, calling abort with error",t),this.abort(t),t}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(e){this.timeline.closeRead==null&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),this.onCloseRead?.(),this.timeline.closeWrite!=null?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(e){this.timeline.closeWrite==null&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),this.onCloseWrite?.(),this.timeline.closeRead!=null?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(e){this.status==="open"&&(this.log.trace("closing gracefully"),this.status="closing",await Ye(Promise.all([this.closeWrite(e),this.closeRead(e),this.closed.promise]),e?.signal),this.status="closed",this.log.trace("closed gracefully"))}async closeRead(e={}){if(this.readStatus==="closing"||this.readStatus==="closed")return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);const t=this.readStatus;this.readStatus="closing",this.status!=="reset"&&this.status!=="aborted"&&this.timeline.closeRead==null&&(this.log.trace("send close read to remote"),await this.sendCloseRead(e)),t==="ready"&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(e={}){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),this.writeStatus==="ready"&&(this.log.trace("sink was never sunk, sink an empty array"),await Ye(this.sink([]),e.signal)),this.writeStatus==="writing"&&(this.sendingData!=null&&await Ye(this.sendingData.promise,e.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await Ye(this.sinkEnd.promise,e.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(e){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;this.log("abort with error",e),this.log("try to send reset to remote");const t=this.sendReset();si(t)&&t.catch(n=>{this.log.error("error sending reset message",n)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(e),this.onAbort?.(e)}reset(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;const e=new bh("stream reset");this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(e),this.onReset?.()}_closeSinkAndSource(e){this._closeSink(e),this._closeSource(e)}_closeSink(e){this.writeStatus==="writing"&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(e)}_closeSource(e){this.readStatus!=="closing"&&this.readStatus!=="closed"&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(e))}remoteCloseWrite(){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("received remote close write but local source is already closed");return}this.log.trace("remote close write"),this._closeSource()}remoteCloseRead(){if(this.writeStatus==="closing"||this.writeStatus==="closed"){this.log("received remote close read but local sink is already closed");return}this.log.trace("remote close read"),this._closeSink()}destroy(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset"){this.log("received destroy but we are already closed");return}this.log.trace("stream destroyed"),this._closeSinkAndSource()}sourcePush(e){this.streamSource.push(e)}sourceReadableLength(){return this.streamSource.readableLength}}function qu(r){const[e,t]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>e.next(),push:s=>{n.push(s)},next:()=>n.length>0?{done:!1,value:n.shift()}:e.next(),[t](){return this}}}function Ny(r){return r[Symbol.asyncIterator]!=null}function Qa(r){return r?.then!=null}function Wu(r,e){let t=0;if(Ny(r))return async function*(){for await(const c of r){const l=e(c,t++);Qa(l)&&await l,yield c}}();const n=qu(r),{value:s,done:i}=n.next();if(i===!0)return function*(){}();if(typeof e(s,t++)?.then=="function")return async function*(){yield s;for await(const c of n){const l=e(c,t++);Qa(l)&&await l,yield c}}();const a=e;return function*(){yield s;for(const c of n)a(c,t++),yield c}()}var Ze;(function(r){r[r.Init=0]="Init",r[r.SYNSent=1]="SYNSent",r[r.SYNReceived=2]="SYNReceived",r[r.Established=3]="Established",r[r.Finished=4]="Finished"})(Ze||(Ze={}));class Fy extends Ku{name;state;config;_id;sendWindowCapacity;sendWindowCapacityUpdate;recvWindow;recvWindowCapacity;epochStart;getRTT;sendFrame;constructor(e){super({...e,onEnd:t=>{this.state=Ze.Finished,e.onEnd?.(t)}}),this.config=e.config,this._id=parseInt(e.id,10),this.name=e.name,this.state=e.state,this.sendWindowCapacity=Bo,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=e.getRTT,this.sendFrame=e.sendFrame,this.source=Wu(this.source,()=>{this.sendWindowUpdate()})}async sendNewStream(){}async sendData(e,t={}){for(e=e.sublist();e.byteLength!==0;){if(this.sendWindowCapacity===0&&(this.log?.trace("wait for send window capacity, status %s",this.status),await this.waitForSendWindowCapacity(t),this.status==="closed"||this.status==="aborted"||this.status==="reset")){this.log?.trace("%s while waiting for send window capacity",this.status);return}const n=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-Ur,e.length),s=this.getSendFlags();this.sendFrame({type:ye.Data,flag:s,streamID:this._id,length:n},e.sublist(0,n)),this.sendWindowCapacity-=n,e.consume(n)}}async sendReset(){this.sendFrame({type:ye.WindowUpdate,flag:he.RST,streamID:this._id,length:0})}async sendCloseWrite(){const e=this.getSendFlags()|he.FIN;this.sendFrame({type:ye.WindowUpdate,flag:e,streamID:this._id,length:0})}async sendCloseRead(){}async waitForSendWindowCapacity(e={}){if(this.sendWindowCapacity>0)return;let t,n;const s=()=>{this.status==="open"||this.status==="closing"?n(new Kt("Stream aborted")):t()};e.signal?.addEventListener("abort",s);try{await new Promise((i,o)=>{this.sendWindowCapacityUpdate=()=>{i()},n=o,t=i})}finally{e.signal?.removeEventListener("abort",s)}}handleWindowUpdate(e){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(e.flag);const t=this.sendWindowCapacity;this.sendWindowCapacity+=e.length,t===0&&e.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(e,t){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(e.flag),this.recvWindowCapacity<e.length)throw new zu("Receive window exceeded");const n=await t();this.recvWindowCapacity-=e.length,this.sourcePush(n)}processFlags(e){(e&he.ACK)===he.ACK&&this.state===Ze.SYNSent&&(this.state=Ze.Established),(e&he.FIN)===he.FIN&&this.remoteCloseWrite(),(e&he.RST)===he.RST&&this.reset()}getSendFlags(){switch(this.state){case Ze.Init:return this.state=Ze.SYNSent,he.SYN;case Ze.SYNReceived:return this.state=Ze.Established,he.ACK;default:return 0}}sendWindowUpdate(){const e=this.getSendFlags(),t=Date.now(),n=this.getRTT();if(e===0&&n>-1&&t-this.epochStart<n*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&e===0)return;const s=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=t,this.sendFrame({type:ye.WindowUpdate,flag:e,streamID:this._id,length:s})}}const Hu="/yamux/1.0.0",Uy=500;class By{protocol=Hu;_components;_init;constructor(e,t={}){this._components=e,this._init=t}[Symbol.toStringTag]="@chainsafe/libp2p-yamux";[et]=["@libp2p/stream-multiplexing"];createStreamMuxer(e){return new $y(this._components,{...this._init,...e})}}class $y{protocol=Hu;source;sink;config;log;logger;closeController;nextStreamID;_streams;nextPingID;activePing;rtt;client;localGoAway;remoteGoAway;numInboundStreams;numOutboundStreams;onIncomingStream;onStreamEnd;constructor(e,t){this.client=t.direction==="outbound",this.config={...Ty,...t},this.logger=e.logger,this.log=this.logger.forComponent("libp2p:yamux"),Py(this.config),this.closeController=new AbortController,this.closeController.signal,this.onIncomingStream=t.onIncomingStream,this.onStreamEnd=t.onStreamEnd,this._streams=new Map,this.source=dn({onEnd:()=>{this.log?.trace("muxer source ended"),this._streams.forEach(n=>{n.destroy()})}}),this.sink=async n=>{const s=()=>{const a=Uu(n);if(a.return!=null){const c=a.return();zy(c)&&c.catch(l=>{this.log?.("could not cause sink source to return",l)})}};let i,o;try{const a=new Dy(n);try{this.closeController.signal.addEventListener("abort",s);for await(const c of a.emitFrames())await this.handleFrame(c.header,c.readData)}finally{this.closeController.signal.removeEventListener("abort",s)}i=st.NormalTermination}catch(a){Cy.has(a.name)?(this.log?.error("protocol error in sink",a),i=st.ProtocolError):(this.log?.error("internal error in sink",a),i=st.InternalError),o=a}this.log?.trace("muxer sink ended"),o!=null?this.abort(o,i):await this.close({reason:i})},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(n=>this.log?.error("keepalive error: %s",n)),this.ping().catch(n=>this.log?.error("ping error: %s",n))}get streams(){return Array.from(this._streams.values())}newStream(e){if(this.remoteGoAway!==void 0)throw new Tr("Muxer closed remotely");if(this.localGoAway!==void 0)throw new Tr("Muxer closed locally");const t=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new xl("max outbound streams exceeded");this.log?.trace("new outgoing stream id=%s",t);const n=this._newStream(t,e,Ze.Init,"outbound");return this._streams.set(t,n),this.numOutboundStreams++,n.sendWindowUpdate(),n}async ping(){if(this.remoteGoAway!==void 0)throw new Tr("Muxer closed remotely");if(this.localGoAway!==void 0)throw new Tr("Muxer closed locally");if(this.activePing===void 0){let e=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((s,i)=>{const o=()=>{i(new Tr("Muxer closed locally"))};this.closeController.signal.addEventListener("abort",o,{once:!0}),e=()=>{this.closeController.signal.removeEventListener("abort",o),s()}}),resolve:e};const t=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}const n=Date.now();this.rtt=n-t}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}async close(e={}){if(this.closeController.signal.aborted)return;const t=e?.reason??st.NormalTermination;if(this.log?.trace("muxer close reason=%s",t),e.signal==null){const n=AbortSignal.timeout(Uy);e={...e,signal:n}}try{await Promise.all([...this._streams.values()].map(async n=>n.close(e))),this.sendGoAway(t),this._closeMuxer()}catch(n){this.abort(n)}}abort(e,t){if(!this.closeController.signal.aborted){t=t??st.InternalError,this.log?.error("muxer abort reason=%s error=%s",t,e);for(const n of this._streams.values())n.abort(e);this.sendGoAway(t),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(e,t,n,s){if(this._streams.get(e)!=null)throw new W("Stream already exists with that id");const i=new Fy({id:e.toString(),name:t,state:n,direction:s,sendFrame:this.sendFrame.bind(this),onEnd:()=>{this.closeStream(e),this.onStreamEnd?.(i)},log:this.logger.forComponent(`libp2p:yamux:${s}:${e}`),config:this.config,getRTT:this.getRTT.bind(this)});return i}closeStream(e){this.client===(e%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(e)}async keepAliveLoop(){const e=new Promise((t,n)=>{this.closeController.signal.addEventListener("abort",n,{once:!0})});for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let t;try{await Promise.race([e,new Promise(n=>{t=setTimeout(n,this.config.keepAliveInterval)})]),this.ping().catch(n=>this.log?.error("ping error: %s",n))}catch{clearInterval(t);return}}}async handleFrame(e,t){const{streamID:n,type:s,length:i}=e;if(this.log?.trace("received frame %o",e),n===0)switch(s){case ye.Ping:{this.handlePing(e);return}case ye.GoAway:{this.handleGoAway(i);return}default:throw new tr("Invalid frame type")}else switch(e.type){case ye.Data:case ye.WindowUpdate:{await this.handleStreamMessage(e,t);return}default:throw new tr("Invalid frame type")}}handlePing(e){if(e.flag===he.SYN)this.log?.trace("received ping request pingId=%s",e.length),this.sendPing(e.length,he.ACK);else if(e.flag===he.ACK)this.log?.trace("received ping response pingId=%s",e.length),this.handlePingResponse(e.length);else throw new tr("Invalid frame flag")}handlePingResponse(e){if(this.activePing===void 0)throw new Bu("ping not requested");if(this.activePing.id!==e)throw new $u("ping doesn't match our id");this.activePing.resolve()}handleGoAway(e){this.log?.trace("received GoAway reason=%s",st[e]??"unknown"),this.remoteGoAway=e;for(const t of this._streams.values())t.reset();this._closeMuxer()}async handleStreamMessage(e,t){const{streamID:n,flag:s,type:i}=e;(s&he.SYN)===he.SYN&&this.incomingStream(n);const o=this._streams.get(n);if(o===void 0){if(i===ye.Data){if(this.log?.("discarding data for stream id=%s",n),t===void 0)throw new Error("unreachable");await t()}else this.log?.trace("frame for missing stream id=%s",n);return}switch(i){case ye.WindowUpdate:{o.handleWindowUpdate(e);return}case ye.Data:{if(t===void 0)throw new Error("unreachable");await o.handleData(e,t);return}default:throw new Error("unreachable")}}incomingStream(e){if(this.client!==(e%2===0))throw new W("Both endpoints are clients");if(this._streams.has(e))return;if(this.log?.trace("new incoming stream id=%s",e),this.localGoAway!==void 0){this.sendFrame({type:ye.WindowUpdate,flag:he.RST,streamID:e,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){this.log?.("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:ye.WindowUpdate,flag:he.RST,streamID:e,length:0});return}const t=this._newStream(e,void 0,Ze.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(e,t),this.onIncomingStream?.(t)}sendFrame(e,t){if(this.log?.trace("sending frame %o",e),e.type===ye.Data){if(t===void 0)throw new tr("Invalid frame");this.source.push(new j(Xa(e),t))}else this.source.push(Xa(e))}sendPing(e,t=he.SYN){t===he.SYN?this.log?.trace("sending ping request pingId=%s",e):this.log?.trace("sending ping response pingId=%s",e),this.sendFrame({type:ye.Ping,flag:t,streamID:0,length:e})}sendGoAway(e=st.NormalTermination){this.log?.("sending GoAway reason=%s",st[e]),this.localGoAway=e,this.sendFrame({type:ye.GoAway,flag:0,streamID:0,length:e})}}function zy(r){return r!=null&&typeof r.then=="function"}function Ky(r={}){return e=>new By(e,r)}var is;(function(r){let e;r.codec=()=>(e==null&&(e=ge((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&t.payload.byteLength>0&&(n.uint32(26),n.bytes(t.payload)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={publicKey:ne(0),payloadType:ne(0),payload:ne(0),signature:ne(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=t.bytes();break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>pe(t,r.codec()),r.decode=(t,n)=>fe(t,r.codec(),n)})(is||(is={}));class qy extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}}class at{static createFromProtobuf=async e=>{const t=is.decode(e),n=Dt(t.publicKey);return new at({publicKey:n,payloadType:t.payloadType,payload:t.payload,signature:t.signature})};static seal=async(e,t)=>{if(t==null)throw new Error("Missing private key");const n=e.domain,s=e.codec,i=e.marshal(),o=ja(n,s,i),a=await t.sign(o.subarray());return new at({publicKey:t.publicKey,payloadType:s,payload:i,signature:a})};static openAndCertify=async(e,t)=>{const n=await at.createFromProtobuf(e);if(!await n.validate(t))throw new qy("Envelope signature is not valid for the given domain");return n};publicKey;payloadType;payload;signature;marshaled;constructor(e){const{publicKey:t,payloadType:n,payload:s,signature:i}=e;this.publicKey=t,this.payloadType=n,this.payload=s,this.signature=i}marshal(){return this.marshaled==null&&(this.marshaled=is.encode({publicKey:yt(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return e==null?!1:De(this.marshal(),e.marshal())}async validate(e){const t=ja(e,this.payloadType,this.payload);return this.publicKey.verify(t.subarray(),this.signature)}}const ja=(r,e,t)=>{const n=K(r),s=ot(n.byteLength),i=ot(e.length),o=ot(t.length);return new j(s,n,i,e,o,t)};function Wy(r,e){const t=(n,s)=>n.toString().localeCompare(s.toString());return r.length!==e.length?!1:(e.sort(t),r.sort(t).every((n,s)=>e[s].equals(n)))}class Hy{index=0;input="";new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,n=e();return n===void 0&&(this.index=t),n}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{const t=this.readChar();if(t===e)return t})}readSeparator(e,t,n){return this.readAtomically(()=>{if(!(t>0&&this.readGivenChar(e)===void 0))return n()})}readNumber(e,t,n,s){return this.readAtomically(()=>{let i=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",l=2**(8*s)-1;for(;;){const u=this.readAtomically(()=>{const d=this.readChar();if(d===void 0)return;const h=Number.parseInt(d,e);if(!Number.isNaN(h))return h});if(u===void 0)break;if(i*=e,i+=u,i>l||(o+=1,t!==void 0&&o>t))return}if(o!==0)return!n&&c&&o>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const n=this.readSeparator(".",t,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;e[t]=n}return e})}readIPv6Addr(){const e=t=>{for(let n=0;n<t.length/2;n++){const s=n*2;if(n<t.length-3){const o=this.readSeparator(":",n,()=>this.readIPv4Addr());if(o!==void 0)return t[s]=o[0],t[s+1]=o[1],t[s+2]=o[2],t[s+3]=o[3],[s+4,!0]}const i=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(i===void 0)return[s,!1];t[s]=i>>8,t[s+1]=i&255}return[t.length,!1]};return this.readAtomically(()=>{const t=new Uint8Array(16),[n,s]=e(t);if(n===16)return t;if(s||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const i=new Uint8Array(14),o=16-(n+2),[a]=e(i.subarray(0,o));return t.set(i.subarray(0,a),16-a),t})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const Vu=45,Vy=15,hr=new Hy;function Gu(r){if(!(r.length>Vy))return hr.new(r).parseWith(()=>hr.readIPv4Addr())}function Yu(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>Vu))return hr.new(r).parseWith(()=>hr.readIPv6Addr())}function os(r,e=!1){if(r.includes("%")&&(r=r.split("%")[0]),r.length>Vu)return;const t=hr.new(r).parseWith(()=>hr.readIPAddr());if(t)return e&&t.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,t[0],t[1],t[2],t[3]]):t}function Gy(r,e,t){let n=0;for(const s of r)if(!(n<e)){if(n>t)break;if(s!==255)return!1;n++}return!0}function Yy(r,e,t,n){let s=0;for(const i of r)if(!(s<t)){if(s>n)break;if(i!==e[s])return!1;s++}return!0}function Xy(r){switch(r.length){case Gr:return r.join(".");case Yr:{const e=[];for(let t=0;t<r.length;t++)t%2===0&&e.push(r[t].toString(16).padStart(2,"0")+r[t+1].toString(16).padStart(2,"0"));return e.join(":")}default:throw new Error("Invalid ip length")}}function Qy(r){let e=0;for(let[t,n]of r.entries()){if(n===255){e+=8;continue}for(;(n&128)!=0;)e++,n=n<<1;if((n&128)!=0)return-1;for(let s=t+1;s<r.length;s++)if(r[s]!=0)return-1;break}return e}function jy(r){let e="0x";for(const t of r)e+=(t>>4).toString(16)+(t&15).toString(16);return e}const Gr=4,Yr=16,Zy=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function Xu(r,e){e.length===Yr&&r.length===Gr&&Gy(e,0,11)&&(e=e.slice(12)),e.length===Gr&&r.length===Yr&&Yy(r,Zy,0,11)&&(r=r.slice(12));const t=r.length;if(t!=e.length)throw new Error("Failed to mask ip");const n=new Uint8Array(t);for(let s=0;s<t;s++)n[s]=r[s]&e[s];return n}function Jy(r,e){if(typeof e=="string"&&(e=os(e)),e==null)throw new Error("Invalid ip");if(e.length!==r.network.length)return!1;for(let t=0;t<e.length;t++)if((r.network[t]&r.mask[t])!==(e[t]&r.mask[t]))return!1;return!0}function ew(r){const[e,t]=r.split("/");if(!e||!t)throw new Error("Failed to parse given CIDR: "+r);let n=Gr,s=Gu(e);if(s==null&&(n=Yr,s=Yu(e),s==null))throw new Error("Failed to parse given CIDR: "+r);const i=parseInt(t,10);if(Number.isNaN(i)||String(i).length!==t.length||i<0||i>n*8)throw new Error("Failed to parse given CIDR: "+r);const o=Qu(i,8*n);return{network:Xu(s,o),mask:o}}function Qu(r,e){if(e!==8*Gr&&e!==8*Yr)throw new Error("Invalid CIDR mask");if(r<0||r>e)throw new Error("Invalid CIDR mask");const t=e/8,n=new Uint8Array(t);for(let s=0;s<t;s++){if(r>=8){n[s]=255,r-=8;continue}n[s]=255-(255>>r),r=0}return n}class ju{constructor(e,t){if(t==null)({network:this.network,mask:this.mask}=ew(e));else{const n=os(e);if(n==null)throw new Error("Failed to parse network");t=String(t);const s=parseInt(t,10);if(Number.isNaN(s)||String(s).length!==t.length||s<0||s>n.length*8){const i=os(t);if(i==null)throw new Error("Failed to parse mask");this.mask=i}else this.mask=Qu(s,8*n.length);this.network=Xu(n,this.mask)}}contains(e){return Jy({network:this.network,mask:this.mask},e)}toString(){const e=Qy(this.mask),t=e!==-1?String(e):jy(this.mask);return Xy(this.network)+"/"+t}}function tw(r,e){return new ju(r).contains(e)}function fr(r){return!!Gu(r)}function $o(r){return!!Yu(r)}function Zu(r){return!!os(r)}const Za=fr,rw=$o,Ju=function(r){let e=0;if(r=r.toString().trim(),Za(r)){const t=new Uint8Array(e+4);return r.split(/\./g).forEach(n=>{t[e++]=parseInt(n,10)&255}),t}if(rw(r)){const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const i=Za(t[n]);let o;i&&(o=Ju(t[n]),t[n]=G(o.slice(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,G(o.slice(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const i=[n,1];for(n=9-t.length;n>0;n--)i.push("0");t.splice.apply(t,i)}const s=new Uint8Array(e+16);for(n=0;n<t.length;n++){const i=parseInt(t[n],16);s[e++]=i>>8&255,s[e++]=i&255}return s}throw new Error("invalid ip address")},nw=function(r,e=0,t){e=~~e,t=t??r.length-e;const n=new DataView(r.buffer);if(t===4){const s=[];for(let i=0;i<t;i++)s.push(r[e+i]);return s.join(".")}if(t===16){const s=[];for(let i=0;i<t;i+=2)s.push(n.getUint16(e+i).toString(16));return s.join(":").replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}return""},Ke=-1,Xr={},Xi={},sw=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,Ke,"ip6zone"],[43,8,"ipcidr"],[53,Ke,"dns",!0],[54,Ke,"dns4",!0],[55,Ke,"dns6",!0],[56,Ke,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,Ke,"unix",!1,!0],[421,Ke,"ipfs"],[421,Ke,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,Ke,"garlic64"],[448,0,"tls"],[449,Ke,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,Ke,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[481,Ke,"http-path"],[777,Ke,"memory"]];sw.forEach(r=>{const e=iw(...r);Xi[e.code]=e,Xr[e.name]=e});function iw(r,e,t,n,s){return{code:r,size:e,name:t,resolvable:!!n,path:!!s}}function V(r){if(typeof r=="number"){if(Xi[r]!=null)return Xi[r];throw new Error(`no protocol with code: ${r}`)}else if(typeof r=="string"){if(Xr[r]!=null)return Xr[r];throw new Error(`no protocol with name: ${r}`)}throw new Error(`invalid protocol id type: ${typeof r}`)}const ow=V("ip4"),aw=V("ip6"),cw=V("ipcidr");function ed(r,e){switch(V(r).code){case 4:case 41:return dw(e);case 42:return ai(e);case 43:return G(e,"base10");case 6:case 273:case 33:case 132:return td(e).toString();case 53:case 54:case 55:case 56:case 400:case 449:case 777:return ai(e);case 421:return gw(e);case 444:return tc(e);case 445:return tc(e);case 466:return pw(e);case 481:return globalThis.encodeURIComponent(ai(e));default:return G(e,"base16")}}function Ja(r,e){switch(V(r).code){case 4:return ec(e);case 41:return ec(e);case 42:return oi(e);case 43:return K(e,"base10");case 6:case 273:case 33:case 132:return zo(parseInt(e,10));case 53:case 54:case 55:case 56:case 400:case 449:case 777:return oi(e);case 421:return hw(e);case 444:return mw(e);case 445:return yw(e);case 466:return fw(e);case 481:return oi(globalThis.decodeURIComponent(e));default:return K(e,"base16")}}function lw(r){let e,t;if(r.stringTuples().forEach(([n,s])=>{(n===ow.code||n===aw.code)&&(t=s),n===cw.code&&(e=s)}),e==null||t==null)throw new Error("Invalid multiaddr");return new ju(t,e)}const ii=Object.values(Mi).map(r=>r.decoder),uw=function(){let r=ii[0].or(ii[1]);return ii.slice(2).forEach(e=>r=r.or(e)),r}();function ec(r){if(!Zu(r))throw new Error("invalid ip address");return Ju(r)}function dw(r){const e=nw(r,0,r.length);if(e==null)throw new Error("ipBuff is required");if(!Zu(e))throw new Error("invalid ip address");return e}function zo(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,r),new Uint8Array(e)}function td(r){return new DataView(r.buffer).getUint16(r.byteOffset)}function oi(r){const e=K(r),t=Uint8Array.from(ot(e.length));return tt([t,e],t.length+e.length)}function ai(r){const e=Gt(r);if(r=r.slice(Se(e)),r.length!==e)throw new Error("inconsistent lengths");return G(r)}function hw(r){let e;r[0]==="Q"||r[0]==="1"?e=Vt(me.decode(`z${r}`)).bytes:e=oe.parse(r).multihash.bytes;const t=Uint8Array.from(ot(e.length));return tt([t,e],t.length+e.length)}function fw(r){const e=uw.decode(r),t=Uint8Array.from(ot(e.length));return tt([t,e],t.length+e.length)}function pw(r){const e=Gt(r),t=r.slice(Se(e));if(t.length!==e)throw new Error("inconsistent lengths");return"u"+G(t,"base64url")}function gw(r){const e=Gt(r),t=r.slice(Se(e));if(t.length!==e)throw new Error("inconsistent lengths");return G(t,"base58btc")}function mw(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=mt.decode("b"+e[0]),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=zo(n);return tt([t,s],t.length+s.length)}function yw(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=mt.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=zo(n);return tt([t,s],t.length+s.length)}function tc(r){const e=r.slice(0,r.length-2),t=r.slice(r.length-2),n=G(e,"base32"),s=td(t);return`${n}:${s}`}function ww(r){r=Qi(r);const e=[],t=[];let n=null;const s=r.split("/").slice(1);if(s.length===1&&s[0]==="")return{bytes:new Uint8Array,string:"/",tuples:[],stringTuples:[],path:null};for(let i=0;i<s.length;i++){const o=s[i],a=V(o);if(a.size===0){e.push([a.code]),t.push([a.code]);continue}if(i++,i>=s.length)throw new sd("invalid address: "+r);if(a.path===!0){n=Qi(s.slice(i).join("/")),e.push([a.code,Ja(a.code,n)]),t.push([a.code,n]);break}const c=Ja(a.code,s[i]);e.push([a.code,c]),t.push([a.code,ed(a.code,c)])}return{string:rd(t),bytes:nd(e),tuples:e,stringTuples:t,path:n}}function rc(r){const e=[],t=[];let n=null,s=0;for(;s<r.length;){const i=Gt(r,s),o=Se(i),a=V(i),c=bw(a,r.slice(s+o));if(c===0){e.push([i]),t.push([i]),s+=o;continue}const l=r.slice(s+o,s+o+c);if(s+=c+o,s>r.length)throw new sd("Invalid address Uint8Array: "+G(r,"base16"));e.push([i,l]);const u=ed(i,l);if(t.push([i,u]),a.path===!0){n=u;break}}return{bytes:Uint8Array.from(r),string:rd(t),tuples:e,stringTuples:t,path:n}}function rd(r){const e=[];return r.map(t=>{const n=V(t[0]);return e.push(n.name),t.length>1&&t[1]!=null&&e.push(t[1]),null}),Qi(e.join("/"))}function nd(r){return tt(r.map(e=>{const t=V(e[0]);let n=Uint8Array.from(ot(t.code));return e.length>1&&e[1]!=null&&(n=tt([n,e[1]])),n}))}function bw(r,e){if(r.size>0)return r.size/8;if(r.size===0)return 0;{const t=Gt(e instanceof Uint8Array?e:Uint8Array.from(e));return t+Se(t)}}function Qi(r){return"/"+r.trim().split("/").filter(e=>e).join("/")}class sd extends Error{static name="ParseError";name="ParseError";constructor(e){super(`Error parsing address: ${e}`)}}const vw=Symbol.for("nodejs.util.inspect.custom"),id=Symbol.for("@multiformats/js-multiaddr/multiaddr"),Ew=[V("dns").code,V("dns4").code,V("dns6").code,V("dnsaddr").code];class Sw extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}}class rr{bytes;#e;#t;#r;#a;[id]=!0;constructor(e){e==null&&(e="");let t;if(e instanceof Uint8Array)t=rc(e);else if(typeof e=="string"){if(e.length>0&&e.charAt(0)!=="/")throw new Error(`multiaddr "${e}" must start with a "/"`);t=ww(e)}else if(ks(e))t=rc(e.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr");this.bytes=t.bytes,this.#e=t.string,this.#t=t.tuples,this.#r=t.stringTuples,this.#a=t.path}toString(){return this.#e}toJSON(){return this.toString()}toOptions(){let e,t,n,s,i="";const o=V("tcp"),a=V("udp"),c=V("ip4"),l=V("ip6"),u=V("dns6"),d=V("ip6zone");for(const[p,f]of this.stringTuples())p===d.code&&(i=`%${f??""}`),Ew.includes(p)&&(t=o.name==="tcp"?"tcp":"udp",s=443,n=`${f??""}${i}`,e=p===u.code?6:4),(p===o.code||p===a.code)&&(t=V(p).name==="tcp"?"tcp":"udp",s=parseInt(f??"")),(p===c.code||p===l.code)&&(t=V(p).name==="tcp"?"tcp":"udp",n=`${f??""}${i}`,e=p===l.code?6:4);if(e==null||t==null||n==null||s==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:n,transport:t,port:s}}protos(){return this.#t.map(([e])=>Object.assign({},V(e)))}protoCodes(){return this.#t.map(([e])=>e)}protoNames(){return this.#t.map(([e])=>V(e).name)}tuples(){return this.#t.map(([e,t])=>t==null?[e]:[e,t])}stringTuples(){return this.#r.map(([e,t])=>t==null?[e]:[e,t])}encapsulate(e){return e=new rr(e),new rr(this.toString()+e.toString())}decapsulate(e){const t=e.toString(),n=this.toString(),s=n.lastIndexOf(t);if(s<0)throw new Error(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new rr(n.slice(0,s))}decapsulateCode(e){const t=this.tuples();for(let n=t.length-1;n>=0;n--)if(t[n][0]===e)return new rr(nd(t.slice(0,n)));return this}getPeerId(){try{let e=[];this.stringTuples().forEach(([n,s])=>{n===Xr.p2p.code&&e.push([n,s]),n===Xr["p2p-circuit"].code&&(e=[])});const t=e.pop();if(t?.[1]!=null){const n=t[1];return n[0]==="Q"||n[0]==="1"?G(me.decode(`z${n}`),"base58btc"):G(oe.parse(n).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){return this.#a}equals(e){return De(this.bytes,e.bytes)}async resolve(e){const t=this.protos().find(i=>i.resolvable);if(t==null)return[this];const n=Ko.get(t.name);if(n==null)throw new Sw(`no available resolver for ${t.name}`);return(await n(this,e)).map(i=>Y(i))}nodeAddress(){const e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(e){const t=(e??this).protos();return!(t.length!==2||t[0].code!==4&&t[0].code!==41||t[1].code!==6&&t[1].code!==273)}[vw](){return`Multiaddr(${this.#e})`}}const Ko=new Map;function ks(r){return!!r?.[id]}function Y(r){return new rr(r)}const xw="libp2p-peer-record",Aw=Uint8Array.from([3,1]);var as;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=ge((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.multiaddr!=null&&s.multiaddr.byteLength>0&&(i.uint32(10),i.bytes(s.multiaddr)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={multiaddr:ne(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.multiaddr=s.bytes();break}default:{s.skipType(l&7);break}}}return a})),n),t.encode=s=>pe(s,t.codec()),t.decode=(s,i)=>fe(s,t.codec(),i)})(r.AddressInfo||(r.AddressInfo={}));let e;r.codec=()=>(e==null&&(e=ge((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.peerId!=null&&t.peerId.byteLength>0&&(n.uint32(10),n.bytes(t.peerId)),t.seq!=null&&t.seq!==0n&&(n.uint32(16),n.uint64(t.seq)),t.addresses!=null)for(const i of t.addresses)n.uint32(26),r.AddressInfo.codec().encode(i,n);s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={peerId:ne(0),seq:0n,addresses:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.peerId=t.bytes();break}case 2:{i.seq=t.uint64();break}case 3:{if(s.limits?.addresses!=null&&i.addresses.length===s.limits.addresses)throw new bt('Decode error - map field "addresses" had too many elements');i.addresses.push(r.AddressInfo.codec().decode(t,t.uint32(),{limits:s.limits?.addresses$}));break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>pe(t,r.codec()),r.decode=(t,n)=>fe(t,r.codec(),n)})(as||(as={}));class He{static createFromProtobuf=e=>{const t=as.decode(e),n=ln(Vt(t.peerId)),s=(t.addresses??[]).map(o=>Y(o.multiaddr)),i=t.seq;return new He({peerId:n,multiaddrs:s,seqNumber:i})};static DOMAIN=xw;static CODEC=Aw;peerId;multiaddrs;seqNumber;domain=He.DOMAIN;codec=He.CODEC;marshaled;constructor(e){const{peerId:t,multiaddrs:n,seqNumber:s}=e;this.peerId=t,this.multiaddrs=n??[],this.seqNumber=s??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=as.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(e=>({multiaddr:e.bytes}))})),this.marshaled}equals(e){return!(!(e instanceof He)||!this.peerId.equals(e.peerId)||this.seqNumber!==e.seqNumber||!Wy(this.multiaddrs,e.multiaddrs))}}function vt(r,e){const t=ur(r,e),n={read:async(s,i)=>{const o=await t.read(i);return s.decode(o)},write:async(s,i,o)=>{await t.write(i.encode(s),o)},writeV:async(s,i,o)=>{await t.writeV(s.map(a=>i.encode(a)),o)},pb:s=>({read:async i=>n.read(s,i),write:async(i,o)=>n.write(i,s,o),writeV:async(i,o)=>n.writeV(i,s,o),unwrap:()=>n}),unwrap:()=>t.unwrap()};return n}const Cw=290,Iw=1,od=2e3,Tw=100,In=`${ho}-circuit-relay`;BigInt(1<<17);const cs="/libp2p/circuit/relay/0.2.0/hop",nc="/libp2p/circuit/relay/0.2.0/stop",sc=300,Pw=4096,kw=.001;var pr;(function(r){(function(n){n.RESERVE="RESERVE",n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let e;(function(n){n[n.RESERVE=0]="RESERVE",n[n.CONNECT=1]="CONNECT",n[n.STATUS=2]="STATUS"})(e||(e={})),function(n){n.codec=()=>xr(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=ge((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.peer!=null&&(s.uint32(18),gr.codec().encode(n.peer,s)),n.reservation!=null&&(s.uint32(26),ls.codec().encode(n.reservation,s)),n.limit!=null&&(s.uint32(34),mr.codec().encode(n.limit,s)),n.status!=null&&(s.uint32(40),Me.codec().encode(n.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=gr.codec().decode(n,n.uint32(),{limits:i.limits?.peer});break}case 3:{o.reservation=ls.codec().decode(n,n.uint32(),{limits:i.limits?.reservation});break}case 4:{o.limit=mr.codec().decode(n,n.uint32(),{limits:i.limits?.limit});break}case 5:{o.status=Me.codec().decode(n);break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>pe(n,r.codec()),r.decode=(n,s)=>fe(n,r.codec(),s)})(pr||(pr={}));var ft;(function(r){(function(n){n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let e;(function(n){n[n.CONNECT=0]="CONNECT",n[n.STATUS=1]="STATUS"})(e||(e={})),function(n){n.codec=()=>xr(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=ge((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.peer!=null&&(s.uint32(18),gr.codec().encode(n.peer,s)),n.limit!=null&&(s.uint32(26),mr.codec().encode(n.limit,s)),n.status!=null&&(s.uint32(32),Me.codec().encode(n.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=gr.codec().decode(n,n.uint32(),{limits:i.limits?.peer});break}case 3:{o.limit=mr.codec().decode(n,n.uint32(),{limits:i.limits?.limit});break}case 4:{o.status=Me.codec().decode(n);break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>pe(n,r.codec()),r.decode=(n,s)=>fe(n,r.codec(),s)})(ft||(ft={}));var gr;(function(r){let e;r.codec=()=>(e==null&&(e=ge((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.id!=null&&t.id.byteLength>0&&(n.uint32(10),n.bytes(t.id)),t.addrs!=null)for(const i of t.addrs)n.uint32(18),n.bytes(i);s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={id:ne(0),addrs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.id=t.bytes();break}case 2:{if(s.limits?.addrs!=null&&i.addrs.length===s.limits.addrs)throw new bt('Decode error - map field "addrs" had too many elements');i.addrs.push(t.bytes());break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>pe(t,r.codec()),r.decode=(t,n)=>fe(t,r.codec(),n)})(gr||(gr={}));var ls;(function(r){let e;r.codec=()=>(e==null&&(e=ge((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.expire!=null&&t.expire!==0n&&(n.uint32(8),n.uint64(t.expire)),t.addrs!=null)for(const i of t.addrs)n.uint32(18),n.bytes(i);t.voucher!=null&&(n.uint32(26),ds.codec().encode(t.voucher,n)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={expire:0n,addrs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.expire=t.uint64();break}case 2:{if(s.limits?.addrs!=null&&i.addrs.length===s.limits.addrs)throw new bt('Decode error - map field "addrs" had too many elements');i.addrs.push(t.bytes());break}case 3:{i.voucher=ds.codec().decode(t,t.uint32(),{limits:s.limits?.voucher});break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>pe(t,r.codec()),r.decode=(t,n)=>fe(t,r.codec(),n)})(ls||(ls={}));var mr;(function(r){let e;r.codec=()=>(e==null&&(e=ge((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.duration!=null&&(n.uint32(8),n.uint32(t.duration)),t.data!=null&&(n.uint32(16),n.uint64(t.data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.duration=t.uint32();break}case 2:{i.data=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>pe(t,r.codec()),r.decode=(t,n)=>fe(t,r.codec(),n)})(mr||(mr={}));var Me;(function(r){r.UNUSED="UNUSED",r.OK="OK",r.RESERVATION_REFUSED="RESERVATION_REFUSED",r.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",r.PERMISSION_DENIED="PERMISSION_DENIED",r.CONNECTION_FAILED="CONNECTION_FAILED",r.NO_RESERVATION="NO_RESERVATION",r.MALFORMED_MESSAGE="MALFORMED_MESSAGE",r.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(Me||(Me={}));var ji;(function(r){r[r.UNUSED=0]="UNUSED",r[r.OK=100]="OK",r[r.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",r[r.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",r[r.PERMISSION_DENIED=202]="PERMISSION_DENIED",r[r.CONNECTION_FAILED=203]="CONNECTION_FAILED",r[r.NO_RESERVATION=204]="NO_RESERVATION",r[r.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",r[r.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(ji||(ji={}));(function(r){r.codec=()=>xr(ji)})(Me||(Me={}));var us;(function(r){let e;r.codec=()=>(e==null&&(e=ge((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.relay!=null&&t.relay.byteLength>0&&(n.uint32(10),n.bytes(t.relay)),t.peer!=null&&t.peer.byteLength>0&&(n.uint32(18),n.bytes(t.peer)),t.expiration!=null&&t.expiration!==0n&&(n.uint32(24),n.uint64(t.expiration)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={relay:ne(0),peer:ne(0),expiration:0n},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.relay=t.bytes();break}case 2:{i.peer=t.bytes();break}case 3:{i.expiration=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>pe(t,r.codec()),r.decode=(t,n)=>fe(t,r.codec(),n)})(us||(us={}));var ds;(function(r){let e;r.codec=()=>(e==null&&(e=ge((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&(n.uint32(26),us.codec().encode(t.payload,n)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={publicKey:ne(0),payloadType:ne(0),signature:ne(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=us.codec().decode(t,t.uint32(),{limits:s.limits?.payload});break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>pe(t,r.codec()),r.decode=(t,n)=>fe(t,r.codec(),n)})(ds||(ds={}));const _w=r=>r.toString().split("/").slice(1),fn=r=>({match:e=>e.length<1?!1:r(e[0])?e.slice(1):!1,pattern:"fn"}),X=r=>({match:e=>fn(t=>t===r).match(e),pattern:r}),Ar=()=>({match:r=>fn(e=>typeof e=="string").match(r),pattern:"{string}"}),Qr=()=>({match:r=>fn(e=>!isNaN(parseInt(e))).match(r),pattern:"{number}"}),ie=()=>({match:r=>{if(r.length<2||r[0]!=="p2p"&&r[0]!=="ipfs")return!1;if(r[1].startsWith("Q")||r[1].startsWith("1"))try{me.decode(`z${r[1]}`)}catch{return!1}else return!1;return r.slice(2)},pattern:"/p2p/{peerid}"}),hs=()=>({match:r=>{if(r.length<2||r[0]!=="certhash")return!1;try{Rl.decode(r[1])}catch{return!1}return r.slice(2)},pattern:"/certhash/{certhash}"}),re=r=>({match:e=>{const t=r.match(e);return t===!1?e:t},pattern:`optional(${r.pattern})`}),Oe=(...r)=>({match:e=>{let t;for(const n of r){const s=n.match(e);s!==!1&&(t==null||s.length<t.length)&&(t=s)}return t??!1},pattern:`or(${r.map(e=>e.pattern).join(", ")})`}),Q=(...r)=>({match:e=>{for(const t of r){const n=t.match(e);if(n===!1)return!1;e=n}return e},pattern:`and(${r.map(e=>e.pattern).join(", ")})`});function ce(...r){function e(s){let i=_w(s);for(const o of r){const a=o.match(i);if(a===!1)return!1;i=a}return i}function t(s){return e(s)!==!1}function n(s){const i=e(s);return i===!1?!1:i.length===0}return{matchers:r,matches:t,exactMatch:n}}const Dw=ie(),Lw=ce(Dw),_s=Q(X("dns4"),Ar()),Ds=Q(X("dns6"),Ar()),Ls=Q(X("dnsaddr"),Ar()),qo=Q(X("dns"),Ar());ce(_s,re(ie()));ce(Ds,re(ie()));ce(Ls,re(ie()));ce(Oe(qo,Ls,_s,Ds),re(ie()));const ad=Q(X("ip4"),fn(fr)),cd=Q(X("ip6"),fn($o)),Wo=Oe(ad,cd),wt=Oe(Wo,qo,_s,Ds,Ls),Rw=ce(Oe(Wo,Q(Oe(qo,Ls,_s,Ds),re(ie())))),ic=ce(ad),oc=ce(cd);ce(Wo);const Ho=Q(wt,X("tcp"),Qr()),pn=Q(wt,X("udp"),Qr()),fs=ce(Q(Ho,re(ie())));ce(pn);const Vo=Q(pn,X("quic"),re(ie())),Rs=Q(pn,X("quic-v1"),re(ie())),Mw=Oe(Vo,Rs);ce(Vo);const Ow=ce(Rs),Zi=Oe(wt,Ho,pn,Vo,Rs),ld=Oe(Q(Zi,X("ws"),re(ie()))),jr=ce(ld),ud=Oe(Q(Zi,X("wss"),re(ie())),Q(Zi,X("tls"),re(Q(X("sni"),Ar())),X("ws"),re(ie()))),ps=ce(ud),dd=Q(pn,X("webrtc-direct"),re(hs()),re(hs()),re(ie())),ac=ce(dd),hd=Q(Rs,X("webtransport"),re(hs()),re(hs()),re(ie())),cc=ce(hd),gs=Oe(ld,ud,Q(Ho,re(ie())),Q(Mw,re(ie())),Q(wt,re(ie())),dd,hd,ie()),fd=ce(gs),Nw=Q(gs,X("p2p-circuit"),ie()),Zr=ce(Nw),Fw=Oe(Q(gs,X("p2p-circuit"),X("webrtc"),re(ie())),Q(gs,X("webrtc"),re(ie())),Q(X("webrtc"),re(ie()))),Ji=ce(Fw),Uw=Oe(Q(wt,X("tcp"),Qr(),X("http"),re(ie())),Q(wt,X("http"),re(ie())));ce(Uw);const Bw=Oe(Q(wt,X("tcp"),Oe(Q(X("443"),X("http")),Q(Qr(),X("https")),Q(Qr(),X("tls"),X("http"))),re(ie())),Q(wt,X("tls"),X("http"),re(ie())),Q(wt,X("https"),re(ie())));ce(Bw);const $w=Oe(Q(X("memory"),Ar(),re(ie())));ce($w);function Lt(r){const e=new globalThis.AbortController;function t(){e.abort();for(const i of r)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}for(const i of r){if(i?.aborted===!0){t();break}i?.addEventListener!=null&&i.addEventListener("abort",t)}function n(){for(const i of r)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}const s=e.signal;return s.clear=n,s}class lc extends Error{static name="HadEnoughRelaysError";name="HadEnoughRelaysError"}class zw extends Error{static name="DoubleRelayError";name="DoubleRelayError"}class Kw extends Error{static name="RelayQueueFullError";name="RelayQueueFullError"}function uc(r){const e=r*BigInt(1e3),t=new Date().getTime();return Number(e-BigInt(t))}class dc{expires;bytes;constructor(e){e?.duration!=null&&e?.duration!==0&&(this.expires=Date.now()+e.duration*1e3),this.bytes=e?.data,this.bytes===0n&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(e){this.bytes!=null&&(this.bytes-=BigInt(e.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(this.expires==null&&this.bytes==null)return;const e={};if(this.bytes!=null){const t=this;Object.defineProperty(e,"bytes",{get(){return t.bytes}})}if(this.expires!=null){const t=this;Object.defineProperty(e,"seconds",{get(){return Math.round(((t.expires??0)-Date.now())/1e3)}})}return e}}const pd=ce(Q(fd.matchers[0],X("p2p-circuit"))),gd=ce(X("p2p-circuit"));function Br(r,e){const t={[Symbol.iterator]:()=>t,next:()=>{const n=r.next(),s=n.value;return n.done===!0||s==null?{done:!0,value:void 0}:{done:!1,value:e(s)}}};return t}function ci(r){const e=Vt(me.decode(`z${r}`));return ln(e)}class Ms{map;constructor(e){if(this.map=new Map,e!=null)for(const[t,n]of e.entries())this.map.set(t.toString(),{key:t,value:n})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return Br(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach((t,n)=>{e(t.value,t.key,this)})}get(e){return this.map.get(e.toString())?.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return Br(this.map.values(),e=>e.key)}values(){return Br(this.map.values(),e=>e.value)}get size(){return this.map.size}}class sr{set;constructor(e){if(this.set=new Set,e!=null)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return Br(this.set.entries(),e=>{const t=ci(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const n=ci(t);e(n,n,this)})}has(e){return this.set.has(e.toString())}values(){return Br(this.set.values(),e=>ci(e))}intersection(e){const t=new sr;for(const n of e)this.has(n)&&t.add(n);return t}difference(e){const t=new sr;for(const n of this)e.has(n)||t.add(n);return t}union(e){const t=new sr;for(const n of e)t.add(n);for(const n of this)t.add(n);return t}}const Go={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},md={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},yd=new globalThis.TextEncoder;function qw(r,e){const t=Go[e];let n=md[e];for(let s=0;s<r.length;s++)n^=BigInt(r[s]),n=BigInt.asUintN(e,n*t);return n}function Ww(r,e,t){if(t.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const n=Go[e];let s=md[e],i=r;for(;i.length>0;){const o=yd.encodeInto(i,t);i=i.slice(o.read);for(let a=0;a<o.written;a++)s^=BigInt(t[a]),s=BigInt.asUintN(e,s*n)}return s}function Hw(r,{size:e=32,utf8Buffer:t}={}){if(!Go[e])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof r=="string"){if(t)return Ww(r,e,t);r=yd.encode(r)}return qw(r,e)}const Yo={hash:r=>Number(Hw(r,{size:32})),hashV:(r,e)=>Vw(Yo.hash(r,e))};function Vw(r){let e=r.toString(16);return e.length%2===1&&(e=`0${e}`),K(e,"base16")}const wd=64;class Ft{fp;h;seed;constructor(e,t,n,s=2){if(s>wd)throw new TypeError("Invalid Fingerprint Size");const i=t.hashV(e,n),o=ne(s);for(let a=0;a<o.length;a++)o[a]=i[a];o.length===0&&(o[0]=7),this.fp=o,this.h=t,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return e?.fp instanceof Uint8Array?De(this.fp,e.fp):!1}}function ms(r,e){return Math.floor(Math.random()*(e-r))+r}class Tn{contents;constructor(e){this.contents=new Array(e).fill(null)}has(e){if(!(e instanceof Ft))throw new TypeError("Invalid Fingerprint");return this.contents.some(t=>e.equals(t))}add(e){if(!(e instanceof Ft))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(this.contents[t]==null)return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof Ft))throw new TypeError("Invalid Fingerprint");const t=ms(0,this.contents.length-1),n=this.contents[t];return this.contents[t]=e,n}remove(e){if(!(e instanceof Ft))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex(n=>e.equals(n));return t>-1?(this.contents[t]=null,!0):!1}}const Gw=500;class hc{bucketSize;filterSize;fingerprintSize;buckets;count;hash;seed;constructor(e){this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??Yo,this.seed=e.seed??ms(0,Math.pow(2,10))}add(e){typeof e=="string"&&(e=K(e));const t=new Ft(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=(n^t.hash())%this.filterSize;if(this.buckets[n]==null&&(this.buckets[n]=new Tn(this.bucketSize)),this.buckets[s]==null&&(this.buckets[s]=new Tn(this.bucketSize)),this.buckets[n].add(t)||this.buckets[s].add(t))return this.count++,!0;const i=[n,s];let o=i[ms(0,i.length-1)];this.buckets[o]==null&&(this.buckets[o]=new Tn(this.bucketSize));for(let a=0;a<Gw;a++){const c=this.buckets[o].swap(t);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new Tn(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(e){typeof e=="string"&&(e=K(e));const t=new Ft(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=this.buckets[n]?.has(t)??!1;if(s)return s;const i=(n^t.hash())%this.filterSize;return this.buckets[i]?.has(t)??!1}remove(e){typeof e=="string"&&(e=K(e));const t=new Ft(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=this.buckets[n]?.remove(t)??!1;if(s)return this.count--,s;const i=(n^t.hash())%this.filterSize,o=this.buckets[i]?.remove(t)??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const Yw={1:.5,2:.84,4:.95,8:.98};function Xw(r=.001){return r>.002?2:r>1e-5?4:8}function Qw(r,e=.001){const t=Xw(e),n=Yw[t],s=Math.round(r/n),i=Math.min(Math.ceil(Math.log2(1/e)+Math.log2(2*t)),wd);return{filterSize:s,bucketSize:t,fingerprintSize:i}}class jw{filterSize;bucketSize;fingerprintSize;scale;filterSeries;hash;seed;constructor(e){this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??Yo,this.seed=e.seed??ms(0,Math.pow(2,10)),this.filterSeries=[new hc({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if(typeof e=="string"&&(e=K(e)),this.has(e))return!0;let t=this.filterSeries.find(n=>n.reliable);if(t==null){const n=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new hc({filterSize:n,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){typeof e=="string"&&(e=K(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){typeof e=="string"&&(e=K(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce((e,t)=>e+t.count,0)}}function Jr(r,e=.001,t){return new jw({...Qw(r,e)})}class Zw{filter;constructor(e,t){this.filter=Jr(e,t)}has(e){return this.filter.has(e.toMultihash().bytes)}add(e){this.filter.add(e.toMultihash().bytes)}remove(e){this.filter.remove?.(e.toMultihash().bytes)}}function Jw(r,e=.001){return new Zw(r,e)}function fc(r){const{stream:e,remoteAddr:t,logger:n,onDataRead:s,onDataWrite:i}=r,o=n.forComponent("libp2p:stream:converter");let a=!1,c=!1;const l=e.close.bind(e);e.close=async f=>{await l(f),p(!0)};const u=e.abort.bind(e);e.abort=f=>{u(f),p(!0)};const d=e.sink.bind(e);e.sink=async f=>{try{await d(Uo(f,g=>Wu(g,m=>i?.(m))))}catch(g){g.type!=="aborted"&&o.error("%s error in sink",t,g)}finally{c=!0,p()}};const h={log:o,sink:e.sink,source:async function*(){try{for await(const f of e.source)s?.(f),yield f}finally{a=!0,p()}}(),remoteAddr:t,timeline:{open:Date.now(),close:void 0},close:e.close,abort:e.abort};function p(f){f===!0&&(a=!0,c=!0),a&&c&&h.timeline.close==null&&(h.timeline.close=Date.now())}return h}class se extends Event{type;detail;constructor(e,t){super(e),this.type=e,this.detail=t}}let eb=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.name="AbortError",this.code=t??"ABORT_ERR"}};async function ir(r,e,t,n){const s=new eb(n?.errorMessage,n?.errorCode);return t?.aborted===!0?Promise.reject(s):new Promise((i,o)=>{function a(){t?.removeEventListener("abort",u),r.removeEventListener(e,c),n?.errorEvent!=null&&r.removeEventListener(n.errorEvent,l)}const c=d=>{try{if(n?.filter?.(d)===!1)return}catch(h){a(),o(h);return}a(),i(d)},l=d=>{a(),o(d.detail)},u=()=>{a(),o(s)};t?.addEventListener("abort",u),r.addEventListener(e,c),n?.errorEvent!=null&&r.addEventListener(n.errorEvent,l)})}function eo(r,e){let t;const n=function(){const s=function(){t=void 0,r()};clearTimeout(t),t=setTimeout(s,e)};return n.start=()=>{},n.stop=()=>{clearTimeout(t)},n}class tb extends Error{remainingPoints;msBeforeNext;consumedPoints;isFirstInDuration;constructor(e="Rate limit exceeded",t){super(e),this.name="RateLimitError",this.remainingPoints=t.remainingPoints,this.msBeforeNext=t.msBeforeNext,this.consumedPoints=t.consumedPoints,this.isFirstInDuration=t.isFirstInDuration}}class rb extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}class nb{deferred;signal;constructor(e){this.signal=e,this.deferred=de(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new Kt)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}}function sb(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class ib{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=sb(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,n)=>t&&n.signal?.aborted===!0,!0)&&(this.controller.abort(new Kt),this.cleanup())}async join(e={}){const t=new nb(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await Ye(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}}class bd extends _t{concurrency;maxSize;queue;pending;sort;constructor(e={}){super(),this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,e.metricName!=null&&e.metrics?.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})}),this.sort=e.sort,this.queue=[],this.emitEmpty=eo(this.emitEmpty.bind(this),1),this.emitIdle=eo(this.emitIdle.bind(this),1)}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if(t.status==="queued"){e=t;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new rb;const n=new ib(e,t);return this.enqueue(n),this.safeDispatchEvent("add"),this.tryToStartAnother(),n.join(t).then(s=>(this.safeDispatchEvent("completed",{detail:s}),this.safeDispatchEvent("success",{detail:{job:n,result:s}}),s)).catch(s=>{if(n.status==="queued"){for(let i=0;i<this.queue.length;i++)if(this.queue[i]===n){this.queue.splice(i,1);break}}throw this.safeDispatchEvent("error",{detail:s}),this.safeDispatchEvent("failure",{detail:{job:n,error:s}}),s})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new Kt)}),this.clear()}async onEmpty(e){this.size!==0&&await ir(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await ir(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await ir(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=dn({objectMode:!0}),n=c=>{c!=null?this.abort():this.clear(),t.end(c)},s=c=>{c.detail!=null&&t.push(c.detail)},i=c=>{n(c.detail)},o=()=>{n()},a=()=>{n(new Kt("Queue aborted"))};this.addEventListener("completed",s),this.addEventListener("error",i),this.addEventListener("idle",o),e?.signal?.addEventListener("abort",a);try{yield*t}finally{this.removeEventListener("completed",s),this.removeEventListener("error",i),this.removeEventListener("idle",o),e?.signal?.removeEventListener("abort",a),n()}}}class Xo extends bd{has(e){return this.find(e)!=null}find(e){return this.queue.find(t=>e.equals(t.options.peerId))}}class ob extends _t{peerStore;registrar;connectionManager;randomWalk;started;running;topologyId;log;discoveryController;filter;queue;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.started=!1,this.running=!1,this.peerStore=e.peerStore,this.registrar=e.registrar,this.connectionManager=e.connectionManager,this.randomWalk=e.randomWalk,this.filter=t.filter,this.discoveryController=new AbortController,this.discoveryController.signal}isStarted(){return this.started}async start(){this.topologyId=await this.registrar.register(cs,{filter:this.filter,onConnect:e=>{this.log.trace("discovered relay %p queue (length: %d, active %d)",e,this.queue?.size,this.queue?.running),this.safeDispatchEvent("relay:discover",{detail:e})}}),this.started=!0}stop(){this.topologyId!=null&&this.registrar.unregister(this.topologyId),this.discoveryController?.abort(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,this.discoveryController.signal,Promise.resolve().then(async()=>{this.log("searching peer store for relays");const e=await this.peerStore.all({filters:[n=>n.protocols.includes(cs)],orders:[()=>Math.random()<.5?1:-1,(n,s)=>{const i=pc(n),o=pc(s);return i>o?-1:o>i?1:0}]});for(const n of e)this.log.trace("found relay peer %p in peer store",n.id),this.safeDispatchEvent("relay:discover",{detail:n.id});this.log("found %d relay peers in peer store",e.length);const t=this.queue=new Xo({concurrency:5});this.log("start random walk");for await(const n of this.randomWalk.walk({signal:this.discoveryController.signal})){if(this.log.trace("found random peer %p",n.id),t.has(n.id)){this.log.trace("random peer %p was already in queue",n.id);continue}if(this.connectionManager.getConnections(n.id)?.length>0){this.log.trace("random peer %p was already connected",n.id);continue}if(!await this.connectionManager.isDialable(n.multiaddrs)){this.log.trace("random peer %p was not dialable",n.id,n.multiaddrs.map(s=>s.toString()));continue}t.queued>10&&(this.log.trace("wait for space in queue for %p",n.id),await t.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",n.id,t.size,t.running),t.add(async()=>{const s=Lt([this.discoveryController.signal,AbortSignal.timeout(5e3)]);try{await this.connectionManager.openConnection(n.id,{signal:s})}finally{s.clear()}},{peerId:n.id,signal:this.discoveryController.signal}).catch(s=>{this.log.error("error opening connection to random peer %p",n.id,s)})}this.log("stop random walk"),await t.onIdle()}).catch(e=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network",e)}))}stopDiscovery(){this.log("stop discovery"),this.running=!1,this.discoveryController?.abort()}}function pc(r){const e=r.metadata.get("last-dial-success");return e==null?0:new Date(G(e)).getTime()}class ab extends _t{connectionManager;addressManager;reservationStore;listeningAddrs;log;listenTimeout;reservationId;relay;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.connectionManager=e.connectionManager,this.addressManager=e.addressManager,this.reservationStore=e.reservationStore,this.listeningAddrs=[],this.listenTimeout=t.listenTimeout??od,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}_onRemoveRelayPeer=e=>{this.log("relay removed %p our relay %p",e.detail.relay,this.relay,this.relay?.equals(e.detail.relay)),this.relay?.equals(e.detail.relay)===!0&&(this.log("relay peer removed %p",e.detail.relay),this.listeningAddrs.forEach(t=>{this.addressManager.removeObservedAddr(t)}),this.listeningAddrs=[],this.safeDispatchEvent("listening"))};_onAddRelayPeer=e=>{const{details:t}=e.detail;t.type!=="configured"&&t.id===this.reservationId&&this.addedRelay(e.detail)};async listen(e){if(gd.exactMatch(e))this.log("searching for circuit relay servers"),this.reservationId=this.reservationStore.reserveRelay();else if(pd.exactMatch(e)){this.log("listen on specific relay server %a",e);const t=AbortSignal.timeout(this.listenTimeout),n=e.decapsulate("/p2p-circuit"),s=await this.connectionManager.openConnection(n,{signal:t});if(!this.reservationStore.hasReservation(s.remotePeer)){this.log("making reservation on peer %p",s.remotePeer);const i=await this.reservationStore.addRelay(s.remotePeer,"configured");this.addedRelay(i)}}else throw new _i(`Could not listen on p2p-circuit address "${e}"`)}getAddrs(){return[...this.listeningAddrs.values()].flat()}updateAnnounceAddrs(){}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask(()=>{this.safeDispatchEvent("close")})}addedRelay(e){this.log("relay peer added %p",e.relay),this.relay=e.relay,this.listeningAddrs=e.details.reservation.addrs.map(t=>Y(t).encapsulate("/p2p-circuit")),this.listeningAddrs.forEach(t=>{this.addressManager.confirmObservedAddr(t,{type:"transport"})}),queueMicrotask(()=>{this.safeDispatchEvent("listening")})}}function cb(r){return new ab(r)}const lb="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";let ub=(r=21)=>{let e="",t=crypto.getRandomValues(new Uint8Array(r|=0));for(;r--;)e+=lb[t[r]&63];return e};const db=60*1e3*10,hb=60*1e3*5,fb=30*1e3;class pb extends _t{peerId;connectionManager;peerStore;events;reserveQueue;reservations;pendingReservations;maxReservationQueueLength;reservationCompletionTimeout;started;log;relayFilter;constructor(e,t){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.reservations=new Ms,this.pendingReservations=[],this.maxReservationQueueLength=t?.maxReservationQueueLength??Tw,this.reservationCompletionTimeout=t?.reservationCompletionTimeout??od,this.started=!1,this.relayFilter=Jr(100),this.reserveQueue=new Xo({concurrency:t?.reservationConcurrency??Iw,metricName:"libp2p_relay_reservation_queue",metrics:e.metrics}),this.events.addEventListener("connection:close",n=>{[...this.reservations.values()].find(i=>i.connection===n.detail.id)!=null&&this.#t(n.detail.remotePeer).catch(i=>{this.log("could not remove relay %p - %e",n.detail,i)})})}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>t.tags.has(In)]});this.log("removing tag from %d old relays",e.length),await Promise.all(e.map(async t=>{await this.peerStore.merge(t.id,{tags:{[In]:void 0}})})),this.log("redialing %d old relays",e.length),await Promise.all(e.map(async t=>this.addRelay(t.id,"discovered"))),this.#r()}).catch(e=>{this.log.error(e)})}stop(){this.reserveQueue.clear(),this.reservations.forEach(({timeout:e})=>{clearTimeout(e)}),this.reservations.clear(),this.started=!1}reserveRelay(){const e=ub();return this.pendingReservations.push(e),this.#r(),e}async addRelay(e,t){if(this.peerId.equals(e))throw this.log.trace("not trying to use self as relay"),new _i("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new Kw("The reservation queue is full");const n=this.reserveQueue.find(e);if(n!=null)return this.log.trace("potential relay peer %p is already in the reservation queue",e),n.join();if(this.relayFilter.has(e.toMultihash().bytes))throw new _i("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",e),this.reserveQueue.add(async()=>{const s=Date.now();try{const i=this.reservations.get(e);if(i!=null){const f=this.connectionManager.getConnections(e);let g=!1;if(f.length===0&&this.log("already have relay reservation with %p but we are no longer connected",e),f.map(m=>m.id).includes(i.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",e),g=!0),g&&uc(i.reservation.expire)>db)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",e),{relay:e,details:i};await this.#t(e)}if(t==="discovered"&&this.pendingReservations.length===0)throw new lc("Not making reservation on discovered relay because we do not need any more relays");const o=AbortSignal.timeout(this.reservationCompletionTimeout);const a=await this.connectionManager.openConnection(e,{signal:o});if(Zr.matches(a.remoteAddr))throw new zw("not creating reservation over relayed connection");const c=await this.#e(a,{signal:o}),l=uc(c.expire);this.log("created reservation on relay peer %p, expiry date is %s",e,new Date(Date.now()+l).toString());const u=Math.min(Math.max(l-hb,fb),Math.pow(2,31)-1),d=setTimeout(()=>{this.log("refresh reservation to relay %p",e),this.addRelay(e,t).catch(async f=>{this.log.error("could not refresh reservation to relay %p - %e",e,f),await this.#t(e)}).catch(f=>{this.log.error("could not remove expired reservation to relay %p - %e",e,f)})},u);let h;if(t==="discovered"){const f=this.pendingReservations.pop();if(f==null)throw new lc("Made reservation on relay but did not need any more discovered relays");h={timeout:d,reservation:c,type:t,connection:a.id,id:f}}else h={timeout:d,reservation:c,type:t,connection:a.id};this.reservations.set(e,h),await this.peerStore.merge(e,{tags:{[In]:{value:1,ttl:l}}}),this.#r();const p={relay:e,details:h};return this.safeDispatchEvent("relay:created-reservation",{detail:p}),p}catch(i){throw t==="discovered"&&i.name==="HadEnoughRelaysError"||this.log.error("could not reserve slot on %p after %dms - %e",e,Date.now()-s,i),(i.name==="DialError"||i.name==="UnsupportedProtocolError")&&this.relayFilter.add(e.toMultihash().bytes),this.#t(e).catch(o=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",e,o)}),i}},{peerId:e})}hasReservation(e){return this.reservations.has(e)}getReservation(e){return this.reservations.get(e)?.reservation}reservationCount(e){return e==null?this.reservations.size:[...this.reservations.values()].reduce((t,n)=>(n.type===e&&t++,t),0)}cancelReservations(){[...this.reservations.values()].forEach(e=>{clearTimeout(e.timeout)}),this.reservations.clear()}async#e(e,t){t.signal?.throwIfAborted(),this.log("requesting reservation from %p",e.remotePeer);const n=await e.newStream(cs,t),i=vt(n).pb(pr);this.log.trace("send RESERVE to %p",e.remotePeer),await i.write({type:pr.Type.RESERVE},t);let o;try{this.log.trace("reading response from %p",e.remotePeer),o=await i.read(t)}catch(c){throw n.abort(c),c}finally{n.status!=="closed"&&await n.close(t)}if(this.log.trace("read response %o",o),o.status===Me.OK&&o.reservation!=null){const c=new Set;c.add(e.remoteAddr.toString());for(const l of o.reservation.addrs){let u=Y(l);u.getPeerId()==null&&(u=u.encapsulate(`/p2p/${e.remotePeer}`)),u=Y(u.toString().replace(`/p2p/${e.remotePeer}/p2p/${e.remotePeer}`,`/p2p/${e.remotePeer}`)),c.add(u.toString())}return o.reservation.addrs=[...c].map(l=>Y(l).bytes),o.reservation}const a=`reservation failed with status ${o.status??"undefined"}`;throw this.log.error(a),new Error(a)}async#t(e){const t=this.reservations.get(e);t!=null&&(this.log("removing relay reservation with %p from local store",e),clearTimeout(t.timeout),this.reservations.delete(e),t.type==="discovered"&&this.pendingReservations.push(t.id),await this.peerStore.merge(e,{tags:{[In]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:e,details:t}}),this.#r())}#r(){if(this.pendingReservations.length===0){this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),this.safeDispatchEvent("relay:found-enough-relays");return}this.relayFilter=Jr(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")}}const gb=r=>{if(r.peer==null)return!1;try{r.peer.addrs.forEach(Y)}catch{return!1}return!0},gc={maxInboundStopStreams:sc,maxOutboundStopStreams:sc};class mb{discovery;registrar;peerStore;connectionManager;transportManager;peerId;upgrader;addressManager;connectionGater;reservationStore;logger;maxInboundStopStreams;maxOutboundStopStreams;started;log;shutdownController;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:circuit-relay:transport"),this.registrar=e.registrar,this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.transportManager=e.transportManager,this.logger=e.logger,this.peerId=e.peerId,this.upgrader=e.upgrader,this.addressManager=e.addressManager,this.connectionGater=e.connectionGater,this.maxInboundStopStreams=t.maxInboundStopStreams??gc.maxInboundStopStreams,this.maxOutboundStopStreams=t.maxOutboundStopStreams??gc.maxOutboundStopStreams,this.shutdownController=new AbortController,this.discovery=new ob(e,{filter:t.discoveryFilter??Jw(Pw,kw)}),this.discovery.addEventListener("relay:discover",n=>{this.reservationStore.addRelay(n.detail,"discovered").catch(s=>{s.name!=="HadEnoughRelaysError"&&s.name!=="RelayQueueFullError"&&this.log.error("could not add discovered relay %p",n.detail,s)})}),this.reservationStore=new pb(e,t),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{this.discovery?.startDiscovery()}),this.reservationStore.addEventListener("relay:found-enough-relays",()=>{this.discovery?.stopDiscovery()}),this.started=!1}[Symbol.toStringTag]="@libp2p/circuit-relay-v2-transport";[et]=["@libp2p/transport","@libp2p/circuit-relay-v2-transport"];get[zn](){return this.discovery!=null?["@libp2p/identify"]:[]}[fo]=!0;isStarted(){return this.started}async start(){this.shutdownController=new AbortController,this.shutdownController.signal,await this.registrar.handle(nc,e=>{const t=this.upgrader.createInboundAbortSignal(this.shutdownController.signal);this.onStop(e,t).catch(n=>{this.log.error("error while handling STOP protocol",n),e.stream.abort(n)}).finally(()=>{t.clear()})},{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await Al(this.discovery,this.reservationStore),this.started=!0}async stop(){this.shutdownController.abort(),await Cl(this.discovery,this.reservationStore),await this.registrar.unhandle(nc),this.started=!1}async dial(e,t){if(e.protoCodes().filter(p=>p===Cw).length!==1){const p="Invalid circuit relay address";throw this.log.error(p,e),new Or(p)}const n=e.toString().split("/p2p-circuit"),s=Y(n[0]),i=Y(n[n.length-1]),o=s.getPeerId(),a=i.getPeerId();if(o==null||a==null){const p=`ircuit relay dial to ${e.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${p}`),new Or(`C${p}`)}const c=lt(o),l=lt(a);let d=this.connectionManager.getConnections(c)[0];d==null?(await this.peerStore.merge(c,{multiaddrs:[s]}),t.onProgress?.(new se("circuit-relay:open-connection")),d=await this.connectionManager.openConnection(c,t)):t.onProgress?.(new se("circuit-relay:reuse-connection"));let h;try{t.onProgress?.(new se("circuit-relay:open-hop-stream")),h=await d.newStream(cs,t);const p=vt(h),f=p.pb(pr);t.onProgress?.(new se("circuit-relay:write-connect-message")),await f.write({type:pr.Type.CONNECT,peer:{id:l.toMultihash().bytes,addrs:[Y(i).bytes]}},t),t.onProgress?.(new se("circuit-relay:read-connect-response"));const g=await f.read(t);if(g.status!==Me.OK)throw new it(`failed to connect via relay with status ${g?.status?.toString()??"undefined"}`);const m=new dc(g.limit),v=fc({stream:p.unwrap(),remoteAddr:e,localAddr:s.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),logger:this.logger,onDataRead:m.onData,onDataWrite:m.onData});return this.log("new outbound relayed connection %a",v.remoteAddr),await this.upgrader.upgradeOutbound(v,{...t,limits:m.getLimits()})}catch(p){throw this.log.error("circuit relay dial to destination %p via relay %p failed",l,c,p),h?.abort(p),p}}createListener(e){return cb({peerId:this.peerId,connectionManager:this.connectionManager,addressManager:this.addressManager,reservationStore:this.reservationStore,logger:this.logger})}listenFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>pd.exactMatch(t)||gd.exactMatch(t))}dialFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>Zr.exactMatch(t))}async onStop({connection:e,stream:t},n){if(!this.reservationStore.hasReservation(e.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.transportManager.listen([e.remoteAddr.encapsulate("/p2p-circuit")])}catch(u){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on",u)}const s=vt(t).pb(ft),i=await s.read({signal:n});if(this.log("new circuit relay v2 stop stream from %p with type %s",e.remotePeer,i.type),i?.type===void 0){this.log.error("type was missing from circuit v2 stop protocol request from %s",e.remotePeer),await s.write({type:ft.Type.STATUS,status:Me.MALFORMED_MESSAGE},{signal:n}),await t.close();return}if(i.type!==ft.Type.CONNECT){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await s.write({type:ft.Type.STATUS,status:Me.UNEXPECTED_MESSAGE},{signal:n}),await t.close();return}if(!gb(i)){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await s.write({type:ft.Type.STATUS,status:Me.MALFORMED_MESSAGE},{signal:n}),await t.close({signal:n});return}const o=ln(Vt(i.peer.id));if(await this.connectionGater.denyInboundRelayedConnection?.(e.remotePeer,o)===!0){this.log.error("connection gater denied inbound relayed connection from %p",e.remotePeer),await s.write({type:ft.Type.STATUS,status:Me.PERMISSION_DENIED},{signal:n}),await t.close({signal:n});return}this.log.trace("sending success response to %p",e.remotePeer),await s.write({type:ft.Type.STATUS,status:Me.OK},{signal:n});const a=new dc(i.limit),c=e.remoteAddr.encapsulate(`/p2p-circuit/p2p/${o.toString()}`);this.addressManager.getAddresses()[0];const l=fc({stream:s.unwrap().unwrap(),remoteAddr:c,logger:this.logger,onDataRead:a.onData,onDataWrite:a.onData});this.log("new inbound relayed connection %a",l.remoteAddr),await this.upgrader.upgradeInbound(l,{limits:a.getLimits(),signal:n}),this.log("%s connection %a upgraded","inbound",l.remoteAddr)}}function yb(r={}){return e=>new mb(e,r)}function wb(r){return r[Symbol.asyncIterator]!=null}function to(r){if(wb(r))return(async()=>{for await(const e of r);})();for(const e of r);}const Pn=globalThis.CustomEvent??Event;async function*vd(r,e={}){let t=e.concurrency??1/0;t<1&&(t=1/0);const n=e.ordered??!1,s=new EventTarget,i=[];let o=de(),a=de(),c=!1,l,u=!1;s.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const f of r){if(i.length===t&&(o=de(),await o.promise),u)break;const g={done:!1};i.push(g),f().then(m=>{g.done=!0,g.ok=!0,g.value=m,s.dispatchEvent(new Pn("task-complete"))},m=>{g.done=!0,g.err=m,s.dispatchEvent(new Pn("task-complete"))})}c=!0,s.dispatchEvent(new Pn("task-complete"))}catch(f){l=f,s.dispatchEvent(new Pn("task-complete"))}});function d(){return n?i[0]?.done:!!i.find(f=>f.done)}function*h(){for(;i.length>0&&i[0].done;){const f=i[0];if(i.shift(),f.ok)yield f.value;else throw u=!0,o.resolve(),f.err;o.resolve()}}function*p(){for(;d();)for(let f=0;f<i.length;f++)if(i[f].done){const g=i[f];if(i.splice(f,1),f--,g.ok)yield g.value;else throw u=!0,o.resolve(),g.err;o.resolve()}}for(;;){if(d()||(a=de(),await a.promise),l!=null||(n?yield*h():yield*p(),l!=null))throw l;if(c&&i.length===0)break}}const bb="0.1.0",vb="id",Eb="id/push",Sb="1.0.0",xb="1.0.0",Ab=1024*8,Cb=32;var yr;(function(r){let e;r.codec=()=>(e==null&&(e=ge((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.protocolVersion!=null&&(n.uint32(42),n.string(t.protocolVersion)),t.agentVersion!=null&&(n.uint32(50),n.string(t.agentVersion)),t.publicKey!=null&&(n.uint32(10),n.bytes(t.publicKey)),t.listenAddrs!=null)for(const i of t.listenAddrs)n.uint32(18),n.bytes(i);if(t.observedAddr!=null&&(n.uint32(34),n.bytes(t.observedAddr)),t.protocols!=null)for(const i of t.protocols)n.uint32(26),n.string(i);t.signedPeerRecord!=null&&(n.uint32(66),n.bytes(t.signedPeerRecord)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={listenAddrs:[],protocols:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 5:{i.protocolVersion=t.string();break}case 6:{i.agentVersion=t.string();break}case 1:{i.publicKey=t.bytes();break}case 2:{if(s.limits?.listenAddrs!=null&&i.listenAddrs.length===s.limits.listenAddrs)throw new bt('Decode error - map field "listenAddrs" had too many elements');i.listenAddrs.push(t.bytes());break}case 4:{i.observedAddr=t.bytes();break}case 3:{if(s.limits?.protocols!=null&&i.protocols.length===s.limits.protocols)throw new bt('Decode error - map field "protocols" had too many elements');i.protocols.push(t.string());break}case 8:{i.signedPeerRecord=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>pe(t,r.codec()),r.decode=(t,n)=>fe(t,r.codec(),n)})(yr||(yr={}));const Ge={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:Ab,runOnConnectionOpen:!0,runOnSelfUpdate:!0,runOnLimitedConnection:!0,concurrency:Cb};function Ib(r){if(r!=null&&r.length>0)try{return Y(r)}catch{}}function Tb(r,e){return e??r.userAgent}async function Ed(r,e,t,n,s){if(t("received identify from %p",n.remotePeer),s==null)throw new it("message was null or undefined");const i={};if(s.listenAddrs.length>0&&(i.addresses=s.listenAddrs.map(c=>({isCertified:!1,multiaddr:Y(c)}))),s.protocols.length>0&&(i.protocols=s.protocols),s.publicKey!=null){const c=Dt(s.publicKey);if(!Hr(c).equals(n.remotePeer))throw new it("public key did not match remote PeerId");i.publicKey=c}let o;if(s.signedPeerRecord!=null){t.trace("received signedPeerRecord from %p",n.remotePeer);let c=s.signedPeerRecord;const l=await at.openAndCertify(c,He.DOMAIN);let u=He.createFromProtobuf(l.payload);const d=un(l.publicKey.toCID());if(!u.peerId.equals(d))throw new it("signing key does not match PeerId in the PeerRecord");if(!n.remotePeer.equals(u.peerId))throw new it("signing key does not match remote PeerId");let h;try{h=await r.get(u.peerId)}catch(p){if(p.name!=="NotFoundError")throw p}if(h!=null&&(i.metadata=h.metadata,h.peerRecordEnvelope!=null)){const p=await at.createFromProtobuf(h.peerRecordEnvelope),f=He.createFromProtobuf(p.payload);f.seqNumber>=u.seqNumber&&(t("sequence number was lower or equal to existing sequence number - stored: %d received: %d",f.seqNumber,u.seqNumber),u=f,c=h.peerRecordEnvelope)}i.peerRecordEnvelope=c,i.addresses=u.multiaddrs.map(p=>({isCertified:!0,multiaddr:p})),o={seq:u.seqNumber,addresses:u.multiaddrs}}else t("%p did not send a signed peer record",n.remotePeer);if(t.trace("patching %p with",n.remotePeer,i),await r.patch(n.remotePeer,i),s.agentVersion!=null||s.protocolVersion!=null){const c={};s.agentVersion!=null&&(c.AgentVersion=K(s.agentVersion)),s.protocolVersion!=null&&(c.ProtocolVersion=K(s.protocolVersion)),t.trace("merging %p metadata",n.remotePeer,c),await r.merge(n.remotePeer,{metadata:c})}const a={peerId:n.remotePeer,protocolVersion:s.protocolVersion,agentVersion:s.agentVersion,publicKey:s.publicKey,listenAddrs:s.listenAddrs.map(c=>Y(c)),observedAddr:s.observedAddr==null?void 0:Y(s.observedAddr),protocols:s.protocols,signedPeerRecord:o,connection:n};return e.safeDispatchEvent("peer:identify",{detail:a}),a}class Sd{host;protocol;started;timeout;peerId;privateKey;peerStore;registrar;addressManager;maxInboundStreams;maxOutboundStreams;maxMessageSize;maxObservedAddresses;events;runOnLimitedConnection;log;constructor(e,t){this.protocol=t.protocol,this.started=!1,this.peerId=e.peerId,this.privateKey=e.privateKey,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.events=e.events,this.log=t.log,this.timeout=t.timeout??Ge.timeout,this.maxInboundStreams=t.maxInboundStreams??Ge.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??Ge.maxOutboundStreams,this.maxMessageSize=t.maxMessageSize??Ge.maxMessageSize,this.maxObservedAddresses=t.maxObservedAddresses??Ge.maxObservedAddresses,this.runOnLimitedConnection=t.runOnLimitedConnection??Ge.runOnLimitedConnection,this.host={protocolVersion:`${t.protocolPrefix??Ge.protocolPrefix}/${bb}`,agentVersion:Tb(e.nodeInfo,t.agentVersion)}}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:K(this.host.agentVersion),ProtocolVersion:K(this.host.protocolVersion)}}),await this.registrar.handle(this.protocol,e=>{this.handleProtocol(e).catch(t=>{this.log.error(t)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.registrar.unhandle(this.protocol),this.started=!1}}class Pb extends Sd{connectionManager;concurrency;constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??Ge.protocolPrefix}/${Eb}/${xb}`,log:e.logger.forComponent("libp2p:identify-push")}),this.connectionManager=e.connectionManager,this.concurrency=t.concurrency??Ge.concurrency,(t.runOnSelfUpdate??Ge.runOnSelfUpdate)&&e.events.addEventListener("self:peer:update",n=>{this.push().catch(s=>{this.log.error(s)})})}[et]=["@libp2p/identify-push"];async push(){if(!this.isStarted())return;const e=this.addressManager.getAddresses().map(u=>u.decapsulateCode(V("p2p").code)),t=new He({peerId:this.peerId,multiaddrs:e}),n=await at.seal(t,this.privateKey),s=this.registrar.getProtocols(),i=await this.peerStore.get(this.peerId),o=G(i.metadata.get("AgentVersion")??K(this.host.agentVersion)),a=G(i.metadata.get("ProtocolVersion")??K(this.host.protocolVersion)),c=this;async function*l(){for(const u of c.connectionManager.getConnections())(await c.peerStore.get(u.remotePeer)).protocols.includes(c.protocol)&&(yield async()=>{let h;const p=AbortSignal.timeout(c.timeout);try{h=await u.newStream(c.protocol,{signal:p,runOnLimitedConnection:c.runOnLimitedConnection}),await vt(h,{maxDataLength:c.maxMessageSize}).pb(yr).write({listenAddrs:e.map(g=>g.bytes),signedPeerRecord:n.marshal(),protocols:s,agentVersion:o,protocolVersion:a},{signal:p}),await h.close({signal:p})}catch(f){c.log.error("could not push identify update to peer",f),h?.abort(f)}})}await to(vd(l(),{concurrency:this.concurrency}))}async handleProtocol(e){const{connection:t,stream:n}=e;try{if(this.peerId.equals(t.remotePeer))throw new Error("received push from ourselves?");const s={signal:AbortSignal.timeout(this.timeout)},o=await vt(n,{maxDataLength:this.maxMessageSize}).pb(yr).read(s);await n.close(s),await Ed(this.peerStore,this.events,this.log,t,o)}catch(s){this.log.error("received invalid message",s),n.abort(s);return}this.log.trace("handled push from %p",t.remotePeer)}}const kb=41;function _b(r){try{const[[e,t]]=r.stringTuples();if(t==null)return!1;if(e===kb)return tw("2000::/3",t)}catch{}return!1}function Os(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var Zt={},mc;function Db(){return mc||(mc=1,function(){var r,e,t,n,s,i,o,a;a=function(c){var l,u,d,h;return l=(c&255<<24)>>>24,u=(c&255<<16)>>>16,d=(c&65280)>>>8,h=c&255,[l,u,d,h].join(".")},o=function(c){var l,u,d,h,p,f;for(l=[],d=h=0;h<=3&&c.length!==0;d=++h){if(d>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}f=e(c),p=f[0],u=f[1],c=c.substring(u),l.push(p)}if(c.length!==0)throw new Error("Invalid IP");switch(l.length){case 1:if(l[0]>4294967295)throw new Error("Invalid IP");return l[0]>>>0;case 2:if(l[0]>255||l[1]>16777215)throw new Error("Invalid IP");return(l[0]<<24|l[1])>>>0;case 3:if(l[0]>255||l[1]>255||l[2]>65535)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2])>>>0;case 4:if(l[0]>255||l[1]>255||l[2]>255||l[3]>255)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2]<<8|l[3])>>>0;default:throw new Error("Invalid IP")}},t=function(c){return c.charCodeAt(0)},n=t("0"),i=t("a"),s=t("A"),e=function(c){var l,u,d,h,p;for(h=0,l=10,u="9",d=0,c.length>1&&c[d]==="0"&&(c[d+1]==="x"||c[d+1]==="X"?(d+=2,l=16):"0"<=c[d+1]&&c[d+1]<="9"&&(d++,l=8,u="7")),p=d;d<c.length;){if("0"<=c[d]&&c[d]<=u)h=h*l+(t(c[d])-n)>>>0;else if(l===16)if("a"<=c[d]&&c[d]<="f")h=h*l+(10+t(c[d])-i)>>>0;else if("A"<=c[d]&&c[d]<="F")h=h*l+(10+t(c[d])-s)>>>0;else break;else break;if(h>4294967295)throw new Error("too large");d++}if(d===p)throw new Error("empty octet");return[h,d]},r=function(){function c(l,u){var d,h,p;if(typeof l!="string")throw new Error("Missing `net' parameter");if(u||(p=l.split("/",2),l=p[0],u=p[1]),u||(u=32),typeof u=="string"&&u.indexOf(".")>-1){try{this.maskLong=o(u)}catch{throw new Error("Invalid mask: "+u)}for(d=h=32;h>=0;d=--h)if(this.maskLong===4294967295<<32-d>>>0){this.bitmask=d;break}}else if(u||u===0)this.bitmask=parseInt(u,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(l)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+l)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+u);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(l){return typeof l=="string"&&(l.indexOf("/")>0||l.split(".").length!==4)&&(l=new c(l)),l instanceof c?this.contains(l.base)&&this.contains(l.broadcast||l.last):(o(l)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(l){return l==null&&(l=1),new c(a(this.netLong+this.size*l),this.mask)},c.prototype.forEach=function(l){var u,d,h;for(h=o(this.first),d=o(this.last),u=0;h<=d;)l(a(h),h,u),u++,h++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),Zt.ip2long=o,Zt.long2ip=a,Zt.Netmask=r}.call(Zt)),Zt}var Lb=Db();const Rb=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],Mb=Rb.map(r=>new Lb.Netmask(r));function Qo(r){for(const e of Mb)if(e.contains(r))return!0;return!1}function Ob(r){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(r)}function Nb(r){const e=r.split(":");if(e.length<2)return!1;const t=e[e.length-1].padStart(4,"0"),n=e[e.length-2].padStart(4,"0"),s=`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(t.substring(0,2),16)}.${parseInt(t.substring(2),16)}`;return Qo(s)}function Fb(r){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)}function Ub(r){const e=r.split(":"),t=e[e.length-1];return Qo(t)}function Bb(r){return/^::$/.test(r)||/^::1$/.test(r)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(r)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(r)||/^ff([0-9a-fA-F]{2,2}):/i.test(r)}function Ns(r){return fr(r)?Qo(r):Ob(r)?Nb(r):Fb(r)?Ub(r):$o(r)?Bb(r):void 0}const $b=4,zb=41;function xd(r){try{const[[e]]=r.stringTuples();return e===$b||e===zb}catch{}return!1}function en(r){try{if(!xd(r))return!1;const[[,e]]=r.stringTuples();return e==null?!1:Ns(e)??!1}catch{}return!0}const Kb=41;class qb extends Sd{constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??Ge.protocolPrefix}/${vb}/${Sb}`,log:e.logger.forComponent("libp2p:identify")}),(t.runOnConnectionOpen??Ge.runOnConnectionOpen)&&e.events.addEventListener("connection:open",n=>{const s=n.detail;this.identify(s).catch(i=>{i.name!==go.name&&this.log.error("error during identify trigged by connection:open",i)})})}[et]=["@libp2p/identify"];async _identify(e,t={}){let n;if(t.signal==null){const s=AbortSignal.timeout(this.timeout);t={...t,signal:s}}try{n=await e.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const i=await vt(n,{maxDataLength:this.maxMessageSize}).pb(yr).read(t);return await n.close(t),i}catch(s){throw n?.abort(s),s}}async identify(e,t={}){const n=await this._identify(e,t),{publicKey:s,protocols:i,observedAddr:o}=n;if(s==null)throw new it("public key was missing from identify message");const a=Dt(s),c=un(a.toCID());if(!e.remotePeer.equals(c))throw new it("identified peer does not match the expected peer");if(this.peerId.equals(c))throw new it("identified peer is our own peer id?");return this.maybeAddObservedAddress(o),this.log("identify completed for peer %p and protocols %o",c,i),Ed(this.peerStore,this.events,this.log,e,n)}maybeAddObservedAddress(e){const t=Ib(e);if(t==null)return;if(this.log.trace("our observed address was %a",t),en(t)){this.log.trace("our observed address was private");return}if(t.stringTuples()[0][0]===Kb&&!_b(t)){this.log.trace("our observed address was IPv6 but not a global unicast address");return}fs.exactMatch(t)||(this.log.trace("storing the observed address"),this.addressManager.addObservedAddr(t))}async handleProtocol(e){const{connection:t,stream:n}=e,s=AbortSignal.timeout(this.timeout);try{const i=await this.peerStore.get(this.peerId),o=this.addressManager.getAddresses().map(u=>u.decapsulateCode(V("p2p").code));let a=i.peerRecordEnvelope;if(o.length>0&&a==null){const u=new He({peerId:this.peerId,multiaddrs:o});a=(await at.seal(u,this.privateKey)).marshal().subarray()}let c=t.remoteAddr.bytes;Rw.matches(t.remoteAddr)||(c=void 0),await vt(n).pb(yr).write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:yt(this.privateKey.publicKey),listenAddrs:o.map(u=>u.bytes),signedPeerRecord:a,observedAddr:c,protocols:i.protocols},{signal:s}),await n.close({signal:s})}catch(i){this.log.error("could not respond to identify request",i),n.abort(i)}}}function Wb(r={}){return e=>new qb(e,r)}function Hb(r={}){return e=>new Pb(e,r)}const li=32,Vb="1.0.0",Gb="ping",Yb="ipfs",Xb=1e4,Qb=2,jb=1;class Zb{protocol;components;started;timeout;maxInboundStreams;maxOutboundStreams;runOnLimitedConnection;log;constructor(e,t={}){this.components=e,this.log=e.logger.forComponent("libp2p:ping"),this.started=!1,this.protocol=`/${t.protocolPrefix??Yb}/${Gb}/${Vb}`,this.timeout=t.timeout??Xb,this.maxInboundStreams=t.maxInboundStreams??Qb,this.maxOutboundStreams=t.maxOutboundStreams??jb,this.runOnLimitedConnection=t.runOnLimitedConnection??!0,this.handleMessage=this.handleMessage.bind(this)}[Symbol.toStringTag]="@libp2p/ping";[et]=["@libp2p/ping"];async start(){await this.components.registrar.handle(this.protocol,this.handleMessage,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(e){this.log("incoming ping from %p",e.connection.remotePeer);const{stream:t}=e,n=Date.now(),s=es(t);let i=!1;Promise.resolve().then(async()=>{for(;;){const o=AbortSignal.timeout(this.timeout);o.addEventListener("abort",()=>{t?.abort(new mo("ping timeout"))});const a=await s.read({bytes:li,signal:o});await s.write(a,{signal:o}),i=!0}}).catch(o=>{i&&o.name==="UnexpectedEOFError"&&t.readStatus!=="ready"||(this.log.error("incoming ping from %p failed with error - %e",e.connection.remotePeer,o),t?.abort(o))}).finally(()=>{const o=Date.now()-n;this.log("incoming ping from %p complete in %dms",e.connection.remotePeer,o);const a=AbortSignal.timeout(this.timeout);t.close({signal:a}).catch(c=>{this.log.error("error closing ping stream from %p - %e",e.connection.remotePeer,c),t?.abort(c)})})}async ping(e,t={}){this.log("pinging %p",e);const n=Date.now(),s=Mo(li),i=await this.components.connectionManager.openConnection(e,t);let o;if(t.signal==null){const a=AbortSignal.timeout(this.timeout);t={...t,signal:a}}try{o=await i.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const a=es(o),[,c]=await Promise.all([a.write(s,t),a.read({...t,bytes:li})]),l=Date.now()-n;if(!De(s,c.subarray()))throw new Sh(`Received wrong ping ack after ${l}ms`);return this.log("ping %p complete in %dms",i.remotePeer,l),l}catch(a){throw this.log.error("error while pinging %p",i.remotePeer,a),o?.abort(a),a}finally{o!=null&&await o.close(t)}}}function Jb(r={}){return e=>new Zb(e,r)}var Fe;(function(r){(function(n){n.FIN="FIN",n.STOP_SENDING="STOP_SENDING",n.RESET="RESET",n.FIN_ACK="FIN_ACK"})(r.Flag||(r.Flag={}));let e;(function(n){n[n.FIN=0]="FIN",n[n.STOP_SENDING=1]="STOP_SENDING",n[n.RESET=2]="RESET",n[n.FIN_ACK=3]="FIN_ACK"})(e||(e={})),function(n){n.codec=()=>xr(e)}(r.Flag||(r.Flag={}));let t;r.codec=()=>(t==null&&(t=ge((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.flag!=null&&(s.uint32(8),r.Flag.codec().encode(n.flag,s)),n.message!=null&&(s.uint32(18),s.bytes(n.message)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.flag=r.Flag.codec().decode(n);break}case 2:{o.message=n.bytes();break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>pe(n,r.codec()),r.decode=(n,s)=>fe(n,r.codec(),s)})(Fe||(Fe={}));const e0=["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478","stun:stun.cloudflare.com:3478","stun:stun.services.mozilla.com:3478"];Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");const t0=2*1024*1024,r0=30*1e3,Ad=16*1024;function n0(r=Ad){const e=Se(r-Se(r)),t=1+Se(Object.keys(Fe.Flag).length-1),n=1,s=r-e-t-n,i=Se(s);return e+t+n+i}const s0=n0(),i0=5e3,o0=5e3,a0=3e4,Cd="/webrtc",ro="/webrtc-signaling/0.0.1";var yc=function(r,e,t){if(t||arguments.length===2)for(var n=0,s=e.length,i;n<s;n++)(i||!(n in e))&&(i||(i=Array.prototype.slice.call(e,0,n)),i[n]=e[n]);return r.concat(i||Array.prototype.slice.call(e))},c0=function(){function r(e,t,n){this.name=e,this.version=t,this.os=n,this.type="browser"}return r}(),l0=function(){function r(e){this.version=e,this.type="node",this.name="node",this.os=process.platform}return r}(),u0=function(){function r(e,t,n,s){this.name=e,this.version=t,this.os=n,this.bot=s,this.type="bot-device"}return r}(),d0=function(){function r(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return r}(),h0=function(){function r(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return r}(),f0=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,p0=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,wc=3,g0=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",f0]],bc=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function m0(r){return typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new h0:typeof navigator<"u"?w0(navigator.userAgent):v0()}function y0(r){return r!==""&&g0.reduce(function(e,t){var n=t[0],s=t[1];if(e)return e;var i=s.exec(r);return!!i&&[n,i]},!1)}function w0(r){var e=y0(r);if(!e)return null;var t=e[0],n=e[1];if(t==="searchbot")return new d0;var s=n[1]&&n[1].split(".").join("_").split("_").slice(0,3);s?s.length<wc&&(s=yc(yc([],s,!0),E0(wc-s.length),!0)):s=[];var i=s.join("."),o=b0(r),a=p0.exec(r);return a&&a[1]?new u0(t,i,o,a[1]):new c0(t,i,o)}function b0(r){for(var e=0,t=bc.length;e<t;e++){var n=bc[e],s=n[0],i=n[1],o=i.exec(r);if(o)return s}return null}function v0(){var r=typeof process<"u"&&process.version;return r?new l0(process.version.slice(1)):null}function E0(r){for(var e=[],t=0;t<r;t++)e.push("0");return e}class Id extends Error{constructor(e){super(e),this.name="TimeoutError"}}let S0=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}};const vc=r=>globalThis.DOMException===void 0?new S0(r):new DOMException(r),Ec=r=>{const e=r.reason===void 0?vc("This operation was aborted."):r.reason;return e instanceof Error?e:vc(e)};function jo(r,e){const{milliseconds:t,fallback:n,message:s,customTimers:i={setTimeout,clearTimeout}}=e;let o,a;const l=new Promise((u,d)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(e.signal){const{signal:p}=e;p.aborted&&d(Ec(p)),a=()=>{d(Ec(p))},p.addEventListener("abort",a,{once:!0})}if(t===Number.POSITIVE_INFINITY){r.then(u,d);return}const h=new Id;o=i.setTimeout.call(void 0,()=>{if(n){try{u(n())}catch(p){d(p)}return}typeof r.cancel=="function"&&r.cancel(),s===!1?u():s instanceof Error?d(s):(h.message=s??`Promise timed out after ${t} milliseconds`,d(h))},t),(async()=>{try{u(await r)}catch(p){d(p)}})()}).finally(()=>{l.clear(),a&&e.signal&&e.signal.removeEventListener("abort",a)});return l.clear=()=>{i.clearTimeout.call(void 0,o),o=void 0},l}const Sc=m0(),Td=Sc!=null&&Sc.name==="firefox",Pd=async function*(){},kd=async r=>{};function x0(r,e,t=a0,n){r.readyState==="open"&&Promise.resolve().then(async()=>{if(r.bufferedAmount>0){n.log("%s drain channel with %d buffered bytes",e,r.bufferedAmount);const s=de();let i=!1;r.bufferedAmountLowThreshold=0;const o=()=>{i||(n.log("%s drain channel closed before drain",e),s.resolve())};r.addEventListener("close",o,{once:!0}),r.addEventListener("bufferedamountlow",()=>{i=!0,r.removeEventListener("close",o),s.resolve()}),await jo(s.promise,{milliseconds:t})}}).then(async()=>{r.readyState==="open"&&r.close()}).catch(s=>{n.log.error("error closing outbound stream",s)})}async function xc(r){return r=r??{},typeof r=="function"&&(r=await r()),r.iceServers=r.iceServers??e0.map(e=>({urls:[e]})),r}class Ac{log;peerConnection;remoteAddr;timeline;metrics;source=Pd();sink=kd;constructor(e,t){this.log=e.logger.forComponent("libp2p:webrtc:maconn"),this.remoteAddr=t.remoteAddr,this.timeline=t.timeline,this.peerConnection=t.peerConnection;const n=this.peerConnection,s=n.connectionState;this.peerConnection.onconnectionstatechange=()=>{this.log.trace("peer connection state change",n.connectionState,"initial state",s),(n.connectionState==="disconnected"||n.connectionState==="failed"||n.connectionState==="closed")&&(this.timeline.close=Date.now())}}async close(e){this.log.trace("closing connection"),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({close:!0})}abort(e){this.log.error("closing connection due to error",e),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({abort:!0})}}class A0 extends Ku{channel;incomingData;maxBufferedAmount;bufferedAmountLowEventTimeout;maxMessageSize;receiveFinAck;finAckTimeout;openTimeout;closeController;constructor(e){const t=e.onEnd;switch(e.onEnd=s=>{this.log.trace('readable and writeable ends closed with status "%s"',this.status),Promise.resolve(async()=>{if(!(this.timeline.abort!=null||this.timeline.reset!==null))try{await jo(this.receiveFinAck.promise,{milliseconds:this.finAckTimeout})}catch(i){this.log.error("error receiving FIN_ACK",i)}}).then(()=>{this.incomingData.end(),t?.(s)}).catch(i=>{this.log.error("error ending stream",i)}).finally(()=>{this.channel.close()})},super(e),this.channel=e.channel,this.channel.binaryType="arraybuffer",this.incomingData=dn(),this.bufferedAmountLowEventTimeout=e.bufferedAmountLowEventTimeout??r0,this.maxBufferedAmount=e.maxBufferedAmount??t0,this.maxMessageSize=(e.maxMessageSize??Ad)-s0,this.receiveFinAck=de(),this.finAckTimeout=e.closeTimeout??i0,this.openTimeout=e.openTimeout??o0,this.closeController=new AbortController,this.channel.readyState){case"open":this.timeline.open=new Date().getTime();break;case"closed":case"closing":(this.timeline.close===void 0||this.timeline.close===0)&&(this.timeline.close=Date.now());break;case"connecting":break;default:throw this.log.error("unknown datachannel state %s",this.channel.readyState),new Pi("Unknown datachannel state")}this.channel.onopen=s=>{this.timeline.open=new Date().getTime()},this.channel.onclose=s=>{this.log.trace("received onclose event"),this.closeController.abort(),this.receiveFinAck.resolve(),this.close().catch(i=>{this.log.error("error closing stream after channel closed",i)})},this.channel.onerror=s=>{this.log.trace("received onerror event"),this.closeController.abort();const i=s.error;this.abort(i)},this.channel.onmessage=async s=>{const{data:i}=s;i===null||i.byteLength===0||this.incomingData.push(new Uint8Array(i,0,i.byteLength))};const n=this;Promise.resolve().then(async()=>{for await(const s of Jn(this.incomingData)){const i=n.processIncomingProtobuf(s);i!=null&&n.sourcePush(new j(i))}}).catch(s=>{this.log.error("error processing incoming data channel messages",s)})}sendNewStream(){}async _sendMessage(e,t=!0){if(this.channel.readyState==="closed"||this.channel.readyState==="closing")throw new Pi(`Invalid datachannel state - ${this.channel.readyState}`);if(this.channel.readyState!=="open"){const n=AbortSignal.timeout(this.openTimeout),s=Lt([this.closeController.signal,n]);try{this.log('channel state is "%s" and not "open", waiting for "open" event before sending data',this.channel.readyState),await ir(this.channel,"open",s)}finally{s.clear()}this.log('channel state is now "%s", sending data',this.channel.readyState)}if(t&&this.channel.bufferedAmount>this.maxBufferedAmount){const n=AbortSignal.timeout(this.bufferedAmountLowEventTimeout),s=Lt([this.closeController.signal,n]);try{this.log('channel buffer is %d, wait for "bufferedamountlow" event',this.channel.bufferedAmount),await ir(this.channel,"bufferedamountlow",s)}catch(i){throw n.aborted?new mo(`Timed out waiting for DataChannel buffer to clear after ${this.bufferedAmountLowEventTimeout}ms`):i}finally{s.clear()}}try{this.log.trace('sending message, channel state "%s"',this.channel.readyState),this.channel.send(e.subarray())}catch(n){this.log.error("error while sending message",n)}}async sendData(e){const t=e.byteLength;for(e=e.sublist();e.byteLength>0;){const n=Math.min(e.byteLength,this.maxMessageSize),s=e.subarray(0,n),i=Fe.encode({message:s}),o=Zn.single(i);this.log.trace("sending %d/%d bytes on channel",s.byteLength,t),await this._sendMessage(o),e.consume(n)}this.log.trace('finished sending data, channel state "%s"',this.channel.readyState)}async sendReset(){try{await this._sendFlag(Fe.Flag.RESET)}catch(e){this.log.error("failed to send reset - %e",e)}finally{this.channel.close()}}async sendCloseWrite(e){if(this.channel.readyState!=="open"){this.receiveFinAck.resolve();return}if(await this._sendFlag(Fe.Flag.FIN)){this.log.trace("awaiting FIN_ACK");try{await Ye(this.receiveFinAck.promise,e?.signal,{errorMessage:"sending close-write was aborted before FIN_ACK was received",errorName:"FinAckNotReceivedError"})}catch(n){this.log.error("failed to await FIN_ACK",n)}}else this.log.trace("sending FIN failed, not awaiting FIN_ACK");this.receiveFinAck.resolve()}async sendCloseRead(){this.channel.readyState==="open"&&await this._sendFlag(Fe.Flag.STOP_SENDING)}processIncomingProtobuf(e){const t=Fe.decode(e);if(t.flag!==void 0&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',t.flag,this.writeStatus,this.readStatus),t.flag===Fe.Flag.FIN&&(this.remoteCloseWrite(),this.log.trace("sending FIN_ACK"),this._sendFlag(Fe.Flag.FIN_ACK).catch(n=>{this.log.error("error sending FIN_ACK immediately",n)})),t.flag===Fe.Flag.RESET&&this.reset(),t.flag===Fe.Flag.STOP_SENDING&&this.remoteCloseRead(),t.flag===Fe.Flag.FIN_ACK&&(this.log.trace("received FIN_ACK"),this.receiveFinAck.resolve())),this.readStatus==="ready")return t.message}async _sendFlag(e){if(this.channel.readyState!=="open")return this.log.trace('not sending flag %s because channel is "%s" and not "open"',e.toString(),this.channel.readyState),!1;this.log.trace("sending flag %s",e.toString());const t=Fe.encode({flag:e}),n=Zn.single(t);try{return await this._sendMessage(n,!1),!0}catch(s){this.log.error("could not send flag %s - %e",e.toString(),s)}return!1}}function no(r){const{channel:e,direction:t,handshake:n}=r;return new A0({id:`${e.id}`,log:r.logger.forComponent(`libp2p:webrtc:stream:${n===!0?"handshake":t}:${e.id}`),...r})}class _d{protocol;peerConnection;bufferedStreams=[];metrics;dataChannelOptions;components;log;constructor(e,t){this.components=e,this.peerConnection=t.peerConnection,this.metrics=t.metrics,this.protocol=t.protocol??Cd,this.dataChannelOptions=t.dataChannelOptions??{},this.log=e.logger.forComponent("libp2p:webrtc:muxerfactory"),this.peerConnection.ondatachannel=({channel:n})=>{if(this.log.trace('incoming early datachannel with channel id %d and label "%s"',n.id),n.label==="init"){this.log.trace("closing early init channel"),n.close();return}const s={},i=no({channel:n,direction:"inbound",onEnd:o=>{s.onEnd(o)},logger:e.logger,...this.dataChannelOptions});s.stream=i,s.channel=n,s.onEnd=()=>{this.bufferedStreams=this.bufferedStreams.filter(o=>o.stream.id!==i.id)},this.bufferedStreams.push(s)}}createStreamMuxer(e){return new C0(this.components,{...e,peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,streams:this.bufferedStreams,protocol:this.protocol})}}class C0{init;streams;protocol;log;peerConnection;dataChannelOptions;metrics;logger;constructor(e,t){this.init=t,this.log=e.logger.forComponent("libp2p:webrtc:muxer"),this.logger=e.logger,this.streams=t.streams.map(n=>n.stream),this.peerConnection=t.peerConnection,this.protocol=t.protocol??Cd,this.metrics=t.metrics,this.dataChannelOptions=t.dataChannelOptions??{},this.peerConnection.ondatachannel=({channel:n})=>{if(this.log.trace("incoming datachannel with channel id %d",n.id),n.label==="init"){this.log.trace("closing init channel"),n.close();return}const s=n.id,i=no({channel:n,direction:"inbound",onEnd:()=>{this.#e(i,n),this.log("incoming channel %s ended",s)},logger:this.logger,...this.dataChannelOptions});this.streams.push(i),this.metrics?.increment({incoming_stream:!0}),t?.onIncomingStream?.(i)},this.init.streams.length>0&&queueMicrotask(()=>{this.init.streams.forEach(n=>{n.onEnd=()=>{this.log("incoming early channel %s ended with state %s",n.channel.id,n.channel.readyState),this.#e(n.stream,n.channel)},this.metrics?.increment({incoming_stream:!0}),this.init?.onIncomingStream?.(n.stream)})})}#e(e,t){this.log.trace("stream %s %s %s onEnd",e.direction,e.id,e.protocol),x0(t,`${e.direction} ${e.id} ${e.protocol}`,this.dataChannelOptions.drainTimeout,{log:this.log}),this.streams=this.streams.filter(n=>n.id!==e.id),this.metrics?.increment({stream_end:!0}),this.init?.onStreamEnd?.(e)}async close(e){try{await Promise.all(this.streams.map(async t=>t.close(e)))}catch(t){this.abort(t)}}abort(e){for(const t of this.streams)t.abort(e)}source=Pd();sink=kd;newStream(){const e=this.peerConnection.createDataChannel(""),t=e.id;this.log.trace("opened outgoing datachannel with channel id %s",t);const n=no({channel:e,direction:"outbound",onEnd:()=>{this.#e(n,e),this.log("outgoing channel %s ended",t)},logger:this.logger,...this.dataChannelOptions});return this.streams.push(n),this.metrics?.increment({outgoing_stream:!0}),n}}const Dd=globalThis.RTCPeerConnection,Ld=globalThis.RTCSessionDescription,I0=globalThis.RTCIceCandidate;class T0 extends Error{constructor(e){super(`WebRTC transport error: ${e}`),this.name="WebRTCTransportError"}}class It extends T0{constructor(e="SDP handshake failed"){super(e),this.name="SDPHandshakeFailedError"}}var Je;(function(r){(function(n){n.SDP_OFFER="SDP_OFFER",n.SDP_ANSWER="SDP_ANSWER",n.ICE_CANDIDATE="ICE_CANDIDATE"})(r.Type||(r.Type={}));let e;(function(n){n[n.SDP_OFFER=0]="SDP_OFFER",n[n.SDP_ANSWER=1]="SDP_ANSWER",n[n.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(e||(e={})),function(n){n.codec=()=>xr(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=ge((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.data!=null&&(s.uint32(18),s.string(n.data)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.data=n.string();break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>pe(n,r.codec()),r.decode=(n,s)=>fe(n,r.codec(),s)})(Je||(Je={}));const Rd=async(r,e,t)=>{try{const n=de();for(P0(r,n);;){const s=await Promise.race([n.promise,e.read({signal:t.signal}).catch(()=>{})]);if(s==null){t.signal?.throwIfAborted();break}if(s.type!==Je.Type.ICE_CANDIDATE)throw new it("ICE candidate message expected");const i=JSON.parse(s.data??"null");if(i===""||i===null){t.onProgress?.(new se("webrtc:end-of-ice-candidates")),t.log.trace("end-of-candidates received");continue}const o=new I0(i);t.log.trace("%s received new ICE candidate %o",t.direction,i);try{t.onProgress?.(new se("webrtc:add-ice-candidate",o.candidate)),await r.addIceCandidate(o)}catch(a){t.log.error("%s bad candidate received",t.direction,i,a)}}}catch(n){if(t.log.error("%s error parsing ICE candidate",t.direction,n),t.signal?.aborted===!0&&Zo(r)!=="connected")throw n}};function Zo(r){return Td?r.iceConnectionState:r.connectionState}function P0(r,e){r[Td?"oniceconnectionstatechange":"onconnectionstatechange"]=t=>{switch(Zo(r)){case"connected":e.resolve();break;case"failed":case"disconnected":case"closed":e.reject(new vl("RTCPeerConnection was closed"));break}}}async function k0({rtcConfiguration:r,dataChannel:e,signal:t,metrics:n,multiaddr:s,connectionManager:i,transportManager:o,log:a,logger:c,onProgress:l}){const{baseAddr:u}=L0(s);n?.dialerEvents.increment({open:!0}),a.trace("dialing base address: %a",u);const d=u.getPeerId();if(d==null)throw new W("Relay peer was missing");const h=i.getConnections(lt(d));let p,f=!1;h.length===0?(l?.(new se("webrtc:dial-relay")),p=await o.dial(u,{signal:t,onProgress:l}),f=!0):(l?.(new se("webrtc:reuse-relay-connection")),p=h[0]);try{l?.(new se("webrtc:open-signaling-stream"));const g=await p.newStream(ro,{signal:t,runOnLimitedConnection:!0}),m=vt(g).pb(Je),v=new Dd(r),P=new _d({logger:c},{peerConnection:v,dataChannelOptions:e});try{const b=v.createDataChannel("init");v.onicecandidate=({candidate:x})=>{const k=JSON.stringify(x?.toJSON()??null);a.trace("initiator sending ICE candidate %o",x),m.write({type:Je.Type.ICE_CANDIDATE,data:k},{signal:t}).catch(L=>{a.error("error sending ICE candidate",L)})},v.onicecandidateerror=x=>{a.error("initiator ICE candidate error",x)};const w=await v.createOffer().catch(x=>{throw a.error("could not execute createOffer",x),new It("Failed to set createOffer")});a.trace("initiator send SDP offer %s",w.sdp),l?.(new se("webrtc:send-sdp-offer")),await m.write({type:Je.Type.SDP_OFFER,data:w.sdp},{signal:t}),await v.setLocalDescription(w).catch(x=>{throw a.error("could not execute setLocalDescription",x),new It("Failed to set localDescription")}),l?.(new se("webrtc:read-sdp-answer")),a.trace("initiator read SDP answer");const E=await m.read({signal:t});if(E.type!==Je.Type.SDP_ANSWER)throw new It("Remote should send an SDP answer");a.trace("initiator received SDP answer %s",E.data);const _=new Ld({type:"answer",sdp:E.data});return await v.setRemoteDescription(_).catch(x=>{throw a.error("could not execute setRemoteDescription",x),new It("Failed to set remoteDescription")}),a.trace("initiator read candidates until connected"),l?.(new se("webrtc:read-ice-candidates")),await Rd(v,m,{direction:"initiator",signal:t,log:a,onProgress:l}),a.trace("initiator connected, closing init channel"),b.close(),l?.(new se("webrtc:close-signaling-stream")),a.trace("closing signaling channel"),await g.close({signal:t}),a.trace("initiator connected to remote address %s",s),{remoteAddress:s,peerConnection:v,muxerFactory:P}}catch(b){throw a.error("outgoing signaling error",b),v.close(),g.abort(b),b}finally{v.onicecandidate=null,v.onicecandidateerror=null}}finally{if(f)try{await p.close({signal:t})}catch(g){p.abort(g)}}}const Cc=ce(fd.matchers[0],X("p2p-circuit"));class Jo extends _t{transportManager;shutdownController;events;constructor(e,t){super(),this.transportManager=e.transportManager,this.events=e.events,this.shutdownController=t.shutdownController,this.onTransportListening=this.onTransportListening.bind(this)}async listen(){this.events.addEventListener("transport:listening",this.onTransportListening)}onTransportListening(e){e.detail.getAddrs().filter(n=>Cc.exactMatch(n)).map(n=>n.encapsulate("/webrtc")).length>0&&this.safeDispatchEvent("listening")}getAddrs(){return this.transportManager.getListeners().filter(e=>!(e instanceof Jo)).map(e=>e.getAddrs().filter(t=>Cc.exactMatch(t)).map(t=>t.encapsulate("/webrtc"))).flat()}updateAnnounceAddrs(){}async close(){this.events.removeEventListener("transport:listening",this.onTransportListening),this.shutdownController.abort(),queueMicrotask(()=>{this.safeDispatchEvent("close")})}}async function _0({peerConnection:r,stream:e,signal:t,connection:n,log:s}){s.trace("new inbound signaling stream");const i=vt(e).pb(Je);try{r.onicecandidate=({candidate:u})=>{const d=JSON.stringify(u?.toJSON()??null);s.trace("recipient sending ICE candidate %s",d),i.write({type:Je.Type.ICE_CANDIDATE,data:d},{signal:t}).catch(h=>{s.error("error sending ICE candidate",h)})},s.trace("recipient read SDP offer");const a=await i.read({signal:t});if(a.type!==Je.Type.SDP_OFFER)throw new It(`expected message type SDP_OFFER, received: ${a.type??"undefined"} `);s.trace("recipient received SDP offer %s",a.data);const c=new Ld({type:"offer",sdp:a.data});await r.setRemoteDescription(c).catch(u=>{throw s.error("could not execute setRemoteDescription",u),new It("Failed to set remoteDescription")});const l=await r.createAnswer().catch(u=>{throw s.error("could not execute createAnswer",u),new It("Failed to create answer")});s.trace("recipient send SDP answer %s",l.sdp),await i.write({type:Je.Type.SDP_ANSWER,data:l.sdp},{signal:t}),await r.setLocalDescription(l).catch(u=>{throw s.error("could not execute setLocalDescription",u),new It("Failed to set localDescription")}),s.trace("recipient read candidates until connected"),await Rd(r,i,{direction:"recipient",signal:t,log:s})}catch(a){if(Zo(r)!=="connected")throw s.error("error while handling signaling stream from peer %a",n.remoteAddr,a),r.close(),a;s("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",n.remoteAddr,a)}const o=Y(`/webrtc/p2p/${n.remoteAddr.getPeerId()}`);return s.trace("recipient connected to remote address %s",o),{remoteAddress:o}}class D0{components;init;log;_started=!1;metrics;shutdownController;constructor(e,t={}){this.components=e,this.init=t,this.log=e.logger.forComponent("libp2p:webrtc"),this.shutdownController=new AbortController,this.shutdownController.signal,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}[fo]=!0;[Symbol.toStringTag]="@libp2p/webrtc";[et]=["@libp2p/transport"];[zn]=["@libp2p/identify","@libp2p/circuit-relay-v2-transport"];isStarted(){return this._started}async start(){await this.components.registrar.handle(ro,e=>{const t=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);this._onProtocol(e,t).catch(n=>{this.log.error("failed to handle incoming connect from %p",e.connection.remotePeer,n)}).finally(()=>{t.clear()})},{runOnLimitedConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(ro),this._started=!1}createListener(e){return new Jo(this.components,{shutdownController:this.shutdownController})}listenFilter(e){return e.filter(Ji.exactMatch)}dialFilter(e){return this.listenFilter(e)}async dial(e,t){this.log.trace("dialing address: %a",e);const{remoteAddress:n,peerConnection:s,muxerFactory:i}=await k0({rtcConfiguration:await xc(this.init.rtcConfiguration),dataChannel:this.init.dataChannel,multiaddr:e,dataChannelOptions:this.init.dataChannel,signal:t.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager,log:this.log,logger:this.components.logger,onProgress:t.onProgress}),o=new Ac(this.components,{peerConnection:s,timeline:{open:Date.now()},remoteAddr:n,metrics:this.metrics?.dialerEvents}),a=await t.upgrader.upgradeOutbound(o,{skipProtection:!0,skipEncryption:!0,muxerFactory:i,onProgress:t.onProgress,signal:t.signal});return this._closeOnShutdown(s,o),a}async _onProtocol({connection:e,stream:t},n){const s=new Dd(await xc(this.init.rtcConfiguration)),i=new _d(this.components,{peerConnection:s,dataChannelOptions:this.init.dataChannel});try{const{remoteAddress:o}=await _0({peerConnection:s,connection:e,stream:t,signal:n,log:this.log});await t.close({signal:n});const a=new Ac(this.components,{peerConnection:s,timeline:{open:new Date().getTime()},remoteAddr:o,metrics:this.metrics?.listenerEvents});await this.components.upgrader.upgradeInbound(a,{skipEncryption:!0,skipProtection:!0,muxerFactory:i,signal:n}),this._closeOnShutdown(s,a)}catch(o){throw this.log.error("incoming signaling error",o),s.close(),t.abort(o),o}}_closeOnShutdown(e,t){const n=()=>{t.close().catch(s=>{this.log.error("could not close WebRTCMultiaddrConnection",s)})};this.shutdownController.signal.addEventListener("abort",n),e.addEventListener("close",()=>{this.shutdownController.signal.removeEventListener("abort",n)})}}function L0(r){const e=r.toString().split("/webrtc/");if(e.length!==2)throw new W("webrtc protocol was not present in multiaddr");if(!e[0].includes("/p2p-circuit"))throw new W("p2p-circuit protocol was not present in multiaddr");let t=Y(e[0]);const s=Y("/"+e[1]).getPeerId();if(s==null)throw new W("destination peer id was missing");const i=t.protos().pop();if(i===void 0)throw new W("invalid multiaddr");return i.name!=="p2p"&&(t=t.encapsulate(`/p2p/${s}`)),{baseAddr:t,peerId:lt(s)}}const ht="/",Md=new TextEncoder().encode(ht),kn=Md[0];class Re{_buf;constructor(e,t){if(typeof e=="string")this._buf=K(e);else if(e instanceof Uint8Array)this._buf=e;else throw new Error("Invalid key, should be String of Uint8Array");if(t==null&&(t=!0),t&&this.clean(),this._buf.byteLength===0||this._buf[0]!==kn)throw new Error("Invalid key")}toString(e="utf8"){return G(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new Re(e.join(ht))}static random(){return new Re(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||typeof e=="string"?new Re(e):typeof e.uint8Array=="function"?new Re(e.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=Md),this._buf[0]!==kn){const e=new Uint8Array(this._buf.byteLength+1);e.fill(kn,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===kn;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),n=e.list();for(let s=0;s<t.length;s++){if(n.length<s+1)return!1;const i=t[s],o=n[s];if(i<o)return!0;if(i>o)return!1}return t.length<n.length}reverse(){return Re.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(ht).slice(1)}type(){return R0(this.baseNamespace())}name(){return M0(this.baseNamespace())}instance(e){return new Re(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(ht)||(e+=ht),e+=this.type(),new Re(e)}parent(){const e=this.list();return e.length===1?new Re(ht):new Re(e.slice(0,-1).join(ht))}child(e){return this.toString()===ht?e:e.toString()===ht?this:new Re(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()===this.toString()?!1:e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()===this.toString()?!1:this.toString().startsWith(e.toString())}isTopLevel(){return this.list().length===1}concat(...e){return Re.withNamespaces([...this.namespaces(),...O0(e.map(t=>t.namespaces()))])}}function R0(r){const e=r.split(":");return e.length<2?"":e.slice(0,-1).join(":")}function M0(r){const e=r.split(":");return e[e.length-1]}function O0(r){return[].concat(...r)}function N0(r){return e=>new D0(e,r)}const F0=[V("tcp").code,V("dns").code,V("dnsaddr").code,V("dns4").code,V("dns6").code];function Ic(r){return Od("sni",r)?.[1]}function Tc(r){const e=Od("tcp",r)?.[1];return e==null?"":`:${e}`}function Od(r,e){let t;try{t=V(r).code}catch{return}for(const[n,s]of e)if(n===t&&s!=null)return[n,s]}function Pc(r){return r.some(([e,t])=>e===V("tls").code)}function je(r,e,t){const n=Nd[V(r).name];if(n==null)throw new Error(`Can't interpret protocol ${V(r).name}`);const s=n(e,t);return r===V("ip6").code?`[${s}]`:s}const Nd={ip4:(r,e)=>r,ip6:(r,e)=>e.length===0?r:`[${r}]`,tcp:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`tcp://${je(t[0],t[1]??"",e)}:${r}`},udp:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`udp://${je(t[0],t[1]??"",e)}:${r}`},dnsaddr:(r,e)=>r,dns4:(r,e)=>r,dns6:(r,e)=>r,dns:(r,e)=>r,ipfs:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${je(t[0],t[1]??"",e)}`},p2p:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${je(t[0],t[1]??"",e)}`},http:(r,e)=>{const t=Pc(e),n=Ic(e),s=Tc(e);if(t&&n!=null)return`https://${n}${s}`;const i=t?"https://":"http://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=je(o[0],o[1]??"",e);return a=a.replace("tcp://",""),`${i}${a}`},"http-path":(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");const n=je(t[0],t[1]??"",e),s=decodeURIComponent(r);return`${n}/${s}`},tls:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return je(t[0],t[1]??"",e)},sni:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return je(t[0],t[1]??"",e)},https:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let n=je(t[0],t[1]??"",e);return n=n.replace("tcp://",""),`https://${n}`},ws:(r,e)=>{const t=Pc(e),n=Ic(e),s=Tc(e);if(t&&n!=null)return`wss://${n}${s}`;const i=t?"wss://":"ws://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=je(o[0],o[1]??"",e);return a=a.replace("tcp://",""),`${i}${a}`},wss:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let n=je(t[0],t[1]??"",e);return n=n.replace("tcp://",""),`wss://${n}`}};function U0(r,e){const n=Y(r).stringTuples(),s=n.pop();if(s==null)throw new Error("Unexpected end of multiaddr");const i=V(s[0]),o=Nd[i.name];if(o==null)throw new Error(`No interpreter found for ${i.name}`);let a=o(s[1]??"",n);return F0.includes(s[0])&&(a=a.replace(/^.*:\/\//,""),s[1]==="443"?a=`https://${a}`:a=`http://${a}`),(a.startsWith("http://")||a.startsWith("https://")||a.startsWith("ws://")||a.startsWith("wss://"))&&(a=new URL(a).toString(),a.endsWith("/")&&(a=a.substring(0,a.length-1))),a}const B0=async r=>{if(r.readyState>=2)throw new Error("socket closed");r.readyState!==1&&await new Promise((e,t)=>{function n(){r.removeEventListener("open",s),r.removeEventListener("error",i)}function s(){n(),e()}function i(o){n(),t(o.error??new Error(`connect ECONNREFUSED ${r.url}`))}r.addEventListener("open",s),r.addEventListener("error",i)})},$0=(r,e)=>(e=e??{},e.closeOnEnd=e.closeOnEnd!==!1,async n=>{for await(const s of n){try{await B0(r)}catch(i){if(i.message==="socket closed")break;throw i}if(r.readyState===r.CLOSING||r.readyState===r.CLOSED)break;r.send(s)}e.closeOnEnd!=null&&r.readyState<=1&&await new Promise((s,i)=>{r.addEventListener("close",o=>{if(o.wasClean||o.code===1006)s();else{const a=Object.assign(new Error("ws error"),{event:o});i(a)}}),setTimeout(()=>{r.close()})})});var Jt={},Lr={},kc;function z0(){if(kc)return Lr;kc=1,Object.defineProperty(Lr,"__esModule",{value:!0});class r{constructor(){this.pullQueue=[],this.pushQueue=[],this.eventHandlers={},this.isPaused=!1,this.isStopped=!1}push(n){if(this.isStopped)return;const s={value:n,done:!1};if(this.pullQueue.length){const i=this.pullQueue.shift();i&&i.resolve(s)}else this.pushQueue.push(Promise.resolve(s)),this.highWaterMark!==void 0&&this.pushQueue.length>=this.highWaterMark&&!this.isPaused&&(this.isPaused=!0,this.eventHandlers.highWater?this.eventHandlers.highWater():console&&console.warn(`EventIterator queue reached ${this.pushQueue.length} items`))}stop(){if(!this.isStopped){this.isStopped=!0,this.remove();for(const n of this.pullQueue)n.resolve({value:void 0,done:!0});this.pullQueue.length=0}}fail(n){if(!this.isStopped)if(this.isStopped=!0,this.remove(),this.pullQueue.length){for(const s of this.pullQueue)s.reject(n);this.pullQueue.length=0}else{const s=Promise.reject(n);s.catch(()=>{}),this.pushQueue.push(s)}}remove(){Promise.resolve().then(()=>{this.removeCallback&&this.removeCallback()})}[Symbol.asyncIterator](){return{next:n=>{const s=this.pushQueue.shift();return s?(this.lowWaterMark!==void 0&&this.pushQueue.length<=this.lowWaterMark&&this.isPaused&&(this.isPaused=!1,this.eventHandlers.lowWater&&this.eventHandlers.lowWater()),s):this.isStopped?Promise.resolve({value:void 0,done:!0}):new Promise((i,o)=>{this.pullQueue.push({resolve:i,reject:o})})},return:()=>(this.isStopped=!0,this.pushQueue.length=0,this.remove(),Promise.resolve({value:void 0,done:!0}))}}}class e{constructor(n,{highWaterMark:s=100,lowWaterMark:i=1}={}){const o=new r;o.highWaterMark=s,o.lowWaterMark=i,o.removeCallback=n({push:a=>o.push(a),stop:()=>o.stop(),fail:a=>o.fail(a),on:(a,c)=>{o.eventHandlers[a]=c}})||(()=>{}),this[Symbol.asyncIterator]=()=>o[Symbol.asyncIterator](),Object.freeze(this)}}return Lr.EventIterator=e,Lr.default=e,Lr}var _c;function K0(){if(_c)return Jt;_c=1,Object.defineProperty(Jt,"__esModule",{value:!0});const r=z0();Jt.EventIterator=r.EventIterator;function e(t,n,s){return new r.EventIterator(({push:i})=>(this.addEventListener(t,i,n),()=>this.removeEventListener(t,i,n)),s)}return Jt.subscribe=e,Jt.default=r.EventIterator,Jt}var q0=K0();function Dc(r){return r instanceof ArrayBuffer||r?.constructor?.name==="ArrayBuffer"&&typeof r?.byteLength=="number"}const W0=r=>{r.binaryType="arraybuffer";const e=async()=>{await new Promise((i,o)=>{if(n){i();return}if(s!=null){o(s);return}const a=u=>{r.removeEventListener("open",c),r.removeEventListener("error",l),u()},c=()=>{a(i)},l=u=>{a(()=>{o(u.error??new Error(`connect ECONNREFUSED ${r.url}`))})};r.addEventListener("open",c),r.addEventListener("error",l)})},t=async function*(){const i=new q0.EventIterator(({push:o,stop:a,fail:c})=>{const l=d=>{let h=null;typeof d.data=="string"&&(h=K(d.data)),Dc(d.data)&&(h=new Uint8Array(d.data)),d.data instanceof Uint8Array&&(h=d.data),h!=null&&o(h)},u=d=>{c(d.error??new Error("Socket error"))};return r.addEventListener("message",l),r.addEventListener("error",u),r.addEventListener("close",a),()=>{r.removeEventListener("message",l),r.removeEventListener("error",u),r.removeEventListener("close",a)}},{highWaterMark:1/0});await e();for await(const o of i)yield Dc(o)?new Uint8Array(o):o}();let n=r.readyState===1,s;return r.addEventListener("open",()=>{n=!0,s=null}),r.addEventListener("close",()=>{n=!1,s=null}),r.addEventListener("error",i=>{n||(s=i.error??new Error(`connect ECONNREFUSED ${r.url}`))}),Object.assign(t,{connected:e})},H0=(r,e)=>{e=e??{};const t=W0(r);let n=e.remoteAddress,s=e.remotePort;if(r.url!=null)try{const o=new URL(r.url);n=o.hostname,s=parseInt(o.port,10)}catch{}if(n==null||s==null)throw new Error("Remote connection did not have address and/or port");return{sink:$0(r,e),source:t,connected:async()=>{await t.connected()},close:async()=>{(r.readyState===r.CONNECTING||r.readyState===r.OPEN)&&await new Promise(o=>{r.addEventListener("close",()=>{o()}),r.close()})},destroy:()=>{r.terminate!=null?r.terminate():r.close()},remoteAddress:n,remotePort:s,socket:r}},V0=WebSocket,G0={"http:":"ws:","https:":"wss:"},Lc="ws:",Y0=(r,e)=>{if(r.startsWith("//")&&(r=`${e?.protocol??Lc}${r}`),r.startsWith("/")&&e!=null){const n=e.protocol??Lc,s=e.host,i=e.port!=null&&s?.endsWith(`:${e.port}`)!==!0?`:${e.port}`:"";r=`${n}//${s}${i}${r}`}const t=new URL(r);for(const[n,s]of Object.entries(G0))t.protocol===n&&(t.protocol=s);return t};function X0(r,e){const t=typeof window>"u"?void 0:window.location;e=e??{};const n=Y0(r,t),s=new V0(n.toString(),e.websocket);return H0(s,e)}function Fd(r){return r.filter(e=>ps.exactMatch(e)||jr.exactMatch(e))}function Q0(){throw new Error("WebSocket Servers can not be created in the browser!")}const j0=500;function Z0(r,e,t){const n=t.logger.forComponent("libp2p:websockets:maconn"),s=t.metrics,i=t.metricPrefix??"",o={log:n,async sink(a){try{await r.sink(async function*(){for await(const c of a)c instanceof Uint8Array?yield c:yield c.subarray()}())}catch(c){c.type!=="aborted"&&n.error(c)}},source:r.source,remoteAddr:e,timeline:{open:Date.now()},async close(a={}){const c=Date.now();if(a.signal==null){const u=AbortSignal.timeout(j0);a={...a,signal:u}}const l=()=>{const{host:u,port:d}=o.remoteAddr.toOptions();n("timeout closing stream to %s:%s after %dms, destroying it manually",u,d,Date.now()-c),this.abort(new Kt("Socket close timeout"))};a.signal?.addEventListener("abort",l);try{await r.close()}catch(u){n.error("error closing WebSocket gracefully",u),this.abort(u)}finally{a.signal?.removeEventListener("abort",l),o.timeline.close=Date.now()}},abort(a){const{host:c,port:l}=o.remoteAddr.toOptions();n("timeout closing stream to %s:%s due to error",c,l,a),r.destroy(),o.timeline.close=Date.now(),s?.increment({[`${i}error`]:!0})}};return r.socket.addEventListener("close",()=>{s?.increment({[`${i}close`]:!0}),o.timeline.close==null&&(o.timeline.close=Date.now())},{once:!0}),o}class J0{log;init;logger;metrics;components;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:websockets"),this.logger=e.logger,this.components=e,this.init=t,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total",{label:"event",help:"Total count of WebSockets dialer events by type"})})}[fo]=!0;[Symbol.toStringTag]="@libp2p/websockets";[et]=["@libp2p/transport"];async dial(e,t){this.log("dialing %s",e),t=t??{};const n=await this._connect(e,t),s=Z0(n,e,{logger:this.logger,metrics:this.metrics?.dialerEvents});this.log("new outbound connection %s",s.remoteAddr);const i=await t.upgrader.upgradeOutbound(s,t);return this.log("outbound connection %s upgraded",s.remoteAddr),i}async _connect(e,t){t?.signal?.throwIfAborted();const n=e.toOptions();this.log("dialing %s:%s",n.host,n.port);const s=de(),i=X0(U0(e),this.init);i.socket.addEventListener("error",()=>{const o=new vl(`Could not connect to ${e.toString()}`);this.log.error("connection error:",o),this.metrics?.dialerEvents.increment({error:!0}),s.reject(o)});try{t.onProgress?.(new se("websockets:open-connection")),await Ye(Promise.race([i.connected(),s.promise]),t.signal)}catch(o){throw t.signal?.aborted&&this.metrics?.dialerEvents.increment({abort:!0}),i.close().catch(a=>{this.log.error("error closing raw socket",a)}),o}return this.log("connected %s",e),this.metrics?.dialerEvents.increment({connect:!0}),i}createListener(e){return Q0({logger:this.logger,events:this.components.events,metrics:this.components.metrics},{...this.init,...e})}listenFilter(e){return e=Array.isArray(e)?e:[e],this.init?.filter!=null?this.init?.filter(e):Fd(e)}dialFilter(e){return this.listenFilter(e)}}function ev(r={}){return e=>new J0(e,r)}function ys(r){if(typeof r!="object"||r===null)return!1;const e=Object.getPrototypeOf(r);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in r)&&!(Symbol.iterator in r)}const{hasOwnProperty:Ud}=Object.prototype,{propertyIsEnumerable:tv}=Object,wr=(r,e,t)=>{Object.defineProperty(r,e,{value:t,writable:!0,enumerable:!0,configurable:!0})},rv=void 0,Rc={concatArrays:!1,ignoreUndefined:!1},Fs=r=>{const e=[];for(const t in r)Ud.call(r,t)&&e.push(t);if(Object.getOwnPropertySymbols){const t=Object.getOwnPropertySymbols(r);for(const n of t)tv.call(r,n)&&e.push(n)}return e};function Cr(r){return Array.isArray(r)?nv(r):ys(r)?sv(r):r}function nv(r){const e=r.slice(0,0);return Fs(r).forEach(t=>{wr(e,t,Cr(r[t]))}),e}function sv(r){const e=Object.getPrototypeOf(r)===null?Object.create(null):{};return Fs(r).forEach(t=>{wr(e,t,Cr(r[t]))}),e}const Bd=(r,e,t,n)=>(t.forEach(s=>{typeof e[s]>"u"&&n.ignoreUndefined||(s in r&&r[s]!==Object.getPrototypeOf(r)?wr(r,s,so(r[s],e[s],n)):wr(r,s,Cr(e[s])))}),r),iv=(r,e,t)=>{let n=r.slice(0,0),s=0;return[r,e].forEach(i=>{const o=[];for(let a=0;a<i.length;a++)Ud.call(i,a)&&(o.push(String(a)),i===r?wr(n,s++,i[a]):wr(n,s++,Cr(i[a])));n=Bd(n,i,Fs(i).filter(a=>!o.includes(a)),t)}),n};function so(r,e,t){return t.concatArrays&&Array.isArray(r)&&Array.isArray(e)?iv(r,e,t):!ys(e)||!ys(r)?Cr(e):Bd(r,e,Fs(e),t)}function $d(...r){const e=so(Cr(Rc),this!==rv&&this||{},Rc);let t={_:{}};for(const n of r)if(n!==void 0){if(!ys(n))throw new TypeError("`"+n+"` is not an Option Object");t=so(t,{_:n},e)}return t._}var ui={exports:{}},Mc;function ov(){return Mc||(Mc=1,function(r){var e=Object.prototype.hasOwnProperty,t="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(t=!1));function s(c,l,u){this.fn=c,this.context=l,this.once=u||!1}function i(c,l,u,d,h){if(typeof u!="function")throw new TypeError("The listener must be a function");var p=new s(u,d||c,h),f=t?t+l:l;return c._events[f]?c._events[f].fn?c._events[f]=[c._events[f],p]:c._events[f].push(p):(c._events[f]=p,c._eventsCount++),c}function o(c,l){--c._eventsCount===0?c._events=new n:delete c._events[l]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var l=[],u,d;if(this._eventsCount===0)return l;for(d in u=this._events)e.call(u,d)&&l.push(t?d.slice(1):d);return Object.getOwnPropertySymbols?l.concat(Object.getOwnPropertySymbols(u)):l},a.prototype.listeners=function(l){var u=t?t+l:l,d=this._events[u];if(!d)return[];if(d.fn)return[d.fn];for(var h=0,p=d.length,f=new Array(p);h<p;h++)f[h]=d[h].fn;return f},a.prototype.listenerCount=function(l){var u=t?t+l:l,d=this._events[u];return d?d.fn?1:d.length:0},a.prototype.emit=function(l,u,d,h,p,f){var g=t?t+l:l;if(!this._events[g])return!1;var m=this._events[g],v=arguments.length,P,b;if(m.fn){switch(m.once&&this.removeListener(l,m.fn,void 0,!0),v){case 1:return m.fn.call(m.context),!0;case 2:return m.fn.call(m.context,u),!0;case 3:return m.fn.call(m.context,u,d),!0;case 4:return m.fn.call(m.context,u,d,h),!0;case 5:return m.fn.call(m.context,u,d,h,p),!0;case 6:return m.fn.call(m.context,u,d,h,p,f),!0}for(b=1,P=new Array(v-1);b<v;b++)P[b-1]=arguments[b];m.fn.apply(m.context,P)}else{var w=m.length,E;for(b=0;b<w;b++)switch(m[b].once&&this.removeListener(l,m[b].fn,void 0,!0),v){case 1:m[b].fn.call(m[b].context);break;case 2:m[b].fn.call(m[b].context,u);break;case 3:m[b].fn.call(m[b].context,u,d);break;case 4:m[b].fn.call(m[b].context,u,d,h);break;default:if(!P)for(E=1,P=new Array(v-1);E<v;E++)P[E-1]=arguments[E];m[b].fn.apply(m[b].context,P)}}return!0},a.prototype.on=function(l,u,d){return i(this,l,u,d,!1)},a.prototype.once=function(l,u,d){return i(this,l,u,d,!0)},a.prototype.removeListener=function(l,u,d,h){var p=t?t+l:l;if(!this._events[p])return this;if(!u)return o(this,p),this;var f=this._events[p];if(f.fn)f.fn===u&&(!h||f.once)&&(!d||f.context===d)&&o(this,p);else{for(var g=0,m=[],v=f.length;g<v;g++)(f[g].fn!==u||h&&!f[g].once||d&&f[g].context!==d)&&m.push(f[g]);m.length?this._events[p]=m.length===1?m[0]:m:o(this,p)}return this},a.prototype.removeAllListeners=function(l){var u;return l?(u=t?t+l:l,this._events[u]&&o(this,u)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,r.exports=a}(ui)),ui.exports}var av=ov();const cv=Os(av);function lv(r,e,t){let n=0,s=r.length;for(;s>0;){const i=Math.trunc(s/2);let o=n+i;t(r[o],e)<=0?(n=++o,s-=i+1):s=i}return n}let uv=class{#e=[];enqueue(e,t){t={priority:0,...t};const n={priority:t.priority,id:t.id,run:e};if(this.size===0||this.#e[this.size-1].priority>=t.priority){this.#e.push(n);return}const s=lv(this.#e,n,(i,o)=>o.priority-i.priority);this.#e.splice(s,0,n)}setPriority(e,t){const n=this.#e.findIndex(i=>i.id===e);if(n===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[s]=this.#e.splice(n,1);this.enqueue(s.run,{priority:t,id:e})}dequeue(){return this.#e.shift()?.run}filter(e){return this.#e.filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return this.#e.length}};class io extends cv{#e;#t;#r=0;#a;#c;#p=0;#s;#l;#n;#g;#i=0;#u;#o;#m;#b=1n;timeout;constructor(e){if(super(),e={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:uv,...e},!(typeof e.intervalCap=="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString()??""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString()??""}\` (${typeof e.interval})`);this.#e=e.carryoverConcurrencyCount,this.#t=e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0,this.#a=e.intervalCap,this.#c=e.interval,this.#n=new e.queueClass,this.#g=e.queueClass,this.concurrency=e.concurrency,this.timeout=e.timeout,this.#m=e.throwOnTimeout===!0,this.#o=e.autoStart===!1}get#v(){return this.#t||this.#r<this.#a}get#E(){return this.#i<this.#u}#S(){this.#i--,this.#d(),this.emit("next")}#x(){this.#w(),this.#y(),this.#l=void 0}get#A(){const e=Date.now();if(this.#s===void 0){const t=this.#p-e;if(t<0)this.#r=this.#e?this.#i:0;else return this.#l===void 0&&(this.#l=setTimeout(()=>{this.#x()},t)),!0}return!1}#d(){if(this.#n.size===0)return this.#s&&clearInterval(this.#s),this.#s=void 0,this.emit("empty"),this.#i===0&&this.emit("idle"),!1;if(!this.#o){const e=!this.#A;if(this.#v&&this.#E){const t=this.#n.dequeue();return t?(this.emit("active"),t(),e&&this.#y(),!0):!1}}return!1}#y(){this.#t||this.#s!==void 0||(this.#s=setInterval(()=>{this.#w()},this.#c),this.#p=Date.now()+this.#c)}#w(){this.#r===0&&this.#i===0&&this.#s&&(clearInterval(this.#s),this.#s=void 0),this.#r=this.#e?this.#i:0,this.#h()}#h(){for(;this.#d(););}get concurrency(){return this.#u}set concurrency(e){if(!(typeof e=="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);this.#u=e,this.#h()}async#C(e){return new Promise((t,n)=>{e.addEventListener("abort",()=>{n(e.reason)},{once:!0})})}setPriority(e,t){this.#n.setPriority(e,t)}async add(e,t={}){return t.id??=(this.#b++).toString(),t={timeout:this.timeout,throwOnTimeout:this.#m,...t},new Promise((n,s)=>{this.#n.enqueue(async()=>{this.#i++,this.#r++;try{t.signal?.throwIfAborted();let i=e({signal:t.signal});t.timeout&&(i=jo(Promise.resolve(i),{milliseconds:t.timeout})),t.signal&&(i=Promise.race([i,this.#C(t.signal)]));const o=await i;n(o),this.emit("completed",o)}catch(i){if(i instanceof Id&&!t.throwOnTimeout){n();return}s(i),this.emit("error",i)}finally{this.#S()}},t),this.emit("add"),this.#d()})}async addAll(e,t){return Promise.all(e.map(async n=>this.add(n,t)))}start(){return this.#o?(this.#o=!1,this.#h(),this):this}pause(){this.#o=!0}clear(){this.#n=new this.#g}async onEmpty(){this.#n.size!==0&&await this.#f("empty")}async onSizeLessThan(e){this.#n.size<e||await this.#f("next",()=>this.#n.size<e)}async onIdle(){this.#i===0&&this.#n.size===0||await this.#f("idle")}async#f(e,t){return new Promise(n=>{const s=()=>{t&&!t()||(this.off(e,s),n())};this.on(e,s)})}get size(){return this.#n.size}sizeBy(e){return this.#n.filter(e).length}get pending(){return this.#i}get isPaused(){return this.#o}}function zd(r){const e=[Rt.A];return r==null?e:Array.isArray(r)?r.length===0?e:r:[r]}const Kd=60;function qd(r){return{Status:r.Status??0,TC:r.TC??r.flag_tc??!1,RD:r.RD??r.flag_rd??!1,RA:r.RA??r.flag_ra??!1,AD:r.AD??r.flag_ad??!1,CD:r.CD??r.flag_cd??!1,Question:(r.Question??r.questions??[]).map(e=>({name:e.name,type:Rt[e.type]})),Answer:(r.Answer??r.answers??[]).map(e=>({name:e.name,type:Rt[e.type],TTL:e.TTL??e.ttl??Kd,data:e.data instanceof Uint8Array?G(e.data):e.data}))}}const dv=4;function Oc(r,e={}){const t=new io({concurrency:e.queryConcurrency??dv});return async(n,s={})=>{const i=new URLSearchParams;i.set("name",n),zd(s.types).forEach(a=>{i.append("type",Rt[a])}),s.onProgress?.(new se("dns:query",{detail:n}));const o=await t.add(async()=>{const a=await fetch(`${r}?${i}`,{headers:{accept:"application/dns-json"},signal:s?.signal});if(a.status!==200)throw new Error(`Unexpected HTTP status: ${a.status} - ${a.statusText}`);const c=qd(await a.json());return s.onProgress?.(new se("dns:response",{detail:c})),c},{signal:s.signal});if(o==null)throw new Error("No DNS response received");return o}}function hv(){return[Oc("https://cloudflare-dns.com/dns-query"),Oc("https://dns.google/resolve")]}var di,Nc;function fv(){return Nc||(Nc=1,di=function(r){if(!r)throw Error("hashlru must have a max value, of type number, greater than 0");var e=0,t=Object.create(null),n=Object.create(null);function s(i,o){t[i]=o,e++,e>=r&&(e=0,n=t,t=Object.create(null))}return{has:function(i){return t[i]!==void 0||n[i]!==void 0},remove:function(i){t[i]!==void 0&&(t[i]=void 0),n[i]!==void 0&&(n[i]=void 0)},get:function(i){var o=t[i];if(o!==void 0)return o;if((o=n[i])!==void 0)return s(i,o),o},set:function(i,o){t[i]!==void 0?t[i]=o:s(i,o)},clear:function(){t=Object.create(null),n=Object.create(null)}}}),di}var pv=fv();const gv=Os(pv);class mv{lru;constructor(e){this.lru=gv(e)}get(e,t){let n=!0;const s=[];for(const i of t){const o=this.getAnswers(e,i);if(o.length===0){n=!1;break}s.push(...o)}if(n)return qd({answers:s})}getAnswers(e,t){const n=`${e.toLowerCase()}-${t}`,s=this.lru.get(n);if(s!=null){const i=s.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:Rt[a.type]}));return i.length===0&&this.lru.remove(n),i}return[]}add(e,t){const n=`${e.toLowerCase()}-${t.type}`,s=this.lru.get(n)??[];s.push({expires:Date.now()+(t.TTL??Kd)*1e3,value:t}),this.lru.set(n,s)}remove(e,t){const n=`${e.toLowerCase()}-${t}`;this.lru.remove(n)}clear(){this.lru.clear()}}function yv(r){return new mv(r)}const wv=1e3;class bv{resolvers;cache;constructor(e){this.resolvers={},this.cache=yv(e.cacheSize??wv),Object.entries(e.resolvers??{}).forEach(([t,n])=>{Array.isArray(n)||(n=[n]),t.endsWith(".")||(t=`${t}.`),this.resolvers[t]=n}),this.resolvers["."]==null&&(this.resolvers["."]=hv())}async query(e,t={}){const n=zd(t.types),s=t.cached!==!1?this.cache.get(e,n):void 0;if(s!=null)return t.onProgress?.(new se("dns:cache",{detail:s})),s;const i=`${e.split(".").pop()}.`,o=(this.resolvers[i]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const c of o){if(t.signal?.aborted===!0)break;try{const l=await c(e,{...t,types:n});for(const u of l.Answer)this.cache.add(e,u);return l}catch(l){a.push(l),t.onProgress?.(new se("dns:error",{detail:l}))}}throw a.length===1?a[0]:new AggregateError(a,`DNS lookup of ${e} ${n} failed`)}}var Rt;(function(r){r[r.A=1]="A",r[r.CNAME=5]="CNAME",r[r.TXT=16]="TXT",r[r.AAAA=28]="AAAA"})(Rt||(Rt={}));function vv(r={}){return new bv(r)}const Ev=32,{code:Sv}=V("dnsaddr");class xv extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}const Wd=async function(e,t={}){const n=t.maxRecursiveDepth??Ev;if(n===0)throw new xv("Max recursive depth reached");const[,s]=e.stringTuples().find(([l])=>l===Sv)??[],o=await(t?.dns??vv()).query(`_dnsaddr.${s}`,{signal:t?.signal,types:[Rt.TXT]}),a=e.getPeerId(),c=[];for(const l of o.Answer){const u=l.data.replace(/["']/g,"").trim().split("=")[1];if(u==null||a!=null&&!u.includes(a))continue;const d=Y(u);if(u.startsWith("/dnsaddr")){const h=await d.resolve({...t,maxRecursiveDepth:n-1});c.push(...h.map(p=>p.toString()))}else c.push(d.toString())}return c};var Av={};const Cv={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter:r=>r},connectionManager:{resolvers:{dnsaddr:Wd}},transportManager:{faultTolerance:$r.FATAL_ALL}};async function Iv(r){const e=$d(Cv,r);if(e.connectionProtector===null&&Av?.LIBP2P_FORCE_PNET!=null)throw new W("Private network is enforced, but no protector was provided");return e}const br=1e3,vr=br*60,Er=vr*60,Wt=Er*24,Tv=Wt*7,Pv=Wt*365.25;function Hd(r,e){try{if(typeof r=="string"&&r.length>0)return kv(r);if(typeof r=="number"&&isFinite(r))return e?.long?Dv(r):_v(r);throw new Error("Value is not a string or number.")}catch(t){const n=Lv(t)?`${t.message}. value=${JSON.stringify(r)}`:"An unknown error has occured.";throw new Error(n)}}function kv(r){if(r=String(r),r.length>100)throw new Error("Value exceeds the maximum length of 100 characters.");const e=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(r);if(!e)return NaN;const t=parseFloat(e[1]),n=(e[2]||"ms").toLowerCase();switch(n){case"years":case"year":case"yrs":case"yr":case"y":return t*Pv;case"weeks":case"week":case"w":return t*Tv;case"days":case"day":case"d":return t*Wt;case"hours":case"hour":case"hrs":case"hr":case"h":return t*Er;case"minutes":case"minute":case"mins":case"min":case"m":return t*vr;case"seconds":case"second":case"secs":case"sec":case"s":return t*br;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:throw new Error(`The unit ${n} was matched, but no matching case exists.`)}}function _v(r){const e=Math.abs(r);return e>=Wt?`${Math.round(r/Wt)}d`:e>=Er?`${Math.round(r/Er)}h`:e>=vr?`${Math.round(r/vr)}m`:e>=br?`${Math.round(r/br)}s`:`${r}ms`}function Dv(r){const e=Math.abs(r);return e>=Wt?_n(r,e,Wt,"day"):e>=Er?_n(r,e,Er,"hour"):e>=vr?_n(r,e,vr,"minute"):e>=br?_n(r,e,br,"second"):`${r} ms`}function _n(r,e,t,n){const s=e>=t*1.5;return`${Math.round(r/t)} ${n}${s?"s":""}`}function Lv(r){return typeof r=="object"&&r!==null&&"message"in r}function Rv(r){t.debug=t,t.default=t,t.coerce=c,t.disable=i,t.enable=s,t.enabled=o,t.humanize=Hd,t.destroy=l,Object.keys(r).forEach(u=>{t[u]=r[u]}),t.names=[],t.skips=[],t.formatters={};function e(u){let d=0;for(let h=0;h<u.length;h++)d=(d<<5)-d+u.charCodeAt(h),d|=0;return t.colors[Math.abs(d)%t.colors.length]}t.selectColor=e;function t(u){let d,h=null,p,f;function g(...m){if(!g.enabled)return;const v=g,P=Number(new Date),b=P-(d||P);v.diff=b,v.prev=d,v.curr=P,d=P,m[0]=t.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");let w=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,(_,x)=>{if(_==="%%")return"%";w++;const k=t.formatters[x];if(typeof k=="function"){const L=m[w];_=k.call(v,L),m.splice(w,1),w--}return _}),t.formatArgs.call(v,m),(v.log||t.log).apply(v,m)}return g.namespace=u,g.useColors=t.useColors(),g.color=t.selectColor(u),g.extend=n,g.destroy=t.destroy,Object.defineProperty(g,"enabled",{enumerable:!0,configurable:!1,get:()=>h!==null?h:(p!==t.namespaces&&(p=t.namespaces,f=t.enabled(u)),f),set:m=>{h=m}}),typeof t.init=="function"&&t.init(g),g}function n(u,d){const h=t(this.namespace+(typeof d>"u"?":":d)+u);return h.log=this.log,h}function s(u){t.save(u),t.namespaces=u,t.names=[],t.skips=[];let d;const h=(typeof u=="string"?u:"").split(/[\s,]+/),p=h.length;for(d=0;d<p;d++)h[d]&&(u=h[d].replace(/\*/g,".*?"),u[0]==="-"?t.skips.push(new RegExp("^"+u.substr(1)+"$")):t.names.push(new RegExp("^"+u+"$")))}function i(){const u=[...t.names.map(a),...t.skips.map(a).map(d=>"-"+d)].join(",");return t.enable(""),u}function o(u){if(u[u.length-1]==="*")return!0;let d,h;for(d=0,h=t.skips.length;d<h;d++)if(t.skips[d].test(u))return!1;for(d=0,h=t.names.length;d<h;d++)if(t.names[d].test(u))return!0;return!1}function a(u){return u.toString().substring(2,u.toString().length-2).replace(/\.\*\?$/,"*")}function c(u){return u instanceof Error?u.stack??u.message:u}function l(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.setupFormatters(t.formatters),t.enable(t.load()),t}var Mv={};const ws=zv(),Ov=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function Nv(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/)!=null?!1:typeof document<"u"&&document.documentElement?.style?.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/)!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/)}function Fv(r){if(r[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+r[0]+(this.useColors?"%c ":" ")+"+"+Hd(this.diff),!this.useColors)return;const e="color: "+this.color;r.splice(1,0,e,"color: inherit");let t=0,n=0;r[0].replace(/%[a-zA-Z%]/g,s=>{s!=="%%"&&(t++,s==="%c"&&(n=t))}),r.splice(n,0,e)}const Uv=console.debug??console.log??(()=>{});function Bv(r){try{r?ws?.setItem("debug",r):ws?.removeItem("debug")}catch{}}function $v(){let r;try{r=ws?.getItem("debug")}catch{}return!r&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(r=Mv.DEBUG),r}function zv(){try{return localStorage}catch{}}function Kv(r){r.j=function(e){try{return JSON.stringify(e)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}}const We=Rv({formatArgs:Fv,save:Bv,load:$v,useColors:Nv,setupFormatters:Kv,colors:Ov,storage:ws,log:Uv});We.formatters.b=r=>r==null?"undefined":me.baseEncode(r);We.formatters.t=r=>r==null?"undefined":mt.baseEncode(r);We.formatters.m=r=>r==null?"undefined":Ll.baseEncode(r);We.formatters.p=r=>r==null?"undefined":r.toString();We.formatters.c=r=>r==null?"undefined":r.toString();We.formatters.k=r=>r==null?"undefined":r.toString();We.formatters.a=r=>r==null?"undefined":r.toString();We.formatters.e=r=>r==null?"undefined":Fc(r.stack)??Fc(r.message)??r.toString();function qv(r){const e=()=>{};return e.enabled=!1,e.color="",e.diff=0,e.log=()=>{},e.namespace=r,e.destroy=()=>!0,e.extend=()=>e,e}function Vd(){return{forComponent(r){return Wv(r)}}}function Wv(r){let e=qv(`${r}:trace`);return We.enabled(`${r}:trace`)&&We.names.map(t=>t.toString()).find(t=>t.includes(":trace"))!=null&&(e=We(`${r}:trace`)),Object.assign(We(r),{error:We(`${r}:error`),trace:e})}function Fc(r){if(r!=null&&(r=r.trim(),r.length!==0))return r}function Hv(r){return r[Symbol.asyncIterator]!=null}function oo(r){if(Hv(r))return(async()=>{const t=[];for await(const n of r)t.push(n);return t})();const e=[];for(const t of r)e.push(t);return e}let Gd=class extends Error{static name="AbortError";name="AbortError";constructor(e="The operation was aborted",...t){super(e,...t)}};const kt={},Ht=r=>{r.addEventListener("message",e=>{Ht.dispatchEvent("message",r,e)}),r.port!=null&&r.port.addEventListener("message",e=>{Ht.dispatchEvent("message",r,e)})};Ht.addEventListener=(r,e)=>{kt[r]==null&&(kt[r]=[]),kt[r].push(e)};Ht.removeEventListener=(r,e)=>{kt[r]!=null&&(kt[r]=kt[r].filter(t=>t===e))};Ht.dispatchEvent=function(r,e,t){kt[r]!=null&&kt[r].forEach(n=>n(e,t))};const Uc="lock:worker:request-read",Bc="lock:worker:abort-read-request",$c="lock:worker:release-read",zc="lock:master:grant-read",Kc="lock:worker:request-write",qc="lock:worker:abort-write-request",Wc="lock:worker:release-write",Hc="lock:master:grant-write",Vv=(r=10)=>Math.random().toString().substring(2,r+2),Vc=(r,e,t,n,s,i,o)=>(a,c)=>{if(c.data==null)return;const l={type:c.data.type,name:c.data.name,identifier:c.data.identifier};c.data.type===n&&r.dispatchEvent(new MessageEvent(e,{data:{name:l.name,handler:async()=>{a.postMessage({type:o,name:l.name,identifier:l.identifier}),await new Promise(u=>{const d=h=>{if(h?.data==null)return;const p={type:h.data.type,name:h.data.name,identifier:h.data.identifier};p.type===i&&p.identifier===l.identifier&&(a.removeEventListener("message",d),u())};a.addEventListener("message",d)})}}})),l.type===s&&(a.postMessage({type:s,name:l.name,identifier:l.identifier}),r.dispatchEvent(new MessageEvent(t,{data:{name:l.name}})))},Gc=(r,e,t,n,s)=>async i=>{i?.signal?.throwIfAborted();const o=Vv();return globalThis.postMessage({type:e,identifier:o,name:r}),new Promise((a,c)=>{const l=()=>{process.send?.({type:t,identifier:o,name:r}),c(new Gd)};i?.signal?.addEventListener("abort",l,{once:!0});const u=d=>{if(d?.data==null)return;const h={type:d.data.type,identifier:d.data.identifier};h.type===n&&h.identifier===o&&(globalThis.removeEventListener("message",u),i?.signal?.removeEventListener("abort",l),a(()=>{globalThis.postMessage({type:s,identifier:o,name:r})}))};globalThis.addEventListener("message",u)})},Gv={singleProcess:!1},Yv=r=>{if(r=Object.assign({},Gv,r),!!globalThis.document||r.singleProcess){const t=new EventTarget;return Ht.addEventListener("message",Vc(t,"requestReadLock","abortReadLockRequest",Uc,Bc,$c,zc)),Ht.addEventListener("message",Vc(t,"requestWriteLock","abortWriteLockRequest",Kc,qc,Wc,Hc)),t}return{isWorker:!0,readLock:t=>Gc(t,Uc,Bc,zc,$c),writeLock:t=>Gc(t,Kc,qc,Hc,Wc)}},Mt={};let Ve;async function hi(r,e){let t,n;const s=new Promise((o,a)=>{t=o,n=a}),i=()=>{n(new Gd)};return e?.signal?.addEventListener("abort",i,{once:!0}),r.add(async()=>{await new Promise(o=>{t(()=>{e?.signal?.removeEventListener("abort",i),o()})})},{signal:e?.signal}).catch(o=>{n(o)}),s}const Xv=(r,e)=>{if(Ve.isWorker===!0)return{readLock:Ve.readLock(r,e),writeLock:Ve.writeLock(r,e)};const t=new io({concurrency:1});let n;return{async readLock(s){if(n!=null)return hi(n,s);n=new io({concurrency:e.concurrency,autoStart:!1});const i=n,o=hi(n,s);return t.add(async()=>{i.start(),await i.onIdle().then(()=>{n===i&&(n=null)})}),o},async writeLock(s){return n=null,hi(t,s)}}},Qv={name:"lock",concurrency:1/0,singleProcess:!1};function jv(r){const e=Object.assign({},Qv,r);return Ve==null&&(Ve=Yv(e),Ve.isWorker!==!0&&(Ve.addEventListener("requestReadLock",t=>{const n=t.data.name;if(Mt[n]==null)return;const s=new AbortController,i=o=>{o.data.name===n&&s.abort()};Ve.addEventListener("abortReadLockRequest",i),Mt[n].readLock({signal:s.signal}).then(async o=>t.data.handler().finally(()=>{o()})).finally(()=>{Ve.removeEventListener("abortReadLockRequest",i)})}),Ve.addEventListener("requestWriteLock",async t=>{const n=t.data.name;if(Mt[n]==null)return;const s=new AbortController,i=o=>{o.data.name===n&&s.abort()};Ve.addEventListener("abortWriteLockRequest",i),Mt[t.data.name].writeLock({signal:s.signal}).then(async o=>t.data.handler().finally(()=>{o()})).finally(()=>{Ve.removeEventListener("abortWriteLockRequest",i)})}))),Mt[e.name]==null&&(Mt[e.name]=Xv(e.name,e)),Mt[e.name]}const Zv=36e5,Jv=216e5;var Ut;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=ge((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&s.value.byteLength>0&&(i.uint32(18),i.bytes(s.value)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:"",value:ne(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.key=s.string();break}case 2:{a.value=s.bytes();break}default:{s.skipType(l&7);break}}}return a})),n),t.encode=s=>pe(s,t.codec()),t.decode=(s,i)=>fe(s,t.codec(),i)})(r.Peer$metadataEntry||(r.Peer$metadataEntry={})),function(t){let n;t.codec=()=>(n==null&&(n=ge((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&(i.uint32(18),vs.codec().encode(s.value,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:""},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.key=s.string();break}case 2:{a.value=vs.codec().decode(s,s.uint32(),{limits:o.limits?.value});break}default:{s.skipType(l&7);break}}}return a})),n),t.encode=s=>pe(s,t.codec()),t.decode=(s,i)=>fe(s,t.codec(),i)}(r.Peer$tagsEntry||(r.Peer$tagsEntry={}));let e;r.codec=()=>(e==null&&(e=ge((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.addresses!=null)for(const i of t.addresses)n.uint32(10),bs.codec().encode(i,n);if(t.protocols!=null)for(const i of t.protocols)n.uint32(18),n.string(i);if(t.publicKey!=null&&(n.uint32(34),n.bytes(t.publicKey)),t.peerRecordEnvelope!=null&&(n.uint32(42),n.bytes(t.peerRecordEnvelope)),t.metadata!=null&&t.metadata.size!==0)for(const[i,o]of t.metadata.entries())n.uint32(50),r.Peer$metadataEntry.codec().encode({key:i,value:o},n);if(t.tags!=null&&t.tags.size!==0)for(const[i,o]of t.tags.entries())n.uint32(58),r.Peer$tagsEntry.codec().encode({key:i,value:o},n);t.updated!=null&&(n.uint32(64),n.uint64Number(t.updated)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(s.limits?.addresses!=null&&i.addresses.length===s.limits.addresses)throw new bt('Decode error - map field "addresses" had too many elements');i.addresses.push(bs.codec().decode(t,t.uint32(),{limits:s.limits?.addresses$}));break}case 2:{if(s.limits?.protocols!=null&&i.protocols.length===s.limits.protocols)throw new bt('Decode error - map field "protocols" had too many elements');i.protocols.push(t.string());break}case 4:{i.publicKey=t.bytes();break}case 5:{i.peerRecordEnvelope=t.bytes();break}case 6:{if(s.limits?.metadata!=null&&i.metadata.size===s.limits.metadata)throw new Ia('Decode error - map field "metadata" had too many elements');const c=r.Peer$metadataEntry.codec().decode(t,t.uint32());i.metadata.set(c.key,c.value);break}case 7:{if(s.limits?.tags!=null&&i.tags.size===s.limits.tags)throw new Ia('Decode error - map field "tags" had too many elements');const c=r.Peer$tagsEntry.codec().decode(t,t.uint32(),{limits:{value:s.limits?.tags$value}});i.tags.set(c.key,c.value);break}case 8:{i.updated=t.uint64Number();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>pe(t,r.codec()),r.decode=(t,n)=>fe(t,r.codec(),n)})(Ut||(Ut={}));var bs;(function(r){let e;r.codec=()=>(e==null&&(e=ge((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.multiaddr!=null&&t.multiaddr.byteLength>0&&(n.uint32(10),n.bytes(t.multiaddr)),t.isCertified!=null&&(n.uint32(16),n.bool(t.isCertified)),t.observed!=null&&(n.uint32(24),n.uint64Number(t.observed)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={multiaddr:ne(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.multiaddr=t.bytes();break}case 2:{i.isCertified=t.bool();break}case 3:{i.observed=t.uint64Number();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>pe(t,r.codec()),r.decode=(t,n)=>fe(t,r.codec(),n)})(bs||(bs={}));var vs;(function(r){let e;r.codec=()=>(e==null&&(e=ge((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.value!=null&&t.value!==0&&(n.uint32(8),n.uint32(t.value)),t.expiry!=null&&(n.uint32(16),n.uint64(t.expiry)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={value:0},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.value=t.uint32();break}case 2:{i.expiry=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>pe(t,r.codec()),r.decode=(t,n)=>fe(t,r.codec(),n)})(vs||(vs={}));function eE(r,e){if(r.publicKey!=null||e.publicKey==null)return r;let t;if(r.type==="RSA"){const s=me.decode(`z${r}`);t=Vt(s)}const n=Dt(e.publicKey,t);return Hr(n)}function ao(r,e,t){const n=Ut.decode(e);return co(r,n,t)}function co(r,e,t){const n=new Map,s=BigInt(Date.now());for(const[i,o]of e.tags.entries())o.expiry!=null&&o.expiry<s||n.set(i,o);return{...e,id:eE(r,e),addresses:e.addresses.filter(({observed:i})=>i!=null&&i>Date.now()-t).map(({multiaddr:i,isCertified:o})=>({multiaddr:Y(i),isCertified:o??!1})),metadata:e.metadata,peerRecordEnvelope:e.peerRecordEnvelope??void 0,tags:n}}function tE(r,e){return rE(r.addresses,e.addresses)&&nE(r.protocols,e.protocols)&&sE(r.publicKey,e.publicKey)&&iE(r.peerRecordEnvelope,e.peerRecordEnvelope)&&oE(r.metadata,e.metadata)&&aE(r.tags,e.tags)}function rE(r,e){return Xd(r,e,(t,n)=>!(t.isCertified!==n.isCertified||!De(t.multiaddr,n.multiaddr)))}function nE(r,e){return Xd(r,e,(t,n)=>t===n)}function sE(r,e){return Yd(r,e)}function iE(r,e){return Yd(r,e)}function oE(r,e){return Qd(r,e,(t,n)=>De(t,n))}function aE(r,e){return Qd(r,e,(t,n)=>t.value===n.value&&t.expiry===n.expiry)}function Yd(r,e){return r==null&&e==null?!0:r!=null&&e!=null?De(r,e):!1}function Xd(r,e,t){if(r.length!==e.length)return!1;for(let n=0;n<r.length;n++)if(!t(r[n],e[n]))return!1;return!0}function Qd(r,e,t){if(r.size!==e.size)return!1;for(const[n,s]of r.entries()){const i=e.get(n);if(i==null||!t(s,i))return!1}return!0}const jd="/peers/";function Dn(r){if(!yl(r)||r.type==null)throw new W("Invalid PeerId");const e=r.toCID().toString();return new Re(`${jd}${e}`)}async function cE(r,e,t,n){const s=new Map;for(const i of t){if(i==null)continue;if(i.multiaddr instanceof Uint8Array&&(i.multiaddr=Y(i.multiaddr)),!ks(i.multiaddr))throw new W("Multiaddr was invalid");if(!await e(r,i.multiaddr))continue;const o=i.isCertified??!1,a=i.multiaddr.toString(),c=s.get(a);c!=null?i.isCertified=c.isCertified||o:s.set(a,{multiaddr:i.multiaddr,isCertified:o})}return[...s.values()].sort((i,o)=>i.multiaddr.toString().localeCompare(o.multiaddr.toString())).map(({isCertified:i,multiaddr:o})=>{const a=o.getPeerId();return r.equals(a)&&(o=o.decapsulate(Y(`/p2p/${r}`))),{isCertified:i,multiaddr:o.bytes}})}async function fi(r,e,t,n){if(e==null)throw new W("Invalid PeerData");if(e.publicKey!=null&&r.publicKey!=null&&!e.publicKey.equals(r.publicKey))throw new W("publicKey bytes do not match peer id publicKey bytes");const s=n.existingPeer?.peer;if(s!=null&&!r.equals(s.id))throw new W("peer id did not match existing peer id");let i=s?.addresses??[],o=new Set(s?.protocols??[]),a=s?.metadata??new Map,c=s?.tags??new Map,l=s?.peerRecordEnvelope;if(t==="patch"){if((e.multiaddrs!=null||e.addresses!=null)&&(i=[],e.multiaddrs!=null&&i.push(...e.multiaddrs.map(h=>({isCertified:!1,multiaddr:h}))),e.addresses!=null&&i.push(...e.addresses)),e.protocols!=null&&(o=new Set(e.protocols)),e.metadata!=null){const h=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);a=Ln(h,{validate:Yc})}if(e.tags!=null){const h=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags);c=Ln(h,{validate:Xc,map:Qc})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}if(t==="merge"){if(e.multiaddrs!=null&&i.push(...e.multiaddrs.map(h=>({isCertified:!1,multiaddr:h}))),e.addresses!=null&&i.push(...e.addresses),e.protocols!=null&&(o=new Set([...o,...e.protocols])),e.metadata!=null){const h=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);for(const[p,f]of h)f==null?a.delete(p):a.set(p,f);a=Ln([...a.entries()],{validate:Yc})}if(e.tags!=null){const h=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags),p=new Map(c);for(const[f,g]of h)g==null?p.delete(f):p.set(f,g);c=Ln([...p.entries()],{validate:Xc,map:Qc})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}let u;s?.id.publicKey!=null?u=yt(s.id.publicKey):e.publicKey!=null?u=yt(e.publicKey):r.publicKey!=null&&(u=yt(r.publicKey));const d={addresses:await cE(r,n.addressFilter??(async()=>!0),i,n.existingPeer?.peerPB.addresses),protocols:[...o.values()].sort((h,p)=>h.localeCompare(p)),metadata:a,tags:c,publicKey:u,peerRecordEnvelope:l};return d.addresses.forEach(h=>{h.observed=n.existingPeer?.peerPB.addresses?.find(p=>De(p.multiaddr,p.multiaddr))?.observed??Date.now()}),r.type!=="RSA"&&delete d.publicKey,d}function Ln(r,e){const t=new Map;for(const[n,s]of r)s!=null&&e.validate(n,s);for(const[n,s]of r.sort(([i],[o])=>i.localeCompare(o)))s!=null&&t.set(n,e.map?.(n,s)??s);return t}function Yc(r,e){if(typeof r!="string")throw new W("Metadata key must be a string");if(!(e instanceof Uint8Array))throw new W("Metadata value must be a Uint8Array")}function Xc(r,e){if(typeof r!="string")throw new W("Tag name must be a string");if(e.value!=null){if(parseInt(`${e.value}`,10)!==e.value)throw new W("Tag value must be an integer");if(e.value<0||e.value>100)throw new W("Tag value must be between 0-100")}if(e.ttl!=null){if(parseInt(`${e.ttl}`,10)!==e.ttl)throw new W("Tag ttl must be an integer");if(e.ttl<0)throw new W("Tag ttl must be between greater than 0")}}function Qc(r,e){let t;return e.expiry!=null&&(t=e.expiry),e.ttl!=null&&(t=BigInt(Date.now()+Number(e.ttl))),{value:e.value??0,expiry:t}}function Zd(r){const e=r.toString().split("/")[2],t=oe.parse(e,mt);return un(t)}function pi(r,e,t){const n=Zd(r);return ao(n,e,t)}function lE(r,e){return{prefix:jd,filters:(r.filters??[]).map(t=>({key:n,value:s})=>t(pi(n,s,e))),orders:(r.orders??[]).map(t=>(n,s)=>t(pi(n.key,n.value,e),pi(s.key,s.value,e)))}}class uE{peerId;datastore;lock;addressFilter;log;maxAddressAge;maxPeerAge;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.lock=jv({name:"peer-store",singleProcess:!0}),this.maxAddressAge=t.maxAddressAge??Zv,this.maxPeerAge=t.maxPeerAge??Jv}async has(e){try{return await this.load(e),!0}catch(t){if(t.name!=="NotFoundError")throw t}return!1}async delete(e){this.peerId.equals(e)||await this.datastore.delete(Dn(e))}async load(e){const t=Dn(e),n=await this.datastore.get(t),s=Ut.decode(n);if(this.#r(e,s))throw await this.datastore.delete(t),new ki;return co(e,s,this.peerId.equals(e)?1/0:this.maxAddressAge)}async save(e,t){const n=await this.#e(e),s=await fi(e,t,"patch",{addressFilter:this.addressFilter});return this.#t(e,s,n)}async patch(e,t){const n=await this.#e(e),s=await fi(e,t,"patch",{addressFilter:this.addressFilter,existingPeer:n});return this.#t(e,s,n)}async merge(e,t){const n=await this.#e(e),s=await fi(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:n});return this.#t(e,s,n)}async*all(e){for await(const{key:t,value:n}of this.datastore.query(lE(e??{},this.maxAddressAge))){const s=Zd(t);if(s.equals(this.peerId))continue;const i=Ut.decode(n);if(this.#r(s,i)){await this.datastore.delete(t);continue}yield co(s,i,this.peerId.equals(s)?1/0:this.maxAddressAge)}}async#e(e){try{const t=Dn(e),n=await this.datastore.get(t),s=Ut.decode(n);if(this.#r(e,s))throw await this.datastore.delete(t),new ki;return{peerPB:s,peer:ao(e,n,this.maxAddressAge)}}catch(t){t.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",t)}}async#t(e,t,n){t.updated=Date.now();const s=Ut.encode(t);return await this.datastore.put(Dn(e),s),{peer:ao(e,s,this.maxAddressAge),previous:n?.peer,updated:n==null||!tE(t,n.peerPB)}}#r(e,t){if(t.updated==null)return!0;if(this.peerId.equals(e))return!1;const n=t.updated<Date.now()-this.maxPeerAge,s=Date.now()-this.maxAddressAge,i=t.addresses.filter(o=>o.observed!=null&&o.observed>s);return n&&i.length===0}}class dE{store;events;peerId;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new uE(e,t)}[Symbol.toStringTag]="@libp2p/peer-store";async forEach(e,t){this.log.trace("forEach await read lock");const n=await this.store.lock.readLock();this.log.trace("forEach got read lock");try{for await(const s of this.store.all(t))e(s)}finally{this.log.trace("forEach release read lock"),n()}}async all(e){this.log.trace("all await read lock");const t=await this.store.lock.readLock();this.log.trace("all got read lock");try{return await oo(this.store.all(e))}finally{this.log.trace("all release read lock"),t()}}async delete(e){this.log.trace("delete await write lock");const t=await this.store.lock.writeLock();this.log.trace("delete got write lock");try{await this.store.delete(e)}finally{this.log.trace("delete release write lock"),t()}}async has(e){this.log.trace("has await read lock");const t=await this.store.lock.readLock();this.log.trace("has got read lock");try{return await this.store.has(e)}finally{this.log.trace("has release read lock"),t()}}async get(e){this.log.trace("get await read lock");const t=await this.store.lock.readLock();this.log.trace("get got read lock");try{return await this.store.load(e)}finally{this.log.trace("get release read lock"),t()}}async getInfo(e){const t=await this.get(e);return{id:t.id,multiaddrs:t.addresses.map(({multiaddr:n})=>n)}}async save(e,t){this.log.trace("save await write lock");const n=await this.store.lock.writeLock();this.log.trace("save got write lock");try{const s=await this.store.save(e,t);return this.#e(e,s),s.peer}finally{this.log.trace("save release write lock"),n()}}async patch(e,t){this.log.trace("patch await write lock");const n=await this.store.lock.writeLock();this.log.trace("patch got write lock");try{const s=await this.store.patch(e,t);return this.#e(e,s),s.peer}finally{this.log.trace("patch release write lock"),n()}}async merge(e,t){this.log.trace("merge await write lock");const n=await this.store.lock.writeLock();this.log.trace("merge got write lock");try{const s=await this.store.merge(e,t);return this.#e(e,s),s.peer}finally{this.log.trace("merge release write lock"),n()}}async consumePeerRecord(e,t){const n=await at.openAndCertify(e,He.DOMAIN),s=un(n.publicKey.toCID());if(t?.equals(s)===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",t,s),!1;const i=He.createFromProtobuf(n.payload);let o;try{o=await this.get(s)}catch(a){if(a.name!=="NotFoundError")throw a}if(o?.peerRecordEnvelope!=null){const a=await at.createFromProtobuf(o.peerRecordEnvelope),c=He.createFromProtobuf(a.payload);if(c.seqNumber>=i.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",c.seqNumber,i.seqNumber),!1}return await this.patch(i.peerId,{peerRecordEnvelope:e,addresses:i.multiaddrs.map(a=>({isCertified:!0,multiaddr:a}))}),!0}#e(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))}}function hE(r,e={}){return new dE(r,e)}class Es extends Error{static name="NotFoundError";static code="ERR_NOT_FOUND";name=Es.name;code=Es.code;constructor(e="Not Found"){super(e)}}function fE(r){return r[Symbol.asyncIterator]!=null}function er(r,e){let t=0;if(fE(r))return async function*(){for await(const c of r)await e(c,t++)&&(yield c)}();const n=qu(r),{value:s,done:i}=n.next();if(i===!0)return function*(){}();const o=e(s,t++);if(typeof o.then=="function")return async function*(){await o&&(yield s);for await(const c of n)await e(c,t++)&&(yield c)}();const a=e;return function*(){o===!0&&(yield s);for(const c of n)a(c,t++)&&(yield c)}()}function pE(r){return r[Symbol.asyncIterator]!=null}function jc(r,e){return pE(r)?async function*(){yield*(await oo(r)).sort(e)}():function*(){yield*oo(r).sort(e)}()}function gE(r){return r[Symbol.asyncIterator]!=null}function Zc(r,e){return gE(r)?async function*(){let t=0;if(!(e<1)){for await(const n of r)if(yield n,t++,t===e)return}}():function*(){let t=0;if(!(e<1)){for(const n of r)if(yield n,t++,t===e)return}}()}class mE{put(e,t,n){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:n,value:s}of e)await this.put(n,s,t),yield n}async*getMany(e,t={}){for await(const n of e)yield{key:n,value:await this.get(n,t)}}async*deleteMany(e,t={}){for await(const n of e)await this.delete(n,t),yield n}batch(){let e=[],t=[];return{put(n,s){e.push({key:n,value:s})},delete(n){t.push(n)},commit:async n=>{await to(this.putMany(e,n)),e=[],await to(this.deleteMany(t,n)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let n=this._all(e,t);if(e.prefix!=null){const s=e.prefix;n=er(n,i=>i.key.toString().startsWith(s))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((s,i)=>er(s,i),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((s,i)=>jc(s,i),n)),e.offset!=null){let s=0;const i=e.offset;n=er(n,()=>s++>=i)}return e.limit!=null&&(n=Zc(n,e.limit)),n}queryKeys(e,t){let n=this._allKeys(e,t);if(e.prefix!=null){const s=e.prefix;n=er(n,i=>i.toString().startsWith(s))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((s,i)=>er(s,i),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((s,i)=>jc(s,i),n)),e.offset!=null){const s=e.offset;let i=0;n=er(n,()=>i++>=s)}return e.limit!=null&&(n=Zc(n,e.limit)),n}}class yE extends mE{data;constructor(){super(),this.data=new Map}put(e,t,n){return n?.signal?.throwIfAborted(),this.data.set(e.toString(),t),e}get(e,t){t?.signal?.throwIfAborted();const n=this.data.get(e.toString());if(n==null)throw new Es;return n}has(e,t){return t?.signal?.throwIfAborted(),this.data.has(e.toString())}delete(e,t){t?.signal?.throwIfAborted(),this.data.delete(e.toString())}*_all(e,t){t?.signal?.throwIfAborted();for(const[n,s]of this.data.entries())yield{key:new Re(n),value:s},t?.signal?.throwIfAborted()}*_allKeys(e,t){t?.signal?.throwIfAborted();for(const n of this.data.keys())yield new Re(n),t?.signal?.throwIfAborted()}}const Jc=864e13,wE=448,gi=449,bE=53,vE=54,EE=55,SE=56;class xE{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=new Map}has(e){const t=this.findHost(e);for(const n of this.mappings.values())if(n.domain===t)return!0;return!1}add(e,t){t.forEach(n=>{this.log("add DNS mapping %s to %s",n,e);const s=Ns(n)===!0;this.mappings.set(n,{domain:e,verified:s,expires:s?Jc-Date.now():0,lastVerified:s?Jc-Date.now():void 0})})}remove(e){const t=this.findHost(e);let n=!1;for(const[s,i]of this.mappings.entries())i.domain===t&&(this.log("removing %s to %s DNS mapping %e",s,i.domain,new Error("where")),this.mappings.delete(s),n=n||i.verified);return n}getAll(e){const t=[];for(let n=0;n<e.length;n++){const i=e[n].multiaddr.stringTuples(),o=i[0][1];if(o!=null)for(const[a,c]of this.mappings.entries()){if(o!==a)continue;this.maybeAddSNITuple(i,c.domain)&&(e.splice(n,1),n--,t.push({multiaddr:Y(`/${i.map(u=>[V(u[0]).name,u[1]].join("/")).join("/")}`),verified:c.verified,type:"dns-mapping",expires:c.expires,lastVerified:c.lastVerified}))}}return t}maybeAddSNITuple(e,t){for(let n=0;n<e.length;n++)if(e[n][0]===wE&&e[n+1]?.[0]!==gi)return e.splice(n+1,0,[gi,t]),!0;return!1}confirm(e,t){const n=this.findHost(e);let s=!1;for(const[i,o]of this.mappings.entries())o.domain===n&&(this.log("marking %s to %s DNS mapping as verified",i,o.domain),s=o.verified,o.verified=!0,o.expires=Date.now()+t,o.lastVerified=Date.now());return s}unconfirm(e,t){const n=this.findHost(e);let s=!1;for(const[i,o]of this.mappings.entries())o.domain===n&&(this.log("removing verification of %s to %s DNS mapping",i,o.domain),s=s||o.verified,o.verified=!1,o.expires=Date.now()+t);return s}findHost(e){for(const t of e.stringTuples())if(t[0]===gi||t[0]===bE||t[0]===vE||t[0]===EE||t[0]===SE)return t[1]}}const mi=4,yi=41,wi=6,AE=273;class CE{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=new Map}has(e){const t=e.stringTuples();for(const n of this.mappings.values())for(const s of n)if(s.externalIp===t[0][1])return!0;return!1}add(e,t,n,s=t,i="tcp"){const o=`${e}-${t}-${i}`,a=this.mappings.get(o)??[],c={internalIp:e,internalPort:t,externalIp:n,externalPort:s,externalFamily:fr(n)?4:6,protocol:i,verified:!1,expires:0};a.push(c),this.mappings.set(o,a)}remove(e){const t=e.stringTuples(),n=t[0][1]??"",s=t[1][0]===wi?"tcp":"udp",i=parseInt(t[1][1]??"0");let o=!1;for(const[a,c]of this.mappings.entries()){for(let l=0;l<c.length;l++){const u=c[l];u.externalIp===n&&u.externalPort===i&&u.protocol===s&&(this.log("removing %s:%s to %s:%s %s IP mapping",u.externalIp,u.externalPort,n,i,s),o=o||u.verified,c.splice(l,1),l--)}c.length===0&&this.mappings.delete(a)}return o}getAll(e){const t=[];for(const{multiaddr:n}of e){const s=n.stringTuples();let i;if((s[0][0]===mi||s[0][0]===yi)&&s[1][0]===wi?i=`${s[0][1]}-${s[1][1]}-tcp`:(s[0][0]===mi||s[0][0]===yi)&&s[1][0]===AE&&(i=`${s[0][1]}-${s[1][1]}-udp`),i==null)continue;const o=this.mappings.get(i);if(o!=null)for(const a of o)s[0][0]=a.externalFamily===4?mi:yi,s[0][1]=a.externalIp,s[1][1]=`${a.externalPort}`,t.push({multiaddr:Y(`/${s.map(c=>[V(c[0]).name,c[1]].join("/")).join("/")}`),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return t}confirm(e,t){const s=e.stringTuples()[0][1];let i=!1;for(const o of this.mappings.values())for(const a of o)a.externalIp===s&&(this.log("marking %s to %s IP mapping as verified",a.internalIp,a.externalIp),i=a.verified,a.verified=!0,a.expires=Date.now()+t,a.lastVerified=Date.now());return i}unconfirm(e,t){const n=e.stringTuples(),s=n[0][1]??"",i=n[1][0]===wi?"tcp":"udp",o=parseInt(n[1][1]??"0");let a=!1;for(const c of this.mappings.values())for(let l=0;l<c.length;l++){const u=c[l];u.externalIp===s&&u.externalPort===o&&u.protocol===i&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",u.externalIp,u.externalPort,s,o,i),a=a||u.verified,u.verified=!1,u.expires=Date.now()+t)}return a}}const IE=4,TE=41;function PE(r){try{const[[e,t]]=r.stringTuples();if(t==null)return!1;if(e===IE)return t.startsWith("169.254.");if(e===TE)return t.toLowerCase().startsWith("fe80")}catch{}return!1}const kE={maxObservedAddresses:10};class _E{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=new Map,this.maxObservedAddresses=t.maxObservedAddresses??kE.maxObservedAddresses}has(e){return this.addresses.has(e.toString())}removePrefixed(e){for(const t of this.addresses.keys())t.toString().startsWith(e)&&this.addresses.delete(t)}add(e){this.addresses.size!==this.maxObservedAddresses&&(en(e)||PE(e)||(this.log("adding observed address %a",e),this.addresses.set(e.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([e,t])=>({multiaddr:Y(e),verified:t.verified,type:"observed",expires:t.expires,lastVerified:t.lastVerified}))}remove(e){const t=this.addresses.get(e.toString())?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(e.toString()),t}confirm(e,t){const n=e.toString(),s=this.addresses.get(n)??{verified:!1,expires:Date.now()+t,lastVerified:Date.now()},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.log("marking observed address %a as verified",n),this.addresses.set(n,s),i}}const DE=4,LE=41,RE=53,ME=54,OE=55,NE=56,FE=[DE,LE,RE,ME,OE,NE];function el(r){try{const[[e]]=r.stringTuples();return FE.includes(e)}catch{}return!1}const UE={maxObservedAddresses:10};class BE{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=new Map,this.maxObservedAddresses=t.maxObservedAddresses??UE.maxObservedAddresses}get(e,t){if(en(e))return{multiaddr:e,verified:!0,type:"transport",expires:Date.now()+t,lastVerified:Date.now()};const n=this.toKey(e);let s=this.addresses.get(n);return s==null&&(s={verified:!el(e),expires:0},this.addresses.set(n,s)),{multiaddr:e,verified:s.verified,type:"transport",expires:s.expires,lastVerified:s.lastVerified}}has(e){const t=this.toKey(e);return this.addresses.has(t)}remove(e){const t=this.toKey(e),n=this.addresses.get(t)?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(t),n}confirm(e,t){const n=this.toKey(e),s=this.addresses.get(n)??{verified:!1,expires:0,lastVerified:0},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.addresses.set(n,s),i}unconfirm(e,t){const n=this.toKey(e),s=this.addresses.get(n)??{verified:!1,expires:0},i=s.verified;return s.verified=!1,s.expires=Date.now()+t,this.addresses.set(n,s),i}toKey(e){if(el(e)){const t=e.toOptions();return`${t.host}-${t.port}-${t.transport}`}return e.toString()}}const tl=6e4,rl={addressVerificationTTL:tl*10,addressVerificationRetry:tl*5},$E=r=>r;function bi(r,e){const t=r.getPeerId();return t!=null&&lt(t).equals(e)&&(r=r.decapsulate(Y(`/p2p/${e.toString()}`))),r}class zE{log;components;listen;announce;appendAnnounce;announceFilter;observed;dnsMappings;ipMappings;transportAddresses;observedAddressFilter;addressVerificationTTL;addressVerificationRetry;constructor(e,t={}){const{listen:n=[],announce:s=[],appendAnnounce:i=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=n.map(o=>o.toString()),this.announce=new Set(s.map(o=>o.toString())),this.appendAnnounce=new Set(i.map(o=>o.toString())),this.observed=new _E(e,t),this.dnsMappings=new xE(e,t),this.ipMappings=new CE(e,t),this.transportAddresses=new BE(e,t),this.announceFilter=t.announceFilter??$E,this.observedAddressFilter=Jr(1024),this.addressVerificationTTL=t.addressVerificationTTL??rl.addressVerificationTTL,this.addressVerificationRetry=t.addressVerificationRetry??rl.addressVerificationRetry,this._updatePeerStoreAddresses=eo(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),e.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}[Symbol.toStringTag]="@libp2p/address-manager";_updatePeerStoreAddresses(){const e=this.getAddresses().map(t=>t.getPeerId()===this.components.peerId.toString()?t.decapsulate(`/p2p/${this.components.peerId.toString()}`):t);this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch(t=>{this.log.error("error updating addresses",t)})}getListenAddrs(){return Array.from(this.listen).map(e=>Y(e))}getAnnounceAddrs(){return Array.from(this.announce).map(e=>Y(e))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(e=>Y(e))}getObservedAddrs(){return this.observed.getAll().map(e=>e.multiaddr)}addObservedAddr(e){const t=e.stringTuples(),n=`${t[0][1]}:${t[1][1]}`;this.observedAddressFilter.has(n)||(this.observedAddressFilter.add(n),e=bi(e,this.components.peerId),!this.ipMappings.has(e)&&(this.dnsMappings.has(e)||this.observed.add(e)))}confirmObservedAddr(e,t){e=bi(e,this.components.peerId);let n=!0;(t?.type==="transport"||this.transportAddresses.has(e))&&!this.transportAddresses.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="dns-mapping"||this.dnsMappings.has(e))&&!this.dnsMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="ip-mapping"||this.ipMappings.has(e))&&!this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="observed"||this.observed.has(e))&&(this.maybeUpgradeToIPMapping(e)?(this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL),n=!1):!this.observed.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1)),n||this._updatePeerStoreAddresses()}removeObservedAddr(e,t){e=bi(e,this.components.peerId),this.observed.has(e)&&this.observed.remove(e),this.transportAddresses.has(e)&&this.transportAddresses.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.dnsMappings.has(e)&&this.dnsMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.ipMappings.has(e)&&this.ipMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry)}getAddresses(){const e=new Set,t=this.getAddressesWithMetadata().filter(n=>{if(!n.verified)return!1;const s=n.multiaddr.toString();return e.has(s)?!1:(e.add(s),!0)}).map(n=>n.multiaddr);return this.announceFilter(t.map(n=>{const s=Y(n);return s.protos().pop()?.path===!0||s.getPeerId()===this.components.peerId.toString()?s:s.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const e=this.getAnnounceAddrs();if(e.length>0)return this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(e)}),e.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let t=[];t=t.concat(this.components.transportManager.getAddrs().map(s=>this.transportAddresses.get(s,this.addressVerificationTTL)));const n=this.getAppendAnnounceAddrs();return n.length>0&&(this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(n)}),t=t.concat(n.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),t=t.concat(this.observed.getAll()),t=t.concat(this.ipMappings.getAll(t)),t=t.concat(this.dnsMappings.getAll(t)),t}addDNSMapping(e,t){this.dnsMappings.add(e,t)}removeDNSMapping(e){this.dnsMappings.remove(Y(`/dns/${e}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(e,t,n,s=t,i="tcp"){this.ipMappings.add(e,t,n,s,i),this.observed.removePrefixed(`/ip${fr(n)?4:6}/${n}/${i}/${s}`)}removePublicAddressMapping(e,t,n,s=t,i="tcp"){this.ipMappings.remove(Y(`/ip${fr(n)?4:6}/${n}/${i}/${s}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(e){if(this.ipMappings.has(e))return!1;const t=e.toOptions();if(t.family===6||t.host==="127.0.0.1"||Ns(t.host)===!0)return!1;const n=this.components.transportManager.getListeners(),s=[i=>jr.exactMatch(i)||ps.exactMatch(i),i=>fs.exactMatch(i),i=>Ow.exactMatch(i)];for(const i of s){if(!i(e))continue;const o=n.filter(l=>l.getAddrs().filter(u=>u.toOptions().family===4&&i(u)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(l=>l.toOptions().host!=="127.0.0.1").pop();if(a==null)continue;const c=a.toOptions();return this.observed.remove(e),this.ipMappings.add(c.host,c.port,t.host,t.port,t.transport),!0}return!1}}var nl;(function(r){r.NOT_STARTED_YET="The libp2p node is not started yet",r.NOT_FOUND="Not found"})(nl||(nl={}));class KE extends Error{constructor(e="Missing service"){super(e),this.name="MissingServiceError"}}class qE extends Error{constructor(e="Unmet service dependencies"){super(e),this.name="UnmetServiceDependenciesError"}}class vi extends Error{constructor(e="No content routers available"){super(e),this.name="NoContentRoutersError"}}class sl extends Error{constructor(e="No peer routers available"){super(e),this.name="NoPeerRoutersError"}}class WE extends Error{constructor(e="Should not try to find self"){super(e),this.name="QueriedForSelfError"}}class HE extends Error{constructor(e="Unhandled protocol error"){super(e),this.name="UnhandledProtocolError"}}class VE extends Error{constructor(e="Duplicate protocol handler error"){super(e),this.name="DuplicateProtocolHandlerError"}}class il extends Error{constructor(e="Dial denied error"){super(e),this.name="DialDeniedError"}}class GE extends Error{constructor(e="No transport was configured to listen on this address"){super(e),this.name="UnsupportedListenAddressError"}}class YE extends Error{constructor(e="Configured listen addresses could not be listened on"){super(e),this.name="UnsupportedListenAddressesError"}}class XE extends Error{constructor(e="No valid addresses"){super(e),this.name="NoValidAddressesError"}}class QE extends Error{constructor(e="Connection intercepted"){super(e),this.name="ConnectionInterceptedError"}}class jE extends Error{constructor(e="Connection denied"){super(e),this.name="ConnectionDeniedError"}}class Rn extends Error{constructor(e="Stream is not multiplexed"){super(e),this.name="MuxerUnavailableError"}}class Mn extends Error{constructor(e="Encryption failed"){super(e),this.name="EncryptionFailedError"}}class ZE extends Error{constructor(e="Transport unavailable"){super(e),this.name="TransportUnavailableError"}}class JE{components={};_started=!1;constructor(e={}){this.components={};for(const[t,n]of Object.entries(e))this.components[t]=n;this.components.logger==null&&(this.components.logger=Vd())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter(t=>wo(t)).map(async t=>{await t[e]?.()}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const e1=["metrics","connectionProtector","dns"],t1=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function r1(r={}){const e=new JE(r);return new Proxy(e,{get(n,s,i){if(typeof s=="string"&&!t1.includes(s)){const o=e.components[s];if(o==null&&!e1.includes(s))throw new KE(`${s} not set`);return o}return Reflect.get(n,s,i)},set(n,s,i){return typeof s=="string"?e.components[s]=i:Reflect.set(n,s,i),!0}})}function n1(r){const e={};for(const t of Object.values(r.components))for(const n of s1(t))e[n]=!0;for(const t of Object.values(r.components))for(const n of i1(t))if(e[n]!==!0)throw new qE(`Service "${o1(t)}" required capability "${n}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function s1(r){return Array.isArray(r?.[et])?r[et]:[]}function i1(r){return Array.isArray(r?.[zn])?r[zn]:[]}function o1(r){return r?.[Symbol.toStringTag]??r?.toString()??"unknown"}const a1=4,c1=41;function l1(r={}){return{denyDialPeer:async()=>!1,denyDialMultiaddr:async e=>{if(jr.matches(e))return!1;const t=e.stringTuples();return t[0][0]===a1||t[0][0]===c1?!!Ns(`${t[0][1]}`):!1},denyInboundConnection:async()=>!1,denyOutboundConnection:async()=>!1,denyInboundEncryptedConnection:async()=>!1,denyOutboundEncryptedConnection:async()=>!1,denyInboundUpgradedConnection:async()=>!1,denyOutboundUpgradedConnection:async()=>!1,filterMultiaddrForPeer:async()=>!0,...r}}const ol=()=>{const r=new Error("Delay aborted");return r.name="AbortError",r},u1=new WeakMap;function d1({clearTimeout:r,setTimeout:e}={}){return(t,{value:n,signal:s}={})=>{if(s?.aborted)return Promise.reject(ol());let i,o,a;const c=r??clearTimeout,l=()=>{c(i),a(ol())},u=()=>{s&&s.removeEventListener("abort",l)},d=new Promise((h,p)=>{o=()=>{u(),h(n)},a=p,i=(e??setTimeout)(o,t)});return s&&s.addEventListener("abort",l,{once:!0}),u1.set(d,()=>{c(i),i=null,o()}),d}}const h1=d1();class f1{memoryStorage;points;duration;blockDuration;execEvenly;execEvenlyMinDelayMs;keyPrefix;constructor(e={}){this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.execEvenly=e.execEvenly??!1,this.execEvenlyMinDelayMs=e.execEvenlyMinDelayMs??this.duration*1e3/this.points,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new p1}async consume(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n);let o=this.memoryStorage.incrby(s,t,i);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+t&&(o=this.memoryStorage.set(s,o.consumedPoints,this.blockDuration)),new tb("Rate limit exceeded",o);if(this.execEvenly&&o.msBeforeNext>0&&!o.isFirstInDuration){let a=Math.ceil(o.msBeforeNext/(o.remainingPoints+2));a<this.execEvenlyMinDelayMs&&(a=o.consumedPoints*this.execEvenlyMinDelayMs),await h1(a)}return o}penalty(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,-t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(e,t){const n=t*1e3,s=this.points+1;return this.memoryStorage.set(this.getKey(e),s,t),{remainingPoints:0,msBeforeNext:n===0?-1:n,consumedPoints:s,isFirstInDuration:!1}}set(e,t,n=0){const s=(n>=0?n:this.duration)*1e3;return this.memoryStorage.set(this.getKey(e),t,n),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return t!=null&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return e?.customDuration!=null&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class p1{storage;constructor(){this.storage=new Map}incrby(e,t,n){const s=this.storage.get(e);if(s!=null){const i=s.expiresAt!=null?s.expiresAt.getTime()-new Date().getTime():-1;return s.expiresAt==null||i>0?(s.value+=t,{remainingPoints:0,msBeforeNext:i,consumedPoints:s.value,isFirstInDuration:!1}):this.set(e,t,n)}return this.set(e,t,n)}set(e,t,n){const s=n*1e3,i=this.storage.get(e);i!=null&&clearTimeout(i.timeoutId);const o={value:t,expiresAt:s>0?new Date(Date.now()+s):void 0};return this.storage.set(e,o),s>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(e)},s),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:o.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(t!=null)return{remainingPoints:0,msBeforeNext:t.expiresAt!=null?t.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}delete(e){const t=this.storage.get(e);return t!=null?(t.timeoutId!=null&&clearTimeout(t.timeoutId),this.storage.delete(e),!0):!1}}function Jd(r){if(yl(r))return{peerId:r,multiaddrs:[]};let e=Array.isArray(r)?r:[r],t;if(e.length>0){const n=e[0].getPeerId();t=n==null?void 0:lt(n),e.forEach(s=>{if(!ks(s))throw new po("Invalid multiaddr");const i=s.getPeerId();if(i==null){if(t!=null)throw new W("Multiaddrs must all have the same peer id or have no peer id")}else{const o=lt(i);if(t?.equals(o)!==!0)throw new W("Multiaddrs must all have the same peer id or have no peer id")}})}return e=e.filter(n=>!Lw.exactMatch(n)),{peerId:t,multiaddrs:e}}const g1=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function m1(r,e){const t=r?.streams?.map(s=>s.protocol)??[],n=e?.closableProtocols??g1;if(!(t.filter(s=>s!=null&&!n.includes(s)).length>0))try{await r?.close(e)}catch(s){r?.abort(s)}}const eh=1e4,y1=1e4,al=1e4,th=25,w1=5,b1=10,v1=5,E1="last-dial-failure",S1="last-dial-success",rh=500,nh=100,sh=50;async function x1(r,e){let t=!1;for(const s of Ko.keys())if(t=r.protoNames().includes(s),t)break;if(!t)return[r];const n=await r.resolve(e);return e.log("resolved %s to",r,n.map(s=>s.toString())),n}function lo(r){try{let e;if(typeof r=="string"?e=Y(r):e=r,!e.protoNames().includes("ipcidr")){const n=e.protoNames().includes("ip6")?"/ipcidr/128":"/ipcidr/32";e=e.encapsulate(n)}return lw(e)}catch{throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${r}`)}}const A1={maxConnections:nh};class C1{maxConnections;connectionManager;peerStore;allow;events;log;constructor(e,t={}){this.maxConnections=t.maxConnections??A1.maxConnections,this.allow=(t.allow??[]).map(n=>lo(n)),this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(e=>{this.log.error("error while pruning connections %e",e)})}async _maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length;if(this.log("checking max connections limit %d/%d",t,this.maxConnections),t<=this.maxConnections)return;const n=new Ms;for(const a of e){const c=a.remotePeer;if(!n.has(c)){n.set(c,0);try{const l=await this.peerStore.get(c);n.set(c,[...l.tags.values()].reduce((u,d)=>u+d.value,0))}catch(l){l.name!=="NotFoundError"&&this.log.error("error loading peer tags",l)}}}const s=this.sortConnections(e,n),i=Math.max(t-this.maxConnections,0),o=[];for(const a of s)if(this.log("too many connections open - closing a connection to %p",a.remotePeer),this.allow.some(l=>l.contains(a.remoteAddr.nodeAddress().address))||o.push(a),o.length===i)break;await Promise.all(o.map(async a=>{await m1(a,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:o})}sortConnections(e,t){return e.sort((n,s)=>{const i=n.timeline.open,o=s.timeline.open;return i<o?1:i>o?-1:0}).sort((n,s)=>n.direction==="outbound"&&s.direction==="inbound"?1:n.direction==="inbound"&&s.direction==="outbound"?-1:0).sort((n,s)=>n.streams.length>s.streams.length?1:n.streams.length<s.streams.length?-1:0).sort((n,s)=>{const i=t.get(n.remotePeer)??0,o=t.get(s.remotePeer)??0;return i>o?1:i<o?-1:0})}}class I1 extends bd{constructor(e={}){super({...e,sort:(t,n)=>t.options.priority>n.options.priority?-1:t.options.priority<n.options.priority?1:0})}}function T1(r){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(r)||/^::1$/.test(r)}function cl(r){if(!xd(r))return!1;const{address:e}=r.nodeAddress();return T1(e)}function P1(r,e){const t=fs.exactMatch(r.multiaddr),n=fs.exactMatch(e.multiaddr);if(t&&!n)return-1;if(!t&&n)return 1;const s=ps.exactMatch(r.multiaddr),i=ps.exactMatch(e.multiaddr);if(s&&!i)return-1;if(!s&&i)return 1;const o=jr.exactMatch(r.multiaddr),a=jr.exactMatch(e.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=Ji.exactMatch(r.multiaddr),l=Ji.exactMatch(e.multiaddr);if(c&&!l)return-1;if(!c&&l)return 1;const u=ac.exactMatch(r.multiaddr),d=ac.exactMatch(e.multiaddr);if(u&&!d)return-1;if(!u&&d)return 1;const h=cc.exactMatch(r.multiaddr),p=cc.exactMatch(e.multiaddr);return h&&!p?-1:!h&&p?1:0}function k1(r,e){const t=cl(r.multiaddr),n=cl(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function _1(r,e){const t=en(r.multiaddr),n=en(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function D1(r,e){return r.isCertified&&!e.isCertified?-1:!r.isCertified&&e.isCertified?1:0}function L1(r,e){const t=Zr.exactMatch(r.multiaddr),n=Zr.exactMatch(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function R1(r){return r.sort(P1).sort(D1).sort(L1).sort(_1).sort(k1)}const On={maxParallelDials:sh,maxDialQueueLength:rh,maxPeerAddrsToDial:th,dialTimeout:eh};class M1{queue;components;addressSorter;maxPeerAddrsToDial;maxDialQueueLength;dialTimeout;shutDownController;connections;log;constructor(e,t={}){this.addressSorter=t.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??On.maxPeerAddrsToDial,this.maxDialQueueLength=t.maxDialQueueLength??On.maxDialQueueLength,this.dialTimeout=t.dialTimeout??On.dialTimeout,this.connections=t.connections??new Ms,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.shutDownController=new AbortController,this.shutDownController.signal;for(const[n,s]of Object.entries(t.resolvers??{}))Ko.set(n,s);this.queue=new I1({concurrency:t.maxParallelDials??On.maxParallelDials,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("error",n=>{n.detail?.name!==Kt.name&&this.log.error("error in dial queue - %e",n.detail)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){const{peerId:n,multiaddrs:s}=Jd(e),i=Array.from(this.connections.values()).flat().find(a=>t.force===!0?!1:a.remotePeer.equals(n)?!0:s.find(c=>c.equals(a.remoteAddr)));if(i?.status==="open")return this.log("already connected to %a",i.remoteAddr),t.onProgress?.(new se("dial-queue:already-connected")),i;const o=this.queue.queue.find(a=>{if(n?.equals(a.options.peerId)===!0)return!0;const c=a.options.multiaddrs;if(c==null)return!1;for(const l of s)if(c.has(l.toString()))return!0;return!1});if(o!=null){this.log("joining existing dial target for %p",n);for(const a of s)o.options.multiaddrs.add(a.toString());return t.onProgress?.(new se("dial-queue:already-in-dial-queue")),o.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new Or("Dial queue is full");return this.log("creating dial target for %p",n,s.map(a=>a.toString())),t.onProgress?.(new se("dial-queue:add-to-dial-queue")),this.queue.add(async a=>{a.onProgress?.(new se("dial-queue:start-dial"));const c=Lt([this.shutDownController.signal,a.signal]);try{return await this.dialPeer(a,c)}finally{c.clear()}},{peerId:n,priority:t.priority??ih,multiaddrs:new Set(s.map(a=>a.toString())),signal:t.signal??AbortSignal.timeout(this.dialTimeout),onProgress:t.onProgress})}async dialPeer(e,t){const n=e.peerId,s=e.multiaddrs,i=new Set;let o=e.multiaddrs.size===0,a=0,c=0;const l=[];for(this.log("starting dial to %p",n);o||s.size>0;){c++,o=!1;const u=[],d=new Set(e.multiaddrs);s.clear(),this.log("calculating addrs to dial %p from %s",n,[...d]);const h=await this.calculateMultiaddrs(n,d,{...e,signal:t});for(const p of h){if(i.has(p.multiaddr.toString())){this.log.trace("skipping previously failed multiaddr %a while dialing %p",p.multiaddr,n);continue}u.push(p)}this.log("%s dial to %p with %s",c===1?"starting":"continuing",n,u.map(p=>p.multiaddr.toString())),e?.onProgress?.(new se("dial-queue:calculated-addresses",u));for(const p of u){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,e.peerId),new Or("Peer had more than maxPeerAddrsToDial");a++;try{const f=await this.components.transportManager.dial(p.multiaddr,{...e,signal:t});this.log("dial to %a succeeded",p.multiaddr);try{await this.components.peerStore.merge(f.remotePeer,{multiaddrs:[f.remoteAddr],metadata:{[S1]:K(Date.now().toString())}})}catch(g){this.log.error("could not update last dial failure key for %p",n,g)}return f}catch(f){if(this.log.error("dial failed to %a",p.multiaddr,f),i.add(p.multiaddr.toString()),n!=null)try{await this.components.peerStore.merge(n,{metadata:{[E1]:K(Date.now().toString())}})}catch(g){this.log.error("could not update last dial failure key for %p",n,g)}if(t.aborted)throw new mo(f.message);l.push(f)}}}throw l.length===1?l[0]:new AggregateError(l,"All multiaddr dials failed")}async calculateMultiaddrs(e,t=new Set,n={}){const s=[...t].map(d=>({multiaddr:Y(d),isCertified:!1}));if(e!=null){if(this.components.peerId.equals(e))throw new Or("Tried to dial self");if(await this.components.connectionGater.denyDialPeer?.(e)===!0)throw new il("The dial request is blocked by gater.allowDialPeer");if(s.length===0){this.log("loading multiaddrs for %p",e);try{const d=await this.components.peerStore.get(e);s.push(...d.addresses),this.log("loaded multiaddrs for %p",e,s.map(({multiaddr:h})=>h.toString()))}catch(d){if(d.name!=="NotFoundError")throw d}}if(s.length===0){this.log("looking up multiaddrs for %p in the peer routing",e);try{const d=await this.components.peerRouting.findPeer(e,n);this.log("found multiaddrs for %p in the peer routing",e,s.map(({multiaddr:h})=>h.toString())),s.push(...d.multiaddrs.map(h=>({multiaddr:h,isCertified:!1})))}catch(d){d.name==="NoPeerRoutersError"?this.log("no peer routers configured",e):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",e,d)}}}let i=(await Promise.all(s.map(async d=>{const h=await x1(d.multiaddr,{dns:this.components.dns,...n,log:this.log});return h.length===1&&h[0].equals(d.multiaddr)?d:h.map(p=>({multiaddr:p,isCertified:!1}))}))).flat();if(e!=null){const d=`/p2p/${e.toString()}`;i=i.map(h=>h.multiaddr.protos().pop()?.path===!0?h:h.multiaddr.getPeerId()==null?{multiaddr:h.multiaddr.encapsulate(d),isCertified:h.isCertified}:h)}const o=i.filter(d=>{if(this.components.transportManager.dialTransportForMultiaddr(d.multiaddr)==null)return!1;const h=d.multiaddr.getPeerId();return e!=null&&h!=null?e.equals(h):!0}),a=new Map;for(const d of o){const h=d.multiaddr.toString(),p=a.get(h);if(p!=null){p.isCertified=p.isCertified||d.isCertified||!1;continue}a.set(h,d)}const c=[...a.values()];if(c.length===0)throw new XE("The dial request has no valid addresses");const l=[];for(const d of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(d.multiaddr)||l.push(d);const u=this.addressSorter==null?R1(l):l.sort(this.addressSorter);if(u.length===0)throw new il("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",e??"unknown peer",i.map(({multiaddr:d})=>d.toString())),this.log.trace("addresses for %p after filtering",e??"unknown peer",u.map(({multiaddr:d})=>d.toString())),u}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const n=await this.calculateMultiaddrs(void 0,new Set(e.map(s=>s.toString())),t);return t.runOnLimitedConnection===!1?n.find(s=>!Zr.matches(s.multiaddr))!=null:!0}catch(n){this.log.trace("error calculating if multiaddr(s) were dialable",n)}return!1}}var Ei={},Si,ll;function O1(){if(ll)return Si;ll=1;function r(e,t){typeof t=="boolean"&&(t={forever:t}),this._originalTimeouts=JSON.parse(JSON.stringify(e)),this._timeouts=e,this._options=t||{},this._maxRetryTime=t&&t.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}return Si=r,r.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},r.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},r.prototype.retry=function(e){if(this._timeout&&clearTimeout(this._timeout),!e)return!1;var t=new Date().getTime();if(e&&t-this._operationStart>=this._maxRetryTime)return this._errors.push(e),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(e);var n=this._timeouts.shift();if(n===void 0)if(this._cachedTimeouts)this._errors.splice(0,this._errors.length-1),n=this._cachedTimeouts.slice(-1);else return!1;var s=this;return this._timer=setTimeout(function(){s._attempts++,s._operationTimeoutCb&&(s._timeout=setTimeout(function(){s._operationTimeoutCb(s._attempts)},s._operationTimeout),s._options.unref&&s._timeout.unref()),s._fn(s._attempts)},n),this._options.unref&&this._timer.unref(),!0},r.prototype.attempt=function(e,t){this._fn=e,t&&(t.timeout&&(this._operationTimeout=t.timeout),t.cb&&(this._operationTimeoutCb=t.cb));var n=this;this._operationTimeoutCb&&(this._timeout=setTimeout(function(){n._operationTimeoutCb()},n._operationTimeout)),this._operationStart=new Date().getTime(),this._fn(this._attempts)},r.prototype.try=function(e){console.log("Using RetryOperation.try() is deprecated"),this.attempt(e)},r.prototype.start=function(e){console.log("Using RetryOperation.start() is deprecated"),this.attempt(e)},r.prototype.start=r.prototype.try,r.prototype.errors=function(){return this._errors},r.prototype.attempts=function(){return this._attempts},r.prototype.mainError=function(){if(this._errors.length===0)return null;for(var e={},t=null,n=0,s=0;s<this._errors.length;s++){var i=this._errors[s],o=i.message,a=(e[o]||0)+1;e[o]=a,a>=n&&(t=i,n=a)}return t},Si}var ul;function N1(){return ul||(ul=1,function(r){var e=O1();r.operation=function(t){var n=r.timeouts(t);return new e(n,{forever:t&&(t.forever||t.retries===1/0),unref:t&&t.unref,maxRetryTime:t&&t.maxRetryTime})},r.timeouts=function(t){if(t instanceof Array)return[].concat(t);var n={retries:10,factor:2,minTimeout:1*1e3,maxTimeout:1/0,randomize:!1};for(var s in t)n[s]=t[s];if(n.minTimeout>n.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var i=[],o=0;o<n.retries;o++)i.push(this.createTimeout(o,n));return t&&t.forever&&!i.length&&i.push(this.createTimeout(o,n)),i.sort(function(a,c){return a-c}),i},r.createTimeout=function(t,n){var s=n.randomize?Math.random()+1:1,i=Math.round(s*Math.max(n.minTimeout,1)*Math.pow(n.factor,t));return i=Math.min(i,n.maxTimeout),i},r.wrap=function(t,n,s){if(n instanceof Array&&(s=n,n=null),!s){s=[];for(var i in t)typeof t[i]=="function"&&s.push(i)}for(var o=0;o<s.length;o++){var a=s[o],c=t[a];t[a]=function(u){var d=r.operation(n),h=Array.prototype.slice.call(arguments,1),p=h.pop();h.push(function(f){d.retry(f)||(f&&(arguments[0]=d.mainError()),p.apply(this,arguments))}),d.attempt(function(){u.apply(t,h)})}.bind(t,c),t[a].options=n}}}(Ei)),Ei}var xi,dl;function F1(){return dl||(dl=1,xi=N1()),xi}var U1=F1();const B1=Os(U1),$1=Object.prototype.toString,z1=r=>$1.call(r)==="[object Error]",K1=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Load failed","Network request failed","fetch failed","terminated"]);function q1(r){return r&&z1(r)&&r.name==="TypeError"&&typeof r.message=="string"?r.message==="Load failed"?r.stack===void 0:K1.has(r.message):!1}class W1 extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,{message:e}=e):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}const hl=(r,e,t)=>{const n=t.retries-(e-1);return r.attemptNumber=e,r.retriesLeft=n,r};async function H1(r,e){return new Promise((t,n)=>{e={...e},e.onFailedAttempt??=()=>{},e.shouldRetry??=()=>!0,e.retries??=10;const s=B1.operation(e),i=()=>{s.stop(),n(e.signal?.reason)};e.signal&&!e.signal.aborted&&e.signal.addEventListener("abort",i,{once:!0});const o=()=>{e.signal?.removeEventListener("abort",i),s.stop()};s.attempt(async a=>{try{const c=await r(a);o(),t(c)}catch(c){try{if(!(c instanceof Error))throw new TypeError(`Non-error was thrown: "${c}". You should only throw errors.`);if(c instanceof W1)throw c.originalError;if(c instanceof TypeError&&!q1(c))throw c;if(hl(c,a,e),await e.shouldRetry(c)||(s.stop(),n(c)),await e.onFailedAttempt(c),!s.retry(c))throw s.mainError()}catch(l){hl(l,a,e),o(),n(l)}}})})}class V1{log;queue;started;peerStore;retries;retryInterval;backoffFactor;connectionManager;events;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.queue=new Xo({concurrency:t.maxParallelReconnects??v1,metricName:"libp2p_reconnect_queue",metrics:e.metrics}),this.started=!1,this.retries=t.retries??5,this.backoffFactor=t.backoffFactor,this.retryInterval=t.retryInterval,this.events=e.events,e.events.addEventListener("peer:disconnect",n=>{this.maybeReconnect(n.detail).catch(s=>{this.log.error("failed to maybe reconnect to %p - %e",n.detail,s)})})}async maybeReconnect(e){if(!this.started)return;const t=await this.peerStore.get(e);fl(t)&&(this.queue.has(e)||this.queue.add(async n=>{await H1(async s=>{if(this.started)try{await this.connectionManager.openConnection(e,{signal:n?.signal})}catch(i){throw this.log("reconnecting to %p attempt %d of %d failed - %e",e,s,this.retries,i),i}},{signal:n?.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:e}).catch(async n=>{this.log.error("failed to reconnect to %p - %e",e,n);const s={};[...t.tags.keys()].forEach(i=>{i.startsWith(ho)&&(s[i]=void 0)}),await this.peerStore.merge(e,{tags:s}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:e})}).catch(async n=>{this.log.error("failed to remove keep-alive tag from %p - %e",e,n)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>fl(t)]});await Promise.all(e.map(async t=>{await this.connectionManager.openConnection(t.id).catch(n=>{this.log.error(n)})}))}).catch(e=>{this.log.error(e)})}stop(){this.started=!1,this.queue.abort()}}function fl(r){for(const e of r.tags.keys())if(e.startsWith(ho))return!0;return!1}const ih=50,Ai={maxConnections:nh,inboundConnectionThreshold:w1,maxIncomingPendingConnections:b1};class G1{started;connections;allow;deny;maxIncomingPendingConnections;incomingPendingConnections;outboundPendingConnections;maxConnections;dialQueue;reconnectQueue;connectionPruner;inboundConnectionRateLimiter;peerStore;metrics;events;log;peerId;constructor(e,t={}){if(this.maxConnections=t.maxConnections??Ai.maxConnections,this.maxConnections<1)throw new W("Connection Manager maxConnections must be greater than 0");this.connections=new Ms,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(t.allow??[]).map(n=>lo(n)),this.deny=(t.deny??[]).map(n=>lo(n)),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??Ai.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new f1({points:t.inboundConnectionThreshold??Ai.inboundConnectionThreshold,duration:1}),this.connectionPruner=new C1({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{maxConnections:this.maxConnections,allow:t.allow?.map(n=>Y(n))}),this.dialQueue=new M1(e,{addressSorter:t.addressSorter,maxParallelDials:t.maxParallelDials??sh,maxDialQueueLength:t.maxDialQueueLength??rh,maxPeerAddrsToDial:t.maxPeerAddrsToDial??th,dialTimeout:t.dialTimeout??eh,resolvers:t.resolvers??{dnsaddr:Wd},connections:this.connections}),this.reconnectQueue=new V1({events:e.events,peerStore:e.peerStore,logger:e.logger,connectionManager:this},{retries:t.reconnectRetries,retryInterval:t.reconnectRetryInterval,backoffFactor:t.reconnectBackoffFactor,maxParallelReconnects:t.maxParallelReconnects})}[Symbol.toStringTag]="@libp2p/connection-manager";async start(){this.metrics?.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const e={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const t of this.connections.values())for(const n of t)e[n.direction]++;return e}}),this.metrics?.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const e={};for(const t of this.connections.values())for(const n of t)for(const s of n.streams){const i=`${s.direction} ${s.protocol??"unnegotiated"}`;e[i]=(e[i]??0)+1}return e}}),this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const e={};for(const n of this.connections.values())for(const s of n){const i={};for(const o of s.streams){const a=`${o.direction} ${o.protocol??"unnegotiated"}`;i[a]=(i[a]??0)+1}for(const[o,a]of Object.entries(i))e[o]=e[o]??[],e[o].push(a)}const t={};for(let[n,s]of Object.entries(e)){s=s.sort((o,a)=>o-a);const i=Math.floor(s.length*.9);t[n]=s[i]}return t}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await Al(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await Cl(this.reconnectQueue,this.dialQueue,this.connectionPruner);const e=[];for(const t of this.connections.values())for(const n of t)e.push((async()=>{try{await n.close()}catch(s){this.log.error(s)}})());this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}onConnect(e){this._onConnect(e).catch(t=>{this.log.error(t)})}async _onConnect(e){const{detail:t}=e;if(!this.started){await t.close();return}if(t.status!=="open")return;const n=t.remotePeer,s=!this.connections.has(n),i=this.connections.get(n)??[];i.push(t),this.connections.set(n,i),n.publicKey!=null&&n.type==="RSA"&&await this.peerStore.patch(n,{publicKey:n.publicKey}),s&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e,n=t.remotePeer,i=(this.connections.get(n)??[]).filter(o=>o.id!==t.id);this.connections.set(n,i),i.length===0&&(this.log("onDisconnect remove all connections for peer %p",n),this.connections.delete(n),this.events.safeDispatchEvent("peer:disconnect",{detail:t.remotePeer}))}getConnections(e){if(e!=null)return this.connections.get(e)??[];let t=[];for(const n of this.connections.values())t=t.concat(n);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){if(!this.started)throw new $n("Not started");this.outboundPendingConnections++;try{t.signal?.throwIfAborted();const{peerId:n}=Jd(e);if(this.peerId.equals(n))throw new El("Can not dial self");if(n!=null&&t.force!==!0){this.log("dial %p",n);const a=this.getConnections(n).find(c=>c.limits==null);if(a!=null)return this.log("had an existing non-limited connection to %p",n),t.onProgress?.(new se("dial-queue:already-connected")),a}const s=await this.dialQueue.dial(e,{...t,priority:t.priority??ih});if(s.status!=="open")throw new bl("Remote closed connection during opening");let i=this.connections.get(s.remotePeer);i==null&&(i=[],this.connections.set(s.remotePeer,i));let o=!1;for(const a of i)if(a.id===s.id&&(o=!0),t.force!==!0&&a.id!==s.id&&a.remoteAddr.equals(s.remoteAddr))return s.abort(new po("Duplicate multiaddr connection")),a;return o||i.push(s),s}finally{this.outboundPendingConnections--}}async closeConnections(e,t={}){const n=this.connections.get(e)??[];await Promise.all(n.map(async s=>{try{await s.close(t)}catch(i){s.abort(i)}}))}async acceptIncomingConnection(e){if(this.deny.some(s=>s.contains(e.remoteAddr.nodeAddress().address)))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some(s=>s.contains(e.remoteAddr.nodeAddress().address)))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(e.remoteAddr.isThinWaistAddress()){const s=e.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(s,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,s),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map(n=>Y(n))}))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}class Ci{movingAverage;variance;deviation;forecast;timeSpan;previousTime;constructor(e){this.timeSpan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timeSpan)}push(e,t=Date.now()){if(this.previousTime!=null){const n=this.alpha(t,this.previousTime),s=e-this.movingAverage,i=n*s;this.movingAverage=n*e+(1-n)*this.movingAverage,this.variance=(1-n)*(this.variance+s*i),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+n*s}else this.movingAverage=e;this.previousTime=t}}const Y1=1.2,X1=2,Q1=5e3;class j1{success;failure;next;metric;timeoutMultiplier;failureMultiplier;minTimeout;constructor(e={}){this.success=new Ci(e.interval??5e3),this.failure=new Ci(e.interval??5e3),this.next=new Ci(e.interval??5e3),this.failureMultiplier=e.failureMultiplier??X1,this.timeoutMultiplier=e.timeoutMultiplier??Y1,this.minTimeout=e.minTimeout??Q1,e.metricName!=null&&(this.metric=e.metrics?.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){const t=Math.max(Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier)),this.minTimeout),n=AbortSignal.timeout(t),s=Lt([e.signal,n]);return s.start=Date.now(),s.timeout=t,s}cleanUp(e){const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),this.metric?.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),this.metric?.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}const Z1=1e4,J1="1.0.0",eS="ping",tS="ipfs",pl=32,rS=!0;class nS{protocol;components;log;heartbeatInterval;pingIntervalMs;abortController;timeout;abortConnectionOnPingFailure;constructor(e,t={}){this.components=e,this.protocol=`/${t.protocolPrefix??tS}/${eS}/${J1}`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??Z1,this.abortConnectionOnPingFailure=t.abortConnectionOnPingFailure??rS,this.timeout=new j1({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}[Symbol.toStringTag]="@libp2p/connection-monitor";[et]=["@libp2p/connection-monitor"];start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(e=>{Promise.resolve().then(async()=>{let t=Date.now();try{const n=this.timeout.getTimeoutSignal({signal:this.abortController?.signal}),s=await e.newStream(this.protocol,{signal:n,runOnLimitedConnection:!0}),i=es(s);t=Date.now(),await Promise.all([i.write(Mo(pl),{signal:n}),i.read({bytes:pl,signal:n})]),e.rtt=Date.now()-t,await i.unwrap().close({signal:n})}catch(n){if(n.name!=="UnsupportedProtocolError")throw n;e.rtt=(Date.now()-t)/2}}).catch(t=>{this.log.error("error during heartbeat",t),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),e.abort(t)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){this.abortController?.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}class sS{routers;started;components;constructor(e,t){this.routers=t.routers??[],this.started=!1,this.components=e,this.findProviders=e.metrics?.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,cid:n.toString()}),getAttributesFromYieldedValue:(n,s)=>({...s,providers:[...Array.isArray(s.providers)?s.providers:[],n.id.toString()]})})??this.findProviders,this.provide=e.metrics?.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,cid:n.toString()})})??this.provide,this.cancelReprovide=e.metrics?.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,cid:n.toString()})})??this.cancelReprovide,this.put=e.metrics?.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([n])=>({key:G(n,"base36")})})??this.put,this.get=e.metrics?.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([n])=>({key:G(n,"base36")})})??this.get}[Symbol.toStringTag]="@libp2p/content-routing";isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(this.routers.length===0)throw new vi("No content routers available");const n=this,s=new sr;for await(const i of ts(...n.routers.filter(o=>o.findProviders instanceof Function).map(o=>o.findProviders(e,t))))i!=null&&(i.multiaddrs.length>0&&await this.components.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),!s.has(i.id)&&(s.add(i.id),yield i))}async provide(e,t={}){if(this.routers.length===0)throw new vi("No content routers available");await Promise.all(this.routers.filter(n=>n.provide instanceof Function).map(async n=>{await n.provide(e,t)}))}async cancelReprovide(e,t={}){if(this.routers.length===0)throw new vi("No content routers available");await Promise.all(this.routers.filter(n=>n.cancelReprovide instanceof Function).map(async n=>{await n.cancelReprovide(e,t)}))}async put(e,t,n){if(!this.isStarted())throw new $n;await Promise.all(this.routers.filter(s=>s.put instanceof Function).map(async s=>{await s.put(e,t,n)}))}async get(e,t){if(!this.isStarted())throw new $n;return Promise.any(this.routers.filter(n=>n.get instanceof Function).map(async n=>n.get(e,t)))}}class iS{log;peerId;peerStore;routers;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[],this.findPeer=e.metrics?.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,peer:n.toString()})})??this.findPeer,this.getClosestPeers=e.metrics?.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,key:G(n,"base36")}),getAttributesFromYieldedValue:(n,s)=>({...s,peers:[...Array.isArray(s.peers)?s.peers:[],n.id.toString()]})})??this.getClosestPeers}[Symbol.toStringTag]="@libp2p/peer-routing";async findPeer(e,t){if(this.routers.length===0)throw new sl("No peer routers available");if(e.toString()===this.peerId.toString())throw new WE("Should not try to find self");const n=this,s=ts(...this.routers.filter(i=>i.findPeer instanceof Function).map(i=>async function*(){try{yield await i.findPeer(e,t)}catch(o){n.log.error(o)}}()));for await(const i of s)if(i!=null)return i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),i;throw new ki}async*getClosestPeers(e,t={}){if(this.routers.length===0)throw new sl("No peer routers available");const n=this,s=Jr(1024);for await(const i of vd(async function*(){const o=ts(...n.routers.filter(a=>a.getClosestPeers instanceof Function).map(a=>a.getClosestPeers(e,t)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await n.findPeer(a.id,{...t,useCache:!1})}catch(c){n.log.error("could not find peer multiaddrs",c);return}return a}}()))i!=null&&(i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),!s.has(i.id.toMultihash().bytes)&&(s.add(i.id.toMultihash().bytes),yield i))}}class oS extends _t{peerRouting;log;walking;walkers;shutdownController;walkController;needNext;constructor(e){super(),this.log=e.logger.forComponent("libp2p:random-walk"),this.peerRouting=e.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}[Symbol.toStringTag]="@libp2p/random-walk";start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(e){this.walking||this.startWalk(),this.walkers++;const t=Lt([this.shutdownController.signal,e?.signal]);try{for(;;)this.needNext?.resolve(),this.needNext=de(),yield(await ir(this,"walk:peer",t,{errorEvent:"walk:error"})).detail}finally{t.clear(),this.walkers--,this.walkers===0&&(this.walkController?.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const e=Lt([this.walkController.signal,this.shutdownController.signal]),t=Date.now();let n=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const s=Mo(32);let i=Date.now();for await(const o of this.peerRouting.getClosestPeers(s,{signal:e}))e.aborted&&this.log("aborting walk"),e.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",o.id,Date.now()-i,this.walkers),n++,this.safeDispatchEvent("walk:peer",{detail:o}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await Ye(this.needNext.promise,e)),i=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",s,this.walkers,n)}catch(s){this.log.error("random walk errored",s),this.safeDispatchEvent("walk:error",{detail:s})}this.log("no walkers left, ended walk")}).catch(s=>{this.log.error("random walk errored",s)}).finally(()=>{this.log("finished walk, found %d peers after %dms",n,Date.now()-t),this.walking=!1})}}const oh=32,ah=64;class aS{log;topologies;handlers;components;constructor(e){this.log=e.logger.forComponent("libp2p:registrar"),this.topologies=new Map,this.handlers=new Map,this.components=e,this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}[Symbol.toStringTag]="@libp2p/registrar";getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(t==null)throw new HE(`No handler registered for protocol ${e}`);return t}getTopologies(e){const t=this.topologies.get(e);return t==null?[]:[...t.values()]}async handle(e,t,n){if(this.handlers.has(e)&&n?.force!==!0)throw new VE(`Handler already registered for protocol ${e}`);const s=$d.bind({ignoreUndefined:!0})({maxInboundStreams:oh,maxOutboundStreams:ah},n);this.handlers.set(e,{handler:t,options:s}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]})}async unhandle(e){(Array.isArray(e)?e:[e]).forEach(n=>{this.handlers.delete(n)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()})}async register(e,t){if(t==null)throw new W("invalid topology");const n=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let s=this.topologies.get(e);return s==null&&(s=new Map,this.topologies.set(e,s)),s.set(n,t),n}unregister(e){for(const[t,n]of this.topologies.entries())n.has(e)&&(n.delete(e),n.size===0&&this.topologies.delete(t))}_onDisconnect(e){const t=e.detail;this.components.peerStore.get(t).then(n=>{for(const s of n.protocols){const i=this.topologies.get(s);if(i!=null)for(const o of i.values())o.filter?.has(t)!==!1&&(o.filter?.remove(t),o.onDisconnect?.(t))}}).catch(n=>{n.name!=="NotFoundError"&&this.log.error("could not inform topologies of disconnecting peer %p",t,n)})}_onPeerUpdate(e){const{peer:t,previous:n}=e.detail,s=(n?.protocols??[]).filter(i=>!t.protocols.includes(i));for(const i of s){const o=this.topologies.get(i);if(o!=null)for(const a of o.values())a.filter?.has(t.id)!==!1&&(a.filter?.remove(t.id),a.onDisconnect?.(t.id))}}_onPeerIdentify(e){const t=e.detail.protocols,n=e.detail.connection,s=e.detail.peerId;for(const i of t){const o=this.topologies.get(i);if(o!=null)for(const a of o.values())n.limits!=null&&a.notifyOnLimitedConnection!==!0||a.filter?.has(s)!==!0&&(a.filter?.add(s),a.onConnect?.(s,n))}}}class cS extends Map{metric;constructor(e){super();const{name:t,metrics:n}=e;this.metric=n.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function lS(r){const{name:e,metrics:t}=r;let n;return t!=null?n=new cS({name:e,metrics:t}):n=new Map,n}class uS{log;components;transports;listeners;faultTolerance;started;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=new Map,this.listeners=lS({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??$r.FATAL_ALL}[Symbol.toStringTag]="@libp2p/transport-manager";add(e){const t=e[Symbol.toStringTag];if(t==null)throw new W("Transport must have a valid tag");if(this.transports.has(t))throw new W(`There is already a transport with the tag ${t}`);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,n]of this.listeners)for(this.log("closing listeners for %s",t);n.length>0;){const s=n.pop();s!=null&&e.push(s.close())}await Promise.all(e),this.log("all listeners closed");for(const t of this.listeners.keys())this.listeners.set(t,[]);this.started=!1}async dial(e,t){const n=this.dialTransportForMultiaddr(e);if(n==null)throw new ZE(`No transport available for address ${String(e)}`);return t?.onProgress?.(new se("transport-manager:selected-transport",n[Symbol.toStringTag])),n.dial(e,{...t,upgrader:this.components.upgrader})}getAddrs(){let e=[];for(const t of this.listeners.values())for(const n of t)e=[...e,...n.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values())if(t.dialFilter([e]).length>0)return t}listenTransportForMultiaddr(e){for(const t of this.transports.values())if(t.listenFilter([e]).length>0)return t}async listen(e){if(!this.isStarted())throw new $n("Not started");if(e==null||e.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const t={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};e.forEach(i=>{t.errors.set(i.toString(),new GE)});const n=[];for(const[i,o]of this.transports.entries()){const a=o.listenFilter(e);for(const c of a){this.log("creating listener for %s on %a",i,c);const l=o.createListener({upgrader:this.components.upgrader});let u=this.listeners.get(i)??[];u==null&&(u=[],this.listeners.set(i,u)),u.push(l),l.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:l})}),l.addEventListener("close",()=>{const d=u.findIndex(h=>h===l);u.splice(d,1),this.components.events.safeDispatchEvent("transport:close",{detail:l})}),ic.matches(c)?t.ipv4.attempts++:oc.matches(c)&&t.ipv6.attempts++,n.push(l.listen(c).then(()=>{t.errors.delete(c.toString()),ic.matches(c)&&t.ipv4.success++,oc.matches(c)&&t.ipv6.success++},d=>{throw this.log.error("transport %s could not listen on address %a - %e",i,c,d),t.errors.set(c.toString(),d),d}))}}const s=await Promise.allSettled(n);if(!(s.length>0&&s.every(i=>i.status==="fulfilled"))){if(this.ipv6Unsupported(t)){this.log("all IPv4 addresses succeed but all IPv6 failed");return}if(this.faultTolerance===$r.NO_FATAL){this.log("failed to listen on any address but fault tolerance allows this");return}throw new YE(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...t.errors.entries()].map(([i,o])=>`
  ${i}: ${`${o.stack??o}`.split(`
`).join(`
  `)}
`).join("")}`)}}ipv6Unsupported(e){if(e.ipv4.attempts===0||e.ipv6.attempts===0)return!1;const t=e.ipv4.attempts===e.ipv4.success,n=e.ipv6.success===0;return t&&n}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const n=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const s=t.pop();s!=null&&n.push(s.close())}await Promise.all(n),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}const Be="/multistream/1.0.0",ea=1024,dS=K(`
`);async function Mr(r,e,t){await r.write(e,t)}async function hS(r,e,t){await r.writeV(e,t)}async function fS(r,e){const t=await r.read(e);if(t.byteLength===0||t.get(t.byteLength-1)!==dS[0])throw e.log.error("Invalid mss message - missing newline",t),new it("Missing newline");return t.sublist(0,-1)}async function or(r,e){const t=await fS(r,e);return G(t.subarray())}async function Ii(r,e,t){if(e=Array.isArray(e)?[...e]:[e],e.length===1&&t.negotiateFully===!1)return pS(r,e[0],t);const n=ur(r,{...t,maxDataLength:ea}),s=e.shift();if(s==null)throw new Error("At least one protocol must be specified");t.log.trace('select: write ["%s", "%s"]',Be,s);const i=K(`${Be}
`),o=K(`${s}
`);await hS(n,[i,o],t),t.log.trace("select: reading multistream-select header");let a=await or(n,t);if(t.log.trace('select: read "%s"',a),a===Be&&(t.log.trace("select: reading protocol response"),a=await or(n,t),t.log.trace('select: read "%s"',a)),a===s)return{stream:n.unwrap(),protocol:s};for(const c of e){t.log.trace('select: write "%s"',c),await Mr(n,K(`${c}
`),t),t.log.trace("select: reading protocol response");const l=await or(n,t);if(t.log.trace('select: read "%s" for "%s"',l,c),l===c)return{stream:n.unwrap(),protocol:c}}throw new go("protocol selection failed")}function pS(r,e,t){const n=r.sink.bind(r),s=r.source;let i=!1,o=!1;const a=de();let c=!1,l=!1;const u=de();let d=!1,h=!1;const p=de(),f=ur({sink:n,source:s},{...t,maxDataLength:ea});r.sink=async P=>{const{sink:b}=f.unwrap();await b(async function*(){let w=!1;for await(const E of P){if(l&&await u.promise,c)yield E;else{l=!0,t.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink',Be,e,E.byteLength);const _=`${e}
`;yield new j(Uint8Array.from([19]),K(`${Be}
`),ot(_.length),K(_),E).subarray(),t.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink',Be,e,E.byteLength),c=!0,l=!1,u.resolve(),g().catch(x=>{t.log.error("could not finish optimistic protocol negotiation of %s",e,x)})}w=!0}w||await g()}())};async function g(){if(o){t.log.trace("optimistic: already negotiating %s stream",e),await a.promise;return}o=!0;try{c||(t.log.trace("optimistic: doing send protocol for %s stream",e),await m()),d||(t.log.trace("optimistic: doing read protocol for %s stream",e),await v())}finally{o=!1,i=!0,a.resolve()}}async function m(){if(l){await u.promise;return}l=!0;try{t.log.trace('optimistic: write ["%s", "%s", data] in source',Be,e),await f.writeV([K(`${Be}
`),K(`${e}
`)]),t.log.trace('optimistic: wrote ["%s", "%s", data] in source',Be,e)}finally{c=!0,l=!1,u.resolve()}}async function v(){if(h){await p.promise;return}h=!0;try{t.log.trace("optimistic: reading multistream select header");let P=await or(f,t);if(t.log.trace('optimistic: read multistream select header "%s"',P),P===Be&&(P=await or(f,t)),t.log.trace('optimistic: read protocol "%s", expecting "%s"',P,e),P!==e)throw new go("protocol selection failed")}finally{d=!0,h=!1,p.resolve()}}if(r.source=async function*(){await g(),t.log.trace('optimistic: reading data from "%s" stream',e),yield*f.unwrap().source}(),r.closeRead!=null){const P=r.closeRead.bind(r);r.closeRead=async b=>{i||await g().catch(w=>{t.log.error("could not negotiate protocol before close read",w)}),await P(b)}}if(r.closeWrite!=null){const P=r.closeWrite.bind(r);r.closeWrite=async b=>{i||await g().catch(w=>{t.log.error("could not negotiate protocol before close write",w)}),await P(b)}}if(r.close!=null){const P=r.close.bind(r);r.close=async b=>{const w=[];l&&w.push(u.promise),h&&w.push(p.promise),w.length>0?await Ye(Promise.all(w),b?.signal):(i=!0,o=!1,a.resolve()),await P(b)}}return{stream:r,protocol:e}}async function Ti(r,e,t){e=Array.isArray(e)?e:[e],t.log.trace("handle: available protocols %s",e);const n=ur(r,{...t,maxDataLength:ea,maxLengthLength:2});for(;;){t.log.trace("handle: reading incoming string");const s=await or(n,t);if(t.log.trace('handle: read "%s"',s),s===Be){t.log.trace('handle: respond with "%s" for "%s"',Be,s),await Mr(n,K(`${Be}
`),t),t.log.trace('handle: responded with "%s" for "%s"',Be,s);continue}if(e.includes(s))return t.log.trace('handle: respond with "%s" for "%s"',s,s),await Mr(n,K(`${s}
`),t),t.log.trace('handle: responded with "%s" for "%s"',s,s),{stream:n.unwrap(),protocol:s};if(s==="ls"){const i=new j(...e.map(o=>Zn.single(K(`${o}
`))),K(`
`));t.log.trace('handle: respond with "%s" for %s',e,s),await Mr(n,i,t),t.log.trace('handle: responded with "%s" for %s',e,s);continue}t.log.trace('handle: respond with "na" for "%s"',s),await Mr(n,K(`na
`),t),t.log('handle: responded with "na" for "%s"',s)}}const gS=500;class mS{id;remoteAddr;remotePeer;direction;timeline;multiplexer;encryption;status;limits;log;tags;_newStream;_close;_abort;_getStreams;constructor(e){const{remoteAddr:t,remotePeer:n,newStream:s,close:i,abort:o,getStreams:a}=e;this.id=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`,this.remoteAddr=t,this.remotePeer=n,this.direction=e.direction,this.status="open",this.timeline=e.timeline,this.multiplexer=e.multiplexer,this.encryption=e.encryption,this.limits=e.limits,this.log=e.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`),this.remoteAddr.getPeerId()==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),this._newStream=s,this._close=i,this._abort=o,this._getStreams=a,this.tags=[]}[Symbol.toStringTag]="Connection";[gh]=!0;get streams(){return this._getStreams()}async newStream(e,t){if(this.status==="closing")throw new wh("the connection is being closed");if(this.status==="closed")throw new bl("the connection is closed");if(Array.isArray(e)||(e=[e]),this.limits!=null&&t?.runOnLimitedConnection!==!0)throw new Sl("Cannot open protocol stream on limited connection");const n=await this._newStream(e,t);return n.direction="outbound",n}async close(e={}){if(!(this.status==="closed"||this.status==="closing")){if(this.log("closing connection to %a",this.remoteAddr),this.status="closing",e.signal==null){const t=AbortSignal.timeout(gS);e={...e,signal:t}}try{this.log.trace("closing underlying transport"),await this._close(e),this.log.trace("updating timeline with close time"),this.status="closed",this.timeline.close=Date.now()}catch(t){this.log.error("error encountered during graceful close of connection to %a",this.remoteAddr,t),this.abort(t)}}}abort(e){this.status!=="closed"&&(this.log.error("aborting connection to %a due to error",this.remoteAddr,e),this.status="closing",this._abort(e),this.status="closed",this.timeline.close=Date.now())}}function yS(r){return new mS(r)}function wS(r,e){try{const{options:t}=e.getHandler(r);return t.maxInboundStreams}catch(t){if(t.name!=="UnhandledProtocolError")throw t}return oh}function bS(r,e,t={}){try{const{options:n}=e.getHandler(r);if(n.maxOutboundStreams!=null)return n.maxOutboundStreams}catch(n){if(n.name!=="UnhandledProtocolError")throw n}return t.maxOutboundStreams??ah}function gl(r,e,t){let n=0;return t.streams.forEach(s=>{s.direction===e&&s.protocol===r&&n++}),n}class vS{components;connectionEncrypters;streamMuxers;inboundUpgradeTimeout;inboundStreamProtocolNegotiationTimeout;outboundStreamProtocolNegotiationTimeout;events;metrics;constructor(e,t){this.components=e,this.connectionEncrypters=new Map,t.connectionEncrypters.forEach(n=>{this.connectionEncrypters.set(n.protocol,n)}),this.streamMuxers=new Map,t.streamMuxers.forEach(n=>{this.streamMuxers.set(n.protocol,n)}),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??y1,this.inboundStreamProtocolNegotiationTimeout=t.inboundStreamProtocolNegotiationTimeout??al,this.outboundStreamProtocolNegotiationTimeout=t.outboundStreamProtocolNegotiationTimeout??al,this.events=e.events,this.metrics={dials:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total")}}[Symbol.toStringTag]="@libp2p/upgrader";async shouldBlockConnection(e,...t){const n=this.components.connectionGater[e];if(n==null)return;if(await n.apply(this.components.connectionGater,t)===!0)throw new QE(`The multiaddr connection is blocked by gater.${e}`)}createInboundAbortSignal(e){return Lt([AbortSignal.timeout(this.inboundUpgradeTimeout),e])}async upgradeInbound(e,t){let n=!1;const s=this.createInboundAbortSignal(t.signal);try{if(this.metrics.dials?.increment({inbound:!0}),n=await this.components.connectionManager.acceptIncomingConnection(e),!n)throw new jE("Connection denied");await this.shouldBlockConnection("denyInboundConnection",e),await this._performUpgrade(e,"inbound",{...t,signal:s})}catch(i){throw this.metrics.errors?.increment({inbound:!0}),i}finally{s.clear(),n&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t){try{this.metrics.dials?.increment({outbound:!0});const n=e.remoteAddr.getPeerId();let s;n!=null&&(s=lt(n),await this.shouldBlockConnection("denyOutboundConnection",s,e));let i="outbound";return t.initiator===!1&&(i="inbound"),await this._performUpgrade(e,i,t)}catch(n){throw this.metrics.errors?.increment({outbound:!0}),n}}async _performUpgrade(e,t,n){let s,i,o,a,c;this.components.metrics?.trackMultiaddrConnection(e),e.log.trace("starting the %s connection upgrade",t);let l=e;if(n?.skipProtection!==!0){const u=this.components.connectionProtector;u!=null&&(e.log("protecting the %s connection",t),l=await u.protect(e,n))}try{if(s=l,n?.skipEncryption!==!0){n?.onProgress?.(new se(`upgrader:encrypt-${t}-connection`)),{conn:s,remotePeer:i,protocol:c,streamMuxer:a}=await(t==="inbound"?this._encryptInbound(l,n):this._encryptOutbound(l,n));const u={...l,...s};await this.shouldBlockConnection(t==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",i,u)}else{const u=e.remoteAddr.getPeerId();if(u==null)throw new po(`${t} connection that skipped encryption must have a peer id`);const d=lt(u);c="native",i=d}if(i.equals(this.components.peerId)){const u=new El("Can not dial self");throw e.abort(u),u}if(o=s,n?.muxerFactory!=null)a=n.muxerFactory;else if(a==null&&this.streamMuxers.size>0){n?.onProgress?.(new se(`upgrader:multiplex-${t}-connection`));const u=await(t==="inbound"?this._multiplexInbound({...l,...s},this.streamMuxers,n):this._multiplexOutbound({...l,...s},this.streamMuxers,n));a=u.muxerFactory,o=u.stream}}catch(u){throw e.log.error("failed to upgrade inbound connection %s %a - %e",t==="inbound"?"from":"to",e.remoteAddr,u),u}return await this.shouldBlockConnection(t==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",i,e),e.log("successfully upgraded %s connection",t),this._createConnection({cryptoProtocol:c,direction:t,maConn:e,upgradedConn:o,muxerFactory:a,remotePeer:i,limits:n?.limits})}_createConnection(e){const{cryptoProtocol:t,direction:n,maConn:s,upgradedConn:i,remotePeer:o,muxerFactory:a,limits:c}=e;let l,u,d;a!=null&&(l=a.createStreamMuxer({direction:n,onIncomingStream:f=>{d!=null&&Promise.resolve().then(async()=>{const g=this.components.registrar.getProtocols(),m=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout),{stream:v,protocol:P}=await Ti(f,g,{signal:m,log:f.log,yieldBytes:!1});if(d==null)return;d.log("incoming stream opened on %s",P);const b=wS(P,this.components.registrar);if(gl(P,"inbound",d)===b){const E=new xh(`Too many inbound protocol streams for protocol "${P}" - limit ${b}`);throw f.abort(E),E}f.source=v.source,f.sink=v.sink,f.protocol=P,v.closeWrite!=null&&(f.closeWrite=v.closeWrite),v.closeRead!=null&&(f.closeRead=v.closeRead),v.close!=null&&(f.close=v.close),await this.components.peerStore.merge(o,{protocols:[P]}),this.components.metrics?.trackProtocolStream(f,d),this._onStream({connection:d,stream:f,protocol:P})}).catch(async g=>{d.log.error("error handling incoming stream id %s - %e",f.id,g),f.timeline.close==null&&await f.close()})}}),u=async(f,g={})=>{if(l==null)throw new Rn("Connection is not multiplexed");d.log.trace("starting new stream for protocols %s",f);const m=await l.newStream();d.log.trace("started new stream %s for protocols %s",m.id,f);try{if(g.signal==null){m.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",f);const E=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);g={...g,signal:E}}m.log.trace("selecting protocol from protocols %s",f);const{stream:v,protocol:P}=await Ii(m,f,{...g,log:m.log,yieldBytes:!0});m.log.trace("selected protocol %s",P);const b=bS(P,this.components.registrar,g),w=gl(P,"outbound",d);if(w>=b){const E=new xl(`Too many outbound protocol streams for protocol "${P}" - ${w}/${b}`);throw m.abort(E),E}return await this.components.peerStore.merge(o,{protocols:[P]}),m.source=v.source,m.sink=v.sink,m.protocol=P,v.closeWrite!=null&&(m.closeWrite=v.closeWrite),v.closeRead!=null&&(m.closeRead=v.closeRead),v.close!=null&&(m.close=v.close),this.components.metrics?.trackProtocolStream(m,d),m}catch(v){throw d.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",n==="inbound"?"from":"to",e.maConn.remoteAddr,f,v),m.timeline.close==null&&m.abort(v),v}},Promise.all([l.sink(i.source),i.sink(l.source)]).catch(f=>{d.log.error("error piping data through muxer - %e",f)}));const h=s.timeline;s.timeline=new Proxy(h,{set:(...f)=>(f[1]==="close"&&f[2]!=null&&h.close==null&&(async()=>{try{d.status==="open"&&await d.close()}catch(g){d.log.error("error closing connection after timeline close %e",g)}finally{this.events.safeDispatchEvent("connection:close",{detail:d})}})().catch(g=>{d.log.error("error thrown while dispatching connection:close event %e",g)}),Reflect.set(...f))}),s.timeline.upgraded=Date.now();const p=()=>{throw new Rn("Connection is not multiplexed")};return d=yS({remoteAddr:s.remoteAddr,remotePeer:o,status:"open",direction:n,timeline:s.timeline,multiplexer:l?.protocol,encryption:t,limits:c,logger:this.components.logger,newStream:u??p,getStreams:()=>l?.streams??[],close:async f=>{await l?.close(f),await s.close(f)},abort:f=>{s.abort(f),l?.abort(f)}}),this.events.safeDispatchEvent("connection:open",{detail:d}),d.__maConnTimeline=h,d}_onStream(e){const{connection:t,stream:n,protocol:s}=e,{handler:i,options:o}=this.components.registrar.getHandler(s);if(t.limits!=null&&o.runOnLimitedConnection!==!0)throw new Sl("Cannot open protocol stream on limited connection");i({connection:t,stream:n})}async _encryptInbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{const{stream:s,protocol:i}=await Ti(e,n,{...t,log:e.log}),o=this.connectionEncrypters.get(i);if(o==null)throw new Mn(`no crypto module found for ${i}`);return e.log("encrypting inbound connection to %a using %s",e.remoteAddr,i),{...await o.secureInbound(s,t),protocol:i}}catch(s){throw e.log.error("encrypting inbound connection from %a failed",e.remoteAddr,s),new Mn(s.message)}}async _encryptOutbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{e.log.trace("selecting encrypter from %s",n);const{stream:s,protocol:i}=await Ii(e,n,{...t,log:e.log,yieldBytes:!0}),o=this.connectionEncrypters.get(i);if(o==null)throw new Mn(`no crypto module found for ${i}`);return e.log("encrypting outbound connection to %a using %s",e.remoteAddr,i),{...await o.secureOutbound(s,t),protocol:i}}catch(s){throw e.log.error("encrypting outbound connection to %a failed",e.remoteAddr,s),new Mn(s.message)}}async _multiplexOutbound(e,t,n){const s=Array.from(t.keys());e.log("outbound selecting muxer %s",s);try{e.log.trace("selecting stream muxer from %s",s);const{stream:i,protocol:o}=await Ii(e,s,{...n,log:e.log,yieldBytes:!0});e.log("selected %s as muxer protocol",o);const a=t.get(o);return{stream:i,muxerFactory:a}}catch(i){throw e.log.error("error multiplexing outbound connection",i),new Rn(String(i))}}async _multiplexInbound(e,t,n){const s=Array.from(t.keys());e.log("inbound handling muxers %s",s);try{const{stream:i,protocol:o}=await Ti(e,s,{...n,log:e.log}),a=t.get(o);return{stream:i,muxerFactory:a}}catch(i){throw e.log.error("error multiplexing inbound connection",i),new Rn(String(i))}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}const ch="2.8.8",lh="js-libp2p";function ES(r,e){return`${r??lh}/${e??ch} browser/${globalThis.navigator.userAgent}`}class SS extends _t{peerId;peerStore;contentRouting;peerRouting;metrics;services;logger;status;components;log;constructor(e){super(),this.status="stopped";const t=new _t,n=t.dispatchEvent.bind(t);t.dispatchEvent=l=>{const u=n(l),d=this.dispatchEvent(new CustomEvent(l.type,{detail:l.detail}));return u||d},this.peerId=e.peerId,this.logger=e.logger??Vd(),this.log=this.logger.forComponent("libp2p"),this.services={};const s=e.nodeInfo?.name??lh,i=e.nodeInfo?.version??ch,o=this.components=r1({peerId:e.peerId,privateKey:e.privateKey,nodeInfo:{name:s,version:i,userAgent:e.nodeInfo?.userAgent??ES(s,i)},logger:this.logger,events:t,datastore:e.datastore??new yE,connectionGater:l1(e.connectionGater),dns:e.dns});this.peerStore=this.configureComponent("peerStore",hE(o,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),e.metrics!=null&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),o.events.addEventListener("peer:update",l=>{if(l.detail.previous==null){const u={id:l.detail.peer.id,multiaddrs:l.detail.peer.addresses.map(d=>d.multiaddr)};o.events.safeDispatchEvent("peer:discovery",{detail:u})}}),e.connectionProtector!=null&&this.configureComponent("connectionProtector",e.connectionProtector(o)),this.components.upgrader=new vS(this.components,{connectionEncrypters:(e.connectionEncrypters??[]).map((l,u)=>this.configureComponent(`connection-encryption-${u}`,l(this.components))),streamMuxers:(e.streamMuxers??[]).map((l,u)=>this.configureComponent(`stream-muxers-${u}`,l(this.components))),inboundUpgradeTimeout:e.connectionManager?.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:e.connectionManager?.inboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:e.connectionManager?.outboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout}),this.configureComponent("transportManager",new uS(this.components,e.transportManager)),this.configureComponent("connectionManager",new G1(this.components,e.connectionManager)),e.connectionMonitor?.enabled!==!1&&this.configureComponent("connectionMonitor",new nS(this.components,e.connectionMonitor)),this.configureComponent("registrar",new aS(this.components)),this.configureComponent("addressManager",new zE(this.components,e.addresses));const a=(e.peerRouters??[]).map((l,u)=>this.configureComponent(`peer-router-${u}`,l(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new iS(this.components,{routers:a}));const c=(e.contentRouters??[]).map((l,u)=>this.configureComponent(`content-router-${u}`,l(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new sS(this.components,{routers:c})),this.configureComponent("randomWalk",new oS(this.components)),(e.peerDiscovery??[]).forEach((l,u)=>{this.configureComponent(`peer-discovery-${u}`,l(this.components)).addEventListener("peer",h=>{this.#e(h)})}),e.transports?.forEach((l,u)=>{this.components.transportManager.add(this.configureComponent(`transport-${u}`,l(this.components)))}),e.services!=null)for(const l of Object.keys(e.services)){const u=e.services[l],d=u(this.components);if(d==null){this.log.error("service factory %s returned null or undefined instance",l);continue}this.services[l]=d,this.configureComponent(l,d),d[ra]!=null&&(this.log("registering service %s for content routing",l),c.push(d[ra])),d[sa]!=null&&(this.log("registering service %s for peer routing",l),a.push(d[sa])),d[na]!=null&&(this.log("registering service %s for peer discovery",l),d[na].addEventListener?.("peer",h=>{this.#e(h)}))}n1(o)}configureComponent(e,t){return t==null&&this.log.error("component %s was null or undefined",e),this.components[e]=t,t}async start(){if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await this.components.beforeStart?.(),await this.components.start(),await this.components.afterStart?.(),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started")}catch(e){throw this.log.error("An error occurred starting libp2p",e),this.status="started",await this.stop(),e}}}async stop(){this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await this.components.beforeStop?.(),await this.components.stop(),await this.components.afterStop?.(),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new sr;for(const t of this.components.connectionManager.getConnections())e.add(t.remotePeer);return Array.from(e)}async dial(e,t={}){return this.components.connectionManager.openConnection(e,{priority:75,...t})}async dialProtocol(e,t,n={}){if(t==null)throw new W("no protocols were provided to open a stream");if(t=Array.isArray(t)?t:[t],t.length===0)throw new W("no protocols were provided to open a stream");return(await this.dial(e,n)).newStream(t,n)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e,t={}){ks(e)&&(e=lt(e.getPeerId()??"")),await this.components.connectionManager.closeConnections(e,t)}async getPublicKey(e,t={}){if(this.log("getPublicKey %p",e),e.publicKey!=null)return e.publicKey;try{const o=await this.peerStore.get(e);if(o.id.publicKey!=null)return o.id.publicKey}catch(o){if(o.name!=="NotFoundError")throw o}const n=tt([K("/pk/"),e.toMultihash().bytes]),s=await this.contentRouting.get(n,t),i=Dt(s);return await this.peerStore.patch(e,{publicKey:i}),i}async handle(e,t,n){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async s=>{await this.components.registrar.handle(s,t,n)}))}async unhandle(e){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async t=>{await this.components.registrar.unhandle(t)}))}async register(e,t){return this.components.registrar.register(e,t)}unregister(e){this.components.registrar.unregister(e)}async isDialable(e,t={}){return this.components.connectionManager.isDialable(e,t)}#e(e){const{detail:t}=e;if(t.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(t.id,{multiaddrs:t.multiaddrs}).catch(n=>{this.log.error(n)})}}async function xS(r={}){r.privateKey??=await im();const e=new SS({...await Iv(r),peerId:um(r.privateKey)});return r.start!==!1&&await e.start(),e}class AS{mode;connections;activeTransfer;selectedFile;activePeerId;activeStream;transferConnectionId;constructor(){this.mode="idle",this.connections=new Map,this.activeTransfer=null,this.selectedFile=null,this.activePeerId=null,this.activeStream=null,this.transferConnectionId=null}setMode(e){this.mode=e}getMode(){return this.mode}reset(){this.mode="idle",this.connections.clear(),this.activeTransfer=!1,this.selectedFile=null,this.activePeerId=null,this.activeStream=null}addConnection(e,t){const n=this.connections.get(e.toString())||new Map;n.set(t.id,t),this.connections.set(e.toString(),n)}removeConnection(e,t){const n=this.connections.get(e);n?.delete(t),n&&this.connections.set(e,n)}removeAllConnectionsWithPeer(e){this.connections.delete(e)}getConnectionsForPeer(e){return this.connections.get(e)}getAllConnections(){return Array.from(this.connections.values())}setActiveTransfer(){this.activeTransfer=!0}clearActiveTransfer(){this.activeTransfer=!1}isTransferActive(){return!!this.activeTransfer}setTransferConnectionId(e){this.transferConnectionId=e}getTransferConnectionId(){return this.transferConnectionId}setSelectedFile(e){this.selectedFile=e}getSelectedFile(){return this.selectedFile}clearSelectedFile(){this.selectedFile=null}setActivePeer(e){this.activePeerId=e}getActivePeer(){return this.activePeerId}setActiveStream(e){this.activeStream=e}getActiveStream(){return this.activeStream}}class CS{node;appState;errorHandler;config;fileTransferHandler;connectionUpgrades;retryAttempts;constructor(e,t,n,s,i){this.node=e,this.appState=t,this.errorHandler=n,this.config=s,this.fileTransferHandler=i,this.connectionUpgrades=new Map,this.retryAttempts=new Map}async onConnectionEstablished(e){const t=e.detail,n=t.remotePeer,s=n.toString(),i=t.remoteAddr.toString();if(console.log(`Connection OPENED with: ${s} on ${i}`),i.includes("/p2p-circuit")){const o=t.close.bind(t);let a=!0;t.close=async()=>{if(a){console.log(`Blocking premature close of circuit connection to ${s}`);return}return o()},setTimeout(()=>{a=!1;const c=this.connectionUpgrades.get(s);c&&c.webrtc&&c.webrtc.status==="open"&&console.log("Allowing circuit connection closure - WebRTC established")},3e4)}this.appState.addConnection(n,t),this.connectionUpgrades.has(t.id)||this.connectionUpgrades.set(t.id,{relay:null,webrtc:null,upgrading:!1,stable:!1}),await this.handleConnectionType(t,s,i)}async onConnectionClosed(e){const t=e.detail.remotePeer.toString(),n=e.detail.id;if(this.connectionUpgrades.delete(n),this.appState.isTransferActive()&&this.appState.getMode()==="sender"&&t===this.appState.getActivePeer()&&n===this.appState.getTransferConnectionId()){this.appState.removeConnection(t,e.detail.id),await this.closePeer(e.detail.remotePeer),await this.dialPeer(e.detail.remotePeer,{signal:AbortSignal.timeout(6e4)});let s=this.retryAttempts.get(t)||0;s++,this.retryAttempts.set(t,s)}else this.appState.removeConnection(t,n)}async dialPeer(e,t={}){try{return await this.node.dial(e,t)}catch(n){throw this.errorHandler.handleConnectionError(n,{peerId:e.toString()}),n}}async closePeer(e){const t=this.appState.getConnectionsForPeer(e.toString());if(t)for(const n of t.values())n&&(await n.close(),t.delete(n.id))}async upgradeConnection(e){const t=this.connectionUpgrades.get(e);!t||t.upgrading||(t.upgrading=!0,t.relay&&t.webrtc&&setTimeout(()=>{t.webrtc?.status==="open"&&t.relay?.close()},5e3))}isDirectConnection(e){return e.remoteAddr.toString().includes("/webrtc")&&!e.remoteAddr.toString().includes("/p2p-circuit")}isRelayConnection(e){return e.remoteAddr.toString().includes("/p2p-circuit")}async waitForWebRTCStream(e,t=3e4){const n=e;return n.channel?n.channel.readyState==="open"?e:new Promise((s,i)=>{const o=setTimeout(()=>{i(new Error("WebRTC stream open timeout"))},t),a=()=>{clearTimeout(o),n.channel.removeEventListener("open",a),n.channel.removeEventListener("error",c),s(e)},c=l=>{clearTimeout(o),n.channel.removeEventListener("open",a),n.channel.removeEventListener("error",c),i(l)};n.channel.addEventListener("open",a),n.channel.addEventListener("error",c)}):e}async handleConnectionType(e,t,n){const s=this.connectionUpgrades.get(e.id);if(!s)return;const i=this.config.getRelayAddress();if(n.includes("/p2p-circuit"))s.relay=e,console.log(`Relay connection established for ${t}`);else if(n.includes("/webrtc")){if(s.webrtc=e,this.appState.getMode()==="sender"&&this.appState.getSelectedFile()!=null){const o=Y(n),a=await this.node.dialProtocol(o,this.config.getFileTransferProtocol());this.appState.setTransferConnectionId(e.id),this.appState.setActivePeer(t),this.appState.setActiveStream(await this.waitForWebRTCStream(a)),await this.waitForWebRTCStream(a).then(()=>{this.fileTransferHandler.startFileTransfer()})}console.log(`WebRTC connection established for ${t}`)}else n===i&&(s.relay=e,console.log(`Direct relay connection established for ${t}`))}}class IS{node;appState;progressTracker;uiManager;errorHandler;protocol;transferProgressBytes;receivedFileBuffer;fileNameFromHeader;fileSizeFromHeader;fileTypeFromHeader;headerReceived;receivedBytesTotal;retryAttempts;constructor(e,t,n,s,i){this.node=e,this.appState=t,this.progressTracker=n,this.uiManager=s,this.errorHandler=i,this.protocol="/fileferry/filetransfer/1.0.0",this.transferProgressBytes=0,this.receivedFileBuffer=[],this.fileNameFromHeader="downloaded_file",this.fileSizeFromHeader=0,this.fileTypeFromHeader="application/octet-stream",this.headerReceived=!1,this.receivedBytesTotal=0,this.retryAttempts=0}setupFileTransferProtocol(){const e=async({stream:t,connection:n})=>{this.appState.setActivePeer(n.remotePeer.toString()),this.appState.setTransferConnectionId(n.id),this.appState.isTransferActive()?(console.log("Resuming file transfer after reconnection."),this.appState.setActiveStream(t)):(this.appState.setActiveStream(t),this.appState.setActiveTransfer()),await this.handleFileTransfer()};this.node.handle(this.protocol,e)}async startFileTransfer(){try{const e=this.appState.getActiveStream(),t=this.appState.getSelectedFile();if(!e||!t)throw new Error("No active stream or file to start transfer.");this.appState.isTransferActive()?(console.log("Resuming file transfer after reconnection."),await this.sendFileToStream(e,t)):(this.appState.setActiveTransfer(),await this.sendFileToStream(e,t)),this.appState.clearActiveTransfer()}catch(e){this.retryAttempts>10&&this.errorHandler.handleTransferError(e,{direction:"send"})}}async handleFileTransfer(){try{const e=this.appState.getActiveStream();if(!e)throw new Error("No active stream to handle transfer.");await this.receiveFileFromStream(e)}catch(e){this.retryAttempts>10&&(this._resetReceiverState(),this.errorHandler.handleTransferError(e,{direction:"receive"}))}}async sendFileToStream(e,t,n=1024*64){try{const s=this.createFileHeader(t),i=new TextEncoder().encode(s+`
`);let o=0;const a=e.channel,c=a.bufferedAmountLowThreshold||1024*64,l=async function*(){yield new j(i),await new Promise(u=>setTimeout(u,1));for(let u=0;u<t.size;u+=n){const d=t.slice(u,Math.min(u+n,t.size)),h=new Uint8Array(await d.arrayBuffer());if(o<this.transferProgressBytes){o+=h.length;continue}yield new j(h),a.bufferedAmount>c&&await new Promise(p=>{a.addEventListener("bufferedamountlow",()=>p(),{once:!0})}),o+=h.length,this.transferProgressBytes+=h.length,this.progressTracker.updateProgress(this.transferProgressBytes,t.size,"send")}}.bind(this);await Uo(l(),e.sink),this.progressTracker.updateProgress(this.transferProgressBytes,t.size,"send",!0),this.transferProgressBytes=0}catch(s){throw s}}createFileHeader(e){return JSON.stringify({name:e.name,size:e.size,type:e.type||"application/octet-stream"})}async receiveFileFromStream(e){try{for await(const t of e.source){if(!t||t.length===0)continue;const n=t.subarray();if(this.headerReceived)this.receivedFileBuffer.push(n),this.receivedBytesTotal+=n.length,this.progressTracker.updateProgress(this.receivedBytesTotal,this.fileSizeFromHeader,"receive");else{const s=this.parseFileHeader(n);s.header&&(this.fileNameFromHeader=s.header.name||this.fileNameFromHeader,this.fileSizeFromHeader=s.header.size||this.fileSizeFromHeader,this.fileTypeFromHeader=s.header.type||this.fileTypeFromHeader,this.headerReceived=!0,console.log(`Receiving file: ${this.fileNameFromHeader} (${this.fileSizeFromHeader} bytes)`)),s.bodyData&&s.bodyData.length>0&&(this.receivedFileBuffer.push(s.bodyData),this.receivedBytesTotal+=s.bodyData.length,this.progressTracker.updateProgress(this.receivedBytesTotal,this.fileSizeFromHeader,"receive"))}if(this.receivedBytesTotal>=this.fileSizeFromHeader&&this.fileSizeFromHeader>0){this.progressTracker.updateProgress(this.receivedBytesTotal,this.fileSizeFromHeader,"receive",!0),this.uiManager.showReceivedFileDetails(this.fileNameFromHeader,this.fileSizeFromHeader),await this.saveReceivedFile(this.receivedFileBuffer,this.fileNameFromHeader,this.fileTypeFromHeader),this.appState.clearActiveTransfer(),await this.closeActiveStream();break}}}catch(t){throw t}}async closeActiveStream(){const e=this.appState.getActiveStream();e&&(await e.close(),this.appState.setActiveStream(null))}parseFileHeader(e){try{const t=new TextDecoder("utf-8",{fatal:!1}).decode(e),n=t.indexOf(`
`);if(n!==-1){const s=t.substring(0,n),o=new TextEncoder().encode(s+`
`).byteLength;try{const a=JSON.parse(s),c=o<e.byteLength?e.subarray(o):null;return{header:a,bodyData:c}}catch{return{header:null,bodyData:e}}}return{header:null,bodyData:e}}catch{return{header:null,bodyData:e}}}async saveReceivedFile(e,t,n){const s=new Blob(e,{type:n}),i=URL.createObjectURL(s),o=document.createElement("a");o.href=i,o.download=t,o.style.display="none",document.body.appendChild(o),o.click(),document.body.removeChild(o),setTimeout(()=>{URL.revokeObjectURL(i)},100)}_resetReceiverState(){this.receivedFileBuffer=[],this.fileNameFromHeader="downloaded_file",this.fileSizeFromHeader=0,this.fileTypeFromHeader="application/octet-stream",this.headerReceived=!1,this.receivedBytesTotal=0}}class TS{node;appState;errorHandler;relayPeerId;relayMultiaddr;reservationStatus;constructor(e,t,n){this.node=e,this.appState=t,this.errorHandler=n,this.relayPeerId=null,this.relayMultiaddr=null,this.reservationStatus=null}async connectToRelay(e){try{if(this.relayMultiaddr=Y(e),!this.relayMultiaddr.getPeerId())throw new Error("Could not parse PeerId from relay multiaddr");this.relayPeerId=this.parseRelayPeerId(this.relayMultiaddr),console.log(`Connecting to relay: ${e}`),console.log(`Relay peer ID: ${this.relayPeerId}`);const n=await this.node.dial(this.relayMultiaddr,{signal:AbortSignal.timeout(1e4)});return console.log(`Successfully connected to relay: ${this.relayPeerId}`),n}catch(t){const n=t;throw console.error(`Failed to connect to relay: ${n.message}`),this.errorHandler.handleConnectionError(n,{relay:e}),t}}async waitForRelayAddress(){return new Promise((e,t)=>{let n,s=0;const i=60,o=()=>{s++;const c=this.getCircuitAddress();if(c){console.log(`Circuit address obtained: ${c.toString()}`),clearInterval(n),e(c);return}if(s>=i){clearInterval(n),t(new Error("Timeout: Could not obtain a circuit address via relay."));return}console.log(`Waiting for circuit address... (attempt ${s}/${i})`)},a=this.getCircuitAddress();if(a){console.log(`Circuit address already available: ${a.toString()}`),e(a);return}n=window.setInterval(o,500)})}isConnectedToRelay(){if(!this.relayPeerId)return console.log("No relay peer ID set"),!1;const e=this.appState.getConnectionsForPeer(this.relayPeerId.toString());if(!e)return!1;let t=!1;for(const n of e.values())if(n!==void 0&&n.status==="open"){t=!0;break}return console.log(`Relay connection status: ${t?"connected":"disconnected"}`),t}getCircuitAddress(){return this.node.getMultiaddrs().find(t=>t.toString().includes("/p2p-circuit"))}async reserveRelay(){try{return this.isConnectedToRelay()?await this.waitForRelayAddress()?(this.reservationStatus="reserved",console.log("Relay reservation successful"),!0):!1:(console.log("Not connected to relay, cannot reserve"),!1)}catch(e){const t=e;return console.error(`Relay reservation failed: ${t.message}`),this.errorHandler.handleConnectionError(t,{operation:"reserveRelay"}),!1}}async releaseRelay(){try{if(this.reservationStatus!=="reserved")return console.log("No active relay reservation to release"),!0;if(console.log("Releasing relay reservation..."),this.relayPeerId){const e=this.appState.getConnectionsForPeer(this.relayPeerId.toString());if(e)for(const t of e.values())t&&t.status==="open"&&(await t.close(),console.log("Relay connection closed"));this.appState.removeAllConnectionsWithPeer(this.relayPeerId.toString())}return this.reservationStatus=null,console.log("Relay reservation released"),!0}catch(e){const t=e;return console.error(`Failed to release relay: ${t.message}`),this.errorHandler.handleConnectionError(t,{operation:"releaseRelay"}),!1}}parseRelayPeerId(e){try{const t=e.getPeerId();if(!t)throw new Error("No peer ID found in multiaddr");if(!e.protos().find(s=>s.name==="p2p"))throw new Error("Multiaddr does not contain a p2p component");return console.log(`Parsed relay peer ID: ${t}`),{toString:()=>t}}catch(t){const n=t;return console.error(`Failed to parse relay peer ID: ${n.message}`),this.errorHandler.handleConnectionError(n,{operation:"parseRelayPeerId"}),null}}validateRelayConnection(e){if(!e)return console.log("No connection provided for validation"),!1;if(e.status!=="open")return console.log(`Connection status is ${e.status}, not open`),!1;if(!this.relayPeerId)return console.log("No relay peer ID to validate against"),!1;const t=e.remotePeer.toString()===this.relayPeerId.toString();return console.log(`Relay connection validation: ${t?"valid":"invalid"}`),t}getRelayPeerId(){return this.relayPeerId}getRelayMultiaddr(){return this.relayMultiaddr}getReservationStatus(){return this.reservationStatus}async canUseRelay(){return this.isConnectedToRelay()?!0:(console.log("Cannot use relay: not connected"),!1)}getRelayInfo(){return{peerId:this.relayPeerId?.toString(),multiaddr:this.relayMultiaddr?.toString(),connected:this.isConnectedToRelay(),reservationStatus:this.reservationStatus,circuitAddress:this.getCircuitAddress()?.toString()}}}class PS{geoLocUrl;hostUrl;geoUserUrl;cacheKey;cacheDuration;constructor(){this.geoLocUrl="https://raw.githubusercontent.com/pradt2/always-online-stun/master/geoip_cache.txt",this.hostUrl="https://raw.githubusercontent.com/pradt2/always-online-stun/master/valid_hosts.txt",this.geoUserUrl="http://ip-api.com/json/",this.cacheKey="userGeoData",this.cacheDuration=48*60*60*1e3}async getClosestStunServer(){try{const e=await this.fetchGeoData(),t=await this.getUserGeoData(),n=await this.fetchStunServers();return this.findClosestServer(t,e,n)}catch(e){console.error("Error in getClosestStunServer:",e),this.clearExpiredCache();return}}async fetchGeoData(){return await(await fetch(this.geoLocUrl)).json()}async getUserGeoData(){const e=this.getCachedGeoData();if(e)return e;const t=await fetch(this.geoUserUrl);if(!t.ok)throw new Error(`Failed to fetch user geo data: ${t.status} ${t.statusText}`);const n=await t.json();return this.setCachedGeoData(n),n}calculateDistance(e,t,n,s){return Math.sqrt(Math.pow(e-n,2)+Math.pow(t-s,2))}findClosestServer(e,t,n){const{lat:s,lon:i}=e;return n.trim().split(`
`).map(o=>{const a=o.split(":")[0];if(!t[a])return[o,1/0];const[c,l]=t[a];if(typeof c!="number"||typeof l!="number")return[o,1/0];const u=this.calculateDistance(s,i,c,l);return[o,u]}).reduce(([o,a],[c,l])=>a<=l?[o,a]:[c,l])[0]}getCachedGeoData(){const e=localStorage.getItem(this.cacheKey);if(e){const t=JSON.parse(e);if(t.expiry&&t.expiry>Date.now())return t.data;localStorage.removeItem(this.cacheKey)}return null}setCachedGeoData(e){const t={data:e,expiry:Date.now()+this.cacheDuration};localStorage.setItem(this.cacheKey,JSON.stringify(t))}clearExpiredCache(){localStorage.removeItem(this.cacheKey)}async fetchStunServers(){return await(await fetch(this.hostUrl)).text()}validateStunServer(e){return!!(e&&e.includes(":")&&e.split(":").length===2)}}var Nn={exports:{}},ml;function kS(){return ml||(ml=1,function(r,e){var t=globalThis.require&&e||{};(function(n,s){let i=globalThis.crypto;s._sep=/[\s,:-]+/,s._mword="mnemonic",s._normalize=function(o){return o.normalize("NFKD").trim().toLowerCase()},s.generate=async function(o=128){let a=o/8,c=i.getRandomValues(new Uint8Array(a));return await s.encode(c)},s.encode=async function(o){let a=8*o.length,c=a/32;o=new Uint8Array(o);let l=await i.subtle.digest("SHA-256",o),u=new Uint8Array(l),d="";o.forEach(function(v){let P=v.toString(2).padStart(8,"0");d+=P});let p=u[0].toString(2);p=p.padStart(8,"0");let f=p.slice(0,c);d+=f;let g=[];for(let v=0;v<a+c;v+=11){let P=parseInt(d.slice(v,v+11).padStart(8,"0"),2);g.push(P)}return g.map(function(v){return s.base2048[v]}).join(" ")},s.verify=async function(o){return await s.decode(o),!0},s.checksum=s.verify,s.decode=async function(o,a){o=s._normalize(o);let c=[];o.split(s._sep).forEach(function(b){let w=s.base2048.indexOf(b);if(w<0){let E=new Error(`dashphrase.js: decode failed: unknown word '${b}'`);throw E.code="E_UNKNOWN_WORD",E}c.push(w)});let u=c.map(function(b){return b.toString(2).padStart(11,"0")}).join(""),d=Math.floor(u.length/32),h=u.length-d,p=u.slice(-d),f=[];for(let b=0;b<h;b+=8){let w=u.slice(b,b+8),E=parseInt(w,2);E>=0&&f.push(E)}let g=Uint8Array.from(f),m=await i.subtle.digest("SHA-256",g),P=new Uint8Array(m)[0].toString(2).padStart(8,"0").slice(0,d);if(P!==p&&a?.verify!==!1){let b=new Error(`dashphrase.js: bad checksum: expected '${P}' but got '${p}'`);throw b.code="E_BAD_CHECKSUM",b}return g},s.toSeed=async function(o,a="",c={}){c.verify!==!1&&await s.verify(o),o=s._normalize(o),a=a.normalize("NFKD");let u=new TextEncoder().encode(o),d=new TextEncoder().encode(s._mword+a),g=await s._pbkdf2(u,d,2048,512,"SHA-512");return new Uint8Array(g)},s.pbkdf2=s.toSeed,s._pbkdf2=async function(a,c,l,u,d){let h=!1,p=await i.subtle.importKey("raw",a,{name:"PBKDF2"},h,["deriveKey"]);h=!0;let f=await i.subtle.deriveKey({name:"PBKDF2",salt:c,iterations:l,hash:d},p,{name:"HMAC",hash:d,length:u},h,["sign","verify"]),g=await i.subtle.exportKey("raw",f);return new Uint8Array(g)},s._sha256=async function(o,a=""){o=s._normalize(o),a=a.normalize("NFKD");let c=new TextEncoder().encode(o),l=new TextEncoder().encode(a),u=new Uint8Array(c.length+l.length),d=0;for(let p=0;p<c.length;p+=1)u[d]=c[p],d+=1;for(let p=0;p<l.length;p+=1)u[d]=l[p],d+=1;let h=await i.subtle.digest("SHA-256",u);return new Uint8Array(h)},s.CATMONIC="cat swing flag economy stadium alone churn speed unique patch report train",s.ZOOMONIC="zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",s.ZECRET="TREZOR",s.ZEED="ac27495480225222079d7be181583751e86f571027b0497b5b5d11218e0a8a13332572917f0f8e5a589620c6f15b11c61dee327651a14c34e18231052e48c069",s.base2048="abandon ability able about above absent absorb abstract absurd abuse access accident account accuse achieve acid acoustic acquire across act action actor actress actual adapt add addict address adjust admit adult advance advice aerobic affair afford afraid again age agent agree ahead aim air airport aisle alarm album alcohol alert alien all alley allow almost alone alpha already also alter always amateur amazing among amount amused analyst anchor ancient anger angle angry animal ankle announce annual another answer antenna antique anxiety any apart apology appear apple approve april arch arctic area arena argue arm armed armor army around arrange arrest arrive arrow art artefact artist artwork ask aspect assault asset assist assume asthma athlete atom attack attend attitude attract auction audit august aunt author auto autumn average avocado avoid awake aware away awesome awful awkward axis baby bachelor bacon badge bag balance balcony ball bamboo banana banner bar barely bargain barrel base basic basket battle beach bean beauty because become beef before begin behave behind believe below belt bench benefit best betray better between beyond bicycle bid bike bind biology bird birth bitter black blade blame blanket blast bleak bless blind blood blossom blouse blue blur blush board boat body boil bomb bone bonus book boost border boring borrow boss bottom bounce box boy bracket brain brand brass brave bread breeze brick bridge brief bright bring brisk broccoli broken bronze broom brother brown brush bubble buddy budget buffalo build bulb bulk bullet bundle bunker burden burger burst bus business busy butter buyer buzz cabbage cabin cable cactus cage cake call calm camera camp can canal cancel candy cannon canoe canvas canyon capable capital captain car carbon card cargo carpet carry cart case cash casino castle casual cat catalog catch category cattle caught cause caution cave ceiling celery cement census century cereal certain chair chalk champion change chaos chapter charge chase chat cheap check cheese chef cherry chest chicken chief child chimney choice choose chronic chuckle chunk churn cigar cinnamon circle citizen city civil claim clap clarify claw clay clean clerk clever click client cliff climb clinic clip clock clog close cloth cloud clown club clump cluster clutch coach coast coconut code coffee coil coin collect color column combine come comfort comic common company concert conduct confirm congress connect consider control convince cook cool copper copy coral core corn correct cost cotton couch country couple course cousin cover coyote crack cradle craft cram crane crash crater crawl crazy cream credit creek crew cricket crime crisp critic crop cross crouch crowd crucial cruel cruise crumble crunch crush cry crystal cube culture cup cupboard curious current curtain curve cushion custom cute cycle dad damage damp dance danger daring dash daughter dawn day deal debate debris decade december decide decline decorate decrease deer defense define defy degree delay deliver demand demise denial dentist deny depart depend deposit depth deputy derive describe desert design desk despair destroy detail detect develop device devote diagram dial diamond diary dice diesel diet differ digital dignity dilemma dinner dinosaur direct dirt disagree discover disease dish dismiss disorder display distance divert divide divorce dizzy doctor document dog doll dolphin domain donate donkey donor door dose double dove draft dragon drama drastic draw dream dress drift drill drink drip drive drop drum dry duck dumb dune during dust dutch duty dwarf dynamic eager eagle early earn earth easily east easy echo ecology economy edge edit educate effort egg eight either elbow elder electric elegant element elephant elevator elite else embark embody embrace emerge emotion employ empower empty enable enact end endless endorse enemy energy enforce engage engine enhance enjoy enlist enough enrich enroll ensure enter entire entry envelope episode equal equip era erase erode erosion error erupt escape essay essence estate eternal ethics evidence evil evoke evolve exact example excess exchange excite exclude excuse execute exercise exhaust exhibit exile exist exit exotic expand expect expire explain expose express extend extra eye eyebrow fabric face faculty fade faint faith fall false fame family famous fan fancy fantasy farm fashion fat fatal father fatigue fault favorite feature february federal fee feed feel female fence festival fetch fever few fiber fiction field figure file film filter final find fine finger finish fire firm first fiscal fish fit fitness fix flag flame flash flat flavor flee flight flip float flock floor flower fluid flush fly foam focus fog foil fold follow food foot force forest forget fork fortune forum forward fossil foster found fox fragile frame frequent fresh friend fringe frog front frost frown frozen fruit fuel fun funny furnace fury future gadget gain galaxy gallery game gap garage garbage garden garlic garment gas gasp gate gather gauge gaze general genius genre gentle genuine gesture ghost giant gift giggle ginger giraffe girl give glad glance glare glass glide glimpse globe gloom glory glove glow glue goat goddess gold good goose gorilla gospel gossip govern gown grab grace grain grant grape grass gravity great green grid grief grit grocery group grow grunt guard guess guide guilt guitar gun gym habit hair half hammer hamster hand happy harbor hard harsh harvest hat have hawk hazard head health heart heavy hedgehog height hello helmet help hen hero hidden high hill hint hip hire history hobby hockey hold hole holiday hollow home honey hood hope horn horror horse hospital host hotel hour hover hub huge human humble humor hundred hungry hunt hurdle hurry hurt husband hybrid ice icon idea identify idle ignore ill illegal illness image imitate immense immune impact impose improve impulse inch include income increase index indicate indoor industry infant inflict inform inhale inherit initial inject injury inmate inner innocent input inquiry insane insect inside inspire install intact interest into invest invite involve iron island isolate issue item ivory jacket jaguar jar jazz jealous jeans jelly jewel job join joke journey joy judge juice jump jungle junior junk just kangaroo keen keep ketchup key kick kid kidney kind kingdom kiss kit kitchen kite kitten kiwi knee knife knock know lab label labor ladder lady lake lamp language laptop large later latin laugh laundry lava law lawn lawsuit layer lazy leader leaf learn leave lecture left leg legal legend leisure lemon lend length lens leopard lesson letter level liar liberty library license life lift light like limb limit link lion liquid list little live lizard load loan lobster local lock logic lonely long loop lottery loud lounge love loyal lucky luggage lumber lunar lunch luxury lyrics machine mad magic magnet maid mail main major make mammal man manage mandate mango mansion manual maple marble march margin marine market marriage mask mass master match material math matrix matter maximum maze meadow mean measure meat mechanic medal media melody melt member memory mention menu mercy merge merit merry mesh message metal method middle midnight milk million mimic mind minimum minor minute miracle mirror misery miss mistake mix mixed mixture mobile model modify mom moment monitor monkey monster month moon moral more morning mosquito mother motion motor mountain mouse move movie much muffin mule multiply muscle museum mushroom music must mutual myself mystery myth naive name napkin narrow nasty nation nature near neck need negative neglect neither nephew nerve nest net network neutral never news next nice night noble noise nominee noodle normal north nose notable note nothing notice novel now nuclear number nurse nut oak obey object oblige obscure observe obtain obvious occur ocean october odor off offer office often oil okay old olive olympic omit once one onion online only open opera opinion oppose option orange orbit orchard order ordinary organ orient original orphan ostrich other outdoor outer output outside oval oven over own owner oxygen oyster ozone pact paddle page pair palace palm panda panel panic panther paper parade parent park parrot party pass patch path patient patrol pattern pause pave payment peace peanut pear peasant pelican pen penalty pencil people pepper perfect permit person pet phone photo phrase physical piano picnic picture piece pig pigeon pill pilot pink pioneer pipe pistol pitch pizza place planet plastic plate play please pledge pluck plug plunge poem poet point polar pole police pond pony pool popular portion position possible post potato pottery poverty powder power practice praise predict prefer prepare present pretty prevent price pride primary print priority prison private prize problem process produce profit program project promote proof property prosper protect proud provide public pudding pull pulp pulse pumpkin punch pupil puppy purchase purity purpose purse push put puzzle pyramid quality quantum quarter question quick quit quiz quote rabbit raccoon race rack radar radio rail rain raise rally ramp ranch random range rapid rare rate rather raven raw razor ready real reason rebel rebuild recall receive recipe record recycle reduce reflect reform refuse region regret regular reject relax release relief rely remain remember remind remove render renew rent reopen repair repeat replace report require rescue resemble resist resource response result retire retreat return reunion reveal review reward rhythm rib ribbon rice rich ride ridge rifle right rigid ring riot ripple risk ritual rival river road roast robot robust rocket romance roof rookie room rose rotate rough round route royal rubber rude rug rule run runway rural sad saddle sadness safe sail salad salmon salon salt salute same sample sand satisfy satoshi sauce sausage save say scale scan scare scatter scene scheme school science scissors scorpion scout scrap screen script scrub sea search season seat second secret section security seed seek segment select sell seminar senior sense sentence series service session settle setup seven shadow shaft shallow share shed shell sheriff shield shift shine ship shiver shock shoe shoot shop short shoulder shove shrimp shrug shuffle shy sibling sick side siege sight sign silent silk silly silver similar simple since sing siren sister situate six size skate sketch ski skill skin skirt skull slab slam sleep slender slice slide slight slim slogan slot slow slush small smart smile smoke smooth snack snake snap sniff snow soap soccer social sock soda soft solar soldier solid solution solve someone song soon sorry sort soul sound soup source south space spare spatial spawn speak special speed spell spend sphere spice spider spike spin spirit split spoil sponsor spoon sport spot spray spread spring spy square squeeze squirrel stable stadium staff stage stairs stamp stand start state stay steak steel stem step stereo stick still sting stock stomach stone stool story stove strategy street strike strong struggle student stuff stumble style subject submit subway success such sudden suffer sugar suggest suit summer sun sunny sunset super supply supreme sure surface surge surprise surround survey suspect sustain swallow swamp swap swarm swear sweet swift swim swing switch sword symbol symptom syrup system table tackle tag tail talent talk tank tape target task taste tattoo taxi teach team tell ten tenant tennis tent term test text thank that theme then theory there they thing this thought three thrive throw thumb thunder ticket tide tiger tilt timber time tiny tip tired tissue title toast tobacco today toddler toe together toilet token tomato tomorrow tone tongue tonight tool tooth top topic topple torch tornado tortoise toss total tourist toward tower town toy track trade traffic tragic train transfer trap trash travel tray treat tree trend trial tribe trick trigger trim trip trophy trouble truck true truly trumpet trust truth try tube tuition tumble tuna tunnel turkey turn turtle twelve twenty twice twin twist two type typical ugly umbrella unable unaware uncle uncover under undo unfair unfold unhappy uniform unique unit universe unknown unlock until unusual unveil update upgrade uphold upon upper upset urban urge usage use used useful useless usual utility vacant vacuum vague valid valley valve van vanish vapor various vast vault vehicle velvet vendor venture venue verb verify version very vessel veteran viable vibrant vicious victory video view village vintage violin virtual virus visa visit visual vital vivid vocal voice void volcano volume vote voyage wage wagon wait walk wall walnut want warfare warm warrior wash wasp waste water wave way wealth weapon wear weasel weather web wedding weekend weird welcome west wet whale what wheat wheel when where whip whisper wide width wife wild will win window wine wing wink winner winter wire wisdom wise wish witness wolf woman wonder wood wool word work world worry worth wrap wreck wrestle wrist write wrong yard year yellow you young youth zebra zero zone zoo".normalize("NFKD").split(" "),n.DashPhrase=s})(globalThis.window||{},t),r.exports=t}(Nn,Nn.exports)),Nn.exports}var _S=kS();const DS=Os(_S);class LS{apiUrl;constructor(e){this.apiUrl=e}async generatePhrase(){const e=await DS.generate(16);return[Math.floor(Math.random()*100)+1,...e.split(" ")].join("-")}async registerPhrase(e,t){try{const n=await this.makeApiRequest("/phrase","POST",{Maddr:t.toString(),Phrase:e});if(!n.ok)throw new Error(`Failed to register phrase. Status: ${n.status}`);return await n.json()}catch(n){throw this.handleApiError(n),n}}async lookupPhrase(e){try{const t=await this.makeApiRequest(`/phrase/${encodeURIComponent(e)}`,"GET");if(!t.ok)throw new Error(`Failed to lookup phrase. Status: ${t.status}`);return await t.json()}catch(t){throw this.handleApiError(t),t}}async makeApiRequest(e,t,n=null){const s=`${this.apiUrl}${e}`,i={method:t,headers:{"Content-type":"application/json; charset=UTF-8"}};return n&&(i.body=JSON.stringify(n)),await fetch(s,i)}handleApiError(e){console.error("API Error:",e)}validatePhrase(e){return e!=null&&e.trim().length>0}sanitizePhrase(e){return e.trim().toLowerCase()}}class RS{appState;elements;onFileSelected=()=>{};onPhraseEntered=()=>{};onReceiveModeRequested=()=>{};constructor(e){this.appState=e,this.elements=this.getUIElements(),this.clearPhrase()}showSenderMode(){this.hideElement("initialDropUI"),this.showElement("fileInfoArea")}showSendingInProgress(){this.hideElement("fileInfoArea"),this.showElement("sendInProgress")}showReceiverMode(){this.hideElement("initialReceiveUI"),this.showElement("receiveInProgress")}showHome(){window.location.reload()}showSendWindow(){this.showElement("goBackButton","flex"),this.hideElement("goSendButton"),this.hideElement("goReceiveButton"),this.showElement("sendWindow"),this.hideElement("receiveWindow")}showReceiveWindow(){this.showElement("goBackButton","flex"),this.hideElement("goSendButton"),this.hideElement("goReceiveButton"),this.showElement("receiveWindow"),this.hideElement("sendWindow")}resetUI(){this.showHome(),this.clearFileDisplay(),this.hideErrorPopup()}displaySelectedFile(e){this.updateElement("fileNameDisplay",e.name),this.updateElement("fileSizeDisplay",`${(e.size/1024/1024).toFixed(2)} MB`)}showFileProgress(e,t){const{percentage:n,current:s,total:i,rate:o}=e,a=t==="send"?"sendProgressBar":"receiveProgressBar",c=t==="send"?"sendProgressText":"receiveProgressText",l=t==="send"?"sendRate":"receiveRate";this.updateProgressBar(a,n),this.updateElement(c,`${s} MB / ${i} MB`),this.updateElement(l,`${o} Mbps`)}showReceivedFileDetails(e,t){this.updateElement("receivedFileName",e),this.updateElement("receivedFileSize",`${(t/1024/1024).toFixed(2)} MB`)}showTransferComplete(e){const t=e==="send"?"sendInProgress":"receiveInProgress",n=e==="send"?"sendComplete":"receiveComplete";this.hideElement(t),this.showElement(n)}updateProgressBar(e,t){const n=document.getElementById(e);n&&(n.style.width=`${t}%`)}clearFileDisplay(){this.updateElement("fileNameDisplay",""),this.updateElement("fileSizeDisplay","")}showErrorPopup(e){this.updateElement("errorMessageText",e),this.elements.errorWindow?.classList.remove("hidden")}hideErrorPopup(){this.elements.errorWindow?.classList.add("hidden")}setupEventListeners(){this.setupFileHandlers(),this.setupButtonHandlers(),this.setupErrorHandlers()}setupFileHandlers(){const e=this.elements.dropZone,t=this.elements.fileInput;e?.addEventListener("dragover",this.handleDragOver.bind(this)),e?.addEventListener("drop",this.handleFileDrop.bind(this)),t?.addEventListener("change",this.handleFileSelect.bind(this))}setupButtonHandlers(){this.elements.selectFileButton?.addEventListener("click",()=>this.elements.fileInput?.click()),this.elements.goSendButton?.addEventListener("click",this.showSendWindow.bind(this)),this.elements.goReceiveButton?.addEventListener("click",this.showReceiveWindow.bind(this)),this.elements.goBackButton?.addEventListener("click",this.showHome.bind(this)),this.elements.copyPhraseButton?.addEventListener("click",this.copyPhrase.bind(this)),this.elements.receiveModeButton?.addEventListener("click",()=>{const t=document.getElementById("phraseInput").value.trim();if(!t){this.showErrorPopup("Please enter a valid phrase.");return}this.showReceiverMode(),this.onPhraseEntered(t)})}setupErrorHandlers(){const e=this.elements.errorWindow,t=this.elements.closeErrorButton;e?.addEventListener("click",n=>{n.target===e&&(this.hideErrorPopup(),this.resetUI())}),t?.addEventListener("click",()=>{this.hideErrorPopup(),this.resetUI()})}handleDragOver(e){e.preventDefault()}handleFileDrop(e){e.preventDefault();let t=null;if(e.dataTransfer?.items){const n=[...e.dataTransfer.items].find(s=>s.kind==="file");n&&(t=n.getAsFile())}else e.dataTransfer?.files&&e.dataTransfer.files.length>0&&(t=e.dataTransfer.files[0]);t&&(this.appState.setSelectedFile(t),this.displaySelectedFile(t),this.onFileSelected(t))}handleFileSelect(e){const t=e.target;if(t.files&&t.files[0]){const n=t.files[0];this.appState.setSelectedFile(n),this.displaySelectedFile(n),this.onFileSelected(n)}}showPhrase(e){this.updateElement("generatedPhraseDisplay",e)}copyPhrase(){this.elements.generatedPhraseDisplay?.innerText&&navigator.clipboard.writeText(this.elements.generatedPhraseDisplay.innerText)}clearPhrase(){const e=document.getElementById("phraseInput");e&&(e.value="")}updateElement(e,t){const n=document.getElementById(e);n&&(n.textContent=t)}showElement(e,t="block"){const n=document.getElementById(e);n&&(n.style.display=t)}hideElement(e){const t=document.getElementById(e);t&&(t.style.display="none")}getUIElements(){return{dropZone:document.getElementById("drop_zone"),fileInput:document.getElementById("fileInput"),copyPhraseButton:document.getElementById("copyPhraseButton"),receiveModeButton:document.getElementById("receiveModeButton"),goSendButton:document.getElementById("goSendButton"),goReceiveButton:document.getElementById("goReceiveButton"),goBackButton:document.getElementById("goBackButton"),selectFileButton:document.getElementById("selectFileButton"),errorWindow:document.getElementById("errorWindow"),closeErrorButton:document.getElementById("closeErrorButton"),generatedPhraseDisplay:document.getElementById("generatedPhraseDisplay")}}}class MS{uiManager;lastUpdateTime;lastBytes;updateInterval;constructor(e){this.uiManager=e,this.lastUpdateTime=0,this.lastBytes=0,this.updateInterval=250}updateProgress(e,t,n,s=!1){const i=Date.now(),o=i-this.lastUpdateTime;if(!s&&o<this.updateInterval)return;const a=o/1e3,c=e-this.lastBytes;let l=0;a>0&&c>0&&(l=c/a*8/(1024*1024));const u=t>0?e/t*100:0,d=(e/(1024*1024)).toFixed(2),h=(t/(1024*1024)).toFixed(2);if(console.log("Receive progress: "+u.toFixed(2)+"% ("+d+" MB / "+h+" MB)"),this.uiManager.showSendingInProgress(),u>=100)this.uiManager.showTransferComplete(n);else{const p={percentage:u,current:d,total:h,rate:l.toFixed(2)};this.uiManager.showFileProgress(p,n)}this.lastUpdateTime=i,this.lastBytes=e}}class OS{uiManager;retryAttempts;maxRetries;constructor(e){this.uiManager=e,this.retryAttempts=new Map,this.maxRetries=3}handleConnectionError(e,t){const n=`Connection error: ${e.message}`;this.logError(e,t),this.isRecoverableError(e)&&t.peerId?this.attemptConnectionRecovery(t.peerId):this.uiManager.showErrorPopup(n)}handleTransferError(e,t){const n=`Transfer error: ${e.message}`;this.logError(e,t),this.uiManager.showErrorPopup(n)}handleApiError(e,t){const n=`API error: ${e.message}`;this.logError(e,t),this.uiManager.showErrorPopup(n)}async attemptConnectionRecovery(e){if(!e)return!1;const t=this.retryAttempts.get(e)||0;if(t>=this.maxRetries)return this.logWarning(`Max retry attempts reached for peer: ${e}`,{}),!1;this.retryAttempts.set(e,t+1);try{return await this.retryWithBackoff(async()=>!0,t),this.retryAttempts.delete(e),!0}catch(n){return this.logError(n,{operation:"recovery",peerId:e,attempt:t}),!1}}async retryWithBackoff(e,t){const n=Math.min(1e3*Math.pow(2,t),1e4);return await new Promise(s=>setTimeout(s,n)),await e()}logError(e,t){console.error("Error:",e.message,"Context:",t)}logWarning(e,t){console.warn("Warning:",e,"Context:",t)}isNetworkError(e){return e.message.includes("network")||e.message.includes("connection")||e.code==="NETWORK_ERROR"}isTimeoutError(e){return e.message.includes("timeout")||e.message.includes("timed out")||e.code==="TIMEOUT"}isRecoverableError(e){return this.isNetworkError(e)||this.isTimeoutError(e)}}class NS{config;constructor(){this.config={relay:{address:"/dns4/relay.smp46.me/tcp/443/tls/ws/p2p/12D3KooWPUXghsjtba2yaKbxJAPUpCgZ1UzciEdCPzohBQi7wiPg",timeout:3e4},api:{url:"https://exchange.smp46.me",timeout:1e4},transfer:{chunkSize:256*256,protocol:"/fileferry/filetransfer/1.0.0"},stun:{fallback:"stun:l.google.com:19302",timeout:5e3},debug:!0}}getRelayAddress(){return this.config.relay.address}getApiUrl(){return this.config.api.url}getStunServers(){return[this.config.stun.fallback,"turn:relay.smp46.me:3478?transport=udp","turn:relay.smp46.me:3478?transport=tcp"]}getTransferSettings(){return this.config.transfer}getFileTransferProtocol(){return this.config.transfer.protocol}getChunkSize(){return this.config.transfer.chunkSize}getTimeouts(){return{relay:this.config.relay.timeout,api:this.config.api.timeout,stun:this.config.stun.timeout}}isDebugEnabled(){return this.config.debug}validateConfig(){const e=["relay.address","api.url","transfer.protocol"];for(const t of e)if(!this.getConfigValue(t))throw new Error(`Missing required configuration: ${t}`);return!0}setConfigValue(e,t){const n=e.split(".");let s=this.config;for(let i=0;i<n.length-1;i++)s[n[i]]||(s[n[i]]={}),s=s[n[i]];s[n[n.length-1]]=t}getConfigValue(e,t=null){const n=e.split(".");let s=this.config;for(const i of n){if(s[i]===void 0)return t;s=s[i]}return s}}class FS{config;appState;node;services;managers;constructor(){this.config=new NS,this.appState=new AS,this.node=null,this.services={},this.managers={}}async initialize(){try{this.config.validateConfig(),await this.setupServices(),await this.setupLibp2pNode(),await this.setupManagers(),await this.setupUI(),console.log("FileFerry app initialized successfully")}catch(e){throw console.error("Failed to initialize app:",e),e}}async setupServices(){this.services.stun=new PS,this.services.phrase=new LS(this.config.getApiUrl())}async setupLibp2pNode(){const e=await this.getStunConfiguration(),t={addresses:{listen:["/p2p-circuit","/webrtc"]},transports:[ev({filter:Fd}),N0({rtcConfiguration:{iceServers:[{urls:e},{urls:"turn:relay.smp46.me:3478?transport=udp",username:"ferryCaptain",credential:"i^YV13eTPOHdVzWm#2t5"},{urls:"turn:relay.smp46.me:3478?transport=tcp",username:"ferryCaptain",credential:"i^YV13eTPOHdVzWm#2t5"}],iceCandidatePoolSize:10,bundlePolicy:"max-bundle",rtcpMuxPolicy:"require"}}),yb()],connectionEncrypters:[vy()],streamMuxers:[Ky({maxStreamWindowSize:1024*1024*4})],connectionGater:{denyDialMultiaddr:()=>!1},services:{identify:Wb({timeout:3e4}),identifyPush:Hb({}),ping:Jb({maxInboundStreams:32,maxOutboundStreams:32,timeout:3e4})},connectionManager:{}};this.node=await xS(t),await this.node.start(),console.log(`Node started with Peer ID: ${this.node.peerId.toString()}`)}async setupManagers(){if(!this.node)throw new Error("Libp2p node is not initialized.");this.managers.ui=new RS(this.appState),this.managers.error=new OS(this.managers.ui),this.managers.progress=new MS(this.managers.ui),this.managers.fileTransfer=new IS(this.node,this.appState,this.managers.progress,this.managers.ui,this.managers.error),this.managers.connection=new CS(this.node,this.appState,this.managers.error,this.config,this.managers.fileTransfer),this.managers.relay=new TS(this.node,this.appState,this.managers.error),this.setupEventListeners(),this.managers.fileTransfer.setupFileTransferProtocol()}async setupUI(){if(!this.managers.ui)throw new Error("UIManager not initialized");this.managers.ui.setupEventListeners(),this.managers.ui.onFileSelected=this.handleFileSelected.bind(this),this.managers.ui.onPhraseEntered=this.handlePhraseEntered.bind(this),this.managers.ui.onReceiveModeRequested=this.handleReceiveModeRequested.bind(this)}setupEventListeners(){!this.node||!this.managers.connection||(this.node.addEventListener("connection:open",this.managers.connection.onConnectionEstablished.bind(this.managers.connection)),this.node.addEventListener("connection:close",this.managers.connection.onConnectionClosed.bind(this.managers.connection)))}async getStunConfiguration(){if(!this.services.stun)return this.config.getStunServers()[0];try{const e=await this.services.stun.getClosestStunServer();return e?`stun:${e}`:this.config.getStunServers()[0]}catch(e){return console.warn("Could not fetch closest STUN server:",e),this.config.getStunServers()[0]}}async handleFileSelected(e){if(!(!this.managers.ui||!this.managers.error))try{this.managers.ui.showSenderMode(),await this.startSenderMode(e)}catch(t){this.managers.error.handleTransferError(t,{operation:"fileSelected",direction:"send"})}}async handlePhraseEntered(e){if(this.managers.error)try{await this.startReceiverMode(e)}catch(t){this.managers.error.handleApiError(t,{operation:"phraseEntered"})}}async handleReceiveModeRequested(){this.managers.ui&&this.managers.ui.showReceiverMode()}async startSenderMode(e){if(!(!this.services.phrase||!this.managers.relay||!this.managers.error))try{this.appState.setSelectedFile(e),this.appState.setMode("sender"),console.log("Starting sender mode...");const t=await this.services.phrase.generatePhrase();console.log(`Generated phrase: ${t}`);const n=document.getElementById("generatedPhraseDisplay");if(n&&(n.textContent=t),await this.managers.relay.connectToRelay(this.config.getRelayAddress()),console.log("Waiting for relay to be ready..."),!await this.managers.relay.canUseRelay())throw new Error("Relay is not ready for use");const i=await this.managers.relay.waitForRelayAddress();console.log("Registering phrase..."),await this.services.phrase.registerPhrase(t,i),console.log("Sender mode setup complete. Waiting for receiver...")}catch(t){throw console.error("Failed to start sender mode:",t),this.managers.error.handleTransferError(t,{operation:"startSenderMode",direction:"send"}),this.appState.setMode("idle"),t}}async startReceiverMode(e){if(!this.appState||!this.services.phrase||!this.managers.relay||!this.managers.connection||!this.node)return;this.appState.setMode("receiver");const t=await this.services.phrase.lookupPhrase(e);if(!t.maddr)throw new Error("No address found for phrase");if(await this.managers.relay.connectToRelay(this.config.getRelayAddress()),console.log("Waiting for relay to be ready..."),!await this.managers.relay.canUseRelay())throw new Error("Relay is not ready for use");await this.managers.relay.waitForRelayAddress();const s=Y(t.maddr),i=await this.managers.connection.dialPeer(s,{signal:AbortSignal.timeout(6e4)});console.log(`Connected to sender via phrase: ${e}`),this.appState.setActivePeer(i.remotePeer.toString());const o=setInterval(()=>{if(!this.node){clearInterval(o);return}const c=this.node.getConnections(i.remotePeer).find(l=>l.remoteAddr.toString().includes("/webrtc"));c&&c.status==="open"&&(clearInterval(o),console.log("WebRTC connection established, circuit can now be closed safely"))},1e3)}async start(){await this.initialize(),console.log("FileFerry app started")}async stop(){this.node&&await this.node.stop(),this.appState.reset(),console.log("FileFerry app stopped")}async cleanup(){await this.stop()}}const uh=new FS;document.addEventListener("DOMContentLoaded",async()=>{try{await uh.start()}catch(r){console.error("Failed to start FileFerry app:",r)}});window.addEventListener("unhandledrejection",r=>{console.error("Unhandled promise rejection:",r.reason)});window.addEventListener("error",r=>{console.error("Global error:",r.error)});window.fileFerryApp=uh;
