(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const s of i)if(s.type==="childList")for(const o of s.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function t(i){const s={};return i.integrity&&(s.integrity=i.integrity),i.referrerPolicy&&(s.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?s.credentials="include":i.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(i){if(i.ep)return;i.ep=!0;const s=t(i);fetch(i.href,s)}})();const iC=Symbol.for("@libp2p/connection"),Ny=Symbol.for("@libp2p/content-routing"),Dy=Symbol.for("@libp2p/peer-discovery"),Ag=Symbol.for("@libp2p/peer-id");function Xo(r){return!!r?.[Ag]}const Ly=Symbol.for("@libp2p/peer-routing"),xg="keep-alive",zu=Symbol.for("@libp2p/transport");var fa;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(fa||(fa={}));let Ri=class extends Error{static name="AbortError";constructor(e="The operation was aborted"){super(e),this.name="AbortError"}};class sC extends Error{static name="UnexpectedPeerError";constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}}let oC=class extends Error{static name="InvalidCryptoExchangeError";constructor(e="Invalid crypto exchange"){super(e),this.name="InvalidCryptoExchangeError"}},q=class extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}};class qv extends Error{static name="InvalidPublicKeyError";constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}}class Kv extends Error{static name="InvalidPrivateKeyError";constructor(e="Invalid private key"){super(e),this.name="InvalidPrivateKeyError"}}class aC extends Error{static name="ConnectionClosingError";constructor(e="The connection is closing"){super(e),this.name="ConnectionClosingError"}}class Vv extends Error{static name="ConnectionClosedError";constructor(e="The connection is closed"){super(e),this.name="ConnectionClosedError"}}class zv extends Error{static name="ConnectionFailedError";constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}}class Bo extends Error{static name="MuxerClosedError";constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}}class cC extends Error{static name="StreamResetError";constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}}class wf extends Error{static name="StreamStateError";constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}}let Nn=class extends Error{static name="NotFoundError";constructor(e="Not found"){super(e),this.name="NotFoundError"}};class jv extends Error{static name="InvalidPeerIdError";constructor(e="Invalid PeerID"){super(e),this.name="InvalidPeerIdError"}}let _g=class extends Error{static name="InvalidMultiaddrError";constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}};class lC extends Error{static name="InvalidCIDError";constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}}class uC extends Error{static name="InvalidMultihashError";constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}}class Cg extends Error{static name="UnsupportedProtocolError";constructor(e="Unsupported protocol error"){super(e),this.name="UnsupportedProtocolError"}}class bt extends Error{static name="InvalidMessageError";constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}}class dC extends Error{static name="ProtocolError";constructor(e="Protocol error"){super(e),this.name="ProtocolError"}}let Ig=class extends Error{static name="TimeoutError";constructor(e="Timed out"){super(e),this.name="TimeoutError"}};class pa extends Error{static name="NotStartedError";constructor(e="Not started"){super(e),this.name="NotStartedError"}}class Zo extends Error{static name="DialError";constructor(e="Dial error"){super(e),this.name="DialError"}}class bf extends Error{static name="ListenError";constructor(e="Listen error"){super(e),this.name="ListenError"}}class Hv extends Error{static name="LimitedConnectionError";constructor(e="Limited connection"){super(e),this.name="LimitedConnectionError"}}class hC extends Error{static name="TooManyInboundProtocolStreamsError";constructor(e="Too many inbound protocol streams"){super(e),this.name="TooManyInboundProtocolStreamsError"}}class Wv extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}}class uo extends Error{static name="UnsupportedKeyTypeError";constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}}class sr extends EventTarget{#e=new Map;constructor(){super()}listenerCount(e){const t=this.#e.get(e);return t==null?0:t.length}addEventListener(e,t,n){super.addEventListener(e,t,n);let i=this.#e.get(e);i==null&&(i=[],this.#e.set(e,i)),i.push({callback:t,once:(n!==!0&&n!==!1&&n?.once)??!1})}removeEventListener(e,t,n){super.removeEventListener(e.toString(),t??null,n);let i=this.#e.get(e);i!=null&&(i=i.filter(({callback:s})=>s!==t),this.#e.set(e,i))}dispatchEvent(e){const t=super.dispatchEvent(e);let n=this.#e.get(e.type);return n==null||(n=n.filter(({once:i})=>!i),this.#e.set(e.type,n)),t}safeDispatchEvent(e,t={}){return this.dispatchEvent(new CustomEvent(e,t))}}function kg(r){return r!=null&&typeof r.start=="function"&&typeof r.stop=="function"}async function Gv(...r){const e=[];for(const t of r)kg(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStart!=null&&await t.beforeStart()})),await Promise.all(e.map(async t=>{await t.start()})),await Promise.all(e.map(async t=>{t.afterStart!=null&&await t.afterStart()}))}async function Yv(...r){const e=[];for(const t of r)kg(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStop!=null&&await t.beforeStop()})),await Promise.all(e.map(async t=>{await t.stop()})),await Promise.all(e.map(async t=>{t.afterStop!=null&&await t.afterStop()}))}const $t=Symbol.for("@libp2p/service-capabilities"),Os=Symbol.for("@libp2p/service-dependencies");function fC(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function ju(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function pC(r){return new TextEncoder().encode(r)}function gC(r){return new TextDecoder().decode(r)}function mC(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var i=0;i<r.length;i++){var s=r.charAt(i),o=s.charCodeAt(0);if(t[o]!==255)throw new TypeError(s+" is ambiguous");t[o]=i}var a=r.length,c=r.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function d(m){if(m instanceof Uint8Array||(ArrayBuffer.isView(m)?m=new Uint8Array(m.buffer,m.byteOffset,m.byteLength):Array.isArray(m)&&(m=Uint8Array.from(m))),!(m instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(m.length===0)return"";for(var w=0,y=0,b=0,_=m.length;b!==_&&m[b]===0;)b++,w++;for(var E=(_-b)*u+1>>>0,R=new Uint8Array(E);b!==_;){for(var S=m[b],N=0,T=E-1;(S!==0||N<y)&&T!==-1;T--,N++)S+=256*R[T]>>>0,R[T]=S%a>>>0,S=S/a>>>0;if(S!==0)throw new Error("Non-zero carry");y=N,b++}for(var B=E-y;B!==E&&R[B]===0;)B++;for(var v=c.repeat(w);B<E;++B)v+=r.charAt(R[B]);return v}function h(m){if(typeof m!="string")throw new TypeError("Expected String");if(m.length===0)return new Uint8Array;var w=0;if(m[w]!==" "){for(var y=0,b=0;m[w]===c;)y++,w++;for(var _=(m.length-w)*l+1>>>0,E=new Uint8Array(_);m[w];){var R=t[m.charCodeAt(w)];if(R===255)return;for(var S=0,N=_-1;(R!==0||S<b)&&N!==-1;N--,S++)R+=a*E[N]>>>0,E[N]=R%256>>>0,R=R/256>>>0;if(R!==0)throw new Error("Non-zero carry");b=S,w++}if(m[w]!==" "){for(var T=_-b;T!==_&&E[T]===0;)T++;for(var B=new Uint8Array(y+(_-T)),v=y;T!==_;)B[v++]=E[T++];return B}}}function p(m){var w=h(m);if(w)return w;throw new Error(`Non-${e} character`)}return{encode:d,decodeUnsafe:h,decode:p}}var yC=mC,wC=yC;class bC{name;prefix;baseEncode;constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}let vC=class{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,n){this.name=e,this.prefix=t;const i=t.codePointAt(0);if(i===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=i,this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return Qv(this,e)}};class SC{decoders;constructor(e){this.decoders=e}or(e){return Qv(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n!=null)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function Qv(r,e){return new SC({...r.decoders??{[r.prefix]:r},...e.decoders??{[e.prefix]:e}})}class EC{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,n,i){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=i,this.encoder=new bC(e,t,n),this.decoder=new vC(e,t,i)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function Hu({name:r,prefix:e,encode:t,decode:n}){return new EC(r,e,t,n)}function qa({name:r,prefix:e,alphabet:t}){const{encode:n,decode:i}=wC(t,r);return Hu({prefix:e,name:r,encode:n,decode:s=>ju(i(s))})}function AC(r,e,t,n){let i=r.length;for(;r[i-1]==="=";)--i;const s=new Uint8Array(i*t/8|0);let o=0,a=0,c=0;for(let l=0;l<i;++l){const u=e[r[l]];if(u===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<t|u,o+=t,o>=8&&(o-=8,s[c++]=255&a>>o)}if(o>=t||(255&a<<8-o)!==0)throw new SyntaxError("Unexpected end of data");return s}function xC(r,e,t){const n=e[e.length-1]==="=",i=(1<<t)-1;let s="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>t;)o-=t,s+=e[i&a>>o];if(o!==0&&(s+=e[i&a<<t-o]),n)for(;(s.length*t&7)!==0;)s+="=";return s}function _C(r){const e={};for(let t=0;t<r.length;++t)e[r[t]]=t;return e}function ft({name:r,prefix:e,bitsPerChar:t,alphabet:n}){const i=_C(n);return Hu({prefix:e,name:r,encode(s){return xC(s,n,t)},decode(s){return AC(s,i,t,r)}})}const Qe=qa({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),CC=qa({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),IC=Object.freeze(Object.defineProperty({__proto__:null,base58btc:Qe,base58flickr:CC},Symbol.toStringTag,{value:"Module"})),Vn=ft({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),kC=ft({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),TC=ft({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),PC=ft({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),RC=ft({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),OC=ft({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),BC=ft({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),NC=ft({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),DC=ft({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),LC=Object.freeze(Object.defineProperty({__proto__:null,base32:Vn,base32hex:RC,base32hexpad:BC,base32hexpadupper:NC,base32hexupper:OC,base32pad:TC,base32padupper:PC,base32upper:kC,base32z:DC},Symbol.toStringTag,{value:"Module"})),cl=qa({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),MC=qa({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),FC=Object.freeze(Object.defineProperty({__proto__:null,base36:cl,base36upper:MC},Symbol.toStringTag,{value:"Module"}));var UC=Jv,My=128,$C=-128,qC=Math.pow(2,31);function Jv(r,e,t){e=e||[],t=t||0;for(var n=t;r>=qC;)e[t++]=r&255|My,r/=128;for(;r&$C;)e[t++]=r&255|My,r>>>=7;return e[t]=r|0,Jv.bytes=t-n+1,e}var KC=vf,VC=128,Fy=127;function vf(r,n){var t=0,n=n||0,i=0,s=n,o,a=r.length;do{if(s>=a)throw vf.bytes=0,new RangeError("Could not decode varint");o=r[s++],t+=i<28?(o&Fy)<<i:(o&Fy)*Math.pow(2,i),i+=7}while(o>=VC);return vf.bytes=s-n,t}var zC=Math.pow(2,7),jC=Math.pow(2,14),HC=Math.pow(2,21),WC=Math.pow(2,28),GC=Math.pow(2,35),YC=Math.pow(2,42),QC=Math.pow(2,49),JC=Math.pow(2,56),XC=Math.pow(2,63),ZC=function(r){return r<zC?1:r<jC?2:r<HC?3:r<WC?4:r<GC?5:r<YC?6:r<QC?7:r<JC?8:r<XC?9:10},e2={encode:UC,decode:KC,encodingLength:ZC},El=e2;function Sf(r,e=0){return[El.decode(r,e),El.decode.bytes]}function Al(r,e,t=0){return El.encode(r,e,t),e}function xl(r){return El.encodingLength(r)}function dn(r,e){const t=e.byteLength,n=xl(r),i=n+xl(t),s=new Uint8Array(i+t);return Al(r,s,0),Al(t,s,n),s.set(e,i),new Tg(r,t,e,s)}function Ji(r){const e=ju(r),[t,n]=Sf(e),[i,s]=Sf(e.subarray(n)),o=e.subarray(n+s);if(o.byteLength!==i)throw new Error("Incorrect length");return new Tg(t,i,o,e)}function t2(r,e){if(r===e)return!0;{const t=e;return r.code===t.code&&r.size===t.size&&t.bytes instanceof Uint8Array&&fC(r.bytes,t.bytes)}}class Tg{code;size;digest;bytes;constructor(e,t,n,i){this.code=e,this.size=t,this.digest=n,this.bytes=i}}function Uy(r,e){const{bytes:t,version:n}=r;switch(n){case 0:return n2(t,Ef(r),e??Qe.encoder);default:return i2(t,Ef(r),e??Vn.encoder)}}const $y=new WeakMap;function Ef(r){const e=$y.get(r);if(e==null){const t=new Map;return $y.set(r,t),t}return e}class Be{code;version;multihash;bytes;"/";constructor(e,t,n,i){this.code=t,this.version=e,this.multihash=n,this.bytes=i,this["/"]=i}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==No)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==s2)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return Be.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=dn(e,t);return Be.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return Be.equals(this,e)}static equals(e,t){const n=t;return n!=null&&e.code===n.code&&e.version===n.version&&t2(e.multihash,n.multihash)}toString(e){return Uy(this,e)}toJSON(){return{"/":Uy(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof Be)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:n,code:i,multihash:s,bytes:o}=t;return new Be(n,i,s,o??qy(n,i,s.bytes))}else if(t[o2]===!0){const{version:n,multihash:i,code:s}=t,o=Ji(i);return Be.create(n,s,o)}else return null}static create(e,t,n){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==No)throw new Error(`Version 0 CID must use dag-pb (code: ${No}) block encoding`);return new Be(e,t,n,n.bytes)}case 1:{const i=qy(e,t,n.bytes);return new Be(e,t,n,i)}default:throw new Error("Invalid version")}}static createV0(e){return Be.create(0,No,e)}static createV1(e,t){return Be.create(1,e,t)}static decode(e){const[t,n]=Be.decodeFirst(e);if(n.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=Be.inspectBytes(e),n=t.size-t.multihashSize,i=ju(e.subarray(n,n+t.multihashSize));if(i.byteLength!==t.multihashSize)throw new Error("Incorrect length");const s=i.subarray(t.multihashSize-t.digestSize),o=new Tg(t.multihashCode,t.digestSize,s,i);return[t.version===0?Be.createV0(o):Be.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[d,h]=Sf(e.subarray(t));return t+=h,d};let i=n(),s=No;if(i===18?(i=0,t=0):s=n(),i!==0&&i!==1)throw new RangeError(`Invalid CID version ${i}`);const o=t,a=n(),c=n(),l=t+c,u=l-o;return{version:i,codec:s,multihashCode:a,digestSize:c,multihashSize:u,size:l}}static parse(e,t){const[n,i]=r2(e,t),s=Be.decode(i);if(s.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Ef(s).set(n,e),s}}function r2(r,e){switch(r[0]){case"Q":{const t=e??Qe;return[Qe.prefix,t.decode(`${Qe.prefix}${r}`)]}case Qe.prefix:{const t=e??Qe;return[Qe.prefix,t.decode(r)]}case Vn.prefix:{const t=e??Vn;return[Vn.prefix,t.decode(r)]}case cl.prefix:{const t=e??cl;return[cl.prefix,t.decode(r)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],e.decode(r)]}}}function n2(r,e,t){const{prefix:n}=t;if(n!==Qe.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const i=e.get(n);if(i==null){const s=t.encode(r).slice(1);return e.set(n,s),s}else return i}function i2(r,e,t){const{prefix:n}=t,i=e.get(n);if(i==null){const s=t.encode(r);return e.set(n,s),s}else return i}const No=112,s2=18;function qy(r,e,t){const n=xl(r),i=n+xl(e),s=new Uint8Array(i+t.byteLength);return Al(r,s,0),Al(e,s,n),s.set(t,i),s}const o2=Symbol.for("@ipld/js-cid/CID"),Xv=0,a2="identity",Zv=ju;function c2(r){return dn(Xv,Zv(r))}const Ka={code:Xv,name:a2,encode:Zv,digest:c2};function Je(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function Ie(r=0){return new Uint8Array(r)}function $r(r=0){return new Uint8Array(r)}function qr(r,e){e==null&&(e=r.reduce((i,s)=>i+s.length,0));const t=$r(e);let n=0;for(const i of r)t.set(i,n),n+=i.length;return t}const eS=Symbol.for("@achingbrain/uint8arraylist");function Ky(r,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(const n of r){const i=t+n.byteLength;if(e<i)return{buf:n,index:e-t};t=i}throw new RangeError("index is out of bounds")}function Ac(r){return!!r?.[eS]}class ye{bufs;length;[eS]=!0;constructor(...e){this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const n of e)if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.push(n);else if(Ac(n))t+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const n of e.reverse())if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.unshift(n);else if(Ac(n))t+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){const t=Ky(this.bufs,e);return t.buf[t.index]}set(e,t){const n=Ky(this.bufs,e);n.buf[n.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let n=0;n<e.length;n++)this.set(t+n,e[n]);else if(Ac(e))for(let n=0;n<e.length;n++)this.set(t+n,e.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){const{bufs:n,length:i}=this._subList(e,t);return qr(n,i)}subarray(e,t){const{bufs:n,length:i}=this._subList(e,t);return n.length===1?n[0]:qr(n,i)}sublist(e,t){const{bufs:n,length:i}=this._subList(e,t),s=new ye;return s.length=i,s.bufs=[...n],s}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};const n=[];let i=0;for(let s=0;s<this.bufs.length;s++){const o=this.bufs[s],a=i,c=a+o.byteLength;if(i=c,e>=c)continue;const l=e>=a&&e<c,u=t>a&&t<=c;if(l&&u){if(e===a&&t===c){n.push(o);break}const d=e-a;n.push(o.subarray(d,d+(t-e)));break}if(l){if(e===0){n.push(o);continue}n.push(o.subarray(e-a));continue}if(u){if(t===c){n.push(o);break}n.push(o.subarray(0,t-a));break}n.push(o)}return{bufs:n,length:t-e}}indexOf(e,t=0){if(!Ac(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const n=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const i=n.byteLength;if(i===0)throw new TypeError("search must be at least 1 byte long");const s=256,o=new Int32Array(s);for(let d=0;d<s;d++)o[d]=-1;for(let d=0;d<i;d++)o[n[d]]=d;const a=o,c=this.byteLength-n.byteLength,l=n.byteLength-1;let u;for(let d=t;d<=c;d+=u){u=0;for(let h=l;h>=0;h--){const p=this.get(d+h);if(n[h]!==p){u=Math.max(1,h-a[p]);break}}if(u===0)return d}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const n=$r(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,t),this.write(n,e)}getInt16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,t)}setInt16(e,t,n){const i=Ie(2);new DataView(i.buffer,i.byteOffset,i.byteLength).setInt16(0,t,n),this.write(i,e)}getInt32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,t)}setInt32(e,t,n){const i=Ie(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setInt32(0,t,n),this.write(i,e)}getBigInt64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,t)}setBigInt64(e,t,n){const i=Ie(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setBigInt64(0,t,n),this.write(i,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const n=$r(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,t),this.write(n,e)}getUint16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,t)}setUint16(e,t,n){const i=Ie(2);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint16(0,t,n),this.write(i,e)}getUint32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,t)}setUint32(e,t,n){const i=Ie(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint32(0,t,n),this.write(i,e)}getBigUint64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,t)}setBigUint64(e,t,n){const i=Ie(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setBigUint64(0,t,n),this.write(i,e)}getFloat32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,t)}setFloat32(e,t,n){const i=Ie(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setFloat32(0,t,n),this.write(i,e)}getFloat64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,t)}setFloat64(e,t,n){const i=Ie(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setFloat64(0,t,n),this.write(i,e)}equals(e){if(e==null||!(e instanceof ye)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!Je(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const n=new ye;return n.bufs=e,t==null&&(t=e.reduce((i,s)=>i+s.byteLength,0)),n.length=t,n}}const l2=qa({prefix:"9",name:"base10",alphabet:"0123456789"}),u2=Object.freeze(Object.defineProperty({__proto__:null,base10:l2},Symbol.toStringTag,{value:"Module"})),d2=ft({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),h2=ft({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),f2=Object.freeze(Object.defineProperty({__proto__:null,base16:d2,base16upper:h2},Symbol.toStringTag,{value:"Module"})),p2=ft({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),g2=Object.freeze(Object.defineProperty({__proto__:null,base2:p2},Symbol.toStringTag,{value:"Module"})),tS=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),m2=tS.reduce((r,e,t)=>(r[t]=e,r),[]),y2=tS.reduce((r,e,t)=>{const n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);return r[n]=t,r},[]);function w2(r){return r.reduce((e,t)=>(e+=m2[t],e),"")}function b2(r){const e=[];for(const t of r){const n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);const i=y2[n];if(i==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(i)}return new Uint8Array(e)}const v2=Hu({prefix:"ðŸš€",name:"base256emoji",encode:w2,decode:b2}),S2=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:v2},Symbol.toStringTag,{value:"Module"})),Va=ft({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),E2=ft({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),za=ft({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),A2=ft({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),x2=Object.freeze(Object.defineProperty({__proto__:null,base64:Va,base64pad:E2,base64url:za,base64urlpad:A2},Symbol.toStringTag,{value:"Module"})),_2=ft({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),C2=Object.freeze(Object.defineProperty({__proto__:null,base8:_2},Symbol.toStringTag,{value:"Module"})),I2=Hu({prefix:"\0",name:"identity",encode:r=>gC(r),decode:r=>pC(r)}),k2=Object.freeze(Object.defineProperty({__proto__:null,identity:I2},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;function T2({name:r,code:e,encode:t}){return new P2(r,e,t)}class P2{name;code;encode;constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?dn(this.code,t):t.then(n=>dn(this.code,n))}else throw Error("Unknown type, must be binary type")}}function R2(r){return async e=>new Uint8Array(await crypto.subtle.digest(r,e))}const Xi=T2({name:"sha2-256",code:18,encode:R2("SHA-256")}),_l={...k2,...g2,...C2,...u2,...f2,...LC,...FC,...IC,...x2,...S2};function rS(r,e,t,n){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:n}}}const Vy=rS("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),ah=rS("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);const e=$r(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),nS={utf8:Vy,"utf-8":Vy,hex:_l.base16,latin1:ah,ascii:ah,binary:ah,..._l};function Z(r,e="utf8"){const t=nS[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${r}`)}function ne(r,e="utf8"){const t=nS[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(r).substring(1)}const O2=parseInt("11111",2),Af=parseInt("10000000",2),B2=parseInt("01111111",2),zy={0:Do,1:Do,2:N2,3:M2,4:F2,5:L2,6:D2,16:Do,22:Do,48:Do};function Zi(r,e={offset:0}){const t=r[e.offset]&O2;if(e.offset++,zy[t]!=null)return zy[t](r,e);throw new Error("No decoder for tag "+t)}function ja(r,e){let t=0;if((r[e.offset]&Af)===Af){const n=r[e.offset]&B2;let i="0x";e.offset++;for(let s=0;s<n;s++,e.offset++)i+=r[e.offset].toString(16).padStart(2,"0");t=parseInt(i,16)}else t=r[e.offset],e.offset++;return t}function Do(r,e){ja(r,e);const t=[];for(;!(e.offset>=r.byteLength);){const n=Zi(r,e);if(n===null)break;t.push(n)}return t}function N2(r,e){const t=ja(r,e),n=e.offset,i=e.offset+t,s=[];for(let o=n;o<i;o++)o===n&&r[o]===0||s.push(r[o]);return e.offset+=t,Uint8Array.from(s)}function D2(r,e){const t=ja(r,e),n=e.offset+t,i=r[e.offset];e.offset++;let s=0,o=0;i<40?(s=0,o=i):i<80?(s=1,o=i-40):(s=2,o=i-80);let a=`${s}.${o}`,c=[];for(;e.offset<n;){const l=r[e.offset];if(e.offset++,c.push(l&127),l<128){c.reverse();let u=0;for(let d=0;d<c.length;d++)u+=c[d]<<d*7;a+=`.${u}`,c=[]}}return a}function L2(r,e){return e.offset++,null}function M2(r,e){const t=ja(r,e),n=r[e.offset];e.offset++;const i=r.subarray(e.offset,e.offset+t-1);if(e.offset+=t,n!==0)throw new Error("Unused bits in bit string is unimplemented");return i}function F2(r,e){const t=ja(r,e),n=r.subarray(e.offset,e.offset+t);return e.offset+=t,n}function U2(r){let e=r.toString(16);e.length%2===1&&(e="0"+e);const t=new ye;for(let n=0;n<e.length;n+=2)t.append(Uint8Array.from([parseInt(`${e[n]}${e[n+1]}`,16)]));return t}function Wu(r){if(r.byteLength<128)return Uint8Array.from([r.byteLength]);const e=U2(r.byteLength);return new ye(Uint8Array.from([e.byteLength|Af]),e)}function jt(r){const e=new ye,t=128;return(r.subarray()[0]&t)===t&&e.append(Uint8Array.from([0])),e.append(r),new ye(Uint8Array.from([2]),Wu(e),e)}function Pg(r){const e=Uint8Array.from([0]),t=new ye(e,r);return new ye(Uint8Array.from([3]),Wu(t),t)}function $2(r){return new ye(Uint8Array.from([4]),Wu(r),r)}function sn(r,e=48){const t=new ye;for(const n of r)t.append(n);return new ye(Uint8Array.from([e]),Wu(t),t)}const q2="1.2.840.10045.3.1.7",K2="1.3.132.0.34",V2="1.3.132.0.35";async function z2(r="P-256"){const e=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:r},!0,["sign","verify"]);return{publicKey:await crypto.subtle.exportKey("jwk",e.publicKey),privateKey:await crypto.subtle.exportKey("jwk",e.privateKey)}}async function j2(r,e,t){const n=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv??"P-256"},!1,["sign"]);t?.signal?.throwIfAborted();const i=await crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},n,e.subarray());return t?.signal?.throwIfAborted(),new Uint8Array(i,0,i.byteLength)}async function H2(r,e,t,n){const i=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv??"P-256"},!1,["verify"]);n?.signal?.throwIfAborted();const s=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},i,e,t.subarray());return n?.signal?.throwIfAborted(),s}const W2=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),G2=Uint8Array.from([6,5,43,129,4,0,34]),Y2=Uint8Array.from([6,5,43,129,4,0,35]),iS={ext:!0,kty:"EC",crv:"P-256"},sS={ext:!0,kty:"EC",crv:"P-384"},oS={ext:!0,kty:"EC",crv:"P-521"},Ss=32,Es=48,As=66;function Q2(r){const e=Zi(r);return aS(e)}function aS(r){const e=r[1],t=ne(e,"base64url"),n=r[2][1][0],i=1;let s,o;if(e.byteLength===Ss)return s=ne(n.subarray(i,i+Ss),"base64url"),o=ne(n.subarray(i+Ss),"base64url"),new ul({...iS,key_ops:["sign"],d:t,x:s,y:o});if(e.byteLength===Es)return s=ne(n.subarray(i,i+Es),"base64url"),o=ne(n.subarray(i+Es),"base64url"),new ul({...sS,key_ops:["sign"],d:t,x:s,y:o});if(e.byteLength===As)return s=ne(n.subarray(i,i+As),"base64url"),o=ne(n.subarray(i+As),"base64url"),new ul({...oS,key_ops:["sign"],d:t,x:s,y:o});throw new q(`Private key length was wrong length, got ${e.byteLength}, expected 32, 48 or 66`)}function cS(r){const e=Zi(r);return J2(e)}function J2(r){const e=r[1][1][0],t=1;let n,i;if(e.byteLength===Ss*2+1)return n=ne(e.subarray(t,t+Ss),"base64url"),i=ne(e.subarray(t+Ss),"base64url"),new ll({...iS,key_ops:["verify"],x:n,y:i});if(e.byteLength===Es*2+1)return n=ne(e.subarray(t,t+Es),"base64url"),i=ne(e.subarray(t+Es),"base64url"),new ll({...sS,key_ops:["verify"],x:n,y:i});if(e.byteLength===As*2+1)return n=ne(e.subarray(t,t+As),"base64url"),i=ne(e.subarray(t+As),"base64url"),new ll({...oS,key_ops:["verify"],x:n,y:i});throw new q(`coordinates were wrong length, got ${e.byteLength}, expected 65, 97 or 133`)}function X2(r){return sn([jt(Uint8Array.from([1])),$2(Z(r.d??"","base64url")),sn([lS(r.crv)],160),sn([Pg(new ye(Uint8Array.from([4]),Z(r.x??"","base64url"),Z(r.y??"","base64url")))],161)]).subarray()}function Z2(r){return sn([jt(Uint8Array.from([1])),sn([lS(r.crv)],160),sn([Pg(new ye(Uint8Array.from([4]),Z(r.x??"","base64url"),Z(r.y??"","base64url")))],161)]).subarray()}function lS(r){if(r==="P-256")return W2;if(r==="P-384")return G2;if(r==="P-521")return Y2;throw new q(`Invalid curve ${r}`)}async function eI(r="P-256"){const e=await z2(r);return new ul(e.privateKey)}class ll{type="ECDSA";jwk;_raw;constructor(e){this.jwk=e}get raw(){return this._raw==null&&(this._raw=Z2(this.jwk)),this._raw}toMultihash(){return Ka.digest(on(this))}toCID(){return Be.createV1(114,this.toMultihash())}toString(){return Qe.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Je(this.raw,e.raw)}async verify(e,t,n){return H2(this.jwk,t,e,n)}}class ul{type="ECDSA";jwk;publicKey;_raw;constructor(e){this.jwk=e,this.publicKey=new ll({crv:e.crv,ext:e.ext,key_ops:["verify"],kty:"EC",x:e.x,y:e.y})}get raw(){return this._raw==null&&(this._raw=X2(this.jwk)),this._raw}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Je(this.raw,e.raw)}async sign(e,t){return j2(this.jwk,e,t)}}const is=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Rg(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function xi(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function Er(r,...e){if(!Rg(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function Gu(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");xi(r.outputLen),xi(r.blockLen)}function Cl(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function tI(r,e){Er(r);const t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function Kr(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function ea(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function kr(r,e){return r<<32-e|r>>>e}function ch(r,e){return r<<e|r>>>32-e>>>0}const uS=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",rI=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function Bs(r){if(Er(r),uS)return r.toHex();let e="";for(let t=0;t<r.length;t++)e+=rI[r[t]];return e}const Yr={_0:48,_9:57,A:65,F:70,a:97,f:102};function jy(r){if(r>=Yr._0&&r<=Yr._9)return r-Yr._0;if(r>=Yr.A&&r<=Yr.F)return r-(Yr.A-10);if(r>=Yr.a&&r<=Yr.f)return r-(Yr.a-10)}function Og(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(uS)return Uint8Array.fromHex(r);const e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let i=0,s=0;i<t;i++,s+=2){const o=jy(r.charCodeAt(s)),a=jy(r.charCodeAt(s+1));if(o===void 0||a===void 0){const c=r[s]+r[s+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+s)}n[i]=o*16+a}return n}const nI=async()=>{};async function iI(r,e,t){let n=Date.now();for(let i=0;i<r;i++){t(i);const s=Date.now()-n;s>=0&&s<e||(await nI(),n+=s)}}function dS(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}function ga(r){return typeof r=="string"&&(r=dS(r)),Er(r),r}function Hy(r){return typeof r=="string"&&(r=dS(r)),Er(r),r}function tn(...r){let e=0;for(let n=0;n<r.length;n++){const i=r[n];Er(i),e+=i.length}const t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){const s=r[n];t.set(s,i),i+=s.length}return t}function sI(r,e){if(e!==void 0&&{}.toString.call(e)!=="[object Object]")throw new Error("options should be object or undefined");return Object.assign(r,e)}class hS{}function Bg(r){const e=n=>r().update(ga(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function Yu(r=32){if(is&&typeof is.getRandomValues=="function")return is.getRandomValues(new Uint8Array(r));if(is&&typeof is.randomBytes=="function")return Uint8Array.from(is.randomBytes(r));throw new Error("crypto.getRandomValues must be defined")}function oI(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const i=BigInt(32),s=BigInt(4294967295),o=Number(t>>i&s),a=Number(t&s),c=n?4:0,l=n?0:4;r.setUint32(e+c,o,n),r.setUint32(e+l,a,n)}function fS(r,e,t){return r&e^~r&t}function pS(r,e,t){return r&e^r&t^e&t}class Ng extends hS{constructor(e,t,n,i){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=i,this.buffer=new Uint8Array(e),this.view=ea(this.buffer)}update(e){Cl(this),e=ga(e),Er(e);const{view:t,buffer:n,blockLen:i}=this,s=e.length;for(let o=0;o<s;){const a=Math.min(i-this.pos,s-o);if(a===i){const c=ea(e);for(;i<=s-o;o+=i)this.process(c,o);continue}n.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Cl(this),tI(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:i,isLE:s}=this;let{pos:o}=this;t[o++]=128,Kr(this.buffer.subarray(o)),this.padOffset>i-o&&(this.process(n,0),o=0);for(let d=o;d<i;d++)t[d]=0;oI(n,i-8,BigInt(this.length*8),s),this.process(n,0);const a=ea(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=c/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<l;d++)a.setUint32(4*d,u[d],s)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:i,finished:s,destroyed:o,pos:a}=this;return e.destroyed=o,e.finished=s,e.length=i,e.pos=a,i%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}}const xn=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),gt=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),xc=BigInt(2**32-1),Wy=BigInt(32);function aI(r,e=!1){return e?{h:Number(r&xc),l:Number(r>>Wy&xc)}:{h:Number(r>>Wy&xc)|0,l:Number(r&xc)|0}}function cI(r,e=!1){const t=r.length;let n=new Uint32Array(t),i=new Uint32Array(t);for(let s=0;s<t;s++){const{h:o,l:a}=aI(r[s],e);[n[s],i[s]]=[o,a]}return[n,i]}const Gy=(r,e,t)=>r>>>t,Yy=(r,e,t)=>r<<32-t|e>>>t,ss=(r,e,t)=>r>>>t|e<<32-t,os=(r,e,t)=>r<<32-t|e>>>t,_c=(r,e,t)=>r<<64-t|e>>>t-32,Cc=(r,e,t)=>r>>>t-32|e<<64-t;function Qr(r,e,t,n){const i=(e>>>0)+(n>>>0);return{h:r+t+(i/2**32|0)|0,l:i|0}}const lI=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),uI=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,dI=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),hI=(r,e,t,n,i)=>e+t+n+i+(r/2**32|0)|0,fI=(r,e,t,n,i)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(i>>>0),pI=(r,e,t,n,i,s)=>e+t+n+i+s+(r/2**32|0)|0,gI=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),_n=new Uint32Array(64);class mI extends Ng{constructor(e=32){super(64,e,8,!1),this.A=xn[0]|0,this.B=xn[1]|0,this.C=xn[2]|0,this.D=xn[3]|0,this.E=xn[4]|0,this.F=xn[5]|0,this.G=xn[6]|0,this.H=xn[7]|0}get(){const{A:e,B:t,C:n,D:i,E:s,F:o,G:a,H:c}=this;return[e,t,n,i,s,o,a,c]}set(e,t,n,i,s,o,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=i|0,this.E=s|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let d=0;d<16;d++,t+=4)_n[d]=e.getUint32(t,!1);for(let d=16;d<64;d++){const h=_n[d-15],p=_n[d-2],m=kr(h,7)^kr(h,18)^h>>>3,w=kr(p,17)^kr(p,19)^p>>>10;_n[d]=w+_n[d-7]+m+_n[d-16]|0}let{A:n,B:i,C:s,D:o,E:a,F:c,G:l,H:u}=this;for(let d=0;d<64;d++){const h=kr(a,6)^kr(a,11)^kr(a,25),p=u+h+fS(a,c,l)+gI[d]+_n[d]|0,w=(kr(n,2)^kr(n,13)^kr(n,22))+pS(n,i,s)|0;u=l,l=c,c=a,a=o+p|0,o=s,s=i,i=n,n=p+w|0}n=n+this.A|0,i=i+this.B|0,s=s+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(n,i,s,o,a,c,l,u)}roundClean(){Kr(_n)}destroy(){this.set(0,0,0,0,0,0,0,0),Kr(this.buffer)}}const gS=cI(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),yI=gS[0],wI=gS[1],Cn=new Uint32Array(80),In=new Uint32Array(80);class bI extends Ng{constructor(e=64){super(128,e,16,!1),this.Ah=gt[0]|0,this.Al=gt[1]|0,this.Bh=gt[2]|0,this.Bl=gt[3]|0,this.Ch=gt[4]|0,this.Cl=gt[5]|0,this.Dh=gt[6]|0,this.Dl=gt[7]|0,this.Eh=gt[8]|0,this.El=gt[9]|0,this.Fh=gt[10]|0,this.Fl=gt[11]|0,this.Gh=gt[12]|0,this.Gl=gt[13]|0,this.Hh=gt[14]|0,this.Hl=gt[15]|0}get(){const{Ah:e,Al:t,Bh:n,Bl:i,Ch:s,Cl:o,Dh:a,Dl:c,Eh:l,El:u,Fh:d,Fl:h,Gh:p,Gl:m,Hh:w,Hl:y}=this;return[e,t,n,i,s,o,a,c,l,u,d,h,p,m,w,y]}set(e,t,n,i,s,o,a,c,l,u,d,h,p,m,w,y){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=i|0,this.Ch=s|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=d|0,this.Fl=h|0,this.Gh=p|0,this.Gl=m|0,this.Hh=w|0,this.Hl=y|0}process(e,t){for(let E=0;E<16;E++,t+=4)Cn[E]=e.getUint32(t),In[E]=e.getUint32(t+=4);for(let E=16;E<80;E++){const R=Cn[E-15]|0,S=In[E-15]|0,N=ss(R,S,1)^ss(R,S,8)^Gy(R,S,7),T=os(R,S,1)^os(R,S,8)^Yy(R,S,7),B=Cn[E-2]|0,v=In[E-2]|0,I=ss(B,v,19)^_c(B,v,61)^Gy(B,v,6),C=os(B,v,19)^Cc(B,v,61)^Yy(B,v,6),P=dI(T,C,In[E-7],In[E-16]),O=hI(P,N,I,Cn[E-7],Cn[E-16]);Cn[E]=O|0,In[E]=P|0}let{Ah:n,Al:i,Bh:s,Bl:o,Ch:a,Cl:c,Dh:l,Dl:u,Eh:d,El:h,Fh:p,Fl:m,Gh:w,Gl:y,Hh:b,Hl:_}=this;for(let E=0;E<80;E++){const R=ss(d,h,14)^ss(d,h,18)^_c(d,h,41),S=os(d,h,14)^os(d,h,18)^Cc(d,h,41),N=d&p^~d&w,T=h&m^~h&y,B=fI(_,S,T,wI[E],In[E]),v=pI(B,b,R,N,yI[E],Cn[E]),I=B|0,C=ss(n,i,28)^_c(n,i,34)^_c(n,i,39),P=os(n,i,28)^Cc(n,i,34)^Cc(n,i,39),O=n&s^n&a^s&a,L=i&o^i&c^o&c;b=w|0,_=y|0,w=p|0,y=m|0,p=d|0,m=h|0,{h:d,l:h}=Qr(l|0,u|0,v|0,I|0),l=a|0,u=c|0,a=s|0,c=o|0,s=n|0,o=i|0;const M=lI(I,P,L);n=uI(M,v,C,O),i=M|0}({h:n,l:i}=Qr(this.Ah|0,this.Al|0,n|0,i|0)),{h:s,l:o}=Qr(this.Bh|0,this.Bl|0,s|0,o|0),{h:a,l:c}=Qr(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:u}=Qr(this.Dh|0,this.Dl|0,l|0,u|0),{h:d,l:h}=Qr(this.Eh|0,this.El|0,d|0,h|0),{h:p,l:m}=Qr(this.Fh|0,this.Fl|0,p|0,m|0),{h:w,l:y}=Qr(this.Gh|0,this.Gl|0,w|0,y|0),{h:b,l:_}=Qr(this.Hh|0,this.Hl|0,b|0,_|0),this.set(n,i,s,o,a,c,l,u,d,h,p,m,w,y,b,_)}roundClean(){Kr(Cn,In)}destroy(){Kr(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const mS=Bg(()=>new mI),yS=Bg(()=>new bI);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Dg=BigInt(0),xf=BigInt(1);function Oi(r,e){if(typeof e!="boolean")throw new Error(r+" boolean expected, got "+e)}function Ic(r){const e=r.toString(16);return e.length&1?"0"+e:e}function wS(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Dg:BigInt("0x"+r)}function Qu(r){return wS(Bs(r))}function Bi(r){return Er(r),wS(Bs(Uint8Array.from(r).reverse()))}function Lg(r,e){return Og(r.toString(16).padStart(e*2,"0"))}function Ha(r,e){return Lg(r,e).reverse()}function qe(r,e,t){let n;if(typeof e=="string")try{n=Og(e)}catch(s){throw new Error(r+" must be hex string or Uint8Array, cause: "+s)}else if(Rg(e))n=Uint8Array.from(e);else throw new Error(r+" must be hex string or Uint8Array");const i=n.length;if(typeof t=="number"&&i!==t)throw new Error(r+" of length "+t+" expected, got "+i);return n}const lh=r=>typeof r=="bigint"&&Dg<=r;function vI(r,e,t){return lh(r)&&lh(e)&&lh(t)&&e<=r&&r<t}function Dn(r,e,t,n){if(!vI(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function SI(r){let e;for(e=0;r>Dg;r>>=xf,e+=1);return e}const Ju=r=>(xf<<BigInt(r))-xf;function EI(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");const n=p=>new Uint8Array(p),i=p=>Uint8Array.of(p);let s=n(r),o=n(r),a=0;const c=()=>{s.fill(1),o.fill(0),a=0},l=(...p)=>t(o,s,...p),u=(p=n(0))=>{o=l(i(0),p),s=l(),p.length!==0&&(o=l(i(1),p),s=l())},d=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let p=0;const m=[];for(;p<e;){s=l();const w=s.slice();m.push(w),p+=s.length}return tn(...m)};return(p,m)=>{c(),u(p);let w;for(;!(w=m(d()));)u();return c(),w}}function ho(r,e,t={}){if(!r||typeof r!="object")throw new Error("expected valid options object");function n(i,s,o){const a=r[i];if(o&&a===void 0)return;const c=typeof a;if(c!==s||a===null)throw new Error(`param "${i}" is invalid: expected ${s}, got ${c}`)}Object.entries(e).forEach(([i,s])=>n(i,s,!1)),Object.entries(t).forEach(([i,s])=>n(i,s,!0))}function Il(r){const e=new WeakMap;return(t,...n)=>{const i=e.get(t);if(i!==void 0)return i;const s=r(t,...n);return e.set(t,s),s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ft=BigInt(0),lt=BigInt(1),mi=BigInt(2),AI=BigInt(3),bS=BigInt(4),vS=BigInt(5),SS=BigInt(8);function Ke(r,e){const t=r%e;return t>=Ft?t:e+t}function $e(r,e,t){let n=r;for(;e-- >Ft;)n*=n,n%=t;return n}function Qy(r,e){if(r===Ft)throw new Error("invert: expected non-zero number");if(e<=Ft)throw new Error("invert: expected positive modulus, got "+e);let t=Ke(r,e),n=e,i=Ft,s=lt;for(;t!==Ft;){const a=n/t,c=n%t,l=i-s*a;n=t,t=c,i=s,s=l}if(n!==lt)throw new Error("invert: does not exist");return Ke(i,e)}function ES(r,e){const t=(r.ORDER+lt)/bS,n=r.pow(e,t);if(!r.eql(r.sqr(n),e))throw new Error("Cannot find square root");return n}function xI(r,e){const t=(r.ORDER-vS)/SS,n=r.mul(e,mi),i=r.pow(n,t),s=r.mul(e,i),o=r.mul(r.mul(s,mi),i),a=r.mul(s,r.sub(o,r.ONE));if(!r.eql(r.sqr(a),e))throw new Error("Cannot find square root");return a}function _I(r){if(r<BigInt(3))throw new Error("sqrt is not defined for small field");let e=r-lt,t=0;for(;e%mi===Ft;)e/=mi,t++;let n=mi;const i=fo(r);for(;Jy(i,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return ES;let s=i.pow(n,e);const o=(e+lt)/mi;return function(c,l){if(c.is0(l))return l;if(Jy(c,l)!==1)throw new Error("Cannot find square root");let u=t,d=c.mul(c.ONE,s),h=c.pow(l,e),p=c.pow(l,o);for(;!c.eql(h,c.ONE);){if(c.is0(h))return c.ZERO;let m=1,w=c.sqr(h);for(;!c.eql(w,c.ONE);)if(m++,w=c.sqr(w),m===u)throw new Error("Cannot find square root");const y=lt<<BigInt(u-m-1),b=c.pow(d,y);u=m,d=c.sqr(b),h=c.mul(h,d),p=c.mul(p,b)}return p}}function CI(r){return r%bS===AI?ES:r%SS===vS?xI:_I(r)}const II=(r,e)=>(Ke(r,e)&lt)===lt,kI=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function TI(r){const e={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},t=kI.reduce((n,i)=>(n[i]="function",n),e);return ho(r,t),r}function PI(r,e,t){if(t<Ft)throw new Error("invalid exponent, negatives unsupported");if(t===Ft)return r.ONE;if(t===lt)return e;let n=r.ONE,i=e;for(;t>Ft;)t&lt&&(n=r.mul(n,i)),i=r.sqr(i),t>>=lt;return n}function AS(r,e,t=!1){const n=new Array(e.length).fill(t?r.ZERO:void 0),i=e.reduce((o,a,c)=>r.is0(a)?o:(n[c]=o,r.mul(o,a)),r.ONE),s=r.inv(i);return e.reduceRight((o,a,c)=>r.is0(a)?o:(n[c]=r.mul(o,n[c]),r.mul(o,a)),s),n}function Jy(r,e){const t=(r.ORDER-lt)/mi,n=r.pow(e,t),i=r.eql(n,r.ONE),s=r.eql(n,r.ZERO),o=r.eql(n,r.neg(r.ONE));if(!i&&!s&&!o)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function RI(r,e){e!==void 0&&xi(e);const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function fo(r,e,t=!1,n={}){if(r<=Ft)throw new Error("invalid field: expected ORDER > 0, got "+r);let i,s;if(typeof e=="object"&&e!=null){if(n.sqrt||t)throw new Error("cannot specify opts in two arguments");const u=e;u.BITS&&(i=u.BITS),u.sqrt&&(s=u.sqrt),typeof u.isLE=="boolean"&&(t=u.isLE)}else typeof e=="number"&&(i=e),n.sqrt&&(s=n.sqrt);const{nBitLength:o,nByteLength:a}=RI(r,i);if(a>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const l=Object.freeze({ORDER:r,isLE:t,BITS:o,BYTES:a,MASK:Ju(o),ZERO:Ft,ONE:lt,create:u=>Ke(u,r),isValid:u=>{if(typeof u!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof u);return Ft<=u&&u<r},is0:u=>u===Ft,isValidNot0:u=>!l.is0(u)&&l.isValid(u),isOdd:u=>(u&lt)===lt,neg:u=>Ke(-u,r),eql:(u,d)=>u===d,sqr:u=>Ke(u*u,r),add:(u,d)=>Ke(u+d,r),sub:(u,d)=>Ke(u-d,r),mul:(u,d)=>Ke(u*d,r),pow:(u,d)=>PI(l,u,d),div:(u,d)=>Ke(u*Qy(d,r),r),sqrN:u=>u*u,addN:(u,d)=>u+d,subN:(u,d)=>u-d,mulN:(u,d)=>u*d,inv:u=>Qy(u,r),sqrt:s||(u=>(c||(c=CI(r)),c(l,u))),toBytes:u=>t?Ha(u,a):Lg(u,a),fromBytes:u=>{if(u.length!==a)throw new Error("Field.fromBytes: expected "+a+" bytes, got "+u.length);return t?Bi(u):Qu(u)},invertBatch:u=>AS(l,u),cmov:(u,d,h)=>h?d:u});return Object.freeze(l)}function xS(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function _S(r){const e=xS(r);return e+Math.ceil(e/2)}function OI(r,e,t=!1){const n=r.length,i=xS(e),s=_S(e);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);const o=t?Bi(r):Qu(r),a=Ke(o,e-lt)+lt;return t?Ha(a,i):Lg(a,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ns=BigInt(0),yi=BigInt(1);function ta(r,e){const t=e.negate();return r?t:e}function CS(r,e,t){const n=e==="pz"?o=>o.pz:o=>o.ez,i=AS(r.Fp,t.map(n));return t.map((o,a)=>o.toAffine(i[a])).map(r.fromAffine)}function IS(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function uh(r,e){IS(r,e);const t=Math.ceil(e/r)+1,n=2**(r-1),i=2**r,s=Ju(r),o=BigInt(r);return{windows:t,windowSize:n,mask:s,maxNumber:i,shiftBy:o}}function Xy(r,e,t){const{windowSize:n,mask:i,maxNumber:s,shiftBy:o}=t;let a=Number(r&i),c=r>>o;a>n&&(a-=s,c+=yi);const l=e*n,u=l+Math.abs(a)-1,d=a===0,h=a<0,p=e%2!==0;return{nextN:c,offset:u,isZero:d,isNeg:h,isNegF:p,offsetF:l}}function BI(r,e){if(!Array.isArray(r))throw new Error("array expected");r.forEach((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)})}function NI(r,e){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)})}const dh=new WeakMap,kS=new WeakMap;function hh(r){return kS.get(r)||1}function Zy(r){if(r!==Ns)throw new Error("invalid wNAF")}function TS(r,e){return{constTimeNegate:ta,hasPrecomputes(t){return hh(t)!==1},unsafeLadder(t,n,i=r.ZERO){let s=t;for(;n>Ns;)n&yi&&(i=i.add(s)),s=s.double(),n>>=yi;return i},precomputeWindow(t,n){const{windows:i,windowSize:s}=uh(n,e),o=[];let a=t,c=a;for(let l=0;l<i;l++){c=a,o.push(c);for(let u=1;u<s;u++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(t,n,i){let s=r.ZERO,o=r.BASE;const a=uh(t,e);for(let c=0;c<a.windows;c++){const{nextN:l,offset:u,isZero:d,isNeg:h,isNegF:p,offsetF:m}=Xy(i,c,a);i=l,d?o=o.add(ta(p,n[m])):s=s.add(ta(h,n[u]))}return Zy(i),{p:s,f:o}},wNAFUnsafe(t,n,i,s=r.ZERO){const o=uh(t,e);for(let a=0;a<o.windows&&i!==Ns;a++){const{nextN:c,offset:l,isZero:u,isNeg:d}=Xy(i,a,o);if(i=c,!u){const h=n[l];s=s.add(d?h.negate():h)}}return Zy(i),s},getPrecomputes(t,n,i){let s=dh.get(n);return s||(s=this.precomputeWindow(n,t),t!==1&&(typeof i=="function"&&(s=i(s)),dh.set(n,s))),s},wNAFCached(t,n,i){const s=hh(t);return this.wNAF(s,this.getPrecomputes(s,t,i),n)},wNAFCachedUnsafe(t,n,i,s){const o=hh(t);return o===1?this.unsafeLadder(t,n,s):this.wNAFUnsafe(o,this.getPrecomputes(o,t,i),n,s)},setWindowSize(t,n){IS(n,e),kS.set(t,n),dh.delete(t)}}}function DI(r,e,t,n){let i=e,s=r.ZERO,o=r.ZERO;for(;t>Ns||n>Ns;)t&yi&&(s=s.add(i)),n&yi&&(o=o.add(i)),i=i.double(),t>>=yi,n>>=yi;return{p1:s,p2:o}}function PS(r,e,t,n){BI(t,r),NI(n,e);const i=t.length,s=n.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");const o=r.ZERO,a=SI(BigInt(i));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const l=Ju(c),u=new Array(Number(l)+1).fill(o),d=Math.floor((e.BITS-1)/c)*c;let h=o;for(let p=d;p>=0;p-=c){u.fill(o);for(let w=0;w<s;w++){const y=n[w],b=Number(y>>BigInt(p)&l);u[b]=u[b].add(t[w])}let m=o;for(let w=u.length-1,y=o;w>0;w--)y=y.add(u[w]),m=m.add(y);if(h=h.add(m),p!==0)for(let w=0;w<c;w++)h=h.double()}return h}function ew(r,e){if(e){if(e.ORDER!==r)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return TI(e),e}else return fo(r)}function RS(r,e,t={}){if(!e||typeof e!="object")throw new Error(`expected valid ${r} CURVE object`);for(const a of["p","n","h"]){const c=e[a];if(!(typeof c=="bigint"&&c>Ns))throw new Error(`CURVE.${a} must be positive bigint`)}const n=ew(e.p,t.Fp),i=ew(e.n,t.Fn),o=["Gx","Gy","a",r==="weierstrass"?"b":"d"];for(const a of o)if(!n.isValid(e[a]))throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);return{Fp:n,Fn:i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Pr=BigInt(0),Ct=BigInt(1),fh=BigInt(2),LI=BigInt(8),MI={zip215:!0};function FI(r,e,t,n){const i=r.sqr(t),s=r.sqr(n),o=r.add(r.mul(e.a,i),s),a=r.add(r.ONE,r.mul(e.d,r.mul(i,s)));return r.eql(o,a)}function UI(r,e={}){const{Fp:t,Fn:n}=RS("edwards",r,e),{h:i,n:s}=r;ho(e,{},{uvRatio:"function"});const o=fh<<BigInt(n.BYTES*8)-Ct,a=w=>t.create(w),c=e.uvRatio||((w,y)=>{try{return{isValid:!0,value:t.sqrt(t.div(w,y))}}catch{return{isValid:!1,value:Pr}}});if(!FI(t,r,r.Gx,r.Gy))throw new Error("bad curve params: generator point");function l(w,y,b=!1){const _=b?Ct:Pr;return Dn("coordinate "+w,y,_,o),y}function u(w){if(!(w instanceof p))throw new Error("ExtendedPoint expected")}const d=Il((w,y)=>{const{ex:b,ey:_,ez:E}=w,R=w.is0();y==null&&(y=R?LI:t.inv(E));const S=a(b*y),N=a(_*y),T=a(E*y);if(R)return{x:Pr,y:Ct};if(T!==Ct)throw new Error("invZ was invalid");return{x:S,y:N}}),h=Il(w=>{const{a:y,d:b}=r;if(w.is0())throw new Error("bad point: ZERO");const{ex:_,ey:E,ez:R,et:S}=w,N=a(_*_),T=a(E*E),B=a(R*R),v=a(B*B),I=a(N*y),C=a(B*a(I+T)),P=a(v+a(b*a(N*T)));if(C!==P)throw new Error("bad point: equation left != right (1)");const O=a(_*E),L=a(R*S);if(O!==L)throw new Error("bad point: equation left != right (2)");return!0});class p{constructor(y,b,_,E){this.ex=l("x",y),this.ey=l("y",b),this.ez=l("z",_,!0),this.et=l("t",E),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(y){if(y instanceof p)throw new Error("extended point not allowed");const{x:b,y:_}=y||{};return l("x",b),l("y",_),new p(b,_,Ct,a(b*_))}static normalizeZ(y){return CS(p,"ez",y)}static msm(y,b){return PS(p,n,y,b)}_setWindowSize(y){this.precompute(y)}precompute(y=8,b=!0){return m.setWindowSize(this,y),b||this.multiply(fh),this}assertValidity(){h(this)}equals(y){u(y);const{ex:b,ey:_,ez:E}=this,{ex:R,ey:S,ez:N}=y,T=a(b*N),B=a(R*E),v=a(_*N),I=a(S*E);return T===B&&v===I}is0(){return this.equals(p.ZERO)}negate(){return new p(a(-this.ex),this.ey,this.ez,a(-this.et))}double(){const{a:y}=r,{ex:b,ey:_,ez:E}=this,R=a(b*b),S=a(_*_),N=a(fh*a(E*E)),T=a(y*R),B=b+_,v=a(a(B*B)-R-S),I=T+S,C=I-N,P=T-S,O=a(v*C),L=a(I*P),M=a(v*P),U=a(C*I);return new p(O,L,U,M)}add(y){u(y);const{a:b,d:_}=r,{ex:E,ey:R,ez:S,et:N}=this,{ex:T,ey:B,ez:v,et:I}=y,C=a(E*T),P=a(R*B),O=a(N*_*I),L=a(S*v),M=a((E+R)*(T+B)-C-P),U=L-O,K=L+O,j=a(P-b*C),V=a(M*U),se=a(K*j),Y=a(M*j),ae=a(U*K);return new p(V,se,ae,Y)}subtract(y){return this.add(y.negate())}multiply(y){const b=y;Dn("scalar",b,Ct,s);const{p:_,f:E}=m.wNAFCached(this,b,p.normalizeZ);return p.normalizeZ([_,E])[0]}multiplyUnsafe(y,b=p.ZERO){const _=y;return Dn("scalar",_,Pr,s),_===Pr?p.ZERO:this.is0()||_===Ct?this:m.wNAFCachedUnsafe(this,_,p.normalizeZ,b)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}isTorsionFree(){return m.wNAFCachedUnsafe(this,s).is0()}toAffine(y){return d(this,y)}clearCofactor(){return i===Ct?this:this.multiplyUnsafe(i)}static fromBytes(y,b=!1){return Er(y),this.fromHex(y,b)}static fromHex(y,b=!1){const{d:_,a:E}=r,R=t.BYTES;y=qe("pointHex",y,R),Oi("zip215",b);const S=y.slice(),N=y[R-1];S[R-1]=N&-129;const T=Bi(S),B=b?o:t.ORDER;Dn("pointHex.y",T,Pr,B);const v=a(T*T),I=a(v-Ct),C=a(_*v-E);let{isValid:P,value:O}=c(I,C);if(!P)throw new Error("Point.fromHex: invalid y coordinate");const L=(O&Ct)===Ct,M=(N&128)!==0;if(!b&&O===Pr&&M)throw new Error("Point.fromHex: x=0 and x_0=1");return M!==L&&(O=a(-O)),p.fromAffine({x:O,y:T})}static fromPrivateScalar(y){return p.BASE.multiply(y)}toBytes(){const{x:y,y:b}=this.toAffine(),_=Ha(b,t.BYTES);return _[_.length-1]|=y&Ct?128:0,_}toRawBytes(){return this.toBytes()}toHex(){return Bs(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}p.BASE=new p(r.Gx,r.Gy,Ct,a(r.Gx*r.Gy)),p.ZERO=new p(Pr,Ct,Ct,Pr),p.Fp=t,p.Fn=n;const m=TS(p,n.BYTES*8);return p}function $I(r,e){ho(e,{hash:"function"},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:t,hash:n}=e,{BASE:i,Fp:s,Fn:o}=r,a=o.ORDER,c=e.randomBytes||Yu,l=e.adjustScalarBytes||(S=>S),u=e.domain||((S,N,T)=>{if(Oi("phflag",T),N.length||T)throw new Error("Contexts/pre-hash are not supported");return S});function d(S){return o.create(S)}function h(S){return d(Bi(S))}function p(S){const N=s.BYTES;S=qe("private key",S,N);const T=qe("hashed private key",n(S),2*N),B=l(T.slice(0,N)),v=T.slice(N,2*N),I=h(B);return{head:B,prefix:v,scalar:I}}function m(S){const{head:N,prefix:T,scalar:B}=p(S),v=i.multiply(B),I=v.toBytes();return{head:N,prefix:T,scalar:B,point:v,pointBytes:I}}function w(S){return m(S).pointBytes}function y(S=Uint8Array.of(),...N){const T=tn(...N);return h(n(u(T,qe("context",S),!!t)))}function b(S,N,T={}){S=qe("message",S),t&&(S=t(S));const{prefix:B,scalar:v,pointBytes:I}=m(N),C=y(T.context,B,S),P=i.multiply(C).toBytes(),O=y(T.context,P,I,S),L=d(C+O*v);Dn("signature.s",L,Pr,a);const M=s.BYTES,U=tn(P,Ha(L,M));return qe("result",U,M*2)}const _=MI;function E(S,N,T,B=_){const{context:v,zip215:I}=B,C=s.BYTES;S=qe("signature",S,2*C),N=qe("message",N),T=qe("publicKey",T,C),I!==void 0&&Oi("zip215",I),t&&(N=t(N));const P=Bi(S.slice(C,2*C));let O,L,M;try{O=r.fromHex(T,I),L=r.fromHex(S.slice(0,C),I),M=i.multiplyUnsafe(P)}catch{return!1}if(!I&&O.isSmallOrder())return!1;const U=y(v,L.toBytes(),O.toBytes(),N);return L.add(O.multiplyUnsafe(U)).subtract(M).clearCofactor().is0()}return i.precompute(8),{getPublicKey:w,sign:b,verify:E,utils:{getExtendedPublicKey:m,randomPrivateKey:()=>c(s.BYTES),precompute(S=8,N=r.BASE){return N.precompute(S,!1)}},Point:r}}function qI(r){const e={a:r.a,d:r.d,p:r.Fp.ORDER,n:r.n,h:r.h,Gx:r.Gx,Gy:r.Gy},t=r.Fp,n=fo(e.n,r.nBitLength,!0),i={Fp:t,Fn:n,uvRatio:r.uvRatio},s={hash:r.hash,randomBytes:r.randomBytes,adjustScalarBytes:r.adjustScalarBytes,domain:r.domain,prehash:r.prehash,mapToCurve:r.mapToCurve};return{CURVE:e,curveOpts:i,eddsaOpts:s}}function KI(r,e){return Object.assign({},e,{ExtendedPoint:e.Point,CURVE:r})}function VI(r){const{CURVE:e,curveOpts:t,eddsaOpts:n}=qI(r),i=UI(e,t),s=$I(i,n);return KI(r,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Lo=BigInt(0),as=BigInt(1),kc=BigInt(2);function zI(r){return ho(r,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...r})}function jI(r){const e=zI(r),{P:t,type:n,adjustScalarBytes:i,powPminus2:s,randomBytes:o}=e,a=n==="x25519";if(!a&&n!=="x448")throw new Error("invalid type");const c=o||Yu,l=a?255:448,u=a?32:56,d=BigInt(a?9:5),h=BigInt(a?121665:39081),p=a?kc**BigInt(254):kc**BigInt(447),m=a?BigInt(8)*kc**BigInt(251)-as:BigInt(4)*kc**BigInt(445)-as,w=p+m+as,y=v=>Ke(v,t),b=_(d);function _(v){return Ha(y(v),u)}function E(v){const I=qe("u coordinate",v,u);return a&&(I[31]&=127),y(Bi(I))}function R(v){return Bi(i(qe("scalar",v,u)))}function S(v,I){const C=B(E(I),R(v));if(C===Lo)throw new Error("invalid private or public key received");return _(C)}function N(v){return S(v,b)}function T(v,I,C){const P=y(v*(I-C));return I=y(I-P),C=y(C+P),{x_2:I,x_3:C}}function B(v,I){Dn("u",v,Lo,t),Dn("scalar",I,p,w);const C=I,P=v;let O=as,L=Lo,M=v,U=as,K=Lo;for(let V=BigInt(l-1);V>=Lo;V--){const se=C>>V&as;K^=se,{x_2:O,x_3:M}=T(K,O,M),{x_2:L,x_3:U}=T(K,L,U),K=se;const Y=O+L,ae=y(Y*Y),z=O-L,ve=y(z*z),fe=ae-ve,le=M+U,pt=M-U,tt=y(pt*Y),Ge=y(le*z),An=tt+Ge,Ye=tt-Ge;M=y(An*An),U=y(P*y(Ye*Ye)),O=y(ae*ve),L=y(fe*(ae+y(h*fe)))}({x_2:O,x_3:M}=T(K,O,M)),{x_2:L,x_3:U}=T(K,L,U);const j=s(L);return y(O*j)}return{scalarMult:S,scalarMultBase:N,getSharedSecret:(v,I)=>S(v,I),getPublicKey:v=>N(v),utils:{randomPrivateKey:()=>c(u)},GuBytes:b.slice()}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */BigInt(0);const HI=BigInt(1),tw=BigInt(2),WI=BigInt(3),GI=BigInt(5),YI=BigInt(8),Wa={p:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:YI,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function OS(r){const e=BigInt(10),t=BigInt(20),n=BigInt(40),i=BigInt(80),s=Wa.p,a=r*r%s*r%s,c=$e(a,tw,s)*a%s,l=$e(c,HI,s)*r%s,u=$e(l,GI,s)*l%s,d=$e(u,e,s)*u%s,h=$e(d,t,s)*d%s,p=$e(h,n,s)*h%s,m=$e(p,i,s)*p%s,w=$e(m,i,s)*p%s,y=$e(w,e,s)*u%s;return{pow_p_5_8:$e(y,tw,s)*r%s,b2:a}}function BS(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}const rw=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function QI(r,e){const t=Wa.p,n=Ke(e*e*e,t),i=Ke(n*n*e,t),s=OS(r*i).pow_p_5_8;let o=Ke(r*n*s,t);const a=Ke(e*o*o,t),c=o,l=Ke(o*rw,t),u=a===r,d=a===Ke(-r,t),h=a===Ke(-r*rw,t);return u&&(o=c),(d||h)&&(o=l),II(o,t)&&(o=Ke(-o,t)),{isValid:u||d,value:o}}const JI=fo(Wa.p,void 0,!0),XI={...Wa,Fp:JI,hash:yS,adjustScalarBytes:BS,uvRatio:QI},kl=VI(XI),Tc=(()=>{const r=Wa.p;return jI({P:r,type:"x25519",powPminus2:e=>{const{pow_p_5_8:t,b2:n}=OS(e);return Ke($e(t,WI,r)*n,r)},adjustScalarBytes:BS})})();class nw extends Error{constructor(e="An error occurred while signing a message"){super(e),this.name="SigningError"}}class iw extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}}class ZI extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}}const Pt={get(r=globalThis){const e=r.crypto;if(e?.subtle==null)throw new ZI("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return e}},Tl=32,Br=64,_f=32;let xs;const NS=(async()=>{try{return await Pt.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function ek(){const r=kl.utils.randomPrivateKey(),e=kl.getPublicKey(r);return{privateKey:ak(r,e),publicKey:e}}async function tk(r,e){let t;r.length===Br?t=r.subarray(0,32):t=r;const n={crv:"Ed25519",kty:"OKP",x:ne(r.subarray(32),"base64url"),d:ne(t,"base64url"),ext:!0,key_ops:["sign"]},i=await Pt.get().subtle.importKey("jwk",n,{name:"Ed25519"},!0,["sign"]),s=await Pt.get().subtle.sign({name:"Ed25519"},i,e instanceof Uint8Array?e:e.subarray());return new Uint8Array(s,0,s.byteLength)}function rk(r,e){const t=r.subarray(0,_f);return kl.sign(e instanceof Uint8Array?e:e.subarray(),t)}async function nk(r,e){return xs==null&&(xs=await NS),xs?tk(r,e):rk(r,e)}async function ik(r,e,t){if(r.buffer instanceof ArrayBuffer){const n=await Pt.get().subtle.importKey("raw",r.buffer,{name:"Ed25519"},!1,["verify"]);return await Pt.get().subtle.verify({name:"Ed25519"},n,e,t instanceof Uint8Array?t:t.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function sk(r,e,t){return kl.verify(e,t instanceof Uint8Array?t:t.subarray(),r)}async function ok(r,e,t){return xs==null&&(xs=await NS),xs?ik(r,e,t):sk(r,e,t)}function ak(r,e){const t=new Uint8Array(Br);for(let n=0;n<_f;n++)t[n]=r[n],t[_f+n]=e[n];return t}function Xu(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class DS{type="Ed25519";raw;constructor(e){this.raw=ma(e,Tl)}toMultihash(){return Ka.digest(on(this))}toCID(){return Be.createV1(114,this.toMultihash())}toString(){return Qe.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Je(this.raw,e.raw)}verify(e,t,n){n?.signal?.throwIfAborted();const i=ok(this.raw,t,e);return Xu(i)?i.then(s=>(n?.signal?.throwIfAborted(),s)):i}}class Cf{type="Ed25519";raw;publicKey;constructor(e,t){this.raw=ma(e,Br),this.publicKey=new DS(t)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Je(this.raw,e.raw)}sign(e,t){t?.signal?.throwIfAborted();const n=nk(this.raw,e);return Xu(n)?n.then(i=>(t?.signal?.throwIfAborted(),i)):(t?.signal?.throwIfAborted(),n)}}function LS(r){if(r.length>Br){r=ma(r,Br+Tl);const n=r.subarray(0,Br),i=r.subarray(Br,r.length);return new Cf(n,i)}r=ma(r,Br);const e=r.subarray(0,Br),t=r.subarray(Tl);return new Cf(e,t)}function MS(r){return r=ma(r,Tl),new DS(r)}async function ck(){const{privateKey:r,publicKey:e}=ek();return new Cf(r,e)}function ma(r,e){if(r=Uint8Array.from(r??[]),r.length!==e)throw new q(`Key must be a Uint8Array of length ${e}, got ${r.length}`);return r}const lk=Math.pow(2,7),uk=Math.pow(2,14),dk=Math.pow(2,21),Mg=Math.pow(2,28),Fg=Math.pow(2,35),Ug=Math.pow(2,42),$g=Math.pow(2,49),xe=128,yt=127;function Et(r){if(r<lk)return 1;if(r<uk)return 2;if(r<dk)return 3;if(r<Mg)return 4;if(r<Fg)return 5;if(r<Ug)return 6;if(r<$g)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Pl(r,e,t=0){switch(Et(r)){case 8:e[t++]=r&255|xe,r/=128;case 7:e[t++]=r&255|xe,r/=128;case 6:e[t++]=r&255|xe,r/=128;case 5:e[t++]=r&255|xe,r/=128;case 4:e[t++]=r&255|xe,r>>>=7;case 3:e[t++]=r&255|xe,r>>>=7;case 2:e[t++]=r&255|xe,r>>>=7;case 1:{e[t++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return e}function hk(r,e,t=0){switch(Et(r)){case 8:e.set(t++,r&255|xe),r/=128;case 7:e.set(t++,r&255|xe),r/=128;case 6:e.set(t++,r&255|xe),r/=128;case 5:e.set(t++,r&255|xe),r/=128;case 4:e.set(t++,r&255|xe),r>>>=7;case 3:e.set(t++,r&255|xe),r>>>=7;case 2:e.set(t++,r&255|xe),r>>>=7;case 1:{e.set(t++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return e}function FS(r,e){let t=r[e],n=0;if(n+=t&yt,t<xe||(t=r[e+1],n+=(t&yt)<<7,t<xe)||(t=r[e+2],n+=(t&yt)<<14,t<xe)||(t=r[e+3],n+=(t&yt)<<21,t<xe)||(t=r[e+4],n+=(t&yt)*Mg,t<xe)||(t=r[e+5],n+=(t&yt)*Fg,t<xe)||(t=r[e+6],n+=(t&yt)*Ug,t<xe)||(t=r[e+7],n+=(t&yt)*$g,t<xe))return n;throw new RangeError("Could not decode varint")}function fk(r,e){let t=r.get(e),n=0;if(n+=t&yt,t<xe||(t=r.get(e+1),n+=(t&yt)<<7,t<xe)||(t=r.get(e+2),n+=(t&yt)<<14,t<xe)||(t=r.get(e+3),n+=(t&yt)<<21,t<xe)||(t=r.get(e+4),n+=(t&yt)*Mg,t<xe)||(t=r.get(e+5),n+=(t&yt)*Fg,t<xe)||(t=r.get(e+6),n+=(t&yt)*Ug,t<xe)||(t=r.get(e+7),n+=(t&yt)*$g,t<xe))return n;throw new RangeError("Could not decode varint")}function _s(r,e,t=0){return e==null&&(e=$r(Et(r))),e instanceof Uint8Array?Pl(r,e,t):hk(r,e,t)}function Zu(r,e=0){return r instanceof Uint8Array?FS(r,e):fk(r,e)}const qg=new Float32Array([-0]),Ln=new Uint8Array(qg.buffer);function pk(r,e,t){qg[0]=r,e[t]=Ln[0],e[t+1]=Ln[1],e[t+2]=Ln[2],e[t+3]=Ln[3]}function gk(r,e){return Ln[0]=r[e],Ln[1]=r[e+1],Ln[2]=r[e+2],Ln[3]=r[e+3],qg[0]}const Kg=new Float64Array([-0]),wt=new Uint8Array(Kg.buffer);function mk(r,e,t){Kg[0]=r,e[t]=wt[0],e[t+1]=wt[1],e[t+2]=wt[2],e[t+3]=wt[3],e[t+4]=wt[4],e[t+5]=wt[5],e[t+6]=wt[6],e[t+7]=wt[7]}function yk(r,e){return wt[0]=r[e],wt[1]=r[e+1],wt[2]=r[e+2],wt[3]=r[e+3],wt[4]=r[e+4],wt[5]=r[e+5],wt[6]=r[e+6],wt[7]=r[e+7],Kg[0]}const wk=BigInt(Number.MAX_SAFE_INTEGER),bk=BigInt(Number.MIN_SAFE_INTEGER);class vt{lo;hi;constructor(e,t){this.lo=e|0,this.hi=t|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(t+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(BigInt(t)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?t===0?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:n<128?9:10}static fromBigInt(e){if(e===0n)return _i;if(e<wk&&e>bk)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let n=e>>32n,i=e-(n<<32n);return t&&(n=~n|0n,i=~i|0n,++i>sw&&(i=0n,++n>sw&&(n=0n))),new vt(Number(i),Number(n))}static fromNumber(e){if(e===0)return _i;const t=e<0;t&&(e=-e);let n=e>>>0,i=(e-n)/4294967296>>>0;return t&&(i=~i>>>0,n=~n>>>0,++n>4294967295&&(n=0,++i>4294967295&&(i=0))),new vt(n,i)}static from(e){return typeof e=="number"?vt.fromNumber(e):typeof e=="bigint"?vt.fromBigInt(e):typeof e=="string"?vt.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new vt(e.low>>>0,e.high>>>0):_i}}const _i=new vt(0,0);_i.toBigInt=function(){return 0n};_i.zzEncode=_i.zzDecode=function(){return this};_i.length=function(){return 1};const sw=4294967296n;function vk(r){let e=0,t=0;for(let n=0;n<r.length;++n)t=r.charCodeAt(n),t<128?e+=1:t<2048?e+=2:(t&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,e+=4):e+=3;return e}function Sk(r,e,t){if(t-e<1)return"";let i;const s=[];let o=0,a;for(;e<t;)a=r[e++],a<128?s[o++]=a:a>191&&a<224?s[o++]=(a&31)<<6|r[e++]&63:a>239&&a<365?(a=((a&7)<<18|(r[e++]&63)<<12|(r[e++]&63)<<6|r[e++]&63)-65536,s[o++]=55296+(a>>10),s[o++]=56320+(a&1023)):s[o++]=(a&15)<<12|(r[e++]&63)<<6|r[e++]&63,o>8191&&((i??(i=[])).push(String.fromCharCode.apply(String,s)),o=0);return i!=null?(o>0&&i.push(String.fromCharCode.apply(String,s.slice(0,o))),i.join("")):String.fromCharCode.apply(String,s.slice(0,o))}function US(r,e,t){const n=t;let i,s;for(let o=0;o<r.length;++o)i=r.charCodeAt(o),i<128?e[t++]=i:i<2048?(e[t++]=i>>6|192,e[t++]=i&63|128):(i&64512)===55296&&((s=r.charCodeAt(o+1))&64512)===56320?(i=65536+((i&1023)<<10)+(s&1023),++o,e[t++]=i>>18|240,e[t++]=i>>12&63|128,e[t++]=i>>6&63|128,e[t++]=i&63|128):(e[t++]=i>>12|224,e[t++]=i>>6&63|128,e[t++]=i&63|128);return t-n}function hr(r,e){return RangeError(`index out of range: ${r.pos} + ${e??1} > ${r.len}`)}function Pc(r,e){return(r[e-4]|r[e-3]<<8|r[e-2]<<16|r[e-1]<<24)>>>0}class Ek{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(e){this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,hr(this,10);return e}int32(){return this.uint32()|0}sint32(){const e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw hr(this,4);return Pc(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw hr(this,4);return Pc(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw hr(this,4);const e=gk(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw hr(this,4);const e=yk(this.buf,this.pos);return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,n=this.pos+e;if(n>this.len)throw hr(this,e);return this.pos+=e,t===n?new Uint8Array(0):this.buf.subarray(t,n)}string(){const e=this.bytes();return Sk(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw hr(this,e);this.pos+=e}else do if(this.pos>=this.len)throw hr(this);while((this.buf[this.pos++]&128)!==0);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new vt(0,0);let t=0;if(this.len-this.pos>4){for(;t<4;++t)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw hr(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,e}if(this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw hr(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw hr(this,8);const e=Pc(this.buf,this.pos+=4),t=Pc(this.buf,this.pos+=4);return new vt(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=FS(this.buf,this.pos);return this.pos+=Et(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function Ak(r){return new Ek(r instanceof Uint8Array?r:r.subarray())}function Pe(r,e,t){const n=Ak(r);return e.decode(n,void 0,t)}function xk(r){let n,i=8192;return function(o){if(o<1||o>4096)return $r(o);i+o>8192&&(n=$r(8192),i=0);const a=n.subarray(i,i+=o);return(i&7)!==0&&(i=(i|7)+1),a}}class zo{fn;len;next;val;constructor(e,t,n){this.fn=e,this.len=t,this.next=void 0,this.val=n}}function ph(){}class _k{head;tail;len;next;constructor(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}}const Ck=xk();function Ik(r){return globalThis.Buffer!=null?$r(r):Ck(r)}class If{len;head;tail;states;constructor(){this.len=0,this.head=new zo(ph,0,0),this.tail=this.head,this.states=null}_push(e,t,n){return this.tail=this.tail.next=new zo(e,t,n),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new Tk((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(Rc,10,vt.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=vt.fromBigInt(e);return this._push(Rc,t.length(),t)}uint64Number(e){return this._push(Pl,Et(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=vt.fromBigInt(e).zzEncode();return this._push(Rc,t.length(),t)}sint64Number(e){const t=vt.fromNumber(e).zzEncode();return this._push(Rc,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(gh,1,e?1:0)}fixed32(e){return this._push(Mo,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=vt.fromBigInt(e);return this._push(Mo,4,t.lo)._push(Mo,4,t.hi)}fixed64Number(e){const t=vt.fromNumber(e);return this._push(Mo,4,t.lo)._push(Mo,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(pk,4,e)}double(e){return this._push(mk,8,e)}bytes(e){const t=e.length>>>0;return t===0?this._push(gh,1,0):this.uint32(t)._push(Pk,t,e)}string(e){const t=vk(e);return t!==0?this.uint32(t)._push(US,t,e):this._push(gh,1,0)}fork(){return this.states=new _k(this),this.head=this.tail=new zo(ph,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new zo(ph,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=e.next,this.tail=t,this.len+=n),this}finish(){let e=this.head.next;const t=Ik(this.len);let n=0;for(;e!=null;)e.fn(e.val,t,n),n+=e.len,e=e.next;return t}}function gh(r,e,t){e[t]=r&255}function kk(r,e,t){for(;r>127;)e[t++]=r&127|128,r>>>=7;e[t]=r}class Tk extends zo{next;constructor(e,t){super(kk,e,t),this.next=void 0}}function Rc(r,e,t){for(;r.hi!==0;)e[t++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)e[t++]=r.lo&127|128,r.lo=r.lo>>>7;e[t++]=r.lo}function Mo(r,e,t){e[t]=r&255,e[t+1]=r>>>8&255,e[t+2]=r>>>16&255,e[t+3]=r>>>24}function Pk(r,e,t){e.set(r,t)}globalThis.Buffer!=null&&(If.prototype.bytes=function(r){const e=r.length>>>0;return this.uint32(e),e>0&&this._push(Rk,e,r),this},If.prototype.string=function(r){const e=globalThis.Buffer.byteLength(r);return this.uint32(e),e>0&&this._push(Ok,e,r),this});function Rk(r,e,t){e.set(r,t)}function Ok(r,e,t){r.length<40?US(r,e,t):e.utf8Write!=null?e.utf8Write(r,t):e.set(Z(r),t)}function Bk(){return new If}function Re(r,e){const t=Bk();return e.encode(r,t,{lengthDelimited:!1}),t.finish()}var Rl;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(Rl||(Rl={}));function $S(r,e,t,n){return{name:r,type:e,encode:t,decode:n}}function hn(r){function e(i){if(r[i.toString()]==null)throw new Error("Invalid enum value");return r[i]}const t=function(s,o){const a=e(s);o.int32(a)},n=function(s){const o=s.int32();return e(o)};return $S("enum",Rl.VARINT,t,n)}function Oe(r,e){return $S("message",Rl.LENGTH_DELIMITED,r,e)}class Ar extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"}class ow extends Error{code="ERR_MAX_SIZE";name="MaxSizeError"}var Fe;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1",r.ECDSA="ECDSA"})(Fe||(Fe={}));var kf;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1",r[r.ECDSA=3]="ECDSA"})(kf||(kf={}));(function(r){r.codec=()=>hn(kf)})(Fe||(Fe={}));var Wn;(function(r){let e;r.codec=()=>(e==null&&(e=Oe((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),Fe.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.Type=Fe.codec().decode(t);break}case 2:{s.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Re(t,r.codec()),r.decode=(t,n)=>Pe(t,r.codec(),n)})(Wn||(Wn={}));var Ol;(function(r){let e;r.codec=()=>(e==null&&(e=Oe((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),Fe.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.Type=Fe.codec().decode(t);break}case 2:{s.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Re(t,r.codec()),r.decode=(t,n)=>Pe(t,r.codec(),n)})(Ol||(Ol={}));function Ds(r){if(isNaN(r)||r<=0)throw new q("random bytes length must be a Number bigger than 0");return Yu(r)}const Ci=mS;let Vg=class{type="RSA";jwk;_raw;_multihash;constructor(e,t){this.jwk=e,this._multihash=t}get raw(){return this._raw==null&&(this._raw=jg(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return Be.createV1(114,this._multihash)}toString(){return Qe.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Je(this.raw,e.raw)}verify(e,t,n){return Wk(this.jwk,t,e,n)}},qS=class{type="RSA";jwk;_raw;publicKey;constructor(e,t){this.jwk=e,this.publicKey=t}get raw(){return this._raw==null&&(this._raw=Mk(this.jwk)),this._raw}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Je(this.raw,e.raw)}sign(e,t){return Hk(this.jwk,e,t)}};const KS=8192,zg=18,Nk=1062,Dk=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function Lk(r){return{n:ne(r[1],"base64url"),e:ne(r[2],"base64url"),d:ne(r[3],"base64url"),p:ne(r[4],"base64url"),q:ne(r[5],"base64url"),dp:ne(r[6],"base64url"),dq:ne(r[7],"base64url"),qi:ne(r[8],"base64url"),kty:"RSA"}}function Mk(r){if(r.n==null||r.e==null||r.d==null||r.p==null||r.q==null||r.dp==null||r.dq==null||r.qi==null)throw new q("JWK was missing components");return sn([jt(Uint8Array.from([0])),jt(Z(r.n,"base64url")),jt(Z(r.e,"base64url")),jt(Z(r.d,"base64url")),jt(Z(r.p,"base64url")),jt(Z(r.q,"base64url")),jt(Z(r.dp,"base64url")),jt(Z(r.dq,"base64url")),jt(Z(r.qi,"base64url"))]).subarray()}function Fk(r){const e=Zi(r[1],{offset:0});return{kty:"RSA",n:ne(e[0],"base64url"),e:ne(e[1],"base64url")}}function jg(r){if(r.n==null||r.e==null)throw new q("JWK was missing components");return sn([Dk,Pg(sn([jt(Z(r.n,"base64url")),jt(Z(r.e,"base64url"))]))]).subarray()}function Uk(r){const e=Zi(r);return VS(e)}function VS(r){const e=Lk(r);return Kk(e)}function $k(r,e){if(r.byteLength>=Nk)throw new qv("Key size is too large");const t=Zi(r,{offset:0});return qk(t,r,e)}function qk(r,e,t){const n=Fk(r);if(t==null){const i=Ci(Wn.encode({Type:Fe.RSA,Data:e}));t=dn(zg,i)}return new Vg(n,t)}function Kk(r){if(Yk(r)>KS)throw new q("Key size is too large");const e=zk(r),t=Ci(Wn.encode({Type:Fe.RSA,Data:jg(e.publicKey)})),n=dn(zg,t);return new qS(e.privateKey,new Vg(e.publicKey,n))}async function Vk(r){if(r>KS)throw new q("Key size is too large");const e=await jk(r),t=Ci(Wn.encode({Type:Fe.RSA,Data:jg(e.publicKey)})),n=dn(zg,t);return new qS(e.privateKey,new Vg(e.publicKey,n))}function zk(r){if(r==null)throw new q("Missing key parameter");return{privateKey:r,publicKey:{kty:r.kty,n:r.n,e:r.e}}}async function jk(r,e){const t=await Pt.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:r,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),n=await Gk(t);return{privateKey:n[0],publicKey:n[1]}}async function Hk(r,e,t){const n=await Pt.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]);t?.signal?.throwIfAborted();const i=await Pt.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},n,e instanceof Uint8Array?e:e.subarray());return t?.signal?.throwIfAborted(),new Uint8Array(i,0,i.byteLength)}async function Wk(r,e,t,n){const i=await Pt.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);n?.signal?.throwIfAborted();const s=await Pt.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},i,e,t instanceof Uint8Array?t:t.subarray());return n?.signal?.throwIfAborted(),s}async function Gk(r,e){if(r.privateKey==null||r.publicKey==null)throw new q("Private and public key are required");return await Promise.all([Pt.get().subtle.exportKey("jwk",r.privateKey),Pt.get().subtle.exportKey("jwk",r.publicKey)])}function Yk(r){if(r.kty!=="RSA")throw new q("invalid key type");if(r.n==null)throw new q("invalid key modulus");return Z(r.n,"base64url").length*8}class zS extends hS{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Gu(e);const n=ga(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,s=new Uint8Array(i);s.set(n.length>i?e.create().update(n).digest():n);for(let o=0;o<s.length;o++)s[o]^=54;this.iHash.update(s),this.oHash=e.create();for(let o=0;o<s.length;o++)s[o]^=106;this.oHash.update(s),Kr(s)}update(e){return Cl(this),this.iHash.update(e),this}digestInto(e){Cl(this),Er(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:i,destroyed:s,blockLen:o,outputLen:a}=this;return e=e,e.finished=i,e.destroyed=s,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ga=(r,e,t)=>new zS(r,e).update(t).digest();Ga.create=(r,e)=>new zS(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function aw(r){r.lowS!==void 0&&Oi("lowS",r.lowS),r.prehash!==void 0&&Oi("prehash",r.prehash)}class Qk extends Error{constructor(e=""){super(e)}}const Zr={Err:Qk,_tlv:{encode:(r,e)=>{const{Err:t}=Zr;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const n=e.length/2,i=Ic(n);if(i.length/2&128)throw new t("tlv.encode: long form length too big");const s=n>127?Ic(i.length/2|128):"";return Ic(r)+s+i+e},decode(r,e){const{Err:t}=Zr;let n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");const i=e[n++],s=!!(i&128);let o=0;if(!s)o=i;else{const c=i&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const l=e.subarray(n,n+c);if(l.length!==c)throw new t("tlv.decode: length bytes not complete");if(l[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const u of l)o=o<<8|u;if(n+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(n,n+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+o)}}},_int:{encode(r){const{Err:e}=Zr;if(r<ra)throw new e("integer: negative integers are not allowed");let t=Ic(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(r){const{Err:e}=Zr;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return Qu(r)}},toSig(r){const{Err:e,_int:t,_tlv:n}=Zr,i=qe("signature",r),{v:s,l:o}=n.decode(48,i);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,s),{v:l,l:u}=n.decode(2,c);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(l)}},hexFromSig(r){const{_tlv:e,_int:t}=Zr,n=e.encode(2,t.encode(r.r)),i=e.encode(2,t.encode(r.s)),s=n+i;return e.encode(48,s)}},ra=BigInt(0),na=BigInt(1),Jk=BigInt(2),Oc=BigInt(3),Xk=BigInt(4);function Zk(r,e,t){function n(i){const s=r.sqr(i),o=r.mul(s,i);return r.add(r.add(o,r.mul(i,e)),t)}return n}function jS(r,e,t){const{BYTES:n}=r;function i(s){let o;if(typeof s=="bigint")o=s;else{let a=qe("private key",s);if(e){if(!e.includes(a.length*2))throw new Error("invalid private key");const c=new Uint8Array(n);c.set(a,c.length-a.length),a=c}try{o=r.fromBytes(a)}catch{throw new Error(`invalid private key: expected ui8a of size ${n}, got ${typeof s}`)}}if(t&&(o=r.create(o)),!r.isValidNot0(o))throw new Error("invalid private key: out of range [1..N-1]");return o}return i}function eT(r,e={}){const{Fp:t,Fn:n}=RS("weierstrass",r,e),{h:i,n:s}=r;ho(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:o}=e;if(o&&(!t.is0(r.a)||typeof o.beta!="bigint"||typeof o.splitScalar!="function"))throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');function a(){if(!t.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function c(B,v,I){const{x:C,y:P}=v.toAffine(),O=t.toBytes(C);if(Oi("isCompressed",I),I){a();const L=!t.isOdd(P);return tn(HS(L),O)}else return tn(Uint8Array.of(4),O,t.toBytes(P))}function l(B){Er(B);const v=t.BYTES,I=v+1,C=2*v+1,P=B.length,O=B[0],L=B.subarray(1);if(P===I&&(O===2||O===3)){const M=t.fromBytes(L);if(!t.isValid(M))throw new Error("bad point: is not on curve, wrong x");const U=h(M);let K;try{K=t.sqrt(U)}catch(se){const Y=se instanceof Error?": "+se.message:"";throw new Error("bad point: is not on curve, sqrt error"+Y)}a();const j=t.isOdd(K);return(O&1)===1!==j&&(K=t.neg(K)),{x:M,y:K}}else if(P===C&&O===4){const M=t.fromBytes(L.subarray(v*0,v*1)),U=t.fromBytes(L.subarray(v*1,v*2));if(!p(M,U))throw new Error("bad point: is not on curve");return{x:M,y:U}}else throw new Error(`bad point: got length ${P}, expected compressed=${I} or uncompressed=${C}`)}const u=e.toBytes||c,d=e.fromBytes||l,h=Zk(t,r.a,r.b);function p(B,v){const I=t.sqr(v),C=h(B);return t.eql(I,C)}if(!p(r.Gx,r.Gy))throw new Error("bad curve params: generator point");const m=t.mul(t.pow(r.a,Oc),Xk),w=t.mul(t.sqr(r.b),BigInt(27));if(t.is0(t.add(m,w)))throw new Error("bad curve params: a or b");function y(B,v,I=!1){if(!t.isValid(v)||I&&t.is0(v))throw new Error(`bad point coordinate ${B}`);return v}function b(B){if(!(B instanceof S))throw new Error("ProjectivePoint expected")}const _=Il((B,v)=>{const{px:I,py:C,pz:P}=B;if(t.eql(P,t.ONE))return{x:I,y:C};const O=B.is0();v==null&&(v=O?t.ONE:t.inv(P));const L=t.mul(I,v),M=t.mul(C,v),U=t.mul(P,v);if(O)return{x:t.ZERO,y:t.ZERO};if(!t.eql(U,t.ONE))throw new Error("invZ was invalid");return{x:L,y:M}}),E=Il(B=>{if(B.is0()){if(e.allowInfinityPoint&&!t.is0(B.py))return;throw new Error("bad point: ZERO")}const{x:v,y:I}=B.toAffine();if(!t.isValid(v)||!t.isValid(I))throw new Error("bad point: x or y not field elements");if(!p(v,I))throw new Error("bad point: equation left != right");if(!B.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function R(B,v,I,C,P){return I=new S(t.mul(I.px,B),I.py,I.pz),v=ta(C,v),I=ta(P,I),v.add(I)}class S{constructor(v,I,C){this.px=y("x",v),this.py=y("y",I,!0),this.pz=y("z",C),Object.freeze(this)}static fromAffine(v){const{x:I,y:C}=v||{};if(!v||!t.isValid(I)||!t.isValid(C))throw new Error("invalid affine point");if(v instanceof S)throw new Error("projective point not allowed");return t.is0(I)&&t.is0(C)?S.ZERO:new S(I,C,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(v){return CS(S,"pz",v)}static fromBytes(v){return Er(v),S.fromHex(v)}static fromHex(v){const I=S.fromAffine(d(qe("pointHex",v)));return I.assertValidity(),I}static fromPrivateKey(v){const I=jS(n,e.allowedPrivateKeyLengths,e.wrapPrivateKey);return S.BASE.multiply(I(v))}static msm(v,I){return PS(S,n,v,I)}precompute(v=8,I=!0){return T.setWindowSize(this,v),I||this.multiply(Oc),this}_setWindowSize(v){this.precompute(v)}assertValidity(){E(this)}hasEvenY(){const{y:v}=this.toAffine();if(!t.isOdd)throw new Error("Field doesn't support isOdd");return!t.isOdd(v)}equals(v){b(v);const{px:I,py:C,pz:P}=this,{px:O,py:L,pz:M}=v,U=t.eql(t.mul(I,M),t.mul(O,P)),K=t.eql(t.mul(C,M),t.mul(L,P));return U&&K}negate(){return new S(this.px,t.neg(this.py),this.pz)}double(){const{a:v,b:I}=r,C=t.mul(I,Oc),{px:P,py:O,pz:L}=this;let M=t.ZERO,U=t.ZERO,K=t.ZERO,j=t.mul(P,P),V=t.mul(O,O),se=t.mul(L,L),Y=t.mul(P,O);return Y=t.add(Y,Y),K=t.mul(P,L),K=t.add(K,K),M=t.mul(v,K),U=t.mul(C,se),U=t.add(M,U),M=t.sub(V,U),U=t.add(V,U),U=t.mul(M,U),M=t.mul(Y,M),K=t.mul(C,K),se=t.mul(v,se),Y=t.sub(j,se),Y=t.mul(v,Y),Y=t.add(Y,K),K=t.add(j,j),j=t.add(K,j),j=t.add(j,se),j=t.mul(j,Y),U=t.add(U,j),se=t.mul(O,L),se=t.add(se,se),j=t.mul(se,Y),M=t.sub(M,j),K=t.mul(se,V),K=t.add(K,K),K=t.add(K,K),new S(M,U,K)}add(v){b(v);const{px:I,py:C,pz:P}=this,{px:O,py:L,pz:M}=v;let U=t.ZERO,K=t.ZERO,j=t.ZERO;const V=r.a,se=t.mul(r.b,Oc);let Y=t.mul(I,O),ae=t.mul(C,L),z=t.mul(P,M),ve=t.add(I,C),fe=t.add(O,L);ve=t.mul(ve,fe),fe=t.add(Y,ae),ve=t.sub(ve,fe),fe=t.add(I,P);let le=t.add(O,M);return fe=t.mul(fe,le),le=t.add(Y,z),fe=t.sub(fe,le),le=t.add(C,P),U=t.add(L,M),le=t.mul(le,U),U=t.add(ae,z),le=t.sub(le,U),j=t.mul(V,fe),U=t.mul(se,z),j=t.add(U,j),U=t.sub(ae,j),j=t.add(ae,j),K=t.mul(U,j),ae=t.add(Y,Y),ae=t.add(ae,Y),z=t.mul(V,z),fe=t.mul(se,fe),ae=t.add(ae,z),z=t.sub(Y,z),z=t.mul(V,z),fe=t.add(fe,z),Y=t.mul(ae,fe),K=t.add(K,Y),Y=t.mul(le,fe),U=t.mul(ve,U),U=t.sub(U,Y),Y=t.mul(ve,ae),j=t.mul(le,j),j=t.add(j,Y),new S(U,K,j)}subtract(v){return this.add(v.negate())}is0(){return this.equals(S.ZERO)}multiply(v){const{endo:I}=e;if(!n.isValidNot0(v))throw new Error("invalid scalar: out of range");let C,P;const O=L=>T.wNAFCached(this,L,S.normalizeZ);if(I){const{k1neg:L,k1:M,k2neg:U,k2:K}=I.splitScalar(v),{p:j,f:V}=O(M),{p:se,f:Y}=O(K);P=V.add(Y),C=R(I.beta,j,se,L,U)}else{const{p:L,f:M}=O(v);C=L,P=M}return S.normalizeZ([C,P])[0]}multiplyUnsafe(v){const{endo:I}=e,C=this;if(!n.isValid(v))throw new Error("invalid scalar: out of range");if(v===ra||C.is0())return S.ZERO;if(v===na)return C;if(T.hasPrecomputes(this))return this.multiply(v);if(I){const{k1neg:P,k1:O,k2neg:L,k2:M}=I.splitScalar(v),{p1:U,p2:K}=DI(S,C,O,M);return R(I.beta,U,K,P,L)}else return T.wNAFCachedUnsafe(C,v)}multiplyAndAddUnsafe(v,I,C){const P=this.multiplyUnsafe(I).add(v.multiplyUnsafe(C));return P.is0()?void 0:P}toAffine(v){return _(this,v)}isTorsionFree(){const{isTorsionFree:v}=e;return i===na?!0:v?v(S,this):T.wNAFCachedUnsafe(this,s).is0()}clearCofactor(){const{clearCofactor:v}=e;return i===na?this:v?v(S,this):this.multiplyUnsafe(i)}toBytes(v=!0){return Oi("isCompressed",v),this.assertValidity(),u(S,this,v)}toRawBytes(v=!0){return this.toBytes(v)}toHex(v=!0){return Bs(this.toBytes(v))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}S.BASE=new S(r.Gx,r.Gy,t.ONE),S.ZERO=new S(t.ZERO,t.ONE,t.ZERO),S.Fp=t,S.Fn=n;const N=n.BITS,T=TS(S,e.endo?Math.ceil(N/2):N);return S}function HS(r){return Uint8Array.of(r?2:3)}function tT(r,e,t={}){ho(e,{hash:"function"},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const n=e.randomBytes||Yu,i=e.hmac||((C,...P)=>Ga(e.hash,C,tn(...P))),{Fp:s,Fn:o}=r,{ORDER:a,BITS:c}=o;function l(C){const P=a>>na;return C>P}function u(C){return l(C)?o.neg(C):C}function d(C,P){if(!o.isValidNot0(P))throw new Error(`invalid signature ${C}: out of range 1..CURVE.n`)}class h{constructor(P,O,L){d("r",P),d("s",O),this.r=P,this.s=O,L!=null&&(this.recovery=L),Object.freeze(this)}static fromCompact(P){const O=o.BYTES,L=qe("compactSignature",P,O*2);return new h(o.fromBytes(L.subarray(0,O)),o.fromBytes(L.subarray(O,O*2)))}static fromDER(P){const{r:O,s:L}=Zr.toSig(qe("DER",P));return new h(O,L)}assertValidity(){}addRecoveryBit(P){return new h(this.r,this.s,P)}recoverPublicKey(P){const O=s.ORDER,{r:L,s:M,recovery:U}=this;if(U==null||![0,1,2,3].includes(U))throw new Error("recovery id invalid");if(a*Jk<O&&U>1)throw new Error("recovery id is ambiguous for h>1 curve");const j=U===2||U===3?L+a:L;if(!s.isValid(j))throw new Error("recovery id 2 or 3 invalid");const V=s.toBytes(j),se=r.fromHex(tn(HS((U&1)===0),V)),Y=o.inv(j),ae=E(qe("msgHash",P)),z=o.create(-ae*Y),ve=o.create(M*Y),fe=r.BASE.multiplyUnsafe(z).add(se.multiplyUnsafe(ve));if(fe.is0())throw new Error("point at infinify");return fe.assertValidity(),fe}hasHighS(){return l(this.s)}normalizeS(){return this.hasHighS()?new h(this.r,o.neg(this.s),this.recovery):this}toBytes(P){if(P==="compact")return tn(o.toBytes(this.r),o.toBytes(this.s));if(P==="der")return Og(Zr.hexFromSig(this));throw new Error("invalid format")}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return Bs(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return Bs(this.toBytes("compact"))}}const p=jS(o,t.allowedPrivateKeyLengths,t.wrapPrivateKey),m={isValidPrivateKey(C){try{return p(C),!0}catch{return!1}},normPrivateKeyToScalar:p,randomPrivateKey:()=>{const C=a;return OI(n(_S(C)),C)},precompute(C=8,P=r.BASE){return P.precompute(C,!1)}};function w(C,P=!0){return r.fromPrivateKey(C).toBytes(P)}function y(C){if(typeof C=="bigint")return!1;if(C instanceof r)return!0;const O=qe("key",C).length,L=s.BYTES,M=L+1,U=2*L+1;if(!(t.allowedPrivateKeyLengths||o.BYTES===M))return O===M||O===U}function b(C,P,O=!0){if(y(C)===!0)throw new Error("first arg must be private key");if(y(P)===!1)throw new Error("second arg must be public key");return r.fromHex(P).multiply(p(C)).toBytes(O)}const _=e.bits2int||function(C){if(C.length>8192)throw new Error("input is too large");const P=Qu(C),O=C.length*8-c;return O>0?P>>BigInt(O):P},E=e.bits2int_modN||function(C){return o.create(_(C))},R=Ju(c);function S(C){return Dn("num < 2^"+c,C,ra,R),o.toBytes(C)}function N(C,P,O=T){if(["recovered","canonical"].some(ve=>ve in O))throw new Error("sign() legacy options not supported");const{hash:L}=e;let{lowS:M,prehash:U,extraEntropy:K}=O;M==null&&(M=!0),C=qe("msgHash",C),aw(O),U&&(C=qe("prehashed msgHash",L(C)));const j=E(C),V=p(P),se=[S(V),S(j)];if(K!=null&&K!==!1){const ve=K===!0?n(s.BYTES):K;se.push(qe("extraEntropy",ve))}const Y=tn(...se),ae=j;function z(ve){const fe=_(ve);if(!o.isValidNot0(fe))return;const le=o.inv(fe),pt=r.BASE.multiply(fe).toAffine(),tt=o.create(pt.x);if(tt===ra)return;const Ge=o.create(le*o.create(ae+tt*V));if(Ge===ra)return;let An=(pt.x===tt?0:2)|Number(pt.y&na),Ye=Ge;return M&&l(Ge)&&(Ye=u(Ge),An^=1),new h(tt,Ye,An)}return{seed:Y,k2sig:z}}const T={lowS:e.lowS,prehash:!1},B={lowS:e.lowS,prehash:!1};function v(C,P,O=T){const{seed:L,k2sig:M}=N(C,P,O);return EI(e.hash.outputLen,o.BYTES,i)(L,M)}r.BASE.precompute(8);function I(C,P,O,L=B){const M=C;P=qe("msgHash",P),O=qe("publicKey",O),aw(L);const{lowS:U,prehash:K,format:j}=L;if("strict"in L)throw new Error("options.strict was renamed to lowS");if(j!==void 0&&!["compact","der","js"].includes(j))throw new Error('format must be "compact", "der" or "js"');const V=typeof M=="string"||Rg(M),se=!V&&!j&&typeof M=="object"&&M!==null&&typeof M.r=="bigint"&&typeof M.s=="bigint";if(!V&&!se)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let Y,ae;try{if(se)if(j===void 0||j==="js")Y=new h(M.r,M.s);else throw new Error("invalid format");if(V){try{j!=="compact"&&(Y=h.fromDER(M))}catch(Ye){if(!(Ye instanceof Zr.Err))throw Ye}!Y&&j!=="der"&&(Y=h.fromCompact(M))}ae=r.fromHex(O)}catch{return!1}if(!Y||U&&Y.hasHighS())return!1;K&&(P=e.hash(P));const{r:z,s:ve}=Y,fe=E(P),le=o.inv(ve),pt=o.create(fe*le),tt=o.create(z*le),Ge=r.BASE.multiplyUnsafe(pt).add(ae.multiplyUnsafe(tt));return Ge.is0()?!1:o.create(Ge.x)===z}return Object.freeze({getPublicKey:w,getSharedSecret:b,sign:v,verify:I,utils:m,Point:r,Signature:h})}function rT(r){const e={a:r.a,b:r.b,p:r.Fp.ORDER,n:r.n,h:r.h,Gx:r.Gx,Gy:r.Gy},t=r.Fp,n=fo(e.n,r.nBitLength),i={Fp:t,Fn:n,allowedPrivateKeyLengths:r.allowedPrivateKeyLengths,allowInfinityPoint:r.allowInfinityPoint,endo:r.endo,wrapPrivateKey:r.wrapPrivateKey,isTorsionFree:r.isTorsionFree,clearCofactor:r.clearCofactor,fromBytes:r.fromBytes,toBytes:r.toBytes};return{CURVE:e,curveOpts:i}}function nT(r){const{CURVE:e,curveOpts:t}=rT(r),n={hash:r.hash,hmac:r.hmac,randomBytes:r.randomBytes,lowS:r.lowS,bits2int:r.bits2int,bits2int_modN:r.bits2int_modN};return{CURVE:e,curveOpts:t,ecdsaOpts:n}}function iT(r,e){return Object.assign({},e,{ProjectivePoint:e.Point,CURVE:r})}function sT(r){const{CURVE:e,curveOpts:t,ecdsaOpts:n}=nT(r),i=eT(e,t),s=tT(i,n,t);return iT(r,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function oT(r,e){const t=n=>sT({...r,hash:n});return{...t(e),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Bl={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")};BigInt(0);const aT=BigInt(1),Tf=BigInt(2),cw=(r,e)=>(r+e/Tf)/e;function cT(r){const e=Bl.p,t=BigInt(3),n=BigInt(6),i=BigInt(11),s=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),l=r*r*r%e,u=l*l*r%e,d=$e(u,t,e)*u%e,h=$e(d,t,e)*u%e,p=$e(h,Tf,e)*l%e,m=$e(p,i,e)*p%e,w=$e(m,s,e)*m%e,y=$e(w,a,e)*w%e,b=$e(y,c,e)*y%e,_=$e(b,a,e)*w%e,E=$e(_,t,e)*u%e,R=$e(E,o,e)*m%e,S=$e(R,n,e)*l%e,N=$e(S,Tf,e);if(!Pf.eql(Pf.sqr(N),r))throw new Error("Cannot find square root");return N}const Pf=fo(Bl.p,void 0,void 0,{sqrt:cT}),fn=oT({...Bl,Fp:Pf,lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{const e=Bl.n,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-aT*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=t,o=BigInt("0x100000000000000000000000000000000"),a=cw(s*r,e),c=cw(-n*r,e);let l=Ke(r-a*t-c*i,e),u=Ke(-a*n-c*s,e);const d=l>o,h=u>o;if(d&&(l=e-l),h&&(u=e-u),l>o||u>o)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:d,k1:l,k2neg:h,k2:u}}}},mS),lT=32;function uT(r,e,t){const n=Xi.digest(e instanceof Uint8Array?e:e.subarray());if(Xu(n))return n.then(({digest:i})=>(t?.signal?.throwIfAborted(),fn.sign(i,r).toDERRawBytes())).catch(i=>{throw i.name==="AbortError"?i:new nw(String(i))});try{return fn.sign(n.digest,r).toDERRawBytes()}catch(i){throw new nw(String(i))}}function dT(r,e,t,n){const i=Xi.digest(t instanceof Uint8Array?t:t.subarray());if(Xu(i))return i.then(({digest:s})=>(n?.signal?.throwIfAborted(),fn.verify(e,s,r))).catch(s=>{throw s.name==="AbortError"?s:new iw(String(s))});try{return n?.signal?.throwIfAborted(),fn.verify(e,i.digest,r)}catch(s){throw new iw(String(s))}}class WS{type="secp256k1";raw;_key;constructor(e){this._key=gT(e),this.raw=fT(this._key)}toMultihash(){return Ka.digest(on(this))}toCID(){return Be.createV1(114,this.toMultihash())}toString(){return Qe.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Je(this.raw,e.raw)}verify(e,t,n){return dT(this._key,t,e,n)}}class GS{type="secp256k1";raw;publicKey;constructor(e,t){this.raw=pT(e),this.publicKey=new WS(t??mT(e))}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Je(this.raw,e.raw)}sign(e,t){return uT(this.raw,e,t)}}function YS(r){return new GS(r)}function QS(r){return new WS(r)}async function hT(){const r=yT();return new GS(r)}function fT(r){return fn.ProjectivePoint.fromHex(r).toRawBytes(!0)}function pT(r){try{return fn.getPublicKey(r,!0),r}catch(e){throw new Kv(String(e))}}function gT(r){try{return fn.ProjectivePoint.fromHex(r),r}catch(e){throw new qv(String(e))}}function mT(r){try{return fn.getPublicKey(r,!0)}catch(e){throw new Kv(String(e))}}function yT(){return fn.utils.randomPrivateKey()}async function JS(r,e){if(r==="Ed25519")return ck();if(r==="secp256k1")return hT();if(r==="RSA")return Vk(ST(e));if(r==="ECDSA")return eI(ET(e));throw new uo}function Gn(r,e){const{Type:t,Data:n}=Wn.decode(r),i=n??new Uint8Array;switch(t){case Fe.RSA:return $k(i,e);case Fe.Ed25519:return MS(i);case Fe.secp256k1:return QS(i);case Fe.ECDSA:return cS(i);default:throw new uo}}function wT(r){const{Type:e,Data:t}=Wn.decode(r.digest),n=t??new Uint8Array;switch(e){case Fe.Ed25519:return MS(n);case Fe.secp256k1:return QS(n);case Fe.ECDSA:return cS(n);default:throw new uo}}function on(r){return Wn.encode({Type:Fe[r.type],Data:r.raw})}function bT(r){const e=Ol.decode(r),t=e.Data??new Uint8Array;switch(e.Type){case Fe.RSA:return Uk(t);case Fe.Ed25519:return LS(t);case Fe.secp256k1:return YS(t);case Fe.ECDSA:return Q2(t);default:throw new uo}}function vT(r){if(r.byteLength===Br)return LS(r);if(r.byteLength===lT)return YS(r);const e=Zi(r),t=e[2]?.[0];if(t===q2||t===K2||t===V2)return aS(e);if(e.length>8)return VS(e);throw new q("Could not extract private key from raw bytes")}function Ya(r){return Ol.encode({Type:Fe[r.type],Data:r.raw})}function ST(r){return r==null?2048:parseInt(r,10)}function ET(r){if(r==="P-256"||r==null)return"P-256";if(r==="P-384")return"P-384";if(r==="P-521")return"P-521";throw new q("Unsupported curve, should be P-256, P-384 or P-521")}async function XS(r){if(r.type==="RSA")return{privateKey:await crypto.subtle.importKey("jwk",r.jwk,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["sign"]),publicKey:await crypto.subtle.importKey("jwk",r.publicKey.jwk,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["verify"])};if(r.type==="ECDSA")return{privateKey:await crypto.subtle.importKey("jwk",r.jwk,{name:"ECDSA",namedCurve:r.jwk.crv??"P-256"},!0,["sign"]),publicKey:await crypto.subtle.importKey("jwk",r.publicKey.jwk,{name:"ECDSA",namedCurve:r.publicKey.jwk.crv??"P-256"},!0,["verify"])};throw new q("Only RSA and ECDSA keys are supported")}const ZS=Symbol.for("nodejs.util.inspect.custom"),AT=114;class Hg{type;multihash;publicKey;string;constructor(e){this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[Ag]=!0;toString(){return this.string==null&&(this.string=Qe.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return Be.createV1(AT,this.multihash)}toJSON(){return this.toString()}equals(e){if(e==null)return!1;if(e instanceof Uint8Array)return Je(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(e?.toMultihash()?.bytes!=null)return Je(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[ZS](){return`PeerId(${this.toString()})`}}class eE extends Hg{type="RSA";publicKey;constructor(e){super({...e,type:"RSA"}),this.publicKey=e.publicKey}}class tE extends Hg{type="Ed25519";publicKey;constructor(e){super({...e,type:"Ed25519"}),this.publicKey=e.publicKey}}class rE extends Hg{type="secp256k1";publicKey;constructor(e){super({...e,type:"secp256k1"}),this.publicKey=e.publicKey}}const xT=2336;class nE{type="url";multihash;publicKey;url;constructor(e){this.url=e.toString(),this.multihash=Ka.digest(Z(this.url))}[ZS](){return`PeerId(${this.url})`}[Ag]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return Be.createV1(xT,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ne(e)),e.toString()===this.toString())}}const _T=114,lw=2336;function xr(r,e){let t;if(r.charAt(0)==="1"||r.charAt(0)==="Q")t=Ji(Qe.decode(`z${r}`));else{if(r.startsWith("k51qzi5uqu5")||r.startsWith("kzwfwjn5ji4")||r.startsWith("k2k4r8")||r.startsWith("bafz"))return Qa(Be.parse(r));throw new q('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return po(t)}function ya(r){if(r.type==="Ed25519")return new tE({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new rE({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new eE({multihash:r.toCID().multihash,publicKey:r});throw new uo}function CT(r){return ya(r.publicKey)}function po(r){if(kT(r))return new eE({multihash:r});if(IT(r))try{const e=wT(r);if(e.type==="Ed25519")return new tE({multihash:r,publicKey:e});if(e.type==="secp256k1")return new rE({multihash:r,publicKey:e})}catch{const t=ne(r.digest);return new nE(new URL(t))}throw new uC("Supplied PeerID Multihash is invalid")}function Qa(r){if(r?.multihash==null||r.version==null||r.version===1&&r.code!==_T&&r.code!==lw)throw new lC("Supplied PeerID CID is invalid");if(r.code===lw){const e=ne(r.multihash.digest);return new nE(new URL(e))}return po(r.multihash)}function IT(r){return r.code===Ka.code}function kT(r){return r.code===Xi.code}const TT=8,Wg=1024*1024*4;let PT=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},iE=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},RT=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"},uw=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};function sE(r){return r[Symbol.asyncIterator]!=null}function oE(r,e){if(r.byteLength>e)throw new iE("Message length too long")}const ed=r=>{const e=Et(r),t=$r(e);return _s(r,t),ed.bytes=e,t};ed.bytes=0;function Nl(r,e){e=e??{};const t=e.lengthEncoder??ed,n=e?.maxDataLength??Wg;function*i(s){oE(s,n);const o=t(s.byteLength);o instanceof Uint8Array?yield o:yield*o,s instanceof Uint8Array?yield s:yield*s}return sE(r)?async function*(){for await(const s of r)yield*i(s)}():function*(){for(const s of r)yield*i(s)}()}Nl.single=(r,e)=>{e=e??{};const t=e.lengthEncoder??ed,n=e?.maxDataLength??Wg;return oE(r,n),new ye(t(r.byteLength),r)};var di;(function(r){r[r.LENGTH=0]="LENGTH",r[r.DATA=1]="DATA"})(di||(di={}));const Gg=r=>{const e=Zu(r);return Gg.bytes=Et(e),e};Gg.bytes=0;function Dl(r,e){const t=new ye;let n=di.LENGTH,i=-1;const s=e?.lengthDecoder??Gg,o=e?.maxLengthLength??TT,a=e?.maxDataLength??Wg;function*c(){for(;t.byteLength>0;){if(n===di.LENGTH)try{if(i=s(t),i<0)throw new PT("Invalid message length");if(i>a)throw new iE("Message length too long");const l=s.bytes;t.consume(l),e?.onLength!=null&&e.onLength(i),n=di.DATA}catch(l){if(l instanceof RangeError){if(t.byteLength>o)throw new RT("Message length length too long");break}throw l}if(n===di.DATA){if(t.byteLength<i)break;const l=t.sublist(0,i);t.consume(i),e?.onData!=null&&e.onData(l),yield l,n=di.LENGTH}}}return sE(r)?async function*(){for await(const l of r)t.append(l),yield*c();if(t.byteLength>0)throw new uw("Unexpected end of input")}():function*(){for(const l of r)t.append(l),yield*c();if(t.byteLength>0)throw new uw("Unexpected end of input")}()}Dl.fromReader=(r,e)=>{let t=1;const n=async function*(){for(;;)try{const{done:s,value:o}=await r.next(t);if(s===!0)return;o!=null&&(yield o)}catch(s){if(s.code==="ERR_UNDER_READ")return{done:!0,value:null};throw s}finally{t=1}}();return Dl(n,{...e??{},onLength:s=>{t=s}})};function Ve(){const r={};return r.promise=new Promise((e,t)=>{r.resolve=e,r.reject=t}),r}let dw=class extends Error{type;code;constructor(e,t,n){super(e??"The operation was aborted"),this.type="aborted",this.name=n??"AbortError",this.code=t??"ABORT_ERR"}};async function At(r,e,t){if(e==null)return r;if(e.aborted)return r.catch(()=>{}),Promise.reject(new dw(t?.errorMessage,t?.errorCode,t?.errorName));let n;const i=new dw(t?.errorMessage,t?.errorCode,t?.errorName);try{return await Promise.race([r,new Promise((s,o)=>{n=()=>{o(i)},e.addEventListener("abort",n)})])}finally{n!=null&&e.removeEventListener("abort",n)}}class OT{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=Ve(),this.haveNext=Ve()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=Ve(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=Ve(),await At(this.readNext.promise,t?.signal,t)}}function aE(){return new OT}class BT extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"}function Ll(r,e){const t=aE();r.sink(t).catch(async o=>{await t.end(o)}),r.sink=async o=>{for await(const a of o)await t.push(a);await t.end()};let n=r.source;r.source[Symbol.iterator]!=null?n=r.source[Symbol.iterator]():r.source[Symbol.asyncIterator]!=null&&(n=r.source[Symbol.asyncIterator]());const i=new ye;return{read:async o=>{if(o?.signal?.throwIfAborted(),o?.bytes==null){const{done:c,value:l}=await At(n.next(),o?.signal);return c===!0?null:l}for(;i.byteLength<o.bytes;){const{value:c,done:l}=await At(n.next(),o?.signal);if(l===!0)throw new BT("unexpected end of input");i.append(c)}const a=i.sublist(0,o.bytes);return i.consume(o.bytes),a},write:async(o,a)=>{a?.signal?.throwIfAborted(),o instanceof Uint8Array?await t.push(o,a):await t.push(o.subarray(),a)},unwrap:()=>{if(i.byteLength>0){const o=r.source;r.source=async function*(){e?.yieldBytes===!1?yield i:yield*i,yield*o}()}return r}}}class NT extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"}class DT extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"}class LT extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"}function Ls(r,e={}){const t=Ll(r,e);e.maxDataLength!=null&&e.maxLengthLength==null&&(e.maxLengthLength=Et(e.maxDataLength));const n=e?.lengthDecoder??Zu,i=e?.lengthEncoder??_s;return{read:async o=>{let a=-1;const c=new ye;for(;;){c.append(await t.read({...o,bytes:1}));try{a=n(c)}catch(l){if(l instanceof RangeError)continue;throw l}if(a<0)throw new NT("Invalid message length");if(e?.maxLengthLength!=null&&c.byteLength>e.maxLengthLength)throw new LT("message length length too long");if(a>-1)break}if(e?.maxDataLength!=null&&a>e.maxDataLength)throw new DT("message length too long");return t.read({...o,bytes:a})},write:async(o,a)=>{await t.write(new ye(i(o.byteLength),o),a)},writeV:async(o,a)=>{const c=new ye(...o.flatMap(l=>[i(l.byteLength),l]));await t.write(c,a)},unwrap:()=>t.unwrap()}}function hw(){const r=Ve();let e=!1;return{sink:async t=>{if(e)throw new Error("already piped");e=!0,r.resolve(t)},source:async function*(){yield*await r.promise}()}}function MT(){const r=hw(),e=hw();return[{source:r.source,sink:e.sink},{source:e.source,sink:r.sink}]}class fw{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||(e-1&e)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}}class mh{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new fw(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return e?.byteLength!=null?e.byteLength:1}push(e){if(e?.value!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new fw(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return e?.value!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}let FT=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}};function go(r={}){return UT(t=>{const n=t.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function UT(r,e){e=e??{};let t=e.onEnd,n=new mh,i,s,o,a=Ve();const c=async()=>{try{return n.isEmpty()?o?{done:!0}:await new Promise((y,b)=>{s=_=>{s=null,n.push(_);try{y(r(n))}catch(E){b(E)}return i}}):r(n)}finally{n.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=Ve()})}},l=y=>s!=null?s(y):(n.push(y),i),u=y=>(n=new mh,s!=null?s({error:y}):(n.push({error:y}),i)),d=y=>{if(o)return i;if(e?.objectMode!==!0&&y?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:y})},h=y=>o?i:(o=!0,y!=null?u(y):l({done:!0})),p=()=>(n=new mh,h(),{done:!0}),m=y=>(h(y),{done:!0});if(i={[Symbol.asyncIterator](){return this},next:c,return:p,throw:m,push:d,end:h,get readableLength(){return n.size},onEmpty:async y=>{const b=y?.signal;if(b?.throwIfAborted(),n.isEmpty())return;let _,E;b!=null&&(_=new Promise((R,S)=>{E=()=>{S(new FT)},b.addEventListener("abort",E)}));try{await Promise.race([a.promise,_])}finally{E!=null&&b!=null&&b?.removeEventListener("abort",E)}}},t==null)return i;const w=i;return i={[Symbol.asyncIterator](){return this},next(){return w.next()},throw(y){return w.throw(y),t!=null&&(t(y),t=void 0),{done:!0}},return(){return w.return(),t!=null&&(t(),t=void 0),{done:!0}},push:d,end(y){return w.end(y),t!=null&&(t(y),t=void 0),i},get readableLength(){return w.readableLength},onEmpty:y=>w.onEmpty(y)},i}function $T(r){return r[Symbol.asyncIterator]!=null}async function qT(r,e,t){try{await Promise.all(r.map(async n=>{for await(const i of n)await e.push(i,{signal:t}),t.throwIfAborted()})),await e.end(void 0,{signal:t})}catch(n){await e.end(n,{signal:t}).catch(()=>{})}}async function*KT(r){const e=new AbortController,t=aE();qT(r,t,e.signal).catch(()=>{});try{yield*t}finally{e.abort()}}function*VT(r){for(const e of r)yield*e}function Ml(...r){const e=[];for(const t of r)$T(t)||e.push(t);return e.length===r.length?VT(e):KT(r)}function Yg(r,...e){if(r==null)throw new Error("Empty pipeline");if(yh(r)){const n=r;r=()=>n.source}else if(lE(r)||cE(r)){const n=r;r=()=>n}const t=[r,...e];if(t.length>1&&yh(t[t.length-1])&&(t[t.length-1]=t[t.length-1].sink),t.length>2)for(let n=1;n<t.length-1;n++)yh(t[n])&&(t[n]=jT(t[n]));return zT(...t)}const zT=(...r)=>{let e;for(;r.length>0;)e=r.shift()(e);return e},cE=r=>r?.[Symbol.asyncIterator]!=null,lE=r=>r?.[Symbol.iterator]!=null,yh=r=>r==null?!1:r.sink!=null&&r.source!=null,jT=r=>e=>{const t=r.sink(e);if(t?.then!=null){const n=go({objectMode:!0});t.then(()=>{n.end()},o=>{n.end(o)});let i;const s=r.source;if(cE(s))i=async function*(){yield*s,n.end()};else if(lE(s))i=function*(){yield*s,n.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return Ml(n,i())}return r.source},wa=65535,pw=wa-16,Ja=!!globalThis.process?.env?.DUMP_SESSION_KEYS;/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function uE(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Rf(r){if(typeof r!="boolean")throw new Error(`boolean expected, not ${r}`)}function wh(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function Dt(r,...e){if(!uE(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function gw(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function HT(r,e){Dt(r);const t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function zn(r){return new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength/4))}function Ms(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function WT(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}const GT=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function YT(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}function Of(r){if(typeof r=="string")r=YT(r);else if(uE(r))r=Bf(r);else throw new Error("Uint8Array expected, got "+typeof r);return r}function QT(r,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(r,e)}function JT(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}const XT=(r,e)=>{function t(n,...i){if(Dt(n),!GT)throw new Error("Non little-endian hardware is not yet supported");if(r.nonceLength!==void 0){const u=i[0];if(!u)throw new Error("nonce / iv required");r.varSizeNonce?Dt(u):Dt(u,r.nonceLength)}const s=r.tagLength;s&&i[1]!==void 0&&Dt(i[1]);const o=e(n,...i),a=(u,d)=>{if(d!==void 0){if(u!==2)throw new Error("cipher output not supported");Dt(d)}};let c=!1;return{encrypt(u,d){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,Dt(u),a(o.encrypt.length,d),o.encrypt(u,d)},decrypt(u,d){if(Dt(u),s&&u.length<s)throw new Error("invalid ciphertext length: smaller than tagLength="+s);return a(o.decrypt.length,d),o.decrypt(u,d)}}}return Object.assign(t,r),t};function mw(r,e,t=!0){if(e===void 0)return new Uint8Array(r);if(e.length!==r)throw new Error("invalid output length, expected "+r+", got: "+e.length);if(t&&!eP(e))throw new Error("invalid output, must be aligned");return e}function yw(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const i=BigInt(32),s=BigInt(4294967295),o=Number(t>>i&s),a=Number(t&s),c=4,l=0;r.setUint32(e+c,o,n),r.setUint32(e+l,a,n)}function ZT(r,e,t){Rf(t);const n=new Uint8Array(16),i=WT(n);return yw(i,0,BigInt(e),t),yw(i,8,BigInt(r),t),n}function eP(r){return r.byteOffset%4===0}function Bf(r){return Uint8Array.from(r)}const dE=r=>Uint8Array.from(r.split("").map(e=>e.charCodeAt(0))),tP=dE("expand 16-byte k"),rP=dE("expand 32-byte k"),nP=zn(tP),iP=zn(rP);function Se(r,e){return r<<e|r>>>32-e}function Nf(r){return r.byteOffset%4===0}const Bc=64,sP=16,hE=2**32-1,ww=new Uint32Array;function oP(r,e,t,n,i,s,o,a){const c=i.length,l=new Uint8Array(Bc),u=zn(l),d=Nf(i)&&Nf(s),h=d?zn(i):ww,p=d?zn(s):ww;for(let m=0;m<c;o++){if(r(e,t,n,u,o,a),o>=hE)throw new Error("arx: counter overflow");const w=Math.min(Bc,c-m);if(d&&w===Bc){const y=m/4;if(m%4!==0)throw new Error("arx: invalid block position");for(let b=0,_;b<sP;b++)_=y+b,p[_]=h[_]^u[b];m+=Bc;continue}for(let y=0,b;y<w;y++)b=m+y,s[b]=i[b]^l[y];m+=w}}function aP(r,e){const{allowShortKeys:t,extendNonceFn:n,counterLength:i,counterRight:s,rounds:o}=QT({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof r!="function")throw new Error("core must be a function");return wh(i),wh(o),Rf(s),Rf(t),(a,c,l,u,d=0)=>{Dt(a),Dt(c),Dt(l);const h=l.length;if(u===void 0&&(u=new Uint8Array(h)),Dt(u),wh(d),d<0||d>=hE)throw new Error("arx: counter overflow");if(u.length<h)throw new Error(`arx: output (${u.length}) is shorter than data (${h})`);const p=[];let m=a.length,w,y;if(m===32)p.push(w=Bf(a)),y=iP;else if(m===16&&t)w=new Uint8Array(32),w.set(a),w.set(a,16),y=nP,p.push(w);else throw new Error(`arx: invalid 32-byte key, got length=${m}`);Nf(c)||p.push(c=Bf(c));const b=zn(w);if(n){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");n(y,b,zn(c.subarray(0,16)),b),c=c.subarray(16)}const _=16-i;if(_!==c.length)throw new Error(`arx: nonce must be ${_} or 16 bytes`);if(_!==12){const R=new Uint8Array(12);R.set(c,s?0:12-c.length),c=R,p.push(c)}const E=zn(c);return oP(r,y,b,E,l,u,d,o),Ms(...p),u}}const st=(r,e)=>r[e++]&255|(r[e++]&255)<<8;class cP{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=Of(e),Dt(e,32);const t=st(e,0),n=st(e,2),i=st(e,4),s=st(e,6),o=st(e,8),a=st(e,10),c=st(e,12),l=st(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|n<<3)&8191,this.r[2]=(n>>>10|i<<6)&7939,this.r[3]=(i>>>7|s<<9)&8191,this.r[4]=(s>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|l<<8)&8191,this.r[9]=l>>>5&127;for(let u=0;u<8;u++)this.pad[u]=st(e,16+2*u)}process(e,t,n=!1){const i=n?0:2048,{h:s,r:o}=this,a=o[0],c=o[1],l=o[2],u=o[3],d=o[4],h=o[5],p=o[6],m=o[7],w=o[8],y=o[9],b=st(e,t+0),_=st(e,t+2),E=st(e,t+4),R=st(e,t+6),S=st(e,t+8),N=st(e,t+10),T=st(e,t+12),B=st(e,t+14);let v=s[0]+(b&8191),I=s[1]+((b>>>13|_<<3)&8191),C=s[2]+((_>>>10|E<<6)&8191),P=s[3]+((E>>>7|R<<9)&8191),O=s[4]+((R>>>4|S<<12)&8191),L=s[5]+(S>>>1&8191),M=s[6]+((S>>>14|N<<2)&8191),U=s[7]+((N>>>11|T<<5)&8191),K=s[8]+((T>>>8|B<<8)&8191),j=s[9]+(B>>>5|i),V=0,se=V+v*a+I*(5*y)+C*(5*w)+P*(5*m)+O*(5*p);V=se>>>13,se&=8191,se+=L*(5*h)+M*(5*d)+U*(5*u)+K*(5*l)+j*(5*c),V+=se>>>13,se&=8191;let Y=V+v*c+I*a+C*(5*y)+P*(5*w)+O*(5*m);V=Y>>>13,Y&=8191,Y+=L*(5*p)+M*(5*h)+U*(5*d)+K*(5*u)+j*(5*l),V+=Y>>>13,Y&=8191;let ae=V+v*l+I*c+C*a+P*(5*y)+O*(5*w);V=ae>>>13,ae&=8191,ae+=L*(5*m)+M*(5*p)+U*(5*h)+K*(5*d)+j*(5*u),V+=ae>>>13,ae&=8191;let z=V+v*u+I*l+C*c+P*a+O*(5*y);V=z>>>13,z&=8191,z+=L*(5*w)+M*(5*m)+U*(5*p)+K*(5*h)+j*(5*d),V+=z>>>13,z&=8191;let ve=V+v*d+I*u+C*l+P*c+O*a;V=ve>>>13,ve&=8191,ve+=L*(5*y)+M*(5*w)+U*(5*m)+K*(5*p)+j*(5*h),V+=ve>>>13,ve&=8191;let fe=V+v*h+I*d+C*u+P*l+O*c;V=fe>>>13,fe&=8191,fe+=L*a+M*(5*y)+U*(5*w)+K*(5*m)+j*(5*p),V+=fe>>>13,fe&=8191;let le=V+v*p+I*h+C*d+P*u+O*l;V=le>>>13,le&=8191,le+=L*c+M*a+U*(5*y)+K*(5*w)+j*(5*m),V+=le>>>13,le&=8191;let pt=V+v*m+I*p+C*h+P*d+O*u;V=pt>>>13,pt&=8191,pt+=L*l+M*c+U*a+K*(5*y)+j*(5*w),V+=pt>>>13,pt&=8191;let tt=V+v*w+I*m+C*p+P*h+O*d;V=tt>>>13,tt&=8191,tt+=L*u+M*l+U*c+K*a+j*(5*y),V+=tt>>>13,tt&=8191;let Ge=V+v*y+I*w+C*m+P*p+O*h;V=Ge>>>13,Ge&=8191,Ge+=L*d+M*u+U*l+K*c+j*a,V+=Ge>>>13,Ge&=8191,V=(V<<2)+V|0,V=V+se|0,se=V&8191,V=V>>>13,Y+=V,s[0]=se,s[1]=Y,s[2]=ae,s[3]=z,s[4]=ve,s[5]=fe,s[6]=le,s[7]=pt,s[8]=tt,s[9]=Ge}finalize(){const{h:e,pad:t}=this,n=new Uint16Array(10);let i=e[1]>>>13;e[1]&=8191;for(let a=2;a<10;a++)e[a]+=i,i=e[a]>>>13,e[a]&=8191;e[0]+=i*5,i=e[0]>>>13,e[0]&=8191,e[1]+=i,i=e[1]>>>13,e[1]&=8191,e[2]+=i,n[0]=e[0]+5,i=n[0]>>>13,n[0]&=8191;for(let a=1;a<10;a++)n[a]=e[a]+i,i=n[a]>>>13,n[a]&=8191;n[9]-=8192;let s=(i^1)-1;for(let a=0;a<10;a++)n[a]&=s;s=~s;for(let a=0;a<10;a++)e[a]=e[a]&s|n[a];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let o=e[0]+t[0];e[0]=o&65535;for(let a=1;a<8;a++)o=(e[a]+t[a]|0)+(o>>>16)|0,e[a]=o&65535;Ms(n)}update(e){gw(this),e=Of(e),Dt(e);const{buffer:t,blockLen:n}=this,i=e.length;for(let s=0;s<i;){const o=Math.min(n-this.pos,i-s);if(o===n){for(;n<=i-s;s+=n)this.process(e,s);continue}t.set(e.subarray(s,s+o),this.pos),this.pos+=o,s+=o,this.pos===n&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){Ms(this.h,this.r,this.buffer,this.pad)}digestInto(e){gw(this),HT(e,this),this.finished=!0;const{buffer:t,h:n}=this;let{pos:i}=this;if(i){for(t[i++]=1;i<16;i++)t[i]=0;this.process(t,0,!0)}this.finalize();let s=0;for(let o=0;o<8;o++)e[s++]=n[o]>>>0,e[s++]=n[o]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}}function lP(r){const e=(n,i)=>r(i).update(Of(n)).digest(),t=r(new Uint8Array(32));return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=n=>r(n),e}const uP=lP(r=>new cP(r));function dP(r,e,t,n,i,s=20){let o=r[0],a=r[1],c=r[2],l=r[3],u=e[0],d=e[1],h=e[2],p=e[3],m=e[4],w=e[5],y=e[6],b=e[7],_=i,E=t[0],R=t[1],S=t[2],N=o,T=a,B=c,v=l,I=u,C=d,P=h,O=p,L=m,M=w,U=y,K=b,j=_,V=E,se=R,Y=S;for(let z=0;z<s;z+=2)N=N+I|0,j=Se(j^N,16),L=L+j|0,I=Se(I^L,12),N=N+I|0,j=Se(j^N,8),L=L+j|0,I=Se(I^L,7),T=T+C|0,V=Se(V^T,16),M=M+V|0,C=Se(C^M,12),T=T+C|0,V=Se(V^T,8),M=M+V|0,C=Se(C^M,7),B=B+P|0,se=Se(se^B,16),U=U+se|0,P=Se(P^U,12),B=B+P|0,se=Se(se^B,8),U=U+se|0,P=Se(P^U,7),v=v+O|0,Y=Se(Y^v,16),K=K+Y|0,O=Se(O^K,12),v=v+O|0,Y=Se(Y^v,8),K=K+Y|0,O=Se(O^K,7),N=N+C|0,Y=Se(Y^N,16),U=U+Y|0,C=Se(C^U,12),N=N+C|0,Y=Se(Y^N,8),U=U+Y|0,C=Se(C^U,7),T=T+P|0,j=Se(j^T,16),K=K+j|0,P=Se(P^K,12),T=T+P|0,j=Se(j^T,8),K=K+j|0,P=Se(P^K,7),B=B+O|0,V=Se(V^B,16),L=L+V|0,O=Se(O^L,12),B=B+O|0,V=Se(V^B,8),L=L+V|0,O=Se(O^L,7),v=v+I|0,se=Se(se^v,16),M=M+se|0,I=Se(I^M,12),v=v+I|0,se=Se(se^v,8),M=M+se|0,I=Se(I^M,7);let ae=0;n[ae++]=o+N|0,n[ae++]=a+T|0,n[ae++]=c+B|0,n[ae++]=l+v|0,n[ae++]=u+I|0,n[ae++]=d+C|0,n[ae++]=h+P|0,n[ae++]=p+O|0,n[ae++]=m+L|0,n[ae++]=w+M|0,n[ae++]=y+U|0,n[ae++]=b+K|0,n[ae++]=_+j|0,n[ae++]=E+V|0,n[ae++]=R+se|0,n[ae++]=S+Y|0}const hP=aP(dP,{counterRight:!1,counterLength:4,allowShortKeys:!1}),fP=new Uint8Array(16),bw=(r,e)=>{r.update(e);const t=e.length%16;t&&r.update(fP.subarray(t))},pP=new Uint8Array(32);function vw(r,e,t,n,i){const s=r(e,t,pP),o=uP.create(s);i&&bw(o,i),bw(o,n);const a=ZT(n.length,i?i.length:0,!0);o.update(a);const c=o.digest();return Ms(s,a),c}const gP=r=>(e,t,n)=>({encrypt(s,o){const a=s.length;o=mw(a+16,o,!1),o.set(s);const c=o.subarray(0,-16);r(e,t,c,c,1);const l=vw(r,e,t,c,n);return o.set(l,a),Ms(l),o},decrypt(s,o){o=mw(s.length-16,o,!1);const a=s.subarray(0,-16),c=s.subarray(-16),l=vw(r,e,t,a,n);if(!JT(c,l))throw new Error("invalid tag");return o.set(s.subarray(0,-16)),r(e,t,o,o,1),Ms(l),o}}),Sw=XT({blockSize:64,nonceLength:12,tagLength:16},gP(hP));function mP(r,e,t){return Gu(r),t===void 0&&(t=new Uint8Array(r.outputLen)),Ga(r,ga(t),ga(e))}const bh=Uint8Array.from([0]),Ew=Uint8Array.of();function yP(r,e,t,n=32){Gu(r),xi(n);const i=r.outputLen;if(n>255*i)throw new Error("Length should be <= 255*HashLen");const s=Math.ceil(n/i);t===void 0&&(t=Ew);const o=new Uint8Array(s*i),a=Ga.create(r,e),c=a._cloneInto(),l=new Uint8Array(a.outputLen);for(let u=0;u<s;u++)bh[0]=u+1,c.update(u===0?Ew:l).update(t).update(bh).digestInto(l),o.set(l,i*u),a._cloneInto(c);return a.destroy(),c.destroy(),Kr(l,bh),o.slice(0,n)}const wP={hashSHA256(r){return Ci(r.subarray())},getHKDF(r,e){const t=mP(Ci,e,r),i=yP(Ci,t,void 0,96),s=i.subarray(0,32),o=i.subarray(32,64),a=i.subarray(64,96);return[s,o,a]},generateX25519KeyPair(){const r=Tc.utils.randomPrivateKey();return{publicKey:Tc.getPublicKey(r),privateKey:r}},generateX25519KeyPairFromSeed(r){return{publicKey:Tc.getPublicKey(r),privateKey:r}},generateX25519SharedKey(r,e){return Tc.getSharedSecret(r.subarray(),e.subarray())},chaCha20Poly1305Encrypt(r,e,t,n){return Sw(n,e,t).encrypt(r.subarray())},chaCha20Poly1305Decrypt(r,e,t,n,i){return Sw(n,e,t).decrypt(r.subarray(),i)}},bP=wP;function vP(r){return{generateKeypair:r.generateX25519KeyPair,dh:(e,t)=>r.generateX25519SharedKey(e.privateKey,t).subarray(0,32),encrypt:r.chaCha20Poly1305Encrypt,decrypt:r.chaCha20Poly1305Decrypt,hash:r.hashSHA256,hkdf:r.getHKDF}}const Fl=r=>{const e=$r(2);return e[0]=r>>8,e[1]=r,e};Fl.bytes=2;const dl=r=>{if(r.length<2)throw RangeError("Could not decode int16BE");if(r instanceof Uint8Array){let e=0;return e+=r[0]<<8,e+=r[1],e}return r.getUint16(0)};dl.bytes=2;function SP(r){return{xxHandshakeSuccesses:r.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:r.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:r.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:r.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:r.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}function fE(r,e){!e.enabled||!Ja||(r?(e(`LOCAL_STATIC_PUBLIC_KEY ${ne(r.publicKey,"hex")}`),e(`LOCAL_STATIC_PRIVATE_KEY ${ne(r.privateKey,"hex")}`)):e("Missing local static keys."))}function pE(r,e){!e.enabled||!Ja||(r?(e(`LOCAL_PUBLIC_EPHEMERAL_KEY ${ne(r.publicKey,"hex")}`),e(`LOCAL_PRIVATE_EPHEMERAL_KEY ${ne(r.privateKey,"hex")}`)):e("Missing local ephemeral keys."))}function EP(r,e){!e.enabled||!Ja||e(r?`REMOTE_STATIC_PUBLIC_KEY ${ne(r.subarray(),"hex")}`:"Missing remote static public key.")}function gE(r,e){!e.enabled||!Ja||e(r?`REMOTE_EPHEMERAL_PUBLIC_KEY ${ne(r.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function mE(r,e,t){!t.enabled||!Ja||(t(`CIPHER_STATE_1 ${r.n.getUint64()} ${r.k&&ne(r.k,"hex")}`),t(`CIPHER_STATE_2 ${e.n.getUint64()} ${e.k&&ne(e.k,"hex")}`))}class ia extends Error{code;constructor(e="Invalid crypto exchange"){super(e),this.code=ia.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"}const AP=0,xP=4294967295,_P="Cipherstate has reached maximum n, a new handshake must be performed";class CP{n;bytes;view;constructor(e=AP){this.n=e,this.bytes=Ie(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,e,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>xP)throw new Error(_P)}}const Cs=Ie(0);class Nc{k;n;crypto;constructor(e,t=void 0,n=0){this.crypto=e,this.k=t,this.n=new CP(n)}hasKey(){return!!this.k}encryptWithAd(e,t){if(!this.hasKey())return t;this.n.assertValue();const n=this.crypto.encrypt(t,this.n.getBytes(),e,this.k);return this.n.increment(),n}decryptWithAd(e,t,n){if(!this.hasKey())return t;this.n.assertValue();const i=this.crypto.decrypt(t,this.n.getBytes(),e,this.k,n);return this.n.increment(),i}}class IP{cs;ck;h;crypto;constructor(e,t){this.crypto=e;const n=Z(t,"utf-8");this.h=TP(e,n),this.ck=this.h,this.cs=new Nc(e)}mixKey(e){const[t,n]=this.crypto.hkdf(this.ck,e);this.ck=t,this.cs=new Nc(this.crypto,n)}mixHash(e){this.h=this.crypto.hash(new ye(this.h,e))}encryptAndHash(e){const t=this.cs.encryptWithAd(this.h,e);return this.mixHash(t),t}decryptAndHash(e){const t=this.cs.decryptWithAd(this.h,e);return this.mixHash(e),t}split(){const[e,t]=this.crypto.hkdf(this.ck,Cs);return[new Nc(this.crypto,e),new Nc(this.crypto,t)]}}class kP{ss;s;e;rs;re;initiator;crypto;constructor(e){const{crypto:t,protocolName:n,prologue:i,initiator:s,s:o,e:a,rs:c,re:l}=e;this.crypto=t,this.ss=new IP(t,n),this.ss.mixHash(i),this.initiator=s,this.s=o,this.e=a,this.rs=c,this.re=l}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const e=this.crypto.generateKeypair();return this.ss.mixHash(e.publicKey),this.e=e,e.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(e,t=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(e.byteLength<t+32)throw new Error("message is not long enough");this.re=e.sublist(t,t+32),this.ss.mixHash(this.re)}readS(e,t=0){if(this.rs)throw new Error("remote static public key is already set");const n=32+(this.ss.cs.hasKey()?16:0);if(e.byteLength<t+n)throw new Error("message is not long enough");const i=e.sublist(t,t+n);return this.rs=this.ss.decryptAndHash(i),n}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class yE extends kP{writeMessageA(e){return new ye(this.writeE(),this.ss.encryptAndHash(e))}writeMessageB(e){const t=this.writeE();this.writeEE();const n=this.writeS();return this.writeES(),new ye(t,n,this.ss.encryptAndHash(e))}writeMessageC(e){const t=this.writeS();return this.writeSE(),new ye(t,this.ss.encryptAndHash(e))}readMessageA(e){try{return this.readE(e),this.ss.decryptAndHash(e.sublist(32))}catch(t){throw new ia(`handshake stage 0 validation fail: ${t.message}`)}}readMessageB(e){try{this.readE(e),this.readEE();const t=this.readS(e,32);return this.readES(),this.ss.decryptAndHash(e.sublist(32+t))}catch(t){throw new ia(`handshake stage 1 validation fail: ${t.message}`)}}readMessageC(e){try{const t=this.readS(e);return this.readSE(),this.ss.decryptAndHash(e.sublist(t))}catch(t){throw new ia(`handshake stage 2 validation fail: ${t.message}`)}}}function TP(r,e){if(e.length<=32){const t=Ie(32);return t.set(e),t}else return r.hash(e)}var Ul;(function(r){let e;r.codec=()=>(e==null&&(e=Oe((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.webtransportCerthashes!=null)for(const s of t.webtransportCerthashes)n.uint32(10),n.bytes(s);if(t.streamMuxers!=null)for(const s of t.streamMuxers)n.uint32(18),n.string(s);i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={webtransportCerthashes:[],streamMuxers:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(i.limits?.webtransportCerthashes!=null&&s.webtransportCerthashes.length===i.limits.webtransportCerthashes)throw new Ar('Decode error - map field "webtransportCerthashes" had too many elements');s.webtransportCerthashes.push(t.bytes());break}case 2:{if(i.limits?.streamMuxers!=null&&s.streamMuxers.length===i.limits.streamMuxers)throw new Ar('Decode error - map field "streamMuxers" had too many elements');s.streamMuxers.push(t.string());break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Re(t,r.codec()),r.decode=(t,n)=>Pe(t,r.codec(),n)})(Ul||(Ul={}));var $l;(function(r){let e;r.codec=()=>(e==null&&(e=Oe((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.identityKey!=null&&t.identityKey.byteLength>0&&(n.uint32(10),n.bytes(t.identityKey)),t.identitySig!=null&&t.identitySig.byteLength>0&&(n.uint32(18),n.bytes(t.identitySig)),t.extensions!=null&&(n.uint32(34),Ul.codec().encode(t.extensions,n)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={identityKey:Ie(0),identitySig:Ie(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.identityKey=t.bytes();break}case 2:{s.identitySig=t.bytes();break}case 4:{s.extensions=Ul.codec().decode(t,t.uint32(),{limits:i.limits?.extensions});break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Re(t,r.codec()),r.decode=(t,n)=>Pe(t,r.codec(),n)})($l||($l={}));async function wE(r,e,t){const n=await r.sign(vE(e));return $l.encode({identityKey:on(r.publicKey),identitySig:n,extensions:t})}async function bE(r,e,t){try{const n=$l.decode(r),i=Gn(n.identityKey);if(t?.equals(i)===!1)throw new Error(`Payload identity key ${i} does not match expected remote identity key ${t}`);if(!e)throw new Error("Remote static does not exist");const s=vE(e);if(!await i.verify(s,n.identitySig))throw new Error("Invalid payload signature");return n}catch(n){throw new sC(n.message)}}function vE(r){const e=Z("noise-libp2p-static-key:");return r instanceof Uint8Array?qr([e,r],e.length+r.length):(r.prepend(e),r)}async function PP(r,e){const{log:t,connection:n,crypto:i,privateKey:s,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=r,u=await wE(s,a.publicKey,l),d=new yE({crypto:i,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});fE(d.s,t),t.trace("Stage 0 - Initiator starting to send first message."),await n.write(d.writeMessageA(Cs),e),t.trace("Stage 0 - Initiator finished sending first message."),pE(d.e,t),t.trace("Stage 1 - Initiator waiting to receive first message from responder...");const h=d.readMessageB(await n.read(e));t.trace("Stage 1 - Initiator received the message."),gE(d.re,t),EP(d.rs,t),t.trace("Initiator going to check remote's signature...");const p=await bE(h,d.rs,c);t.trace("All good with the signature!"),t.trace("Stage 2 - Initiator sending third handshake message."),await n.write(d.writeMessageC(u),e),t.trace("Stage 2 - Initiator sent message with signed payload.");const[m,w]=d.ss.split();return mE(m,w,t),{payload:p,encrypt:y=>m.encryptWithAd(Cs,y),decrypt:(y,b)=>w.decryptWithAd(Cs,y,b)}}async function RP(r,e){const{log:t,connection:n,crypto:i,privateKey:s,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=r,u=await wE(s,a.publicKey,l),d=new yE({crypto:i,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});fE(d.s,t),t.trace("Stage 0 - Responder waiting to receive first message."),d.readMessageA(await n.read(e)),t.trace("Stage 0 - Responder received first message."),gE(d.re,t),t.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await n.write(d.writeMessageB(u),e),t.trace("Stage 1 - Responder sent the second handshake message with signed payload."),pE(d.e,t),t.trace("Stage 2 - Responder waiting for third handshake message...");const h=d.readMessageC(await n.read(e));t.trace("Stage 2 - Responder received the message, finished handshake.");const p=await bE(h,d.rs,c),[m,w]=d.ss.split();return mE(m,w,t),{payload:p,encrypt:y=>w.encryptWithAd(Cs,y),decrypt:(y,b)=>m.decryptWithAd(Cs,y,b)}}const Aw=16;function OP(r,e){return async function*(t){for await(const n of t)for(let i=0;i<n.length;i+=pw){let s=i+pw;s>n.length&&(s=n.length);let o;n instanceof Uint8Array?o=r.encrypt(n.subarray(i,s)):o=r.encrypt(n.sublist(i,s)),e?.encryptedPackets.increment(),yield new ye(Fl(o.byteLength),o)}}}function BP(r,e){return async function*(t){for await(const n of t)for(let i=0;i<n.length;i+=wa){let s=i+wa;if(s>n.length&&(s=n.length),s-Aw<i)throw new Error("Invalid chunk");const o=n.sublist(i,s),a=n.subarray(i,s-Aw);try{const c=r.decrypt(o,a);e?.decryptedPackets.increment(),yield c}catch(c){throw e?.decryptErrors.increment(),c}}}}class NP{protocol="/noise";crypto;prologue;staticKey;extensions;metrics;components;constructor(e,t={}){const{staticNoiseKey:n,extensions:i,crypto:s,prologueBytes:o}=t,{metrics:a}=e;this.components=e;const c=s??bP;this.crypto=vP(c),this.extensions={webtransportCerthashes:[],...i},this.metrics=a?SP(a):void 0,n?this.staticKey=c.generateX25519KeyPairFromSeed(n):this.staticKey=c.generateX25519KeyPair(),this.prologue=o??Ie(0)}[Symbol.toStringTag]="@chainsafe/libp2p-noise";[$t]=["@libp2p/connection-encryption","@chainsafe/libp2p-noise"];async secureOutbound(e,t){const n=Ls(e,{lengthEncoder:Fl,lengthDecoder:dl,maxDataLength:wa}),i=await this.performHandshakeInitiator(n,this.components.privateKey,t?.remotePeer?.publicKey,t),s=await this.createSecureConnection(n,i);e.source=s.source,e.sink=s.sink;const o=Gn(i.payload.identityKey);return{conn:e,remoteExtensions:i.payload.extensions,remotePeer:ya(o),streamMuxer:t?.skipStreamMuxerNegotiation===!0?void 0:this.getStreamMuxer(i.payload.extensions?.streamMuxers)}}getStreamMuxer(e){if(e==null||e.length===0)return;const t=this.components.upgrader.getStreamMuxers();if(t!=null)for(const n of e){const i=t.get(n);if(i!=null)return i}if(e.length)throw new oC("Early muxer negotiation was requested but the initiator and responder had no common muxers")}async secureInbound(e,t){const n=Ls(e,{lengthEncoder:Fl,lengthDecoder:dl,maxDataLength:wa}),i=await this.performHandshakeResponder(n,this.components.privateKey,t?.remotePeer?.publicKey,t),s=await this.createSecureConnection(n,i);e.source=s.source,e.sink=s.sink;const o=Gn(i.payload.identityKey);return{conn:e,remoteExtensions:i.payload.extensions,remotePeer:ya(o),streamMuxer:t?.skipStreamMuxerNegotiation===!0?void 0:this.getStreamMuxer(i.payload.extensions?.streamMuxers)}}async performHandshakeInitiator(e,t,n,i){let s;const o=i?.skipStreamMuxerNegotiation===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{s=await PP({connection:e,privateKey:t,remoteIdentityKey:n,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:o,webtransportCerthashes:[],...this.extensions}},i),this.metrics?.xxHandshakeSuccesses.increment()}catch(a){throw this.metrics?.xxHandshakeErrors.increment(),a}return s}async performHandshakeResponder(e,t,n,i){let s;const o=i?.skipStreamMuxerNegotiation===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{s=await RP({connection:e,privateKey:t,remoteIdentityKey:n,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:o,webtransportCerthashes:[],...this.extensions}},i),this.metrics?.xxHandshakeSuccesses.increment()}catch(a){throw this.metrics?.xxHandshakeErrors.increment(),a}return s}async createSecureConnection(e,t){const[n,i]=MT(),s=e.unwrap();return await Yg(n,OP(t,this.metrics),s,o=>Dl(o,{lengthDecoder:dl}),BP(t,this.metrics),n),i}}function SE(r={}){return e=>new NP(e,r)}function EE(r){if(r!=null){if(typeof r[Symbol.iterator]=="function")return r[Symbol.iterator]();if(typeof r[Symbol.asyncIterator]=="function")return r[Symbol.asyncIterator]();if(typeof r.next=="function")return r}throw new Error("argument is not an iterator or iterable")}class gs extends Error{static name="InvalidFrameError";constructor(e="The frame was invalid"){super(e),this.name="InvalidFrameError"}}class AE extends Error{static name="UnrequestedPingError";constructor(e="Unrequested ping error"){super(e),this.name="UnrequestedPingError"}}class xE extends Error{static name="NotMatchingPingError";constructor(e="Unrequested ping error"){super(e),this.name="NotMatchingPingError"}}class DP extends Error{static name="InvalidStateError";constructor(e="Invalid state"){super(e),this.name="InvalidStateError"}}class LP extends Error{static name="StreamAlreadyExistsError";constructor(e="Strean already exists"){super(e),this.name="StreamAlreadyExistsError"}}class MP extends Error{static name="DecodeInvalidVersionError";constructor(e="Decode invalid version"){super(e),this.name="DecodeInvalidVersionError"}}class FP extends Error{static name="BothClientsError";constructor(e="Both clients"){super(e),this.name="BothClientsError"}}class _E extends Error{static name="ReceiveWindowExceededError";constructor(e="Receive window exceeded"){super(e),this.name="ReceiveWindowExceededError"}}const UP=new Set([gs.name,AE.name,xE.name,LP.name,MP.name,FP.name,_E.name]),Qg=256*1024,$P=16*1024*1024,qP={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:Qg,maxStreamWindowSize:$P,maxMessageSize:64*1024};function KP(r){if(r.keepAliveInterval<=0)throw new q("keep-alive interval must be positive");if(r.maxInboundStreams<0)throw new q("max inbound streams must be larger or equal 0");if(r.maxOutboundStreams<0)throw new q("max outbound streams must be larger or equal 0");if(r.initialStreamWindowSize<Qg)throw new q("InitialStreamWindowSize must be larger or equal 256 kB");if(r.maxStreamWindowSize<r.initialStreamWindowSize)throw new q("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(r.maxStreamWindowSize>2**32-1)throw new q("MaxStreamWindowSize must be less than equal MAX_UINT32");if(r.maxMessageSize<1024)throw new q("MaxMessageSize must be greater than a kilobyte")}var Ze;(function(r){r[r.Data=0]="Data",r[r.WindowUpdate=1]="WindowUpdate",r[r.Ping=2]="Ping",r[r.GoAway=3]="GoAway"})(Ze||(Ze={}));var ze;(function(r){r[r.SYN=1]="SYN",r[r.ACK=2]="ACK",r[r.FIN=4]="FIN",r[r.RST=8]="RST"})(ze||(ze={}));Object.values(ze).filter(r=>typeof r!="string");const VP=0;var Rr;(function(r){r[r.NormalTermination=0]="NormalTermination",r[r.ProtocolError=1]="ProtocolError",r[r.InternalError=2]="InternalError"})(Rr||(Rr={}));const sa=12,xw=2**24;function zP(r){if(r[0]!==VP)throw new gs("Invalid frame version");return{type:r[1],flag:(r[2]<<8)+r[3],streamID:r[4]*xw+(r[5]<<16)+(r[6]<<8)+r[7],length:r[8]*xw+(r[9]<<16)+(r[10]<<8)+r[11]}}class jP{source;buffer;frameInProgress;constructor(e){this.source=HP(e),this.buffer=new ye,this.frameInProgress=!1}async*emitFrames(){for await(const e of this.source)for(this.buffer.append(e);;){const t=this.readHeader();if(t===void 0)break;const{type:n,length:i}=t;n===Ze.Data?(this.frameInProgress=!0,yield{header:t,readData:this.readBytes.bind(this,i)}):yield{header:t}}}readHeader(){if(this.frameInProgress)throw new DP("decoding frame already in progress");if(this.buffer.length<sa)return;const e=zP(this.buffer.subarray(0,sa));return this.buffer.consume(sa),e}async readBytes(e){if(this.buffer.length<e){for await(const n of this.source)if(this.buffer.append(n),this.buffer.length>=e)break}const t=this.buffer.sublist(0,e);return this.buffer.consume(e),this.frameInProgress=!1,t}}function HP(r){if(r[Symbol.iterator]!==void 0){const e=r[Symbol.iterator]();return e.return=void 0,{[Symbol.iterator](){return e}}}else if(r[Symbol.asyncIterator]!==void 0){const e=r[Symbol.asyncIterator]();return e.return=void 0,{[Symbol.asyncIterator](){return e}}}else throw new Error("a source must be either an iterable or an async iterable")}function _w(r){const e=new Uint8Array(sa);return e[1]=r.type,e[2]=r.flag>>>8,e[3]=r.flag,e[4]=r.streamID>>>24,e[5]=r.streamID>>>16,e[6]=r.streamID>>>8,e[7]=r.streamID,e[8]=r.length>>>24,e[9]=r.length>>>16,e[10]=r.length>>>8,e[11]=r.length,e}function WP(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}function GP(r,e){const t=EE(r).return?.();WP(t)&&t.catch(n=>{e.error("could not cause iterator to return",n)})}const YP=5e3;function vh(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class CE{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;sendingData;constructor(e){this.sinkController=new AbortController,this.sinkEnd=Ve(),this.closed=Ve(),this.log=e.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=e.id,this.metadata=e.metadata??{},this.direction=e.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=e.sendCloseWriteTimeout??YP,this.onEnd=e.onEnd,this.onCloseRead=e.onCloseRead,this.onCloseWrite=e.onCloseWrite,this.onReset=e.onReset,this.onAbort=e.onAbort,this.source=this.streamSource=go({onEnd:t=>{t!=null?this.log.trace("source ended with error",t):this.log.trace("source ended"),this.onSourceEnd(t)}}),this.sink=this.sink.bind(this)}async sink(e){if(this.writeStatus!=="ready")throw new wf(`writable end state is "${this.writeStatus}" not "ready"`);try{this.writeStatus="writing";const t={signal:this.sinkController.signal};if(this.direction==="outbound"){const i=this.sendNewStream(t);vh(i)&&await i}const n=()=>{GP(e,this.log)};try{this.sinkController.signal.addEventListener("abort",n),this.log.trace("sink reading from source");for await(let i of e){i=i instanceof Uint8Array?new ye(i):i;const s=this.sendData(i,t);vh(s)&&(this.sendingData=Ve(),await s,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",n)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),this.writeStatus==="writing"&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(t){throw this.log.trace("sink ended with error, calling abort with error",t),this.abort(t),t}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(e){this.timeline.closeRead==null&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),this.onCloseRead?.(),this.timeline.closeWrite!=null?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(e){this.timeline.closeWrite==null&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),this.onCloseWrite?.(),this.timeline.closeRead!=null?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(e){this.status==="open"&&(this.log.trace("closing gracefully"),this.status="closing",await At(Promise.all([this.closeWrite(e),this.closeRead(e),this.closed.promise]),e?.signal),this.status="closed",this.log.trace("closed gracefully"))}async closeRead(e={}){if(this.readStatus==="closing"||this.readStatus==="closed")return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);const t=this.readStatus;this.readStatus="closing",this.status!=="reset"&&this.status!=="aborted"&&this.timeline.closeRead==null&&(this.log.trace("send close read to remote"),await this.sendCloseRead(e)),t==="ready"&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(e={}){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),this.writeStatus==="ready"&&(this.log.trace("sink was never sunk, sink an empty array"),await At(this.sink([]),e.signal)),this.writeStatus==="writing"&&(this.sendingData!=null&&await At(this.sendingData.promise,e.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await At(this.sinkEnd.promise,e.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(e){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;this.log("abort with error",e),this.log("try to send reset to remote");const t=this.sendReset();vh(t)&&t.catch(n=>{this.log.error("error sending reset message",n)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(e),this.onAbort?.(e)}reset(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;const e=new cC("stream reset");this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(e),this.onReset?.()}_closeSinkAndSource(e){this._closeSink(e),this._closeSource(e)}_closeSink(e){this.writeStatus==="writing"&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(e)}_closeSource(e){this.readStatus!=="closing"&&this.readStatus!=="closed"&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(e))}remoteCloseWrite(){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("received remote close write but local source is already closed");return}this.log.trace("remote close write"),this._closeSource()}remoteCloseRead(){if(this.writeStatus==="closing"||this.writeStatus==="closed"){this.log("received remote close read but local sink is already closed");return}this.log.trace("remote close read"),this._closeSink()}destroy(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset"){this.log("received destroy but we are already closed");return}this.log.trace("stream destroyed"),this._closeSinkAndSource()}sourcePush(e){this.streamSource.push(e)}sourceReadableLength(){return this.streamSource.readableLength}}function IE(r){const[e,t]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>e.next(),push:i=>{n.push(i)},next:()=>n.length>0?{done:!1,value:n.shift()}:e.next(),[t](){return this}}}function QP(r){return r[Symbol.asyncIterator]!=null}function Cw(r){return r?.then!=null}function kE(r,e){let t=0;if(QP(r))return async function*(){for await(const c of r){const l=e(c,t++);Cw(l)&&await l,yield c}}();const n=IE(r),{value:i,done:s}=n.next();if(s===!0)return function*(){}();if(typeof e(i,t++)?.then=="function")return async function*(){yield i;for(const c of n){const l=e(c,t++);Cw(l)&&await l,yield c}}();const a=e;return function*(){yield i;for(const c of n)a(c,t++),yield c}()}var mr;(function(r){r[r.Init=0]="Init",r[r.SYNSent=1]="SYNSent",r[r.SYNReceived=2]="SYNReceived",r[r.Established=3]="Established",r[r.Finished=4]="Finished"})(mr||(mr={}));class JP extends CE{name;state;config;_id;sendWindowCapacity;sendWindowCapacityUpdate;recvWindow;recvWindowCapacity;epochStart;getRTT;sendFrame;constructor(e){super({...e,onEnd:t=>{this.state=mr.Finished,e.onEnd?.(t)}}),this.config=e.config,this._id=parseInt(e.id,10),this.name=e.name,this.state=e.state,this.sendWindowCapacity=Qg,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=e.getRTT,this.sendFrame=e.sendFrame,this.source=kE(this.source,()=>{this.sendWindowUpdate()})}async sendNewStream(){}async sendData(e,t={}){for(e=e.sublist();e.byteLength!==0;){if(this.sendWindowCapacity===0&&(this.log?.trace("wait for send window capacity, status %s",this.status),await this.waitForSendWindowCapacity(t),this.status==="closed"||this.status==="aborted"||this.status==="reset")){this.log?.trace("%s while waiting for send window capacity",this.status);return}const n=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-sa,e.length),i=this.getSendFlags();this.sendFrame({type:Ze.Data,flag:i,streamID:this._id,length:n},e.sublist(0,n)),this.sendWindowCapacity-=n,e.consume(n)}}async sendReset(){this.sendFrame({type:Ze.WindowUpdate,flag:ze.RST,streamID:this._id,length:0})}async sendCloseWrite(){const e=this.getSendFlags()|ze.FIN;this.sendFrame({type:Ze.WindowUpdate,flag:e,streamID:this._id,length:0})}async sendCloseRead(){}async waitForSendWindowCapacity(e={}){if(this.sendWindowCapacity>0)return;let t,n;const i=()=>{this.status==="open"||this.status==="closing"?n(new Ri("Stream aborted")):t()};e.signal?.addEventListener("abort",i);try{await new Promise((s,o)=>{this.sendWindowCapacityUpdate=()=>{s()},n=o,t=s})}finally{e.signal?.removeEventListener("abort",i)}}handleWindowUpdate(e){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(e.flag);const t=this.sendWindowCapacity;this.sendWindowCapacity+=e.length,t===0&&e.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(e,t){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(e.flag),this.recvWindowCapacity<e.length)throw new _E("Receive window exceeded");const n=await t();this.recvWindowCapacity-=e.length,this.sourcePush(n)}processFlags(e){(e&ze.ACK)===ze.ACK&&this.state===mr.SYNSent&&(this.state=mr.Established),(e&ze.FIN)===ze.FIN&&this.remoteCloseWrite(),(e&ze.RST)===ze.RST&&this.reset()}getSendFlags(){switch(this.state){case mr.Init:return this.state=mr.SYNSent,ze.SYN;case mr.SYNReceived:return this.state=mr.Established,ze.ACK;default:return 0}}sendWindowUpdate(){const e=this.getSendFlags(),t=Date.now(),n=this.getRTT();if(e===0&&n>-1&&t-this.epochStart<n*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&e===0)return;const i=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=t,this.sendFrame({type:Ze.WindowUpdate,flag:e,streamID:this._id,length:i})}}const TE="/yamux/1.0.0",XP=500;class ZP{protocol=TE;_components;_init;constructor(e,t={}){this._components=e,this._init=t}[Symbol.toStringTag]="@chainsafe/libp2p-yamux";[$t]=["@libp2p/stream-multiplexing"];createStreamMuxer(e){return new eR(this._components,{...this._init,...e})}}class eR{protocol=TE;source;sink;config;log;logger;closeController;nextStreamID;_streams;nextPingID;activePing;rtt;client;localGoAway;remoteGoAway;numInboundStreams;numOutboundStreams;onIncomingStream;onStreamEnd;constructor(e,t){this.client=t.direction==="outbound",this.config={...qP,...t},this.logger=e.logger,this.log=this.logger.forComponent("libp2p:yamux"),KP(this.config),this.closeController=new AbortController,this.closeController.signal,this.onIncomingStream=t.onIncomingStream,this.onStreamEnd=t.onStreamEnd,this._streams=new Map,this.source=go({onEnd:()=>{this.log?.trace("muxer source ended"),this._streams.forEach(n=>{n.destroy()})}}),this.sink=async n=>{const i=()=>{const a=EE(n);if(a.return!=null){const c=a.return();tR(c)&&c.catch(l=>{this.log?.("could not cause sink source to return",l)})}};let s,o;try{const a=new jP(n);try{this.closeController.signal.addEventListener("abort",i);for await(const c of a.emitFrames())await this.handleFrame(c.header,c.readData)}finally{this.closeController.signal.removeEventListener("abort",i)}s=Rr.NormalTermination}catch(a){UP.has(a.name)?(this.log?.error("protocol error in sink",a),s=Rr.ProtocolError):(this.log?.error("internal error in sink",a),s=Rr.InternalError),o=a}this.log?.trace("muxer sink ended"),o!=null?this.abort(o,s):await this.close({reason:s})},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(n=>this.log?.error("keepalive error: %s",n)),this.ping().catch(n=>this.log?.error("ping error: %s",n))}get streams(){return Array.from(this._streams.values())}newStream(e){if(this.remoteGoAway!==void 0)throw new Bo("Muxer closed remotely");if(this.localGoAway!==void 0)throw new Bo("Muxer closed locally");const t=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new Wv("max outbound streams exceeded");this.log?.trace("new outgoing stream id=%s",t);const n=this._newStream(t,e,mr.Init,"outbound");return this._streams.set(t,n),this.numOutboundStreams++,n.sendWindowUpdate(),n}async ping(){if(this.remoteGoAway!==void 0)throw new Bo("Muxer closed remotely");if(this.localGoAway!==void 0)throw new Bo("Muxer closed locally");if(this.activePing===void 0){let e=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((i,s)=>{const o=()=>{s(new Bo("Muxer closed locally"))};this.closeController.signal.addEventListener("abort",o,{once:!0}),e=()=>{this.closeController.signal.removeEventListener("abort",o),i()}}),resolve:e};const t=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}const n=Date.now();this.rtt=n-t}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}async close(e={}){if(this.closeController.signal.aborted)return;const t=e?.reason??Rr.NormalTermination;if(this.log?.trace("muxer close reason=%s",t),e.signal==null){const n=AbortSignal.timeout(XP);e={...e,signal:n}}try{await Promise.all([...this._streams.values()].map(async n=>n.close(e))),this.sendGoAway(t),this._closeMuxer()}catch(n){this.abort(n)}}abort(e,t){if(!this.closeController.signal.aborted){t=t??Rr.InternalError,this.log?.error("muxer abort reason=%s error=%s",t,e);for(const n of this._streams.values())n.abort(e);this.sendGoAway(t),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(e,t,n,i){if(this._streams.get(e)!=null)throw new q("Stream already exists with that id");const s=new JP({id:e.toString(),name:t,state:n,direction:i,sendFrame:this.sendFrame.bind(this),onEnd:()=>{this.closeStream(e),this.onStreamEnd?.(s)},log:this.logger.forComponent(`libp2p:yamux:${i}:${e}`),config:this.config,getRTT:this.getRTT.bind(this)});return s}closeStream(e){this.client===(e%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(e)}async keepAliveLoop(){const e=new Promise((t,n)=>{this.closeController.signal.addEventListener("abort",n,{once:!0})});for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let t;try{await Promise.race([e,new Promise(n=>{t=setTimeout(n,this.config.keepAliveInterval)})]),this.ping().catch(n=>this.log?.error("ping error: %s",n))}catch{clearInterval(t);return}}}async handleFrame(e,t){const{streamID:n,type:i,length:s}=e;if(this.log?.trace("received frame %o",e),n===0)switch(i){case Ze.Ping:{this.handlePing(e);return}case Ze.GoAway:{this.handleGoAway(s);return}default:throw new gs("Invalid frame type")}else switch(e.type){case Ze.Data:case Ze.WindowUpdate:{await this.handleStreamMessage(e,t);return}default:throw new gs("Invalid frame type")}}handlePing(e){if(e.flag===ze.SYN)this.log?.trace("received ping request pingId=%s",e.length),this.sendPing(e.length,ze.ACK);else if(e.flag===ze.ACK)this.log?.trace("received ping response pingId=%s",e.length),this.handlePingResponse(e.length);else throw new gs("Invalid frame flag")}handlePingResponse(e){if(this.activePing===void 0)throw new AE("ping not requested");if(this.activePing.id!==e)throw new xE("ping doesn't match our id");this.activePing.resolve()}handleGoAway(e){this.log?.trace("received GoAway reason=%s",Rr[e]??"unknown"),this.remoteGoAway=e;for(const t of this._streams.values())t.reset();this._closeMuxer()}async handleStreamMessage(e,t){const{streamID:n,flag:i,type:s}=e;(i&ze.SYN)===ze.SYN&&this.incomingStream(n);const o=this._streams.get(n);if(o===void 0){if(s===Ze.Data){if(this.log?.("discarding data for stream id=%s",n),t===void 0)throw new Error("unreachable");await t()}else this.log?.trace("frame for missing stream id=%s",n);return}switch(s){case Ze.WindowUpdate:{o.handleWindowUpdate(e);return}case Ze.Data:{if(t===void 0)throw new Error("unreachable");await o.handleData(e,t);return}default:throw new Error("unreachable")}}incomingStream(e){if(this.client!==(e%2===0))throw new q("Both endpoints are clients");if(this._streams.has(e))return;if(this.log?.trace("new incoming stream id=%s",e),this.localGoAway!==void 0){this.sendFrame({type:Ze.WindowUpdate,flag:ze.RST,streamID:e,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){this.log?.("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:Ze.WindowUpdate,flag:ze.RST,streamID:e,length:0});return}const t=this._newStream(e,void 0,mr.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(e,t),this.onIncomingStream?.(t)}sendFrame(e,t){if(this.log?.trace("sending frame %o",e),e.type===Ze.Data){if(t===void 0)throw new gs("Invalid frame");this.source.push(new ye(_w(e),t))}else this.source.push(_w(e))}sendPing(e,t=ze.SYN){t===ze.SYN?this.log?.trace("sending ping request pingId=%s",e):this.log?.trace("sending ping response pingId=%s",e),this.sendFrame({type:Ze.Ping,flag:t,streamID:0,length:e})}sendGoAway(e=Rr.NormalTermination){this.log?.("sending GoAway reason=%s",Rr[e]),this.localGoAway=e,this.sendFrame({type:Ze.GoAway,flag:0,streamID:0,length:e})}}function tR(r){return r!=null&&typeof r.then=="function"}function rR(r={}){return e=>new ZP(e,r)}var ql;(function(r){let e;r.codec=()=>(e==null&&(e=Oe((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&t.payload.byteLength>0&&(n.uint32(26),n.bytes(t.payload)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={publicKey:Ie(0),payloadType:Ie(0),payload:Ie(0),signature:Ie(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.publicKey=t.bytes();break}case 2:{s.payloadType=t.bytes();break}case 3:{s.payload=t.bytes();break}case 5:{s.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Re(t,r.codec()),r.decode=(t,n)=>Pe(t,r.codec(),n)})(ql||(ql={}));class nR extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}}class Lr{static createFromProtobuf=e=>{const t=ql.decode(e),n=Gn(t.publicKey);return new Lr({publicKey:n,payloadType:t.payloadType,payload:t.payload,signature:t.signature})};static seal=async(e,t,n)=>{if(t==null)throw new Error("Missing private key");const i=e.domain,s=e.codec,o=e.marshal(),a=Iw(i,s,o),c=await t.sign(a.subarray(),n);return new Lr({publicKey:t.publicKey,payloadType:s,payload:o,signature:c})};static openAndCertify=async(e,t,n)=>{const i=Lr.createFromProtobuf(e);if(!await i.validate(t,n))throw new nR("Envelope signature is not valid for the given domain");return i};publicKey;payloadType;payload;signature;marshaled;constructor(e){const{publicKey:t,payloadType:n,payload:i,signature:s}=e;this.publicKey=t,this.payloadType=n,this.payload=i,this.signature=s}marshal(){return this.marshaled==null&&(this.marshaled=ql.encode({publicKey:on(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return e==null?!1:Je(this.marshal(),e.marshal())}async validate(e,t){const n=Iw(e,this.payloadType,this.payload);return this.publicKey.verify(n.subarray(),this.signature,t)}}const Iw=(r,e,t)=>{const n=Z(r),i=_s(n.byteLength),s=_s(e.length),o=_s(t.length);return new ye(i,n,s,e,o,t)};function iR(r,e){const t=(n,i)=>n.toString().localeCompare(i.toString());return r.length!==e.length?!1:(e.sort(t),r.sort(t).every((n,i)=>e[i].equals(n)))}class tr extends Error{static name="InvalidMultiaddrError";name="InvalidMultiaddrError"}class ba extends Error{static name="ValidationError";name="ValidationError"}class sR extends Error{static name="InvalidParametersError";name="InvalidParametersError"}class oR extends Error{static name="UnknownProtocolError";name="UnknownProtocolError"}class aR{index=0;input="";new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,n=e();return n===void 0&&(this.index=t),n}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{const t=this.readChar();if(t===e)return t})}readSeparator(e,t,n){return this.readAtomically(()=>{if(!(t>0&&this.readGivenChar(e)===void 0))return n()})}readNumber(e,t,n,i){return this.readAtomically(()=>{let s=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",l=2**(8*i)-1;for(;;){const u=this.readAtomically(()=>{const d=this.readChar();if(d===void 0)return;const h=Number.parseInt(d,e);if(!Number.isNaN(h))return h});if(u===void 0)break;if(s*=e,s+=u,s>l||(o+=1,t!==void 0&&o>t))return}if(o!==0)return!n&&c&&o>1?void 0:s})}readIPv4Addr(){return this.readAtomically(()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const n=this.readSeparator(".",t,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;e[t]=n}return e})}readIPv6Addr(){const e=t=>{for(let n=0;n<t.length/2;n++){const i=n*2;if(n<t.length-3){const o=this.readSeparator(":",n,()=>this.readIPv4Addr());if(o!==void 0)return t[i]=o[0],t[i+1]=o[1],t[i+2]=o[2],t[i+3]=o[3],[i+4,!0]}const s=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(s===void 0)return[i,!1];t[i]=s>>8,t[i+1]=s&255}return[t.length,!1]};return this.readAtomically(()=>{const t=new Uint8Array(16),[n,i]=e(t);if(n===16)return t;if(i||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const s=new Uint8Array(14),o=16-(n+2),[a]=e(s.subarray(0,o));return t.set(s.subarray(0,a),16-a),t})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const PE=45,cR=15,Fs=new aR;function RE(r){if(!(r.length>cR))return Fs.new(r).parseWith(()=>Fs.readIPv4Addr())}function OE(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>PE))return Fs.new(r).parseWith(()=>Fs.readIPv6Addr())}function Df(r,e=!1){if(r.includes("%")&&(r=r.split("%")[0]),r.length>PE)return;const t=Fs.new(r).parseWith(()=>Fs.readIPAddr());if(t)return e&&t.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,t[0],t[1],t[2],t[3]]):t}function Ni(r){return!!RE(r)}function Jg(r){return!!OE(r)}const Us=4,Lf=6,Mf=273,lR=33,Mr=41,mo=42,uR=43,Xg=53,Zg=54,td=55,em=56,dR=132,hR=301,fR=302,pR=400,BE=421,gR=444,mR=445,yR=446,wR=447,bR=448,vR=449,SR=454,ER=460,AR=461,xR=465,_R=466,CR=480,IR=481,kR=443,TR=477,PR=478,RR=479,OR=277,BR=275,NR=276,DR=280,LR=281,NE=290,MR=777;function kw(r){return e=>ne(e,r)}function Tw(r){return e=>Z(e,r)}function jo(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function ms(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(e)}function FR(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=Z(e[0],"base32"),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=ms(n);return qr([t,i],t.length+i.length)}function UR(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=Vn.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=ms(n);return qr([t,i],t.length+i.length)}function Pw(r){const e=r.subarray(0,r.length-2),t=r.subarray(r.length-2),n=ne(e,"base32"),i=jo(t);return`${n}:${i}`}const DE=function(r){r=r.toString().trim();const e=new Uint8Array(4);return r.split(/\./g).forEach((t,n)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new tr("Invalid byte value in IP address");e[n]=i}),e},$R=function(r){let e=0;r=r.toString().trim();const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const s=Ni(t[n]);let o;s&&(o=DE(t[n]),t[n]=ne(o.subarray(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,ne(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const s=[n,1];for(n=9-t.length;n>0;n--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(n=0;n<t.length;n++){t[n]===""&&(t[n]="0");const s=parseInt(t[n],16);if(isNaN(s)||s<0||s>65535)throw new tr("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},qR=function(r){if(r.byteLength!==4)throw new tr("IPv4 address was incorrect length");const e=[];for(let t=0;t<r.byteLength;t++)e.push(r[t]);return e.join(".")},KR=function(r){if(r.byteLength!==16)throw new tr("IPv6 address was incorrect length");const e=[];for(let n=0;n<r.byteLength;n+=2){const i=r[n],s=r[n+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const n=new URL(`http://[${t}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new tr(`Invalid IPv6 address "${t}"`)}};function VR(r){try{const e=new URL(`http://[${r}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new tr(`Invalid IPv6 address "${r}"`)}}const Sh=Object.values(_l).map(r=>r.decoder),zR=function(){let r=Sh[0].or(Sh[1]);return Sh.slice(2).forEach(e=>r=r.or(e)),r}();function jR(r){return zR.decode(r)}function HR(r){return e=>r.encoder.encode(e)}function WR(r){if(parseInt(r).toString()!==r)throw new ba("Value must be an integer")}function GR(r){if(r<0)throw new ba("Value must be a positive integer, or zero")}function YR(r){return e=>{if(e>r)throw new ba(`Value must be smaller than or equal to ${r}`)}}function QR(...r){return e=>{for(const t of r)t(e)}}const Dc=QR(WR,GR,YR(65535)),mt=-1;let JR=class{protocolsByCode=new Map;protocolsByName=new Map;getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new oR(`Protocol ${e} was unknown`);return t}addProtocol(e){this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),e.aliases?.forEach(t=>{this.protocolsByName.set(t,e)})}removeProtocol(e){const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),t.aliases?.forEach(n=>{this.protocolsByName.delete(n)}))}};const Fr=new JR,XR=[{code:Us,name:"ip4",size:32,valueToBytes:DE,bytesToValue:qR,validate:r=>{if(!Ni(r))throw new ba(`Invalid IPv4 address "${r}"`)}},{code:Lf,name:"tcp",size:16,valueToBytes:ms,bytesToValue:jo,validate:Dc},{code:Mf,name:"udp",size:16,valueToBytes:ms,bytesToValue:jo,validate:Dc},{code:lR,name:"dccp",size:16,valueToBytes:ms,bytesToValue:jo,validate:Dc},{code:Mr,name:"ip6",size:128,valueToBytes:$R,bytesToValue:KR,stringToValue:VR,validate:r=>{if(!Jg(r))throw new ba(`Invalid IPv6 address "${r}"`)}},{code:mo,name:"ip6zone",size:mt},{code:uR,name:"ipcidr",size:8,bytesToValue:kw("base10"),valueToBytes:Tw("base10")},{code:Xg,name:"dns",size:mt,resolvable:!0},{code:Zg,name:"dns4",size:mt,resolvable:!0},{code:td,name:"dns6",size:mt,resolvable:!0},{code:em,name:"dnsaddr",size:mt,resolvable:!0},{code:dR,name:"sctp",size:16,valueToBytes:ms,bytesToValue:jo,validate:Dc},{code:hR,name:"udt"},{code:fR,name:"utp"},{code:pR,name:"unix",size:mt,path:!0,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:BE,name:"p2p",aliases:["ipfs"],size:mt,bytesToValue:kw("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?Tw("base58btc")(r):Be.parse(r).multihash.bytes},{code:gR,name:"onion",size:96,bytesToValue:Pw,valueToBytes:FR},{code:mR,name:"onion3",size:296,bytesToValue:Pw,valueToBytes:UR},{code:yR,name:"garlic64",size:mt},{code:wR,name:"garlic32",size:mt},{code:bR,name:"tls"},{code:vR,name:"sni",size:mt},{code:SR,name:"noise"},{code:ER,name:"quic"},{code:AR,name:"quic-v1"},{code:xR,name:"webtransport"},{code:_R,name:"certhash",size:mt,bytesToValue:HR(za),valueToBytes:jR},{code:CR,name:"http"},{code:IR,name:"http-path",size:mt,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:kR,name:"https"},{code:TR,name:"ws"},{code:PR,name:"wss"},{code:RR,name:"p2p-websocket-star"},{code:OR,name:"p2p-stardust"},{code:BR,name:"p2p-webrtc-star"},{code:NR,name:"p2p-webrtc-direct"},{code:DR,name:"webrtc-direct"},{code:LR,name:"webrtc"},{code:NE,name:"p2p-circuit"},{code:MR,name:"memory",size:mt}];XR.forEach(r=>{Fr.addProtocol(r)});function ZR(r){const e=[];let t=0;for(;t<r.length;){const n=Zu(r,t),i=Fr.getProtocol(n),s=Et(n),o=nO(i,r,t+s);let a=0;o>0&&i.size===mt&&(a=Et(o));const c=s+a+o,l={code:n,name:i.name,bytes:r.subarray(t,t+c)};if(o>0){const u=t+s+a,d=r.subarray(u,u+o);l.value=i.bytesToValue?.(d)??ne(d)}e.push(l),t+=c}return e}function eO(r){let e=0;const t=[];for(const n of r){if(n.bytes==null){const i=Fr.getProtocol(n.code),s=Et(n.code);let o,a=0,c=0;n.value!=null&&(o=i.valueToBytes?.(n.value)??Z(n.value),a=o.byteLength,i.size===mt&&(c=Et(a)));const l=new Uint8Array(s+c+a);let u=0;Pl(n.code,l,u),u+=s,o!=null&&(i.size===mt&&(Pl(a,l,u),u+=c),l.set(o,u)),n.bytes=l}t.push(n.bytes),e+=n.bytes.byteLength}return qr(t,e)}function tO(r){if(r.charAt(0)!=="/")throw new tr('String multiaddr must start with "/"');const e=[];let t="protocol",n="",i="";for(let s=1;s<r.length;s++){const o=r.charAt(s);o!=="/"&&(t==="protocol"?i+=r.charAt(s):n+=r.charAt(s));const a=s===r.length-1;if(o==="/"||a){const c=Fr.getProtocol(i);if(t==="protocol"){if(c.size==null||c.size===0){e.push({code:c.code,name:c.name}),n="",i="",t="protocol";continue}else if(a)throw new tr(`Component ${i} was missing value`);t="value"}else if(t==="value"){const l={code:c.code,name:c.name};if(c.size!=null&&c.size!==0){if(n==="")throw new tr(`Component ${i} was missing value`);l.value=c.stringToValue?.(n)??n}e.push(l),n="",i="",t="protocol"}}}if(i!==""&&n!=="")throw new tr("Incomplete multiaddr");return e}function rO(r){return`/${r.flatMap(e=>{if(e.value==null)return e.name;const t=Fr.getProtocol(e.code);if(t==null)throw new tr(`Unknown protocol code ${e.code}`);return[e.name,t.valueToString?.(e.value)??e.value]}).join("/")}`}function nO(r,e,t){return r.size==null||r.size===0?0:r.size>0?r.size/8:Zu(e,t)}const iO=Symbol.for("nodejs.util.inspect.custom"),LE=Symbol.for("@multiformats/multiaddr"),sO=[Xg,Zg,td,em];class oO extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}}function aO(r){if(r==null&&(r="/"),rd(r))return r.getComponents();if(r instanceof Uint8Array)return ZR(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),tO(r);if(Array.isArray(r))return r;throw new tr("Must be a string, Uint8Array, Component[], or another Multiaddr")}class ys{[LE]=!0;#e;#r;#t;constructor(e="/",t={}){this.#e=aO(e),t.validate!==!1&&cO(this)}get bytes(){return this.#t==null&&(this.#t=eO(this.#e)),this.#t}toString(){return this.#r==null&&(this.#r=rO(this.#e)),this.#r}toJSON(){return this.toString()}toOptions(){let e,t,n,i,s="";for(const{code:a,name:c,value:l}of this.#e)a===mo&&(s=`%${l??""}`),sO.includes(a)&&(t="tcp",i=443,n=`${l??""}${s}`,e=a===td?6:4),(a===Lf||a===Mf)&&(t=c==="tcp"?"tcp":"udp",i=parseInt(l??"")),(a===Us||a===Mr)&&(t="tcp",n=`${l??""}${s}`,e=a===Mr?6:4);if(e==null||t==null||n==null||i==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:n,transport:t,port:i}}getComponents(){return[...this.#e]}protos(){return this.#e.map(({code:e,value:t})=>{const n=Fr.getProtocol(e);return{code:e,size:n.size??0,name:n.name,resolvable:!!n.resolvable,path:!!n.path}})}protoCodes(){return this.#e.map(({code:e})=>e)}protoNames(){return this.#e.map(({name:e})=>e)}tuples(){return this.#e.map(({code:e,value:t})=>{if(t==null)return[e];const n=Fr.getProtocol(e),i=[e];return t!=null&&i.push(n.valueToBytes?.(t)??Z(t)),i})}stringTuples(){return this.#e.map(({code:e,value:t})=>t==null?[e]:[e,t])}encapsulate(e){const t=new ys(e);return new ys([...this.#e,...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),n=this.toString(),i=n.lastIndexOf(t);if(i<0)throw new sR(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new ys(n.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let n=this.#e.length-1;n>-1;n--)if(this.#e[n].code===e){t=n;break}return new ys(this.#e.slice(0,t),{validate:!1})}getPeerId(){try{let e=[];this.#e.forEach(({code:n,value:i})=>{n===BE&&e.push([n,i]),n===NE&&(e=[])});const t=e.pop();if(t?.[1]!=null){const n=t[1];return n[0]==="Q"||n[0]==="1"?ne(Qe.decode(`z${n}`),"base58btc"):ne(Be.parse(n).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){for(const e of this.#e)if(Fr.getProtocol(e.code).path)return e.value??null;return null}equals(e){return Je(this.bytes,e.bytes)}async resolve(e){const t=this.protos().find(s=>s.resolvable);if(t==null)return[this];const n=tm.get(t.name);if(n==null)throw new oO(`no available resolver for ${t.name}`);return(await n(this,e)).map(s=>de(s))}nodeAddress(){const e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(){return!(this.#e.length!==2||this.#e[0].code!==Us&&this.#e[0].code!==Mr||this.#e[1].code!==Lf&&this.#e[1].code!==Mf)}[iO](){return`Multiaddr(${this.toString()})`}}function cO(r){r.getComponents().forEach(e=>{const t=Fr.getProtocol(e.code);e.value!=null&&t.validate?.(e.value)})}function lO(r,e,t){let n=0;for(const i of r)if(!(n<e)){if(n>t)break;if(i!==255)return!1;n++}return!0}function uO(r,e,t,n){let i=0;for(const s of r)if(!(i<t)){if(i>n)break;if(s!==e[i])return!1;i++}return!0}function dO(r){switch(r.length){case va:return r.join(".");case Sa:{const e=[];for(let t=0;t<r.length;t++)t%2===0&&e.push(r[t].toString(16).padStart(2,"0")+r[t+1].toString(16).padStart(2,"0"));return e.join(":")}default:throw new Error("Invalid ip length")}}function hO(r){let e=0;for(let[t,n]of r.entries()){if(n===255){e+=8;continue}for(;(n&128)!=0;)e++,n=n<<1;if((n&128)!=0)return-1;for(let i=t+1;i<r.length;i++)if(r[i]!=0)return-1;break}return e}function fO(r){let e="0x";for(const t of r)e+=(t>>4).toString(16)+(t&15).toString(16);return e}const va=4,Sa=16,pO=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function ME(r,e){e.length===Sa&&r.length===va&&lO(e,0,11)&&(e=e.slice(12)),e.length===va&&r.length===Sa&&uO(r,pO,0,11)&&(r=r.slice(12));const t=r.length;if(t!=e.length)throw new Error("Failed to mask ip");const n=new Uint8Array(t);for(let i=0;i<t;i++)n[i]=r[i]&e[i];return n}function gO(r,e){if(typeof e=="string"&&(e=Df(e)),e==null)throw new Error("Invalid ip");if(e.length!==r.network.length)return!1;for(let t=0;t<e.length;t++)if((r.network[t]&r.mask[t])!==(e[t]&r.mask[t]))return!1;return!0}function mO(r){const[e,t]=r.split("/");if(!e||!t)throw new Error("Failed to parse given CIDR: "+r);let n=va,i=RE(e);if(i==null&&(n=Sa,i=OE(e),i==null))throw new Error("Failed to parse given CIDR: "+r);const s=parseInt(t,10);if(Number.isNaN(s)||String(s).length!==t.length||s<0||s>n*8)throw new Error("Failed to parse given CIDR: "+r);const o=FE(s,8*n);return{network:ME(i,o),mask:o}}function FE(r,e){if(e!==8*va&&e!==8*Sa)throw new Error("Invalid CIDR mask");if(r<0||r>e)throw new Error("Invalid CIDR mask");const t=e/8,n=new Uint8Array(t);for(let i=0;i<t;i++){if(r>=8){n[i]=255,r-=8;continue}n[i]=255-(255>>r),r=0}return n}class UE{constructor(e,t){if(t==null)({network:this.network,mask:this.mask}=mO(e));else{const n=Df(e);if(n==null)throw new Error("Failed to parse network");t=String(t);const i=parseInt(t,10);if(Number.isNaN(i)||String(i).length!==t.length||i<0||i>n.length*8){const s=Df(t);if(s==null)throw new Error("Failed to parse mask");this.mask=s}else this.mask=FE(i,8*n.length);this.network=ME(n,this.mask)}}contains(e){return gO({network:this.network,mask:this.mask},e)}toString(){const e=hO(this.mask),t=e!==-1?String(e):fO(this.mask);return dO(this.network)+"/"+t}}function yO(r,e){return new UE(r).contains(e)}function wO(r){let e,t;if(r.getComponents().forEach(n=>{(n.name==="ip4"||n.name==="ip6")&&(t=n.value),n.name==="ipcidr"&&(e=n.value)}),e==null||t==null)throw new Error("Invalid multiaddr");return new UE(t,e)}const tm=new Map;function rd(r){return!!r?.[LE]}function de(r){return new ys(r)}function St(r){const e=Fr.getProtocol(r);return{code:e.code,size:e.size??0,name:e.name,resolvable:!!e.resolvable,path:!!e.path}}const bO="libp2p-peer-record",vO=Uint8Array.from([3,1]);var Kl;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=Oe((i,s,o={})=>{o.lengthDelimited!==!1&&s.fork(),i.multiaddr!=null&&i.multiaddr.byteLength>0&&(s.uint32(10),s.bytes(i.multiaddr)),o.lengthDelimited!==!1&&s.ldelim()},(i,s,o={})=>{const a={multiaddr:Ie(0)},c=s==null?i.len:i.pos+s;for(;i.pos<c;){const l=i.uint32();switch(l>>>3){case 1:{a.multiaddr=i.bytes();break}default:{i.skipType(l&7);break}}}return a})),n),t.encode=i=>Re(i,t.codec()),t.decode=(i,s)=>Pe(i,t.codec(),s)})(r.AddressInfo||(r.AddressInfo={}));let e;r.codec=()=>(e==null&&(e=Oe((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.peerId!=null&&t.peerId.byteLength>0&&(n.uint32(10),n.bytes(t.peerId)),t.seq!=null&&t.seq!==0n&&(n.uint32(16),n.uint64(t.seq)),t.addresses!=null)for(const s of t.addresses)n.uint32(26),r.AddressInfo.codec().encode(s,n);i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={peerId:Ie(0),seq:0n,addresses:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.peerId=t.bytes();break}case 2:{s.seq=t.uint64();break}case 3:{if(i.limits?.addresses!=null&&s.addresses.length===i.limits.addresses)throw new Ar('Decode error - map field "addresses" had too many elements');s.addresses.push(r.AddressInfo.codec().decode(t,t.uint32(),{limits:i.limits?.addresses$}));break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Re(t,r.codec()),r.decode=(t,n)=>Pe(t,r.codec(),n)})(Kl||(Kl={}));class Yt{static createFromProtobuf=e=>{const t=Kl.decode(e),n=po(Ji(t.peerId)),i=(t.addresses??[]).map(o=>de(o.multiaddr)),s=t.seq;return new Yt({peerId:n,multiaddrs:i,seqNumber:s})};static DOMAIN=bO;static CODEC=vO;peerId;multiaddrs;seqNumber;domain=Yt.DOMAIN;codec=Yt.CODEC;marshaled;constructor(e){const{peerId:t,multiaddrs:n,seqNumber:i}=e;this.peerId=t,this.multiaddrs=n??[],this.seqNumber=i??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=Kl.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(e=>({multiaddr:e.bytes}))})),this.marshaled}equals(e){return!(!(e instanceof Yt)||!this.peerId.equals(e.peerId)||this.seqNumber!==e.seqNumber||!iR(this.multiaddrs,e.multiaddrs))}}function Qt(r,e){const t=Ls(r,e),n={read:async(i,s)=>{const o=await t.read(s);return i.decode(o)},write:async(i,s,o)=>{await t.write(s.encode(i),o)},writeV:async(i,s,o)=>{await t.writeV(i.map(a=>s.encode(a)),o)},pb:i=>({read:async s=>n.read(i,s),write:async(s,o)=>n.write(s,i,o),writeV:async(s,o)=>n.writeV(s,i,o),unwrap:()=>n}),unwrap:()=>t.unwrap()};return n}const SO=290,EO=1,$E=2e3,AO=100,Lc=`${xg}-circuit-relay`;BigInt(1<<17);const Vl="/libp2p/circuit/relay/0.2.0/hop",Rw="/libp2p/circuit/relay/0.2.0/stop",Ow=300,xO=4096,_O=.001;var $s;(function(r){(function(n){n.RESERVE="RESERVE",n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let e;(function(n){n[n.RESERVE=0]="RESERVE",n[n.CONNECT=1]="CONNECT",n[n.STATUS=2]="STATUS"})(e||(e={})),function(n){n.codec=()=>hn(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=Oe((n,i,s={})=>{s.lengthDelimited!==!1&&i.fork(),n.type!=null&&(i.uint32(8),r.Type.codec().encode(n.type,i)),n.peer!=null&&(i.uint32(18),qs.codec().encode(n.peer,i)),n.reservation!=null&&(i.uint32(26),zl.codec().encode(n.reservation,i)),n.limit!=null&&(i.uint32(34),Ks.codec().encode(n.limit,i)),n.status!=null&&(i.uint32(40),kt.codec().encode(n.status,i)),s.lengthDelimited!==!1&&i.ldelim()},(n,i,s={})=>{const o={},a=i==null?n.len:n.pos+i;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=qs.codec().decode(n,n.uint32(),{limits:s.limits?.peer});break}case 3:{o.reservation=zl.codec().decode(n,n.uint32(),{limits:s.limits?.reservation});break}case 4:{o.limit=Ks.codec().decode(n,n.uint32(),{limits:s.limits?.limit});break}case 5:{o.status=kt.codec().decode(n);break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>Re(n,r.codec()),r.decode=(n,i)=>Pe(n,r.codec(),i)})($s||($s={}));var Xr;(function(r){(function(n){n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let e;(function(n){n[n.CONNECT=0]="CONNECT",n[n.STATUS=1]="STATUS"})(e||(e={})),function(n){n.codec=()=>hn(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=Oe((n,i,s={})=>{s.lengthDelimited!==!1&&i.fork(),n.type!=null&&(i.uint32(8),r.Type.codec().encode(n.type,i)),n.peer!=null&&(i.uint32(18),qs.codec().encode(n.peer,i)),n.limit!=null&&(i.uint32(26),Ks.codec().encode(n.limit,i)),n.status!=null&&(i.uint32(32),kt.codec().encode(n.status,i)),s.lengthDelimited!==!1&&i.ldelim()},(n,i,s={})=>{const o={},a=i==null?n.len:n.pos+i;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=qs.codec().decode(n,n.uint32(),{limits:s.limits?.peer});break}case 3:{o.limit=Ks.codec().decode(n,n.uint32(),{limits:s.limits?.limit});break}case 4:{o.status=kt.codec().decode(n);break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>Re(n,r.codec()),r.decode=(n,i)=>Pe(n,r.codec(),i)})(Xr||(Xr={}));var qs;(function(r){let e;r.codec=()=>(e==null&&(e=Oe((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.id!=null&&t.id.byteLength>0&&(n.uint32(10),n.bytes(t.id)),t.addrs!=null)for(const s of t.addrs)n.uint32(18),n.bytes(s);i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={id:Ie(0),addrs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.id=t.bytes();break}case 2:{if(i.limits?.addrs!=null&&s.addrs.length===i.limits.addrs)throw new Ar('Decode error - map field "addrs" had too many elements');s.addrs.push(t.bytes());break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Re(t,r.codec()),r.decode=(t,n)=>Pe(t,r.codec(),n)})(qs||(qs={}));var zl;(function(r){let e;r.codec=()=>(e==null&&(e=Oe((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.expire!=null&&t.expire!==0n&&(n.uint32(8),n.uint64(t.expire)),t.addrs!=null)for(const s of t.addrs)n.uint32(18),n.bytes(s);t.voucher!=null&&(n.uint32(26),Hl.codec().encode(t.voucher,n)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={expire:0n,addrs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.expire=t.uint64();break}case 2:{if(i.limits?.addrs!=null&&s.addrs.length===i.limits.addrs)throw new Ar('Decode error - map field "addrs" had too many elements');s.addrs.push(t.bytes());break}case 3:{s.voucher=Hl.codec().decode(t,t.uint32(),{limits:i.limits?.voucher});break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Re(t,r.codec()),r.decode=(t,n)=>Pe(t,r.codec(),n)})(zl||(zl={}));var Ks;(function(r){let e;r.codec=()=>(e==null&&(e=Oe((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.duration!=null&&(n.uint32(8),n.uint32(t.duration)),t.data!=null&&(n.uint32(16),n.uint64(t.data)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.duration=t.uint32();break}case 2:{s.data=t.uint64();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Re(t,r.codec()),r.decode=(t,n)=>Pe(t,r.codec(),n)})(Ks||(Ks={}));var kt;(function(r){r.UNUSED="UNUSED",r.OK="OK",r.RESERVATION_REFUSED="RESERVATION_REFUSED",r.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",r.PERMISSION_DENIED="PERMISSION_DENIED",r.CONNECTION_FAILED="CONNECTION_FAILED",r.NO_RESERVATION="NO_RESERVATION",r.MALFORMED_MESSAGE="MALFORMED_MESSAGE",r.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(kt||(kt={}));var Ff;(function(r){r[r.UNUSED=0]="UNUSED",r[r.OK=100]="OK",r[r.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",r[r.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",r[r.PERMISSION_DENIED=202]="PERMISSION_DENIED",r[r.CONNECTION_FAILED=203]="CONNECTION_FAILED",r[r.NO_RESERVATION=204]="NO_RESERVATION",r[r.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",r[r.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(Ff||(Ff={}));(function(r){r.codec=()=>hn(Ff)})(kt||(kt={}));var jl;(function(r){let e;r.codec=()=>(e==null&&(e=Oe((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.relay!=null&&t.relay.byteLength>0&&(n.uint32(10),n.bytes(t.relay)),t.peer!=null&&t.peer.byteLength>0&&(n.uint32(18),n.bytes(t.peer)),t.expiration!=null&&t.expiration!==0n&&(n.uint32(24),n.uint64(t.expiration)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={relay:Ie(0),peer:Ie(0),expiration:0n},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.relay=t.bytes();break}case 2:{s.peer=t.bytes();break}case 3:{s.expiration=t.uint64();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Re(t,r.codec()),r.decode=(t,n)=>Pe(t,r.codec(),n)})(jl||(jl={}));var Hl;(function(r){let e;r.codec=()=>(e==null&&(e=Oe((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&(n.uint32(26),jl.codec().encode(t.payload,n)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={publicKey:Ie(0),payloadType:Ie(0),signature:Ie(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.publicKey=t.bytes();break}case 2:{s.payloadType=t.bytes();break}case 3:{s.payload=jl.codec().decode(t,t.uint32(),{limits:i.limits?.payload});break}case 5:{s.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Re(t,r.codec()),r.decode=(t,n)=>Pe(t,r.codec(),n)})(Hl||(Hl={}));const CO=r=>r.toString().split("/").slice(1),Xa=r=>({match:e=>e.length<1?!1:r(e[0])?e.slice(1):!1,pattern:"fn"}),he=r=>({match:e=>Xa(t=>t===r).match(e),pattern:r}),yo=()=>({match:r=>Xa(e=>typeof e=="string").match(r),pattern:"{string}"}),Ea=()=>({match:r=>Xa(e=>!isNaN(parseInt(e))).match(r),pattern:"{number}"}),Te=()=>({match:r=>{if(r.length<2||r[0]!=="p2p"&&r[0]!=="ipfs")return!1;if(r[1].startsWith("Q")||r[1].startsWith("1"))try{Qe.decode(`z${r[1]}`)}catch{return!1}else return!1;return r.slice(2)},pattern:"/p2p/{peerid}"}),Wl=()=>({match:r=>{if(r.length<2||r[0]!=="certhash")return!1;try{za.decode(r[1])}catch{return!1}return r.slice(2)},pattern:"/certhash/{certhash}"}),_e=r=>({match:e=>{const t=r.match(e);return t===!1?e:t},pattern:`optional(${r.pattern})`}),Rt=(...r)=>({match:e=>{let t;for(const n of r){const i=n.match(e);i!==!1&&(t==null||i.length<t.length)&&(t=i)}return t??!1},pattern:`or(${r.map(e=>e.pattern).join(", ")})`}),me=(...r)=>({match:e=>{for(const t of r){const n=t.match(e);if(n===!1)return!1;e=n}return e},pattern:`and(${r.map(e=>e.pattern).join(", ")})`});function Ne(...r){function e(i){let s=CO(i);for(const o of r){const a=o.match(s);if(a===!1)return!1;s=a}return s}function t(i){return e(i)!==!1}function n(i){const s=e(i);return s===!1?!1:s.length===0}return{matchers:r,matches:t,exactMatch:n}}const IO=Te(),kO=Ne(IO),nd=me(he("dns4"),yo()),id=me(he("dns6"),yo()),sd=me(he("dnsaddr"),yo()),rm=me(he("dns"),yo());Ne(nd,_e(Te()));Ne(id,_e(Te()));Ne(sd,_e(Te()));const TO=Ne(Rt(rm,sd,nd,id),_e(Te())),qE=me(he("ip4"),Xa(Ni)),KE=me(he("ip6"),Xa(Jg)),nm=Rt(qE,KE),an=Rt(nm,rm,nd,id,sd),PO=Ne(Rt(nm,me(Rt(rm,sd,nd,id),_e(Te())))),Bw=Ne(qE),Nw=Ne(KE),RO=Ne(nm),im=me(an,he("tcp"),Ea()),Za=me(an,he("udp"),Ea()),Gl=Ne(me(im,_e(Te())));Ne(Za);const sm=me(Za,he("quic"),_e(Te())),od=me(Za,he("quic-v1"),_e(Te())),OO=Rt(sm,od);Ne(sm);const BO=Ne(od),Uf=Rt(an,im,Za,sm,od),VE=Rt(me(Uf,he("ws"),_e(Te()))),Aa=Ne(VE),zE=Rt(me(Uf,he("wss"),_e(Te())),me(Uf,he("tls"),_e(me(he("sni"),yo())),he("ws"),_e(Te()))),Yl=Ne(zE),jE=me(Za,he("webrtc-direct"),_e(Wl()),_e(Wl()),_e(Te())),$f=Ne(jE),HE=me(od,he("webtransport"),_e(Wl()),_e(Wl()),_e(Te())),Dw=Ne(HE),Ql=Rt(VE,zE,me(im,_e(Te())),me(OO,_e(Te())),me(an,_e(Te())),jE,HE,Te()),WE=Ne(Ql),NO=me(Ql,he("p2p-circuit"),Te()),Yn=Ne(NO),DO=Rt(me(Ql,he("p2p-circuit"),he("webrtc"),_e(Te())),me(Ql,he("webrtc"),_e(Te())),me(he("webrtc"),_e(Te()))),Jl=Ne(DO),LO=Rt(me(an,he("tcp"),Ea(),he("http"),_e(Te())),me(an,he("http"),_e(Te())));Ne(LO);const MO=Rt(me(an,he("tcp"),Rt(me(he("443"),he("http")),me(Ea(),he("https")),me(Ea(),he("tls"),he("http"))),_e(Te())),me(an,he("tls"),he("http"),_e(Te())),me(an,he("https"),_e(Te())));Ne(MO);const FO=Rt(me(he("memory"),yo(),_e(Te())));Ne(FO);function Vr(r){const e=new globalThis.AbortController;function t(){e.abort();for(const s of r)s?.removeEventListener!=null&&s.removeEventListener("abort",t)}for(const s of r){if(s?.aborted===!0){t();break}s?.addEventListener!=null&&s.addEventListener("abort",t)}function n(){for(const s of r)s?.removeEventListener!=null&&s.removeEventListener("abort",t)}const i=e.signal;return i.clear=n,i}class Lw extends Error{static name="HadEnoughRelaysError";name="HadEnoughRelaysError"}class UO extends Error{static name="DoubleRelayError";name="DoubleRelayError"}class $O extends Error{static name="RelayQueueFullError";name="RelayQueueFullError"}function Mw(r){const e=r*BigInt(1e3),t=new Date().getTime();return Number(e-BigInt(t))}class Fw{expires;bytes;constructor(e){e?.duration!=null&&e?.duration!==0&&(this.expires=Date.now()+e.duration*1e3),this.bytes=e?.data,this.bytes===0n&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(e){this.bytes!=null&&(this.bytes-=BigInt(e.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(this.expires==null&&this.bytes==null)return;const e={};if(this.bytes!=null){const t=this;Object.defineProperty(e,"bytes",{get(){return t.bytes}})}if(this.expires!=null){const t=this;Object.defineProperty(e,"seconds",{get(){return Math.round(((t.expires??0)-Date.now())/1e3)}})}return e}}const GE=Ne(me(WE.matchers[0],he("p2p-circuit"))),YE=Ne(he("p2p-circuit"));function oa(r,e){const t={[Symbol.iterator]:()=>t,next:()=>{const n=r.next(),i=n.value;return n.done===!0||i==null?{done:!0,value:void 0}:{done:!1,value:e(i)}}};return t}function Eh(r){const e=Ji(Qe.decode(`z${r}`));return po(e)}class wo{map;constructor(e){if(this.map=new Map,e!=null)for(const[t,n]of e.entries())this.map.set(t.toString(),{key:t,value:n})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return oa(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach((t,n)=>{e(t.value,t.key,this)})}get(e){return this.map.get(e.toString())?.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return oa(this.map.values(),e=>e.key)}values(){return oa(this.map.values(),e=>e.value)}get size(){return this.map.size}}class Ii{set;constructor(e){if(this.set=new Set,e!=null)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return oa(this.set.entries(),e=>{const t=Eh(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const n=Eh(t);e(n,n,this)})}has(e){return this.set.has(e.toString())}values(){return oa(this.set.values(),e=>Eh(e))}intersection(e){const t=new Ii;for(const n of e)this.has(n)&&t.add(n);return t}difference(e){const t=new Ii;for(const n of this)e.has(n)||t.add(n);return t}union(e){const t=new Ii;for(const n of e)t.add(n);for(const n of this)t.add(n);return t}}function qO(){return new Ii}function QE(r,e,t,n){Gu(r);const i=sI({dkLen:32,asyncTick:10},n),{c:s,dkLen:o,asyncTick:a}=i;if(xi(s),xi(o),xi(a),s<1)throw new Error("iterations (c) should be >= 1");const c=Hy(e),l=Hy(t),u=new Uint8Array(o),d=Ga.create(r,c),h=d._cloneInto().update(l);return{c:s,dkLen:o,asyncTick:a,DK:u,PRF:d,PRFSalt:h}}function JE(r,e,t,n,i){return r.destroy(),e.destroy(),n&&n.destroy(),Kr(i),t}function KO(r,e,t,n){const{c:i,dkLen:s,DK:o,PRF:a,PRFSalt:c}=QE(r,e,t,n);let l;const u=new Uint8Array(4),d=ea(u),h=new Uint8Array(a.outputLen);for(let p=1,m=0;m<s;p++,m+=a.outputLen){const w=o.subarray(m,m+a.outputLen);d.setInt32(0,p,!1),(l=c._cloneInto(l)).update(u).digestInto(h),w.set(h.subarray(0,w.length));for(let y=1;y<i;y++){a._cloneInto(l).update(h).digestInto(h);for(let b=0;b<w.length;b++)w[b]^=h[b]}}return JE(a,c,o,l,h)}async function XE(r,e,t,n){const{c:i,dkLen:s,asyncTick:o,DK:a,PRF:c,PRFSalt:l}=QE(r,e,t,n);let u;const d=new Uint8Array(4),h=ea(d),p=new Uint8Array(c.outputLen);for(let m=1,w=0;w<s;m++,w+=c.outputLen){const y=a.subarray(w,w+c.outputLen);h.setInt32(0,m,!1),(u=l._cloneInto(u)).update(d).digestInto(p),y.set(p.subarray(0,y.length)),await iI(i-1,o,()=>{c._cloneInto(u).update(p).digestInto(p);for(let b=0;b<y.length;b++)y[b]^=p[b]})}return JE(c,l,a,u,p)}const Fo=Uint32Array.from([1732584193,4023233417,2562383102,271733878,3285377520]),kn=new Uint32Array(80);class VO extends Ng{constructor(){super(64,20,8,!1),this.A=Fo[0]|0,this.B=Fo[1]|0,this.C=Fo[2]|0,this.D=Fo[3]|0,this.E=Fo[4]|0}get(){const{A:e,B:t,C:n,D:i,E:s}=this;return[e,t,n,i,s]}set(e,t,n,i,s){this.A=e|0,this.B=t|0,this.C=n|0,this.D=i|0,this.E=s|0}process(e,t){for(let c=0;c<16;c++,t+=4)kn[c]=e.getUint32(t,!1);for(let c=16;c<80;c++)kn[c]=ch(kn[c-3]^kn[c-8]^kn[c-14]^kn[c-16],1);let{A:n,B:i,C:s,D:o,E:a}=this;for(let c=0;c<80;c++){let l,u;c<20?(l=fS(i,s,o),u=1518500249):c<40?(l=i^s^o,u=1859775393):c<60?(l=pS(i,s,o),u=2400959708):(l=i^s^o,u=3395469782);const d=ch(n,5)+l+a+u+kn[c]|0;a=o,o=s,s=ch(i,30),i=n,n=d}n=n+this.A|0,i=i+this.B|0,s=s+this.C|0,o=o+this.D|0,a=a+this.E|0,this.set(n,i,s,o,a)}roundClean(){Kr(kn)}destroy(){this.set(0,0,0,0,0),Kr(this.buffer)}}const zO=Bg(()=>new VO),jO=zO,om=yS,Uw={sha1:jO,"sha2-256":Ci,"sha2-512":om};function $w(r,e,t,n,i){if(i!=="sha1"&&i!=="sha2-256"&&i!=="sha2-512"){const a=Object.keys(Uw).join(" / ");throw new q(`Hash '${i}' is unknown or not supported. Must be ${a}`)}const s=Uw[i],o=KO(s,r,e,{c:t,dkLen:n});return Va.encode(o).substring(1)}const am={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},ZE={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},e1=new globalThis.TextEncoder;function HO(r,e){const t=am[e];let n=ZE[e];for(let i=0;i<r.length;i++)n^=BigInt(r[i]),n=BigInt.asUintN(e,n*t);return n}function WO(r,e,t){if(t.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const n=am[e];let i=ZE[e],s=r;for(;s.length>0;){const o=e1.encodeInto(s,t);s=s.slice(o.read);for(let a=0;a<o.written;a++)i^=BigInt(t[a]),i=BigInt.asUintN(e,i*n)}return i}function GO(r,{size:e=32,utf8Buffer:t}={}){if(!am[e])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof r=="string"){if(t)return WO(r,e,t);r=e1.encode(r)}return HO(r,e)}const cm={hash:r=>Number(GO(r,{size:32})),hashV:(r,e)=>YO(cm.hash(r,e))};function YO(r){let e=r.toString(16);return e.length%2===1&&(e=`0${e}`),Z(e,"base16")}const t1=64;class wi{fp;h;seed;constructor(e,t,n,i=2){if(i>t1)throw new TypeError("Invalid Fingerprint Size");const s=t.hashV(e,n),o=Ie(i);for(let a=0;a<o.length;a++)o[a]=s[a];o.length===0&&(o[0]=7),this.fp=o,this.h=t,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return e?.fp instanceof Uint8Array?Je(this.fp,e.fp):!1}}function Xl(r,e){return Math.floor(Math.random()*(e-r))+r}class Mc{contents;constructor(e){this.contents=new Array(e).fill(null)}has(e){if(!(e instanceof wi))throw new TypeError("Invalid Fingerprint");return this.contents.some(t=>e.equals(t))}add(e){if(!(e instanceof wi))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(this.contents[t]==null)return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof wi))throw new TypeError("Invalid Fingerprint");const t=Xl(0,this.contents.length-1),n=this.contents[t];return this.contents[t]=e,n}remove(e){if(!(e instanceof wi))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex(n=>e.equals(n));return t>-1?(this.contents[t]=null,!0):!1}}const QO=500;class qw{bucketSize;filterSize;fingerprintSize;buckets;count;hash;seed;constructor(e){this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??cm,this.seed=e.seed??Xl(0,Math.pow(2,10))}add(e){typeof e=="string"&&(e=Z(e));const t=new wi(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,i=(n^t.hash())%this.filterSize;if(this.buckets[n]==null&&(this.buckets[n]=new Mc(this.bucketSize)),this.buckets[i]==null&&(this.buckets[i]=new Mc(this.bucketSize)),this.buckets[n].add(t)||this.buckets[i].add(t))return this.count++,!0;const s=[n,i];let o=s[Xl(0,s.length-1)];this.buckets[o]==null&&(this.buckets[o]=new Mc(this.bucketSize));for(let a=0;a<QO;a++){const c=this.buckets[o].swap(t);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new Mc(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(e){typeof e=="string"&&(e=Z(e));const t=new wi(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,i=this.buckets[n]?.has(t)??!1;if(i)return i;const s=(n^t.hash())%this.filterSize;return this.buckets[s]?.has(t)??!1}remove(e){typeof e=="string"&&(e=Z(e));const t=new wi(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,i=this.buckets[n]?.remove(t)??!1;if(i)return this.count--,i;const s=(n^t.hash())%this.filterSize,o=this.buckets[s]?.remove(t)??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const JO={1:.5,2:.84,4:.95,8:.98};function XO(r=.001){return r>.002?2:r>1e-5?4:8}function ZO(r,e=.001){const t=XO(e),n=JO[t],i=Math.round(r/n),s=Math.min(Math.ceil(Math.log2(1/e)+Math.log2(2*t)),t1);return{filterSize:i,bucketSize:t,fingerprintSize:s}}class eB{filterSize;bucketSize;fingerprintSize;scale;filterSeries;hash;seed;constructor(e){this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??cm,this.seed=e.seed??Xl(0,Math.pow(2,10)),this.filterSeries=[new qw({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if(typeof e=="string"&&(e=Z(e)),this.has(e))return!0;let t=this.filterSeries.find(n=>n.reliable);if(t==null){const n=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new qw({filterSize:n,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){typeof e=="string"&&(e=Z(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){typeof e=="string"&&(e=Z(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce((e,t)=>e+t.count,0)}}function Vs(r,e=.001,t){return new eB({...ZO(r,e)})}class tB{filter;constructor(e,t){this.filter=Vs(e,t)}has(e){return this.filter.has(e.toMultihash().bytes)}add(e){this.filter.add(e.toMultihash().bytes)}remove(e){this.filter.remove?.(e.toMultihash().bytes)}}function rB(r,e=.001){return new tB(r,e)}class nB extends wo{metric;constructor(e){super();const{name:t,metrics:n}=e;this.metric=n.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function iB(r){const{name:e,metrics:t}=r;let n;return t!=null?n=new nB({name:e,metrics:t}):n=new wo,n}function Kw(r){const{stream:e,remoteAddr:t,logger:n,onDataRead:i,onDataWrite:s}=r,o=n.forComponent("libp2p:stream:converter");let a=!1,c=!1;const l=e.close.bind(e);e.close=async m=>{await l(m),p(!0)};const u=e.abort.bind(e);e.abort=m=>{u(m),p(!0)};const d=e.sink.bind(e);e.sink=async m=>{try{await d(Yg(m,w=>kE(w,y=>s?.(y))))}catch(w){w.type!=="aborted"&&o.error("%s error in sink",t,w)}finally{c=!0,p()}};const h={log:o,sink:e.sink,source:async function*(){try{for await(const m of e.source)i?.(m),yield m}finally{a=!0,p()}}(),remoteAddr:t,timeline:{open:Date.now(),close:void 0},close:e.close,abort:e.abort};function p(m){m===!0&&(a=!0,c=!0),a&&c&&h.timeline.close==null&&(h.timeline.close=Date.now())}return h}class ke extends Event{type;detail;constructor(e,t){super(e),this.type=e,this.detail=t}}let sB=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.name="AbortError",this.code=t??"ABORT_ERR"}};async function Ur(r,e,t,n){const i=new sB(n?.errorMessage,n?.errorCode);return t?.aborted===!0?Promise.reject(i):new Promise((s,o)=>{function a(){t?.removeEventListener("abort",u),r.removeEventListener(e,c),n?.errorEvent!=null&&r.removeEventListener(n.errorEvent,l)}const c=d=>{try{if(n?.filter?.(d)===!1)return}catch(h){a(),o(h);return}a(),s(d)},l=d=>{a(),o(d.detail)},u=()=>{a(),o(i)};t?.addEventListener("abort",u),r.addEventListener(e,c),n?.errorEvent!=null&&r.addEventListener(n.errorEvent,l)})}function xa(r,e){let t;const n=function(){const i=function(){t=void 0,r()};clearTimeout(t),t=setTimeout(i,e)};return n.start=()=>{},n.stop=()=>{clearTimeout(t)},n}class oB extends Error{remainingPoints;msBeforeNext;consumedPoints;isFirstInDuration;constructor(e="Rate limit exceeded",t){super(e),this.name="RateLimitError",this.remainingPoints=t.remainingPoints,this.msBeforeNext=t.msBeforeNext,this.consumedPoints=t.consumedPoints,this.isFirstInDuration=t.isFirstInDuration}}let aB=class extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}},cB=class{deferred;signal;constructor(e){this.signal=e,this.deferred=Ve(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new Ri)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}};function lB(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}let uB=class{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=lB(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,n)=>t&&n.signal?.aborted===!0,!0)&&(this.controller.abort(new Ri),this.cleanup())}async join(e={}){const t=new cB(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await At(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}},r1=class extends sr{concurrency;maxSize;queue;pending;sort;constructor(e={}){super(),this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,e.metricName!=null&&e.metrics?.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})}),this.sort=e.sort,this.queue=[],this.emitEmpty=xa(this.emitEmpty.bind(this),1),this.emitIdle=xa(this.emitIdle.bind(this),1)}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if(t.status==="queued"){e=t;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new aB;const n=new uB(e,t);return this.enqueue(n),this.safeDispatchEvent("add"),this.tryToStartAnother(),n.join(t).then(i=>(this.safeDispatchEvent("completed",{detail:i}),this.safeDispatchEvent("success",{detail:{job:n,result:i}}),i)).catch(i=>{if(n.status==="queued"){for(let s=0;s<this.queue.length;s++)if(this.queue[s]===n){this.queue.splice(s,1);break}}throw this.safeDispatchEvent("error",{detail:i}),this.safeDispatchEvent("failure",{detail:{job:n,error:i}}),i})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new Ri)}),this.clear()}async onEmpty(e){this.size!==0&&await Ur(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await Ur(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await Ur(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=go({objectMode:!0}),n=c=>{c!=null?this.abort():this.clear(),t.end(c)},i=c=>{c.detail!=null&&t.push(c.detail)},s=c=>{n(c.detail)},o=()=>{n()},a=()=>{n(new Ri("Queue aborted"))};this.addEventListener("completed",i),this.addEventListener("error",s),this.addEventListener("idle",o),e?.signal?.addEventListener("abort",a);try{yield*t}finally{this.removeEventListener("completed",i),this.removeEventListener("error",s),this.removeEventListener("idle",o),e?.signal?.removeEventListener("abort",a),n()}}};class ad extends r1{has(e){return this.find(e)!=null}find(e){return this.queue.find(t=>e.equals(t.options.peerId))}}class dB extends sr{components;started;running;topologyId;log;discoveryController;filter;queue;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.components=e,this.started=!1,this.running=!1,this.filter=t.filter,this.discoveryController=new AbortController,this.discoveryController.signal,this.dialPeer=this.dialPeer.bind(this),this.onPeer=this.onPeer.bind(this)}isStarted(){return this.started}async start(){this.topologyId=await this.components.registrar.register(Vl,{filter:this.filter,onConnect:e=>{this.log.trace("discovered relay %p queue (length: %d, active %d)",e,this.queue?.size,this.queue?.running),this.safeDispatchEvent("relay:discover",{detail:e})}}),this.started=!0}stop(){this.topologyId!=null&&this.components.registrar.unregister(this.topologyId),this.running&&this.stopDiscovery(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,this.discoveryController.signal,this.components.events.addEventListener("peer:discovery",this.onPeer),Promise.resolve().then(async()=>{this.log("searching peer store for relays");const e=await this.components.peerStore.all({filters:[n=>n.protocols.includes(Vl)],orders:[()=>Math.random()<.5?1:-1,(n,i)=>{const s=Vw(n),o=Vw(i);return s>o?-1:o>s?1:0}]});for(const n of e)this.log.trace("found relay peer %p in peer store",n.id),this.safeDispatchEvent("relay:discover",{detail:n.id});this.log("found %d relay peers in peer store",e.length);const t=this.queue=new ad({concurrency:5});this.log("start random walk");for await(const n of this.components.randomWalk.walk({signal:this.discoveryController.signal})){if(this.log.trace("found random peer %p",n.id),t.has(n.id)){this.log.trace("random peer %p was already in queue",n.id);continue}if(this.components.connectionManager.getConnections(n.id)?.length>0){this.log.trace("random peer %p was already connected",n.id);continue}if(!await this.components.connectionManager.isDialable(n.multiaddrs)){this.log.trace("random peer %p was not dialable",n.id,n.multiaddrs.map(i=>i.toString()));continue}t.queued>10&&(this.log.trace("wait for space in queue for %p",n.id),await t.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",n.id,t.size,t.running),t.add(this.dialPeer,{peerId:n.id,signal:this.discoveryController.signal}).catch(i=>{this.log.error("error opening connection to random peer %p",n.id,i)})}this.log("stop random walk"),await t.onIdle()}).catch(e=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network",e)}))}stopDiscovery(){this.log("stop discovery"),this.running=!1,this.discoveryController?.abort(),this.queue?.clear(),this.components.events.removeEventListener("peer:discovery",this.onPeer)}onPeer(e){this.log.trace("maybe dialing discovered peer %p - %e",e.detail.id),this.maybeDialPeer(e).catch(t=>{this.log.trace("error dialing discovered peer %p - %e",e.detail.id,t)})}async maybeDialPeer(e){if(this.queue==null)return;const t=e.detail.id,n=e.detail.multiaddrs;if(this.queue.has(t)){this.log.trace("random peer %p was already in queue",t);return}if(this.components.connectionManager.getConnections(t)?.length>0){this.log.trace("random peer %p was already connected",t);return}if(!await this.components.connectionManager.isDialable(n)){this.log.trace("random peer %p was not dialable",t);return}this.queue?.add(this.dialPeer,{peerId:e.detail.id,signal:this.discoveryController.signal}).catch(i=>{this.log.error("error opening connection to discovered peer %p",e.detail.id,i)})}async dialPeer({peerId:e,signal:t}){const n=Vr([AbortSignal.timeout(5e3),t]);try{await this.components.connectionManager.openConnection(e,{signal:n})}finally{n.clear()}}}function Vw(r){const e=r.metadata.get("last-dial-success");return e==null?0:new Date(ne(e)).getTime()}class hB extends sr{connectionManager;addressManager;reservationStore;listeningAddrs;log;listenTimeout;reservationId;relay;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.connectionManager=e.connectionManager,this.addressManager=e.addressManager,this.reservationStore=e.reservationStore,this.listeningAddrs=[],this.listenTimeout=t.listenTimeout??$E,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}_onRemoveRelayPeer=e=>{this.log("relay removed %p our relay %p",e.detail.relay,this.relay,this.relay?.equals(e.detail.relay)),this.relay?.equals(e.detail.relay)===!0&&(this.log("relay peer removed %p",e.detail.relay),this.listeningAddrs.forEach(t=>{this.addressManager.removeObservedAddr(t)}),this.listeningAddrs=[],this.safeDispatchEvent("listening"))};_onAddRelayPeer=e=>{const{details:t}=e.detail;t.type!=="configured"&&t.id===this.reservationId&&this.addedRelay(e.detail)};async listen(e){if(YE.exactMatch(e))this.log("searching for circuit relay servers"),this.reservationId=this.reservationStore.reserveRelay();else if(GE.exactMatch(e)){this.log("listen on specific relay server %a",e);const t=AbortSignal.timeout(this.listenTimeout),n=e.decapsulate("/p2p-circuit"),i=await this.connectionManager.openConnection(n,{signal:t});if(!this.reservationStore.hasReservation(i.remotePeer)){this.log("making reservation on peer %p",i.remotePeer);const s=await this.reservationStore.addRelay(i.remotePeer,"configured");this.addedRelay(s)}}else throw new bf(`Could not listen on p2p-circuit address "${e}"`)}getAddrs(){return[...this.listeningAddrs.values()].flat()}updateAnnounceAddrs(){}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask(()=>{this.safeDispatchEvent("close")})}addedRelay(e){this.log("relay peer added %p",e.relay),this.relay=e.relay,this.listeningAddrs=e.details.reservation.addrs.map(t=>de(t).encapsulate("/p2p-circuit")),this.listeningAddrs.forEach(t=>{this.addressManager.confirmObservedAddr(t,{type:"transport"})}),queueMicrotask(()=>{this.safeDispatchEvent("listening")})}}function fB(r){return new hB(r)}const pB="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";let gB=(r=21)=>{let e="",t=crypto.getRandomValues(new Uint8Array(r|=0));for(;r--;)e+=pB[t[r]&63];return e};const mB=60*1e3*10,yB=60*1e3*5,wB=30*1e3;class bB extends sr{peerId;connectionManager;peerStore;events;reserveQueue;reservations;pendingReservations;maxReservationQueueLength;reservationCompletionTimeout;started;log;relayFilter;constructor(e,t){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.reservations=new wo,this.pendingReservations=[],this.maxReservationQueueLength=t?.maxReservationQueueLength??AO,this.reservationCompletionTimeout=t?.reservationCompletionTimeout??$E,this.started=!1,this.relayFilter=Vs(100),this.reserveQueue=new ad({concurrency:t?.reservationConcurrency??EO,metricName:"libp2p_relay_reservation_queue",metrics:e.metrics}),this.events.addEventListener("connection:close",n=>{[...this.reservations.values()].find(s=>s.connection===n.detail.id)!=null&&this.#r(n.detail.remotePeer).catch(s=>{this.log("could not remove relay %p - %e",n.detail,s)})})}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>t.tags.has(Lc)]});this.log("removing tag from %d old relays",e.length),await Promise.all(e.map(async t=>{await this.peerStore.merge(t.id,{tags:{[Lc]:void 0}})})),this.log("redialing %d old relays",e.length),await Promise.all(e.map(async t=>this.addRelay(t.id,"discovered"))),this.#t()}).catch(e=>{this.log.error(e)})}stop(){this.reserveQueue.clear(),this.reservations.forEach(({timeout:e})=>{clearTimeout(e)}),this.reservations.clear(),this.started=!1}reserveRelay(){const e=gB();return this.pendingReservations.push(e),this.#t(),e}async addRelay(e,t){if(this.peerId.equals(e))throw this.log.trace("not trying to use self as relay"),new bf("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new $O("The reservation queue is full");const n=this.reserveQueue.find(e);if(n!=null)return this.log.trace("potential relay peer %p is already in the reservation queue",e),n.join();if(this.relayFilter.has(e.toMultihash().bytes))throw new bf("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",e),this.reserveQueue.add(async()=>{const i=Date.now();try{const s=this.reservations.get(e);if(s!=null){const m=this.connectionManager.getConnections(e);let w=!1;if(m.length===0&&this.log("already have relay reservation with %p but we are no longer connected",e),m.map(y=>y.id).includes(s.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",e),w=!0),w&&Mw(s.reservation.expire)>mB)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",e),{relay:e,details:s};await this.#r(e)}if(t==="discovered"&&this.pendingReservations.length===0)throw new Lw("Not making reservation on discovered relay because we do not need any more relays");const o=AbortSignal.timeout(this.reservationCompletionTimeout);const a=await this.connectionManager.openConnection(e,{signal:o});if(Yn.matches(a.remoteAddr))throw new UO("not creating reservation over relayed connection");const c=await this.#e(a,{signal:o}),l=Mw(c.expire);this.log("created reservation on relay peer %p, expiry date is %s",e,new Date(Date.now()+l).toString());const u=Math.min(Math.max(l-yB,wB),Math.pow(2,31)-1),d=setTimeout(()=>{this.log("refresh reservation to relay %p",e),this.addRelay(e,t).catch(async m=>{this.log.error("could not refresh reservation to relay %p - %e",e,m),await this.#r(e)}).catch(m=>{this.log.error("could not remove expired reservation to relay %p - %e",e,m)})},u);let h;if(t==="discovered"){const m=this.pendingReservations.pop();if(m==null)throw new Lw("Made reservation on relay but did not need any more discovered relays");h={timeout:d,reservation:c,type:t,connection:a.id,id:m}}else h={timeout:d,reservation:c,type:t,connection:a.id};this.reservations.set(e,h),await this.peerStore.merge(e,{tags:{[Lc]:{value:1,ttl:l}}}),this.#t();const p={relay:e,details:h};return this.safeDispatchEvent("relay:created-reservation",{detail:p}),p}catch(s){throw t==="discovered"&&s.name==="HadEnoughRelaysError"||this.log.error("could not reserve slot on %p after %dms - %e",e,Date.now()-i,s),(s.name==="DialError"||s.name==="UnsupportedProtocolError")&&this.relayFilter.add(e.toMultihash().bytes),this.#r(e).catch(o=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",e,o)}),s}},{peerId:e})}hasReservation(e){return this.reservations.has(e)}getReservation(e){return this.reservations.get(e)?.reservation}reservationCount(e){return e==null?this.reservations.size:[...this.reservations.values()].reduce((t,n)=>(n.type===e&&t++,t),0)}cancelReservations(){[...this.reservations.values()].forEach(e=>{clearTimeout(e.timeout)}),this.reservations.clear()}async#e(e,t){t.signal?.throwIfAborted(),this.log("requesting reservation from %p",e.remotePeer);const n=await e.newStream(Vl,t),s=Qt(n).pb($s);this.log.trace("send RESERVE to %p",e.remotePeer),await s.write({type:$s.Type.RESERVE},t);let o;try{this.log.trace("reading response from %p",e.remotePeer),o=await s.read(t)}catch(c){throw n.abort(c),c}finally{n.status!=="closed"&&await n.close(t)}if(this.log.trace("read response %o",o),o.status===kt.OK&&o.reservation!=null){const c=new Set;c.add(e.remoteAddr.toString());for(const l of o.reservation.addrs){let u=de(l);u.getPeerId()==null&&(u=u.encapsulate(`/p2p/${e.remotePeer}`)),u=de(u.toString().replace(`/p2p/${e.remotePeer}/p2p/${e.remotePeer}`,`/p2p/${e.remotePeer}`)),c.add(u.toString())}return o.reservation.addrs=[...c].map(l=>de(l).bytes),o.reservation}const a=`reservation failed with status ${o.status??"undefined"}`;throw this.log.error(a),new Error(a)}async#r(e){const t=this.reservations.get(e);t!=null&&(this.log("removing relay reservation with %p from local store",e),clearTimeout(t.timeout),this.reservations.delete(e),t.type==="discovered"&&this.pendingReservations.push(t.id),await this.peerStore.merge(e,{tags:{[Lc]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:e,details:t}}),this.#t())}#t(){if(this.pendingReservations.length===0){this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),this.safeDispatchEvent("relay:found-enough-relays");return}this.relayFilter=Vs(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")}}const vB=r=>{if(r.peer==null)return!1;try{r.peer.addrs.forEach(de)}catch{return!1}return!0},zw={maxInboundStopStreams:Ow,maxOutboundStopStreams:Ow};class SB{discovery;registrar;peerStore;connectionManager;transportManager;peerId;upgrader;addressManager;connectionGater;reservationStore;logger;maxInboundStopStreams;maxOutboundStopStreams;started;log;shutdownController;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:circuit-relay:transport"),this.registrar=e.registrar,this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.transportManager=e.transportManager,this.logger=e.logger,this.peerId=e.peerId,this.upgrader=e.upgrader,this.addressManager=e.addressManager,this.connectionGater=e.connectionGater,this.maxInboundStopStreams=t.maxInboundStopStreams??zw.maxInboundStopStreams,this.maxOutboundStopStreams=t.maxOutboundStopStreams??zw.maxOutboundStopStreams,this.shutdownController=new AbortController,this.discovery=new dB(e,{filter:t.discoveryFilter??rB(xO,_O)}),this.discovery.addEventListener("relay:discover",n=>{this.reservationStore.addRelay(n.detail,"discovered").catch(i=>{i.name!=="HadEnoughRelaysError"&&i.name!=="RelayQueueFullError"&&this.log.error("could not add discovered relay %p",n.detail,i)})}),this.reservationStore=new bB(e,t),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{this.discovery?.startDiscovery()}),this.reservationStore.addEventListener("relay:found-enough-relays",()=>{this.discovery?.stopDiscovery()}),this.started=!1}[Symbol.toStringTag]="@libp2p/circuit-relay-v2-transport";[$t]=["@libp2p/transport","@libp2p/circuit-relay-v2-transport"];get[Os](){return this.discovery!=null?["@libp2p/identify"]:[]}[zu]=!0;isStarted(){return this.started}async start(){this.shutdownController=new AbortController,this.shutdownController.signal,await this.registrar.handle(Rw,e=>{const t=this.upgrader.createInboundAbortSignal(this.shutdownController.signal);this.onStop(e,t).catch(n=>{this.log.error("error while handling STOP protocol",n),e.stream.abort(n)}).finally(()=>{t.clear()})},{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await Gv(this.discovery,this.reservationStore),this.started=!0}async stop(){this.shutdownController.abort(),await Yv(this.discovery,this.reservationStore),await this.registrar.unhandle(Rw),this.started=!1}async dial(e,t){if(e.protoCodes().filter(p=>p===SO).length!==1){const p="Invalid circuit relay address";throw this.log.error(p,e),new Zo(p)}const n=e.toString().split("/p2p-circuit"),i=de(n[0]),s=de(n[n.length-1]),o=i.getPeerId(),a=s.getPeerId();if(o==null||a==null){const p=`ircuit relay dial to ${e.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${p}`),new Zo(`C${p}`)}const c=xr(o),l=xr(a);let d=this.connectionManager.getConnections(c)[0];d==null?(await this.peerStore.merge(c,{multiaddrs:[i]}),t.onProgress?.(new ke("circuit-relay:open-connection")),d=await this.connectionManager.openConnection(c,t)):t.onProgress?.(new ke("circuit-relay:reuse-connection"));let h;try{t.onProgress?.(new ke("circuit-relay:open-hop-stream")),h=await d.newStream(Vl,t);const p=Qt(h),m=p.pb($s);t.onProgress?.(new ke("circuit-relay:write-connect-message")),await m.write({type:$s.Type.CONNECT,peer:{id:l.toMultihash().bytes,addrs:[de(s).bytes]}},t),t.onProgress?.(new ke("circuit-relay:read-connect-response"));const w=await m.read(t);if(w.status!==kt.OK)throw new bt(`failed to connect via relay with status ${w?.status?.toString()??"undefined"}`);const y=new Fw(w.limit),b=Kw({stream:p.unwrap(),remoteAddr:e,localAddr:i.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),logger:this.logger,onDataRead:y.onData,onDataWrite:y.onData});return this.log("new outbound relayed connection %a",b.remoteAddr),await this.upgrader.upgradeOutbound(b,{...t,limits:y.getLimits()})}catch(p){throw this.log.error("circuit relay dial to destination %p via relay %p failed",l,c,p),h?.abort(p),p}}createListener(e){return fB({peerId:this.peerId,connectionManager:this.connectionManager,addressManager:this.addressManager,reservationStore:this.reservationStore,logger:this.logger})}listenFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>GE.exactMatch(t)||YE.exactMatch(t))}dialFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>Yn.exactMatch(t))}async onStop({connection:e,stream:t},n){if(!this.reservationStore.hasReservation(e.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.transportManager.listen([e.remoteAddr.encapsulate("/p2p-circuit")])}catch(u){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on",u)}const i=Qt(t).pb(Xr),s=await i.read({signal:n});if(this.log("new circuit relay v2 stop stream from %p with type %s",e.remotePeer,s.type),s?.type===void 0){this.log.error("type was missing from circuit v2 stop protocol request from %s",e.remotePeer),await i.write({type:Xr.Type.STATUS,status:kt.MALFORMED_MESSAGE},{signal:n}),await t.close();return}if(s.type!==Xr.Type.CONNECT){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await i.write({type:Xr.Type.STATUS,status:kt.UNEXPECTED_MESSAGE},{signal:n}),await t.close();return}if(!vB(s)){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await i.write({type:Xr.Type.STATUS,status:kt.MALFORMED_MESSAGE},{signal:n}),await t.close({signal:n});return}const o=po(Ji(s.peer.id));if(await this.connectionGater.denyInboundRelayedConnection?.(e.remotePeer,o)===!0){this.log.error("connection gater denied inbound relayed connection from %p",e.remotePeer),await i.write({type:Xr.Type.STATUS,status:kt.PERMISSION_DENIED},{signal:n}),await t.close({signal:n});return}this.log.trace("sending success response to %p",e.remotePeer),await i.write({type:Xr.Type.STATUS,status:kt.OK},{signal:n});const a=new Fw(s.limit),c=e.remoteAddr.encapsulate(`/p2p-circuit/p2p/${o.toString()}`);this.addressManager.getAddresses()[0];const l=Kw({stream:i.unwrap().unwrap(),remoteAddr:c,logger:this.logger,onDataRead:a.onData,onDataWrite:a.onData});this.log("new inbound relayed connection %a",l.remoteAddr),await this.upgrader.upgradeInbound(l,{limits:a.getLimits(),signal:n}),this.log("%s connection %a upgraded","inbound",l.remoteAddr)}}function EB(r={}){return e=>new SB(e,r)}function AB(r){return r[Symbol.asyncIterator]!=null}function qf(r){if(AB(r))return(async()=>{for await(const e of r);})();for(const e of r);}const Fc=globalThis.CustomEvent??Event;async function*n1(r,e={}){let t=e.concurrency??1/0;t<1&&(t=1/0);const n=e.ordered??!1,i=new EventTarget,s=[];let o=Ve(),a=Ve(),c=!1,l,u=!1;i.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const m of r){if(s.length===t&&(o=Ve(),await o.promise),u)break;const w={done:!1};s.push(w),m().then(y=>{w.done=!0,w.ok=!0,w.value=y,i.dispatchEvent(new Fc("task-complete"))},y=>{w.done=!0,w.err=y,i.dispatchEvent(new Fc("task-complete"))})}c=!0,i.dispatchEvent(new Fc("task-complete"))}catch(m){l=m,i.dispatchEvent(new Fc("task-complete"))}});function d(){return n?s[0]?.done:!!s.find(m=>m.done)}function*h(){for(;s.length>0&&s[0].done;){const m=s[0];if(s.shift(),m.ok)yield m.value;else throw u=!0,o.resolve(),m.err;o.resolve()}}function*p(){for(;d();)for(let m=0;m<s.length;m++)if(s[m].done){const w=s[m];if(s.splice(m,1),m--,w.ok)yield w.value;else throw u=!0,o.resolve(),w.err;o.resolve()}}for(;;){if(d()||(a=Ve(),await a.promise),l!=null||(n?yield*h():yield*p(),l!=null))throw l;if(c&&s.length===0)break}}const xB="0.1.0",_B="id",CB="id/push",IB="1.0.0",kB="1.0.0",TB=1024*8,PB=32,RB=1e3;var zs;(function(r){let e;r.codec=()=>(e==null&&(e=Oe((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.protocolVersion!=null&&(n.uint32(42),n.string(t.protocolVersion)),t.agentVersion!=null&&(n.uint32(50),n.string(t.agentVersion)),t.publicKey!=null&&(n.uint32(10),n.bytes(t.publicKey)),t.listenAddrs!=null)for(const s of t.listenAddrs)n.uint32(18),n.bytes(s);if(t.observedAddr!=null&&(n.uint32(34),n.bytes(t.observedAddr)),t.protocols!=null)for(const s of t.protocols)n.uint32(26),n.string(s);t.signedPeerRecord!=null&&(n.uint32(66),n.bytes(t.signedPeerRecord)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={listenAddrs:[],protocols:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 5:{s.protocolVersion=t.string();break}case 6:{s.agentVersion=t.string();break}case 1:{s.publicKey=t.bytes();break}case 2:{if(i.limits?.listenAddrs!=null&&s.listenAddrs.length===i.limits.listenAddrs)throw new Ar('Decode error - map field "listenAddrs" had too many elements');s.listenAddrs.push(t.bytes());break}case 4:{s.observedAddr=t.bytes();break}case 3:{if(i.limits?.protocols!=null&&s.protocols.length===i.limits.protocols)throw new Ar('Decode error - map field "protocols" had too many elements');s.protocols.push(t.string());break}case 8:{s.signedPeerRecord=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Re(t,r.codec()),r.decode=(t,n)=>Pe(t,r.codec(),n)})(zs||(zs={}));const Zt={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:TB,runOnConnectionOpen:!0,runOnSelfUpdate:!0,runOnLimitedConnection:!0,concurrency:PB};function OB(r){if(r!=null&&r.length>0)try{return de(r)}catch{}}function BB(r,e){return e??r.userAgent}async function i1(r,e,t,n,i){if(t("received identify from %p",n.remotePeer),i==null)throw new bt("message was null or undefined");const s={};if(i.listenAddrs.length>0&&(s.addresses=i.listenAddrs.map(c=>({isCertified:!1,multiaddr:de(c)}))),i.protocols.length>0&&(s.protocols=i.protocols),i.publicKey!=null){const c=Gn(i.publicKey);if(!ya(c).equals(n.remotePeer))throw new bt("public key did not match remote PeerId");s.publicKey=c}let o;if(i.signedPeerRecord!=null){t.trace("received signedPeerRecord from %p",n.remotePeer);let c=i.signedPeerRecord;const l=await Lr.openAndCertify(c,Yt.DOMAIN);let u=Yt.createFromProtobuf(l.payload);const d=Qa(l.publicKey.toCID());if(!u.peerId.equals(d))throw new bt("signing key does not match PeerId in the PeerRecord");if(!n.remotePeer.equals(u.peerId))throw new bt("signing key does not match remote PeerId");let h;try{h=await r.get(u.peerId)}catch(p){if(p.name!=="NotFoundError")throw p}if(h!=null&&(s.metadata=h.metadata,h.peerRecordEnvelope!=null)){const p=Lr.createFromProtobuf(h.peerRecordEnvelope),m=Yt.createFromProtobuf(p.payload);m.seqNumber>=u.seqNumber&&(t("sequence number was lower or equal to existing sequence number - stored: %d received: %d",m.seqNumber,u.seqNumber),u=m,c=h.peerRecordEnvelope)}s.peerRecordEnvelope=c,s.addresses=u.multiaddrs.map(p=>({isCertified:!0,multiaddr:p})),o={seq:u.seqNumber,addresses:u.multiaddrs}}else t("%p did not send a signed peer record",n.remotePeer);if(t.trace("patching %p with",n.remotePeer,s),await r.patch(n.remotePeer,s),i.agentVersion!=null||i.protocolVersion!=null){const c={};i.agentVersion!=null&&(c.AgentVersion=Z(i.agentVersion)),i.protocolVersion!=null&&(c.ProtocolVersion=Z(i.protocolVersion)),t.trace("merging %p metadata",n.remotePeer,c),await r.merge(n.remotePeer,{metadata:c})}const a={peerId:n.remotePeer,protocolVersion:i.protocolVersion,agentVersion:i.agentVersion,publicKey:i.publicKey,listenAddrs:i.listenAddrs.map(c=>de(c)),observedAddr:i.observedAddr==null?void 0:de(i.observedAddr),protocols:i.protocols,signedPeerRecord:o,connection:n};return e.safeDispatchEvent("peer:identify",{detail:a}),a}class s1{host;protocol;started;timeout;peerId;privateKey;peerStore;registrar;addressManager;maxInboundStreams;maxOutboundStreams;maxMessageSize;maxObservedAddresses;events;runOnLimitedConnection;log;constructor(e,t){this.protocol=t.protocol,this.started=!1,this.peerId=e.peerId,this.privateKey=e.privateKey,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.events=e.events,this.log=t.log,this.timeout=t.timeout??Zt.timeout,this.maxInboundStreams=t.maxInboundStreams??Zt.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??Zt.maxOutboundStreams,this.maxMessageSize=t.maxMessageSize??Zt.maxMessageSize,this.maxObservedAddresses=t.maxObservedAddresses??Zt.maxObservedAddresses,this.runOnLimitedConnection=t.runOnLimitedConnection??Zt.runOnLimitedConnection,this.host={protocolVersion:`${t.protocolPrefix??Zt.protocolPrefix}/${xB}`,agentVersion:BB(e.nodeInfo,t.agentVersion)}}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:Z(this.host.agentVersion),ProtocolVersion:Z(this.host.protocolVersion)}}),await this.registrar.handle(this.protocol,e=>{this.handleProtocol(e).catch(t=>{this.log.error(t)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.registrar.unhandle(this.protocol),this.started=!1}}class NB extends s1{connectionManager;concurrency;_push;constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??Zt.protocolPrefix}/${CB}/${kB}`,log:e.logger.forComponent("libp2p:identify-push")}),this.connectionManager=e.connectionManager,this.concurrency=t.concurrency??Zt.concurrency,this._push=xa(this.sendPushMessage.bind(this),t.debounce??RB),(t.runOnSelfUpdate??Zt.runOnSelfUpdate)&&e.events.addEventListener("self:peer:update",n=>{this.push().catch(i=>{this.log.error("error pushing updates to peers - %e",i)})})}[$t]=["@libp2p/identify-push"];async push(){this._push()}async sendPushMessage(){if(this.isStarted())try{const e=this.addressManager.getAddresses().map(u=>u.decapsulateCode(St("p2p").code)),t=new Yt({peerId:this.peerId,multiaddrs:e}),n=await Lr.seal(t,this.privateKey),i=this.registrar.getProtocols(),s=await this.peerStore.get(this.peerId),o=ne(s.metadata.get("AgentVersion")??Z(this.host.agentVersion)),a=ne(s.metadata.get("ProtocolVersion")??Z(this.host.protocolVersion)),c=this;async function*l(){for(const u of c.connectionManager.getConnections())(await c.peerStore.get(u.remotePeer)).protocols.includes(c.protocol)&&(yield async()=>{let h;const p=AbortSignal.timeout(c.timeout);try{h=await u.newStream(c.protocol,{signal:p,runOnLimitedConnection:c.runOnLimitedConnection}),await Qt(h,{maxDataLength:c.maxMessageSize}).pb(zs).write({listenAddrs:e.map(w=>w.bytes),signedPeerRecord:n.marshal(),protocols:i,agentVersion:o,protocolVersion:a},{signal:p}),await h.close({signal:p})}catch(m){c.log.error("could not push identify update to peer",m),h?.abort(m)}})}await qf(n1(l(),{concurrency:this.concurrency}))}catch(e){this.log.error("error pushing updates to peers - %e",e)}}async handleProtocol(e){const{connection:t,stream:n}=e;try{if(this.peerId.equals(t.remotePeer))throw new Error("received push from ourselves?");const i={signal:AbortSignal.timeout(this.timeout)},o=await Qt(n,{maxDataLength:this.maxMessageSize}).pb(zs).read(i);await n.close(i),await i1(this.peerStore,this.events,this.log,t,o)}catch(i){this.log.error("received invalid message",i),n.abort(i);return}this.log.trace("handled push from %p",t.remotePeer)}}function o1(r){try{for(const{code:e,value:t}of r.getComponents())if(t!=null&&e===Mr)return yO("2000::/3",t)}catch{}return!1}var jw=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function bo(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var cs={},Hw;function DB(){return Hw||(Hw=1,function(){var r,e,t,n,i,s,o,a;a=function(c){var l,u,d,h;return l=(c&255<<24)>>>24,u=(c&255<<16)>>>16,d=(c&65280)>>>8,h=c&255,[l,u,d,h].join(".")},o=function(c){var l,u,d,h,p,m;for(l=[],d=h=0;h<=3&&c.length!==0;d=++h){if(d>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}m=e(c),p=m[0],u=m[1],c=c.substring(u),l.push(p)}if(c.length!==0)throw new Error("Invalid IP");switch(l.length){case 1:if(l[0]>4294967295)throw new Error("Invalid IP");return l[0]>>>0;case 2:if(l[0]>255||l[1]>16777215)throw new Error("Invalid IP");return(l[0]<<24|l[1])>>>0;case 3:if(l[0]>255||l[1]>255||l[2]>65535)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2])>>>0;case 4:if(l[0]>255||l[1]>255||l[2]>255||l[3]>255)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2]<<8|l[3])>>>0;default:throw new Error("Invalid IP")}},t=function(c){return c.charCodeAt(0)},n=t("0"),s=t("a"),i=t("A"),e=function(c){var l,u,d,h,p;for(h=0,l=10,u="9",d=0,c.length>1&&c[d]==="0"&&(c[d+1]==="x"||c[d+1]==="X"?(d+=2,l=16):"0"<=c[d+1]&&c[d+1]<="9"&&(d++,l=8,u="7")),p=d;d<c.length;){if("0"<=c[d]&&c[d]<=u)h=h*l+(t(c[d])-n)>>>0;else if(l===16)if("a"<=c[d]&&c[d]<="f")h=h*l+(10+t(c[d])-s)>>>0;else if("A"<=c[d]&&c[d]<="F")h=h*l+(10+t(c[d])-i)>>>0;else break;else break;if(h>4294967295)throw new Error("too large");d++}if(d===p)throw new Error("empty octet");return[h,d]},r=function(){function c(l,u){var d,h,p;if(typeof l!="string")throw new Error("Missing `net' parameter");if(u||(p=l.split("/",2),l=p[0],u=p[1]),u||(u=32),typeof u=="string"&&u.indexOf(".")>-1){try{this.maskLong=o(u)}catch{throw new Error("Invalid mask: "+u)}for(d=h=32;h>=0;d=--h)if(this.maskLong===4294967295<<32-d>>>0){this.bitmask=d;break}}else if(u||u===0)this.bitmask=parseInt(u,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(l)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+l)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+u);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(l){return typeof l=="string"&&(l.indexOf("/")>0||l.split(".").length!==4)&&(l=new c(l)),l instanceof c?this.contains(l.base)&&this.contains(l.broadcast||l.last):(o(l)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(l){return l==null&&(l=1),new c(a(this.netLong+this.size*l),this.mask)},c.prototype.forEach=function(l){var u,d,h;for(h=o(this.first),d=o(this.last),u=0;h<=d;)l(a(h),h,u),u++,h++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),cs.ip2long=o,cs.long2ip=a,cs.Netmask=r}.call(cs)),cs}var LB=DB();const MB=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],FB=MB.map(r=>new LB.Netmask(r));function lm(r){for(const e of FB)if(e.contains(r))return!0;return!1}function UB(r){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(r)}function $B(r){const e=r.split(":");if(e.length<2)return!1;const t=e[e.length-1].padStart(4,"0"),n=e[e.length-2].padStart(4,"0"),i=`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(t.substring(0,2),16)}.${parseInt(t.substring(2),16)}`;return lm(i)}function qB(r){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)}function KB(r){const e=r.split(":"),t=e[e.length-1];return lm(t)}function VB(r){return/^::$/.test(r)||/^::1$/.test(r)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(r)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(r)||/^ff([0-9a-fA-F]{2,2}):/i.test(r)}function ec(r){if(Ni(r))return lm(r);if(UB(r))return $B(r);if(qB(r))return KB(r);if(Jg(r))return VB(r)}function a1(r){try{for(const{code:e}of r.getComponents())if(e!==mo)return e===Us||e===Mr}catch{}return!1}function Di(r){try{if(!a1(r))return!1;const[[,e]]=r.stringTuples();return e==null?!1:ec(e)??!1}catch{}return!0}class zB extends s1{constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??Zt.protocolPrefix}/${_B}/${IB}`,log:e.logger.forComponent("libp2p:identify")}),(t.runOnConnectionOpen??Zt.runOnConnectionOpen)&&e.events.addEventListener("connection:open",n=>{const i=n.detail;this.identify(i).catch(s=>{s.name!==Cg.name&&this.log.error("error during identify trigged by connection:open",s)})})}[$t]=["@libp2p/identify"];async _identify(e,t={}){let n;if(t.signal==null){const i=AbortSignal.timeout(this.timeout);t={...t,signal:i}}try{n=await e.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const s=await Qt(n,{maxDataLength:this.maxMessageSize}).pb(zs).read(t);return await n.close(t),s}catch(i){throw n?.abort(i),i}}async identify(e,t={}){const n=await this._identify(e,t),{publicKey:i,protocols:s,observedAddr:o}=n;if(i==null)throw new bt("public key was missing from identify message");const a=Gn(i),c=Qa(a.toCID());if(!e.remotePeer.equals(c))throw new bt("identified peer does not match the expected peer");if(this.peerId.equals(c))throw new bt("identified peer is our own peer id?");return this.maybeAddObservedAddress(o),this.log("identify completed for peer %p and protocols %o",c,s),i1(this.peerStore,this.events,this.log,e,n)}maybeAddObservedAddress(e){const t=OB(e);if(t==null)return;if(this.log.trace("our observed address was %a",t),Di(t)){this.log.trace("our observed address was private");return}const n=t.getComponents();if((n[0].code===Mr||n[0].code===mo&&n[1].code===Mr)&&!o1(t)){this.log.trace("our observed address was IPv6 but not a global unicast address");return}Gl.exactMatch(t)||(this.log.trace("storing the observed address"),this.addressManager.addObservedAddr(t))}async handleProtocol(e){const{connection:t,stream:n}=e,i=AbortSignal.timeout(this.timeout);try{const s=await this.peerStore.get(this.peerId),o=this.addressManager.getAddresses().map(u=>u.decapsulateCode(St("p2p").code));let a=s.peerRecordEnvelope;if(o.length>0&&a==null){const u=new Yt({peerId:this.peerId,multiaddrs:o});a=(await Lr.seal(u,this.privateKey)).marshal().subarray()}let c=t.remoteAddr.bytes;PO.matches(t.remoteAddr)||(c=void 0),await Qt(n).pb(zs).write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:on(this.privateKey.publicKey),listenAddrs:o.map(u=>u.bytes),signedPeerRecord:a,observedAddr:c,protocols:s.protocols},{signal:i}),await n.close({signal:i})}catch(s){this.log.error("could not respond to identify request",s),n.abort(s)}}}function jB(r={}){return e=>new zB(e,r)}function HB(r={}){return e=>new NB(e,r)}const Ah=32,WB="1.0.0",GB="ping",YB="ipfs",QB=1e4,JB=2,XB=1;class ZB{protocol;components;started;timeout;maxInboundStreams;maxOutboundStreams;runOnLimitedConnection;log;constructor(e,t={}){this.components=e,this.log=e.logger.forComponent("libp2p:ping"),this.started=!1,this.protocol=`/${t.protocolPrefix??YB}/${GB}/${WB}`,this.timeout=t.timeout??QB,this.maxInboundStreams=t.maxInboundStreams??JB,this.maxOutboundStreams=t.maxOutboundStreams??XB,this.runOnLimitedConnection=t.runOnLimitedConnection??!0,this.handleMessage=this.handleMessage.bind(this)}[Symbol.toStringTag]="@libp2p/ping";[$t]=["@libp2p/ping"];async start(){await this.components.registrar.handle(this.protocol,this.handleMessage,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(e){this.log("incoming ping from %p",e.connection.remotePeer);const{stream:t}=e,n=Date.now(),i=Ll(t);let s=!1;Promise.resolve().then(async()=>{for(;;){const o=AbortSignal.timeout(this.timeout);o.addEventListener("abort",()=>{t?.abort(new Ig("ping timeout"))});const a=await i.read({bytes:Ah,signal:o});await i.write(a,{signal:o}),s=!0}}).catch(o=>{s&&o.name==="UnexpectedEOFError"&&t.readStatus!=="ready"||(this.log.error("incoming ping from %p failed with error - %e",e.connection.remotePeer,o),t?.abort(o))}).finally(()=>{const o=Date.now()-n;this.log("incoming ping from %p complete in %dms",e.connection.remotePeer,o);const a=AbortSignal.timeout(this.timeout);t.close({signal:a}).catch(c=>{this.log.error("error closing ping stream from %p - %e",e.connection.remotePeer,c),t?.abort(c)})})}async ping(e,t={}){this.log("pinging %p",e);const n=Date.now(),i=Ds(Ah),s=await this.components.connectionManager.openConnection(e,t);let o;if(t.signal==null){const a=AbortSignal.timeout(this.timeout);t={...t,signal:a}}try{o=await s.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const a=Ll(o),[,c]=await Promise.all([a.write(i,t),a.read({...t,bytes:Ah})]),l=Date.now()-n;if(!Je(i,c.subarray()))throw new dC(`Received wrong ping ack after ${l}ms`);return this.log("ping %p complete in %dms",s.remotePeer,l),l}catch(a){throw this.log.error("error while pinging %p",s.remotePeer,a),o?.abort(a),a}finally{o!=null&&await o.close(t)}}}function eN(r={}){return e=>new ZB(e,r)}var Nt;(function(r){(function(n){n.FIN="FIN",n.STOP_SENDING="STOP_SENDING",n.RESET="RESET",n.FIN_ACK="FIN_ACK"})(r.Flag||(r.Flag={}));let e;(function(n){n[n.FIN=0]="FIN",n[n.STOP_SENDING=1]="STOP_SENDING",n[n.RESET=2]="RESET",n[n.FIN_ACK=3]="FIN_ACK"})(e||(e={})),function(n){n.codec=()=>hn(e)}(r.Flag||(r.Flag={}));let t;r.codec=()=>(t==null&&(t=Oe((n,i,s={})=>{s.lengthDelimited!==!1&&i.fork(),n.flag!=null&&(i.uint32(8),r.Flag.codec().encode(n.flag,i)),n.message!=null&&(i.uint32(18),i.bytes(n.message)),s.lengthDelimited!==!1&&i.ldelim()},(n,i,s={})=>{const o={},a=i==null?n.len:n.pos+i;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.flag=r.Flag.codec().decode(n);break}case 2:{o.message=n.bytes();break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>Re(n,r.codec()),r.decode=(n,i)=>Pe(n,r.codec(),i)})(Nt||(Nt={}));const tN=["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478","stun:stun.cloudflare.com:3478","stun:stun.services.mozilla.com:3478"],Ww=Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"),rN="libp2p+webrtc+v1/",nN=466,iN=2*1024*1024,sN=30*1e3,cd=16*1024;function oN(r=cd){const e=Et(r-Et(r)),t=1+Et(Object.keys(Nt.Flag).length-1),n=1,i=r-e-t-n,s=Et(i);return e+t+n+s}const aN=oN(),cN=5e3,lN=5e3,uN=3e4,c1="/webrtc",Kf="/webrtc-signaling/0.0.1",dN="/libp2p/webrtc-direct/certificate",hN="webrtc-direct-certificate-private-key",fN=12096e5,Gw=864e5;var Yw=function(r,e,t){if(t||arguments.length===2)for(var n=0,i=e.length,s;n<i;n++)(s||!(n in e))&&(s||(s=Array.prototype.slice.call(e,0,n)),s[n]=e[n]);return r.concat(s||Array.prototype.slice.call(e))},pN=function(){function r(e,t,n){this.name=e,this.version=t,this.os=n,this.type="browser"}return r}(),gN=function(){function r(e){this.version=e,this.type="node",this.name="node",this.os=process.platform}return r}(),mN=function(){function r(e,t,n,i){this.name=e,this.version=t,this.os=n,this.bot=i,this.type="bot-device"}return r}(),yN=function(){function r(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return r}(),wN=function(){function r(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return r}(),bN=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,vN=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,Qw=3,SN=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",bN]],Jw=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function EN(r){return typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new wN:typeof navigator<"u"?xN(navigator.userAgent):CN()}function AN(r){return r!==""&&SN.reduce(function(e,t){var n=t[0],i=t[1];if(e)return e;var s=i.exec(r);return!!s&&[n,s]},!1)}function xN(r){var e=AN(r);if(!e)return null;var t=e[0],n=e[1];if(t==="searchbot")return new yN;var i=n[1]&&n[1].split(".").join("_").split("_").slice(0,3);i?i.length<Qw&&(i=Yw(Yw([],i,!0),IN(Qw-i.length),!0)):i=[];var s=i.join("."),o=_N(r),a=vN.exec(r);return a&&a[1]?new mN(t,s,o,a[1]):new pN(t,s,o)}function _N(r){for(var e=0,t=Jw.length;e<t;e++){var n=Jw[e],i=n[0],s=n[1],o=s.exec(r);if(o)return i}return null}function CN(){var r=typeof process<"u"&&process.version;return r?new gN(process.version.slice(1)):null}function IN(r){for(var e=[],t=0;t<r;t++)e.push("0");return e}class l1 extends Error{constructor(e){super(e),this.name="TimeoutError"}}let kN=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}};const Xw=r=>globalThis.DOMException===void 0?new kN(r):new DOMException(r),Zw=r=>{const e=r.reason===void 0?Xw("This operation was aborted."):r.reason;return e instanceof Error?e:Xw(e)};function um(r,e){const{milliseconds:t,fallback:n,message:i,customTimers:s={setTimeout,clearTimeout}}=e;let o,a;const l=new Promise((u,d)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(e.signal){const{signal:p}=e;p.aborted&&d(Zw(p)),a=()=>{d(Zw(p))},p.addEventListener("abort",a,{once:!0})}if(t===Number.POSITIVE_INFINITY){r.then(u,d);return}const h=new l1;o=s.setTimeout.call(void 0,()=>{if(n){try{u(n())}catch(p){d(p)}return}typeof r.cancel=="function"&&r.cancel(),i===!1?u():i instanceof Error?d(i):(h.message=i??`Promise timed out after ${t} milliseconds`,d(h))},t),(async()=>{try{u(await r)}catch(p){d(p)}})()}).finally(()=>{l.clear(),a&&e.signal&&e.signal.removeEventListener("abort",a)});return l.clear=()=>{s.clearTimeout.call(void 0,o),o=void 0},l}const eb=EN(),dm=eb!=null&&eb.name==="firefox",u1=async function*(){},d1=async r=>{};function TN(r,e,t=uN,n){r.readyState==="open"&&Promise.resolve().then(async()=>{if(r.bufferedAmount>0){n.log("%s drain channel with %d buffered bytes",e,r.bufferedAmount);const i=Ve();let s=!1;r.bufferedAmountLowThreshold=0;const o=()=>{s||(n.log("%s drain channel closed before drain",e),i.resolve())};r.addEventListener("close",o,{once:!0}),r.addEventListener("bufferedamountlow",()=>{s=!0,r.removeEventListener("close",o),i.resolve()}),await um(i.promise,{milliseconds:t})}}).then(async()=>{r.readyState==="open"&&r.close()}).catch(i=>{n.log.error("error closing outbound stream",i)})}async function tb(r){return r=r??{},typeof r=="function"&&(r=await r()),r.iceServers=r.iceServers??tN.map(e=>({urls:[e]})),r}const PN=(r=32)=>rN+[...Array(r)].map(()=>Ww.at(Math.floor(Math.random()*Ww.length))).join("");class Vf{log;peerConnection;remoteAddr;timeline;metrics;source=u1();sink=d1;constructor(e,t){this.log=e.logger.forComponent("libp2p:webrtc:maconn"),this.remoteAddr=t.remoteAddr,this.timeline=t.timeline,this.peerConnection=t.peerConnection;const n=this.peerConnection,i=n.connectionState;this.peerConnection.onconnectionstatechange=()=>{this.log.trace("peer connection state change",n.connectionState,"initial state",i),(n.connectionState==="disconnected"||n.connectionState==="failed"||n.connectionState==="closed")&&(this.timeline.close=Date.now())}}async close(e){this.log.trace("closing connection"),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({close:!0})}abort(e){this.log.error("closing connection due to error",e),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({abort:!0})}}class RN extends CE{channel;incomingData;maxBufferedAmount;bufferedAmountLowEventTimeout;maxMessageSize;receiveFinAck;finAckTimeout;openTimeout;closeController;constructor(e){const t=e.onEnd;switch(e.onEnd=i=>{this.log.trace('readable and writeable ends closed with status "%s"',this.status),Promise.resolve(async()=>{if(!(this.timeline.abort!=null||this.timeline.reset!==null))try{await um(this.receiveFinAck.promise,{milliseconds:this.finAckTimeout})}catch(s){this.log.error("error receiving FIN_ACK",s)}}).then(()=>{this.incomingData.end(),t?.(i)}).catch(s=>{this.log.error("error ending stream",s)}).finally(()=>{this.channel.close()})},super(e),this.channel=e.channel,this.channel.binaryType="arraybuffer",this.incomingData=go(),this.bufferedAmountLowEventTimeout=e.bufferedAmountLowEventTimeout??sN,this.maxBufferedAmount=e.maxBufferedAmount??iN,this.maxMessageSize=(e.maxMessageSize??cd)-aN,this.receiveFinAck=Ve(),this.finAckTimeout=e.closeTimeout??cN,this.openTimeout=e.openTimeout??lN,this.closeController=new AbortController,this.channel.readyState){case"open":this.timeline.open=new Date().getTime();break;case"closed":case"closing":(this.timeline.close===void 0||this.timeline.close===0)&&(this.timeline.close=Date.now());break;case"connecting":break;default:throw this.log.error("unknown datachannel state %s",this.channel.readyState),new wf("Unknown datachannel state")}this.channel.onopen=i=>{this.timeline.open=new Date().getTime()},this.channel.onclose=i=>{this.log.trace("received onclose event"),this.closeController.abort(),this.receiveFinAck.resolve(),this.close().catch(s=>{this.log.error("error closing stream after channel closed",s)})},this.channel.onerror=i=>{this.log.trace("received onerror event"),this.closeController.abort();const s=i.error;this.abort(s)},this.channel.onmessage=async i=>{const{data:s}=i;s===null||s.byteLength===0||this.incomingData.push(new Uint8Array(s,0,s.byteLength))};const n=this;Promise.resolve().then(async()=>{for await(const i of Dl(this.incomingData)){const s=n.processIncomingProtobuf(i);s!=null&&n.sourcePush(new ye(s))}}).catch(i=>{this.log.error("error processing incoming data channel messages",i)})}sendNewStream(){}async _sendMessage(e,t=!0){if(this.channel.readyState==="closed"||this.channel.readyState==="closing")throw new wf(`Invalid datachannel state - ${this.channel.readyState}`);if(this.channel.readyState!=="open"){const n=AbortSignal.timeout(this.openTimeout),i=Vr([this.closeController.signal,n]);try{this.log('channel state is "%s" and not "open", waiting for "open" event before sending data',this.channel.readyState),await Ur(this.channel,"open",i)}finally{i.clear()}this.log('channel state is now "%s", sending data',this.channel.readyState)}if(t&&this.channel.bufferedAmount>this.maxBufferedAmount){const n=AbortSignal.timeout(this.bufferedAmountLowEventTimeout),i=Vr([this.closeController.signal,n]);try{this.log('channel buffer is %d, wait for "bufferedamountlow" event',this.channel.bufferedAmount),await Ur(this.channel,"bufferedamountlow",i)}catch(s){throw n.aborted?new Ig(`Timed out waiting for DataChannel buffer to clear after ${this.bufferedAmountLowEventTimeout}ms`):s}finally{i.clear()}}try{this.log.trace('sending message, channel state "%s"',this.channel.readyState),this.channel.send(e.subarray())}catch(n){this.log.error("error while sending message",n)}}async sendData(e){const t=e.byteLength;for(e=e.sublist();e.byteLength>0;){const n=Math.min(e.byteLength,this.maxMessageSize),i=e.subarray(0,n),s=Nt.encode({message:i}),o=Nl.single(s);this.log.trace("sending %d/%d bytes on channel",i.byteLength,t),await this._sendMessage(o),e.consume(n)}this.log.trace('finished sending data, channel state "%s"',this.channel.readyState)}async sendReset(){try{await this._sendFlag(Nt.Flag.RESET)}catch(e){this.log.error("failed to send reset - %e",e)}finally{this.channel.close()}}async sendCloseWrite(e){if(this.channel.readyState!=="open"){this.receiveFinAck.resolve();return}if(await this._sendFlag(Nt.Flag.FIN)){this.log.trace("awaiting FIN_ACK");try{await At(this.receiveFinAck.promise,e?.signal,{errorMessage:"sending close-write was aborted before FIN_ACK was received",errorName:"FinAckNotReceivedError"})}catch(n){this.log.error("failed to await FIN_ACK",n)}}else this.log.trace("sending FIN failed, not awaiting FIN_ACK");this.receiveFinAck.resolve()}async sendCloseRead(){this.channel.readyState==="open"&&await this._sendFlag(Nt.Flag.STOP_SENDING)}processIncomingProtobuf(e){const t=Nt.decode(e);if(t.flag!==void 0&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',t.flag,this.writeStatus,this.readStatus),t.flag===Nt.Flag.FIN&&(this.remoteCloseWrite(),this.log.trace("sending FIN_ACK"),this._sendFlag(Nt.Flag.FIN_ACK).catch(n=>{this.log.error("error sending FIN_ACK immediately",n)})),t.flag===Nt.Flag.RESET&&this.reset(),t.flag===Nt.Flag.STOP_SENDING&&this.remoteCloseRead(),t.flag===Nt.Flag.FIN_ACK&&(this.log.trace("received FIN_ACK"),this.receiveFinAck.resolve())),this.readStatus==="ready")return t.message}async _sendFlag(e){if(this.channel.readyState!=="open")return this.log.trace('not sending flag %s because channel is "%s" and not "open"',e.toString(),this.channel.readyState),!1;this.log.trace("sending flag %s",e.toString());const t=Nt.encode({flag:e}),n=Nl.single(t);try{return await this._sendMessage(n,!1),!0}catch(i){this.log.error("could not send flag %s - %e",e.toString(),i)}return!1}}function Zl(r){const{channel:e,direction:t,handshake:n}=r;return new RN({id:`${e.id}`,log:r.logger.forComponent(`libp2p:webrtc:stream:${n===!0?"handshake":t}:${e.id}`),...r})}class hm{protocol;peerConnection;bufferedStreams=[];metrics;dataChannelOptions;components;log;constructor(e,t){this.components=e,this.peerConnection=t.peerConnection,this.metrics=t.metrics,this.protocol=t.protocol??c1,this.dataChannelOptions=t.dataChannelOptions??{},this.log=e.logger.forComponent("libp2p:webrtc:muxerfactory"),this.peerConnection.ondatachannel=({channel:n})=>{if(this.log.trace('incoming early datachannel with channel id %d and label "%s"',n.id),n.label==="init"){this.log.trace("closing early init channel"),n.close();return}const i={},s=Zl({channel:n,direction:"inbound",onEnd:o=>{i.onEnd(o)},logger:e.logger,...this.dataChannelOptions});i.stream=s,i.channel=n,i.onEnd=()=>{this.bufferedStreams=this.bufferedStreams.filter(o=>o.stream.id!==s.id)},this.bufferedStreams.push(i)}}createStreamMuxer(e){return new ON(this.components,{...e,peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,streams:this.bufferedStreams,protocol:this.protocol})}}class ON{init;streams;protocol;log;peerConnection;dataChannelOptions;metrics;logger;constructor(e,t){this.init=t,this.log=e.logger.forComponent("libp2p:webrtc:muxer"),this.logger=e.logger,this.streams=t.streams.map(n=>n.stream),this.peerConnection=t.peerConnection,this.protocol=t.protocol??c1,this.metrics=t.metrics,this.dataChannelOptions=t.dataChannelOptions??{},this.peerConnection.ondatachannel=({channel:n})=>{if(this.log.trace("incoming datachannel with channel id %d",n.id),n.label==="init"){this.log.trace("closing init channel"),n.close();return}const i=n.id,s=Zl({channel:n,direction:"inbound",onEnd:()=>{this.#e(s,n),this.log("incoming channel %s ended",i)},logger:this.logger,...this.dataChannelOptions});this.streams.push(s),this.metrics?.increment({incoming_stream:!0}),t?.onIncomingStream?.(s)},this.init.streams.length>0&&queueMicrotask(()=>{this.init.streams.forEach(n=>{n.onEnd=()=>{this.log("incoming early channel %s ended with state %s",n.channel.id,n.channel.readyState),this.#e(n.stream,n.channel)},this.metrics?.increment({incoming_stream:!0}),this.init?.onIncomingStream?.(n.stream)})})}#e(e,t){this.log.trace("stream %s %s %s onEnd",e.direction,e.id,e.protocol),TN(t,`${e.direction} ${e.id} ${e.protocol}`,this.dataChannelOptions.drainTimeout,{log:this.log}),this.streams=this.streams.filter(n=>n.id!==e.id),this.metrics?.increment({stream_end:!0}),this.init?.onStreamEnd?.(e)}async close(e){try{await Promise.all(this.streams.map(async t=>t.close(e)))}catch(t){this.abort(t)}}abort(e){for(const t of this.streams)t.abort(e)}source=u1();sink=d1;newStream(){const e=this.peerConnection.createDataChannel(""),t=e.id;this.log.trace("opened outgoing datachannel with channel id %s",t);const n=Zl({channel:e,direction:"outbound",onEnd:()=>{this.#e(n,e),this.log("outgoing channel %s ended",t)},logger:this.logger,...this.dataChannelOptions});return this.streams.push(n),this.metrics?.increment({outgoing_stream:!0}),n}}const h1=globalThis.RTCPeerConnection,f1=globalThis.RTCSessionDescription,BN=globalThis.RTCIceCandidate;class tc extends Error{constructor(e){super(`WebRTC transport error: ${e}`),this.name="WebRTCTransportError"}}class Mn extends tc{constructor(e="SDP handshake failed"){super(e),this.name="SDPHandshakeFailedError"}}class NN extends tc{constructor(e,t){super(`Invalid fingerprint "${e}" within ${t}`),this.name="WebRTC/InvalidFingerprintError"}}class DN extends tc{constructor(e){super(`A method (${e}) was called though it has been intentionally left unimplemented.`),this.name="WebRTC/UnimplementedError"}}class LN extends tc{constructor(e){super(`unsupported hash algorithm code: ${e} please see the codes at https://github.com/multiformats/multicodec/blob/master/table.csv `),this.name="WebRTC/UnsupportedHashAlgorithmError"}}var wr;(function(r){(function(n){n.SDP_OFFER="SDP_OFFER",n.SDP_ANSWER="SDP_ANSWER",n.ICE_CANDIDATE="ICE_CANDIDATE"})(r.Type||(r.Type={}));let e;(function(n){n[n.SDP_OFFER=0]="SDP_OFFER",n[n.SDP_ANSWER=1]="SDP_ANSWER",n[n.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(e||(e={})),function(n){n.codec=()=>hn(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=Oe((n,i,s={})=>{s.lengthDelimited!==!1&&i.fork(),n.type!=null&&(i.uint32(8),r.Type.codec().encode(n.type,i)),n.data!=null&&(i.uint32(18),i.string(n.data)),s.lengthDelimited!==!1&&i.ldelim()},(n,i,s={})=>{const o={},a=i==null?n.len:n.pos+i;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.data=n.string();break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>Re(n,r.codec()),r.decode=(n,i)=>Pe(n,r.codec(),i)})(wr||(wr={}));const p1=async(r,e,t)=>{try{const n=Ve();for(MN(r,n);;){const i=await Promise.race([n.promise,e.read({signal:t.signal}).catch(()=>{})]);if(i==null){t.signal?.throwIfAborted();break}if(i.type!==wr.Type.ICE_CANDIDATE)throw new bt("ICE candidate message expected");const s=JSON.parse(i.data??"null");if(s===""||s===null){t.onProgress?.(new ke("webrtc:end-of-ice-candidates")),t.log.trace("end-of-candidates received");continue}const o=new BN(s);t.log.trace("%s received new ICE candidate %o",t.direction,s);try{t.onProgress?.(new ke("webrtc:add-ice-candidate",o.candidate)),await r.addIceCandidate(o)}catch(a){t.log.error("%s bad candidate received",t.direction,s,a)}}}catch(n){if(t.log.error("%s error parsing ICE candidate",t.direction,n),t.signal?.aborted===!0&&fm(r)!=="connected")throw n}};function fm(r){return dm?r.iceConnectionState:r.connectionState}function MN(r,e){r[dm?"oniceconnectionstatechange":"onconnectionstatechange"]=t=>{switch(fm(r)){case"connected":e.resolve();break;case"failed":case"disconnected":case"closed":e.reject(new zv("RTCPeerConnection was closed"));break}}}async function FN({rtcConfiguration:r,dataChannel:e,signal:t,metrics:n,multiaddr:i,connectionManager:s,transportManager:o,log:a,logger:c,onProgress:l}){const{baseAddr:u}=qN(i);n?.dialerEvents.increment({open:!0}),a.trace("dialing base address: %a",u);const d=u.getPeerId();if(d==null)throw new q("Relay peer was missing");const h=s.getConnections(xr(d));let p,m=!1;h.length===0?(l?.(new ke("webrtc:dial-relay")),p=await o.dial(u,{signal:t,onProgress:l}),m=!0):(l?.(new ke("webrtc:reuse-relay-connection")),p=h[0]);try{l?.(new ke("webrtc:open-signaling-stream"));const w=await p.newStream(Kf,{signal:t,runOnLimitedConnection:!0}),y=Qt(w).pb(wr),b=new h1(r),_=new hm({logger:c},{peerConnection:b,dataChannelOptions:e});try{const E=b.createDataChannel("init");b.onicecandidate=({candidate:T})=>{const B=JSON.stringify(T?.toJSON()??null);a.trace("initiator sending ICE candidate %o",T),y.write({type:wr.Type.ICE_CANDIDATE,data:B},{signal:t}).catch(v=>{a.error("error sending ICE candidate",v)})},b.onicecandidateerror=T=>{a.error("initiator ICE candidate error",T)};const R=await b.createOffer().catch(T=>{throw a.error("could not execute createOffer",T),new Mn("Failed to set createOffer")});a.trace("initiator send SDP offer %s",R.sdp),l?.(new ke("webrtc:send-sdp-offer")),await y.write({type:wr.Type.SDP_OFFER,data:R.sdp},{signal:t}),await b.setLocalDescription(R).catch(T=>{throw a.error("could not execute setLocalDescription",T),new Mn("Failed to set localDescription")}),l?.(new ke("webrtc:read-sdp-answer")),a.trace("initiator read SDP answer");const S=await y.read({signal:t});if(S.type!==wr.Type.SDP_ANSWER)throw new Mn("Remote should send an SDP answer");a.trace("initiator received SDP answer %s",S.data);const N=new f1({type:"answer",sdp:S.data});return await b.setRemoteDescription(N).catch(T=>{throw a.error("could not execute setRemoteDescription",T),new Mn("Failed to set remoteDescription")}),a.trace("initiator read candidates until connected"),l?.(new ke("webrtc:read-ice-candidates")),await p1(b,y,{direction:"initiator",signal:t,log:a,onProgress:l}),a.trace("initiator connected, closing init channel"),E.close(),l?.(new ke("webrtc:close-signaling-stream")),a.trace("closing signaling channel"),await w.close({signal:t}),a.trace("initiator connected to remote address %s",i),{remoteAddress:i,peerConnection:b,muxerFactory:_}}catch(E){throw a.error("outgoing signaling error",E),b.close(),w.abort(E),E}finally{b.onicecandidate=null,b.onicecandidateerror=null}}finally{if(m)try{await p.close({signal:t})}catch(w){p.abort(w)}}}const rb=Ne(WE.matchers[0],he("p2p-circuit"));class pm extends sr{transportManager;shutdownController;events;constructor(e,t){super(),this.transportManager=e.transportManager,this.events=e.events,this.shutdownController=t.shutdownController,this.onTransportListening=this.onTransportListening.bind(this)}async listen(){this.events.addEventListener("transport:listening",this.onTransportListening)}onTransportListening(e){e.detail.getAddrs().filter(n=>rb.exactMatch(n)).map(n=>n.encapsulate("/webrtc")).length>0&&this.safeDispatchEvent("listening")}getAddrs(){return this.transportManager.getListeners().filter(e=>!(e instanceof pm)).map(e=>e.getAddrs().filter(t=>rb.exactMatch(t)).map(t=>t.encapsulate("/webrtc"))).flat()}updateAnnounceAddrs(){}async close(){this.events.removeEventListener("transport:listening",this.onTransportListening),this.shutdownController.abort(),queueMicrotask(()=>{this.safeDispatchEvent("close")})}}async function UN({peerConnection:r,stream:e,signal:t,connection:n,log:i}){i.trace("new inbound signaling stream");const s=Qt(e).pb(wr);try{r.onicecandidate=({candidate:u})=>{const d=JSON.stringify(u?.toJSON()??null);i.trace("recipient sending ICE candidate %s",d),s.write({type:wr.Type.ICE_CANDIDATE,data:d},{signal:t}).catch(h=>{i.error("error sending ICE candidate",h)})},i.trace("recipient read SDP offer");const a=await s.read({signal:t});if(a.type!==wr.Type.SDP_OFFER)throw new Mn(`expected message type SDP_OFFER, received: ${a.type??"undefined"} `);i.trace("recipient received SDP offer %s",a.data);const c=new f1({type:"offer",sdp:a.data});await r.setRemoteDescription(c).catch(u=>{throw i.error("could not execute setRemoteDescription",u),new Mn("Failed to set remoteDescription")});const l=await r.createAnswer().catch(u=>{throw i.error("could not execute createAnswer",u),new Mn("Failed to create answer")});i.trace("recipient send SDP answer %s",l.sdp),await s.write({type:wr.Type.SDP_ANSWER,data:l.sdp},{signal:t}),await r.setLocalDescription(l).catch(u=>{throw i.error("could not execute setLocalDescription",u),new Mn("Failed to set localDescription")}),i.trace("recipient read candidates until connected"),await p1(r,s,{direction:"recipient",signal:t,log:i})}catch(a){if(fm(r)!=="connected")throw i.error("error while handling signaling stream from peer %a",n.remoteAddr,a),r.close(),a;i("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",n.remoteAddr,a)}const o=de(`/webrtc/p2p/${n.remoteAddr.getPeerId()}`);return i.trace("recipient connected to remote address %s",o),{remoteAddress:o}}class $N{components;init;log;_started=!1;metrics;shutdownController;constructor(e,t={}){this.components=e,this.init=t,this.log=e.logger.forComponent("libp2p:webrtc"),this.shutdownController=new AbortController,this.shutdownController.signal,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}[zu]=!0;[Symbol.toStringTag]="@libp2p/webrtc";[$t]=["@libp2p/transport"];[Os]=["@libp2p/identify","@libp2p/circuit-relay-v2-transport"];isStarted(){return this._started}async start(){await this.components.registrar.handle(Kf,e=>{const t=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);this._onProtocol(e,t).catch(n=>{this.log.error("failed to handle incoming connect from %p",e.connection.remotePeer,n)}).finally(()=>{t.clear()})},{runOnLimitedConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(Kf),this._started=!1}createListener(e){return new pm(this.components,{shutdownController:this.shutdownController})}listenFilter(e){return e.filter(Jl.exactMatch)}dialFilter(e){return this.listenFilter(e)}async dial(e,t){this.log.trace("dialing address: %a",e);const{remoteAddress:n,peerConnection:i,muxerFactory:s}=await FN({rtcConfiguration:await tb(this.init.rtcConfiguration),dataChannel:this.init.dataChannel,multiaddr:e,dataChannelOptions:this.init.dataChannel,signal:t.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager,log:this.log,logger:this.components.logger,onProgress:t.onProgress}),o=new Vf(this.components,{peerConnection:i,timeline:{open:Date.now()},remoteAddr:n,metrics:this.metrics?.dialerEvents}),a=await t.upgrader.upgradeOutbound(o,{skipProtection:!0,skipEncryption:!0,muxerFactory:s,onProgress:t.onProgress,signal:t.signal});return this._closeOnShutdown(i,o),a}async _onProtocol({connection:e,stream:t},n){const i=new h1(await tb(this.init.rtcConfiguration)),s=new hm(this.components,{peerConnection:i,dataChannelOptions:this.init.dataChannel});try{const{remoteAddress:o}=await UN({peerConnection:i,connection:e,stream:t,signal:n,log:this.log});await t.close({signal:n});const a=new Vf(this.components,{peerConnection:i,timeline:{open:new Date().getTime()},remoteAddr:o,metrics:this.metrics?.listenerEvents});await this.components.upgrader.upgradeInbound(a,{skipEncryption:!0,skipProtection:!0,muxerFactory:s,signal:n}),this._closeOnShutdown(i,a)}catch(o){throw this.log.error("incoming signaling error",o),i.close(),t.abort(o),o}}_closeOnShutdown(e,t){const n=()=>{t.close().catch(i=>{this.log.error("could not close WebRTCMultiaddrConnection",i)})};this.shutdownController.signal.addEventListener("abort",n),e.addEventListener("close",()=>{this.shutdownController.signal.removeEventListener("abort",n)})}}function qN(r){const e=r.toString().split("/webrtc/");if(e.length!==2)throw new q("webrtc protocol was not present in multiaddr");if(!e[0].includes("/p2p-circuit"))throw new q("p2p-circuit protocol was not present in multiaddr");let t=de(e[0]);const i=de("/"+e[1]).getPeerId();if(i==null)throw new q("destination peer id was missing");const s=t.protos().pop();if(s===void 0)throw new q("invalid multiaddr");return s.name!=="p2p"&&(t=t.encapsulate(`/p2p/${i}`)),{baseAddr:t,peerId:xr(i)}}var nb={};/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */var ib;function KN(){if(ib)return nb;ib=1;var r;return function(e){(function(t){var n=typeof globalThis=="object"?globalThis:typeof jw=="object"?jw:typeof self=="object"?self:typeof this=="object"?this:c(),i=s(e);typeof n.Reflect<"u"&&(i=s(n.Reflect,i)),t(i,n),typeof n.Reflect>"u"&&(n.Reflect=e);function s(l,u){return function(d,h){Object.defineProperty(l,d,{configurable:!0,writable:!0,value:h}),u&&u(d,h)}}function o(){try{return Function("return this;")()}catch{}}function a(){try{return(0,eval)("(function() { return this; })()")}catch{}}function c(){return o()||a()}})(function(t,n){var i=Object.prototype.hasOwnProperty,s=typeof Symbol=="function",o=s&&typeof Symbol.toPrimitive<"u"?Symbol.toPrimitive:"@@toPrimitive",a=s&&typeof Symbol.iterator<"u"?Symbol.iterator:"@@iterator",c=typeof Object.create=="function",l={__proto__:[]}instanceof Array,u=!c&&!l,d={create:c?function(){return oh(Object.create(null))}:l?function(){return oh({__proto__:null})}:function(){return oh({})},has:u?function(x,k){return i.call(x,k)}:function(x,k){return k in x},get:u?function(x,k){return i.call(x,k)?x[k]:void 0}:function(x,k){return x[k]}},h=Object.getPrototypeOf(Function),p=typeof Map=="function"&&typeof Map.prototype.entries=="function"?Map:Z_(),m=typeof Set=="function"&&typeof Set.prototype.entries=="function"?Set:eC(),w=typeof WeakMap=="function"?WeakMap:tC(),y=s?Symbol.for("@reflect-metadata:registry"):void 0,b=Q_(),_=J_(b);function E(x,k,D,H){if(z(D)){if(!Cy(x))throw new TypeError;if(!Iy(k))throw new TypeError;return O(x,k)}else{if(!Cy(x))throw new TypeError;if(!le(k))throw new TypeError;if(!le(H)&&!z(H)&&!ve(H))throw new TypeError;return ve(H)&&(H=void 0),D=Ye(D),L(x,k,D,H)}}t("decorate",E);function R(x,k){function D(H,ce){if(!le(H))throw new TypeError;if(!z(ce)&&!G_(ce))throw new TypeError;V(x,k,H,ce)}return D}t("metadata",R);function S(x,k,D,H){if(!le(D))throw new TypeError;return z(H)||(H=Ye(H)),V(x,k,D,H)}t("defineMetadata",S);function N(x,k,D){if(!le(k))throw new TypeError;return z(D)||(D=Ye(D)),M(x,k,D)}t("hasMetadata",N);function T(x,k,D){if(!le(k))throw new TypeError;return z(D)||(D=Ye(D)),U(x,k,D)}t("hasOwnMetadata",T);function B(x,k,D){if(!le(k))throw new TypeError;return z(D)||(D=Ye(D)),K(x,k,D)}t("getMetadata",B);function v(x,k,D){if(!le(k))throw new TypeError;return z(D)||(D=Ye(D)),j(x,k,D)}t("getOwnMetadata",v);function I(x,k){if(!le(x))throw new TypeError;return z(k)||(k=Ye(k)),se(x,k)}t("getMetadataKeys",I);function C(x,k){if(!le(x))throw new TypeError;return z(k)||(k=Ye(k)),Y(x,k)}t("getOwnMetadataKeys",C);function P(x,k,D){if(!le(k))throw new TypeError;if(z(D)||(D=Ye(D)),!le(k))throw new TypeError;z(D)||(D=Ye(D));var H=Oo(k,D,!1);return z(H)?!1:H.OrdinaryDeleteMetadata(x,k,D)}t("deleteMetadata",P);function O(x,k){for(var D=x.length-1;D>=0;--D){var H=x[D],ce=H(k);if(!z(ce)&&!ve(ce)){if(!Iy(ce))throw new TypeError;k=ce}}return k}function L(x,k,D,H){for(var ce=x.length-1;ce>=0;--ce){var je=x[ce],Xe=je(k,D,H);if(!z(Xe)&&!ve(Xe)){if(!le(Xe))throw new TypeError;H=Xe}}return H}function M(x,k,D){var H=U(x,k,D);if(H)return!0;var ce=sh(k);return ve(ce)?!1:M(x,ce,D)}function U(x,k,D){var H=Oo(k,D,!1);return z(H)?!1:Ge(H.OrdinaryHasOwnMetadata(x,k,D))}function K(x,k,D){var H=U(x,k,D);if(H)return j(x,k,D);var ce=sh(k);if(!ve(ce))return K(x,ce,D)}function j(x,k,D){var H=Oo(k,D,!1);if(!z(H))return H.OrdinaryGetOwnMetadata(x,k,D)}function V(x,k,D,H){var ce=Oo(D,H,!0);ce.OrdinaryDefineOwnMetadata(x,k,D,H)}function se(x,k){var D=Y(x,k),H=sh(x);if(H===null)return D;var ce=se(H,k);if(ce.length<=0)return D;if(D.length<=0)return ce;for(var je=new m,Xe=[],pe=0,Q=D;pe<Q.length;pe++){var ee=Q[pe],re=je.has(ee);re||(je.add(ee),Xe.push(ee))}for(var ie=0,ge=ce;ie<ge.length;ie++){var ee=ge[ie],re=je.has(ee);re||(je.add(ee),Xe.push(ee))}return Xe}function Y(x,k){var D=Oo(x,k,!1);return D?D.OrdinaryOwnMetadataKeys(x,k):[]}function ae(x){if(x===null)return 1;switch(typeof x){case"undefined":return 0;case"boolean":return 2;case"string":return 3;case"symbol":return 4;case"number":return 5;case"object":return x===null?1:6;default:return 6}}function z(x){return x===void 0}function ve(x){return x===null}function fe(x){return typeof x=="symbol"}function le(x){return typeof x=="object"?x!==null:typeof x=="function"}function pt(x,k){switch(ae(x)){case 0:return x;case 1:return x;case 2:return x;case 3:return x;case 4:return x;case 5:return x}var D="string",H=ky(x,o);if(H!==void 0){var ce=H.call(x,D);if(le(ce))throw new TypeError;return ce}return tt(x)}function tt(x,k){var D,H,ce;{var je=x.toString;if(Ec(je)){var H=je.call(x);if(!le(H))return H}var D=x.valueOf;if(Ec(D)){var H=D.call(x);if(!le(H))return H}}throw new TypeError}function Ge(x){return!!x}function An(x){return""+x}function Ye(x){var k=pt(x);return fe(k)?k:An(k)}function Cy(x){return Array.isArray?Array.isArray(x):x instanceof Object?x instanceof Array:Object.prototype.toString.call(x)==="[object Array]"}function Ec(x){return typeof x=="function"}function Iy(x){return typeof x=="function"}function G_(x){switch(ae(x)){case 3:return!0;case 4:return!0;default:return!1}}function ih(x,k){return x===k||x!==x&&k!==k}function ky(x,k){var D=x[k];if(D!=null){if(!Ec(D))throw new TypeError;return D}}function Ty(x){var k=ky(x,a);if(!Ec(k))throw new TypeError;var D=k.call(x);if(!le(D))throw new TypeError;return D}function Py(x){return x.value}function Ry(x){var k=x.next();return k.done?!1:k}function Oy(x){var k=x.return;k&&k.call(x)}function sh(x){var k=Object.getPrototypeOf(x);if(typeof x!="function"||x===h||k!==h)return k;var D=x.prototype,H=D&&Object.getPrototypeOf(D);if(H==null||H===Object.prototype)return k;var ce=H.constructor;return typeof ce!="function"||ce===x?k:ce}function Y_(){var x;!z(y)&&typeof n.Reflect<"u"&&!(y in n.Reflect)&&typeof n.Reflect.defineMetadata=="function"&&(x=X_(n.Reflect));var k,D,H,ce=new w,je={registerProvider:Xe,getProvider:Q,setProvider:re};return je;function Xe(ie){if(!Object.isExtensible(je))throw new Error("Cannot add provider to a frozen registry.");switch(!0){case x===ie:break;case z(k):k=ie;break;case k===ie:break;case z(D):D=ie;break;case D===ie:break;default:H===void 0&&(H=new m),H.add(ie);break}}function pe(ie,ge){if(!z(k)){if(k.isProviderFor(ie,ge))return k;if(!z(D)){if(D.isProviderFor(ie,ge))return k;if(!z(H))for(var De=Ty(H);;){var He=Ry(De);if(!He)return;var dr=Py(He);if(dr.isProviderFor(ie,ge))return Oy(De),dr}}}if(!z(x)&&x.isProviderFor(ie,ge))return x}function Q(ie,ge){var De=ce.get(ie),He;return z(De)||(He=De.get(ge)),z(He)&&(He=pe(ie,ge),z(He)||(z(De)&&(De=new p,ce.set(ie,De)),De.set(ge,He))),He}function ee(ie){if(z(ie))throw new TypeError;return k===ie||D===ie||!z(H)&&H.has(ie)}function re(ie,ge,De){if(!ee(De))throw new Error("Metadata provider not registered.");var He=Q(ie,ge);if(He!==De){if(!z(He))return!1;var dr=ce.get(ie);z(dr)&&(dr=new p,ce.set(ie,dr)),dr.set(ge,De)}return!0}}function Q_(){var x;return!z(y)&&le(n.Reflect)&&Object.isExtensible(n.Reflect)&&(x=n.Reflect[y]),z(x)&&(x=Y_()),!z(y)&&le(n.Reflect)&&Object.isExtensible(n.Reflect)&&Object.defineProperty(n.Reflect,y,{enumerable:!1,configurable:!1,writable:!1,value:x}),x}function J_(x){var k=new w,D={isProviderFor:function(ee,re){var ie=k.get(ee);return z(ie)?!1:ie.has(re)},OrdinaryDefineOwnMetadata:Xe,OrdinaryHasOwnMetadata:ce,OrdinaryGetOwnMetadata:je,OrdinaryOwnMetadataKeys:pe,OrdinaryDeleteMetadata:Q};return b.registerProvider(D),D;function H(ee,re,ie){var ge=k.get(ee),De=!1;if(z(ge)){if(!ie)return;ge=new p,k.set(ee,ge),De=!0}var He=ge.get(re);if(z(He)){if(!ie)return;if(He=new p,ge.set(re,He),!x.setProvider(ee,re,D))throw ge.delete(re),De&&k.delete(ee),new Error("Wrong provider for target.")}return He}function ce(ee,re,ie){var ge=H(re,ie,!1);return z(ge)?!1:Ge(ge.has(ee))}function je(ee,re,ie){var ge=H(re,ie,!1);if(!z(ge))return ge.get(ee)}function Xe(ee,re,ie,ge){var De=H(ie,ge,!0);De.set(ee,re)}function pe(ee,re){var ie=[],ge=H(ee,re,!1);if(z(ge))return ie;for(var De=ge.keys(),He=Ty(De),dr=0;;){var By=Ry(He);if(!By)return ie.length=dr,ie;var rC=Py(By);try{ie[dr]=rC}catch(nC){try{Oy(He)}finally{throw nC}}dr++}}function Q(ee,re,ie){var ge=H(re,ie,!1);if(z(ge)||!ge.delete(ee))return!1;if(ge.size===0){var De=k.get(re);z(De)||(De.delete(ie),De.size===0&&k.delete(De))}return!0}}function X_(x){var k=x.defineMetadata,D=x.hasOwnMetadata,H=x.getOwnMetadata,ce=x.getOwnMetadataKeys,je=x.deleteMetadata,Xe=new w,pe={isProviderFor:function(Q,ee){var re=Xe.get(Q);return!z(re)&&re.has(ee)?!0:ce(Q,ee).length?(z(re)&&(re=new m,Xe.set(Q,re)),re.add(ee),!0):!1},OrdinaryDefineOwnMetadata:k,OrdinaryHasOwnMetadata:D,OrdinaryGetOwnMetadata:H,OrdinaryOwnMetadataKeys:ce,OrdinaryDeleteMetadata:je};return pe}function Oo(x,k,D){var H=b.getProvider(x,k);if(!z(H))return H;if(D){if(b.setProvider(x,k,_))return _;throw new Error("Illegal state.")}}function Z_(){var x={},k=[],D=function(){function pe(Q,ee,re){this._index=0,this._keys=Q,this._values=ee,this._selector=re}return pe.prototype["@@iterator"]=function(){return this},pe.prototype[a]=function(){return this},pe.prototype.next=function(){var Q=this._index;if(Q>=0&&Q<this._keys.length){var ee=this._selector(this._keys[Q],this._values[Q]);return Q+1>=this._keys.length?(this._index=-1,this._keys=k,this._values=k):this._index++,{value:ee,done:!1}}return{value:void 0,done:!0}},pe.prototype.throw=function(Q){throw this._index>=0&&(this._index=-1,this._keys=k,this._values=k),Q},pe.prototype.return=function(Q){return this._index>=0&&(this._index=-1,this._keys=k,this._values=k),{value:Q,done:!0}},pe}(),H=function(){function pe(){this._keys=[],this._values=[],this._cacheKey=x,this._cacheIndex=-2}return Object.defineProperty(pe.prototype,"size",{get:function(){return this._keys.length},enumerable:!0,configurable:!0}),pe.prototype.has=function(Q){return this._find(Q,!1)>=0},pe.prototype.get=function(Q){var ee=this._find(Q,!1);return ee>=0?this._values[ee]:void 0},pe.prototype.set=function(Q,ee){var re=this._find(Q,!0);return this._values[re]=ee,this},pe.prototype.delete=function(Q){var ee=this._find(Q,!1);if(ee>=0){for(var re=this._keys.length,ie=ee+1;ie<re;ie++)this._keys[ie-1]=this._keys[ie],this._values[ie-1]=this._values[ie];return this._keys.length--,this._values.length--,ih(Q,this._cacheKey)&&(this._cacheKey=x,this._cacheIndex=-2),!0}return!1},pe.prototype.clear=function(){this._keys.length=0,this._values.length=0,this._cacheKey=x,this._cacheIndex=-2},pe.prototype.keys=function(){return new D(this._keys,this._values,ce)},pe.prototype.values=function(){return new D(this._keys,this._values,je)},pe.prototype.entries=function(){return new D(this._keys,this._values,Xe)},pe.prototype["@@iterator"]=function(){return this.entries()},pe.prototype[a]=function(){return this.entries()},pe.prototype._find=function(Q,ee){if(!ih(this._cacheKey,Q)){this._cacheIndex=-1;for(var re=0;re<this._keys.length;re++)if(ih(this._keys[re],Q)){this._cacheIndex=re;break}}return this._cacheIndex<0&&ee&&(this._cacheIndex=this._keys.length,this._keys.push(Q),this._values.push(void 0)),this._cacheIndex},pe}();return H;function ce(pe,Q){return pe}function je(pe,Q){return Q}function Xe(pe,Q){return[pe,Q]}}function eC(){var x=function(){function k(){this._map=new p}return Object.defineProperty(k.prototype,"size",{get:function(){return this._map.size},enumerable:!0,configurable:!0}),k.prototype.has=function(D){return this._map.has(D)},k.prototype.add=function(D){return this._map.set(D,D),this},k.prototype.delete=function(D){return this._map.delete(D)},k.prototype.clear=function(){this._map.clear()},k.prototype.keys=function(){return this._map.keys()},k.prototype.values=function(){return this._map.keys()},k.prototype.entries=function(){return this._map.entries()},k.prototype["@@iterator"]=function(){return this.keys()},k.prototype[a]=function(){return this.keys()},k}();return x}function tC(){var x=16,k=d.create(),D=H();return function(){function Q(){this._key=H()}return Q.prototype.has=function(ee){var re=ce(ee,!1);return re!==void 0?d.has(re,this._key):!1},Q.prototype.get=function(ee){var re=ce(ee,!1);return re!==void 0?d.get(re,this._key):void 0},Q.prototype.set=function(ee,re){var ie=ce(ee,!0);return ie[this._key]=re,this},Q.prototype.delete=function(ee){var re=ce(ee,!1);return re!==void 0?delete re[this._key]:!1},Q.prototype.clear=function(){this._key=H()},Q}();function H(){var Q;do Q="@@WeakMap@@"+pe();while(d.has(k,Q));return k[Q]=!0,Q}function ce(Q,ee){if(!i.call(Q,D)){if(!ee)return;Object.defineProperty(Q,D,{value:d.create()})}return Q[D]}function je(Q,ee){for(var re=0;re<ee;++re)Q[re]=Math.random()*255|0;return Q}function Xe(Q){if(typeof Uint8Array=="function"){var ee=new Uint8Array(Q);return typeof crypto<"u"?crypto.getRandomValues(ee):typeof msCrypto<"u"?msCrypto.getRandomValues(ee):je(ee,Q),ee}return je(new Array(Q),Q)}function pe(){var Q=Xe(x);Q[6]=Q[6]&79|64,Q[8]=Q[8]&191|128;for(var ee="",re=0;re<x;++re){var ie=Q[re];(re===4||re===6||re===8)&&(ee+="-"),ie<16&&(ee+="0"),ee+=ie.toString(16).toLowerCase()}return ee}}function oh(x){return x.__=void 0,delete x.__,x}})}(r||(r={})),nb}KN();/*!
 * MIT License
 * 
 * Copyright (c) 2017-2024 Peculiar Ventures, LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */const VN="[object ArrayBuffer]";class G{static isArrayBuffer(e){return Object.prototype.toString.call(e)===VN}static toArrayBuffer(e){return this.isArrayBuffer(e)?e:e.byteLength===e.buffer.byteLength||e.byteOffset===0&&e.byteLength===e.buffer.byteLength?e.buffer:this.toUint8Array(e.buffer).slice(e.byteOffset,e.byteOffset+e.byteLength).buffer}static toUint8Array(e){return this.toView(e,Uint8Array)}static toView(e,t){if(e.constructor===t)return e;if(this.isArrayBuffer(e))return new t(e);if(this.isArrayBufferView(e))return new t(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(e){return this.isArrayBufferView(e)||this.isArrayBuffer(e)}static isArrayBufferView(e){return ArrayBuffer.isView(e)||e&&this.isArrayBuffer(e.buffer)}static isEqual(e,t){const n=G.toUint8Array(e),i=G.toUint8Array(t);if(n.length!==i.byteLength)return!1;for(let s=0;s<n.length;s++)if(n[s]!==i[s])return!1;return!0}static concat(...e){let t;Array.isArray(e[0])&&!(e[1]instanceof Function)||Array.isArray(e[0])&&e[1]instanceof Function?t=e[0]:e[e.length-1]instanceof Function?t=e.slice(0,e.length-1):t=e;let n=0;for(const o of t)n+=o.byteLength;const i=new Uint8Array(n);let s=0;for(const o of t){const a=this.toUint8Array(o);i.set(a,s),s+=a.length}return e[e.length-1]instanceof Function?this.toView(i,e[e.length-1]):i.buffer}}const xh="string",zN=/^[0-9a-f\s]+$/i,jN=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,HN=/^[a-zA-Z0-9-_]+$/;class sb{static fromString(e){const t=unescape(encodeURIComponent(e)),n=new Uint8Array(t.length);for(let i=0;i<t.length;i++)n[i]=t.charCodeAt(i);return n.buffer}static toString(e){const t=G.toUint8Array(e);let n="";for(let s=0;s<t.length;s++)n+=String.fromCharCode(t[s]);return decodeURIComponent(escape(n))}}class Tr{static toString(e,t=!1){const n=G.toArrayBuffer(e),i=new DataView(n);let s="";for(let o=0;o<n.byteLength;o+=2){const a=i.getUint16(o,t);s+=String.fromCharCode(a)}return s}static fromString(e,t=!1){const n=new ArrayBuffer(e.length*2),i=new DataView(n);for(let s=0;s<e.length;s++)i.setUint16(s*2,e.charCodeAt(s),t);return n}}class te{static isHex(e){return typeof e===xh&&zN.test(e)}static isBase64(e){return typeof e===xh&&jN.test(e)}static isBase64Url(e){return typeof e===xh&&HN.test(e)}static ToString(e,t="utf8"){const n=G.toUint8Array(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(n);case"binary":return this.ToBinary(n);case"hex":return this.ToHex(n);case"base64":return this.ToBase64(n);case"base64url":return this.ToBase64Url(n);case"utf16le":return Tr.toString(n,!0);case"utf16":case"utf16be":return Tr.toString(n);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){if(!e)return new ArrayBuffer(0);switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);case"utf16le":return Tr.fromString(e,!0);case"utf16":case"utf16be":return Tr.fromString(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(e){const t=G.toUint8Array(e);if(typeof btoa<"u"){const n=this.ToString(t,"binary");return btoa(n)}else return Buffer.from(t).toString("base64")}static FromBase64(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!te.isBase64(t))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(t)):new Uint8Array(Buffer.from(t,"base64")).buffer}static FromBase64Url(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!te.isBase64Url(t))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e,t=te.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.FromBinary(e);case"utf8":return sb.fromString(e);case"utf16":case"utf16be":return Tr.fromString(e);case"utf16le":case"usc2":return Tr.fromString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToUtf8String(e,t=te.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.ToBinary(e);case"utf8":return sb.toString(e);case"utf16":case"utf16be":return Tr.toString(e);case"utf16le":case"usc2":return Tr.toString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromBinary(e){const t=e.length,n=new Uint8Array(t);for(let i=0;i<t;i++)n[i]=e.charCodeAt(i);return n.buffer}static ToBinary(e){const t=G.toUint8Array(e);let n="";for(let i=0;i<t.length;i++)n+=String.fromCharCode(t[i]);return n}static ToHex(e){const t=G.toUint8Array(e);let n="";const i=t.length;for(let s=0;s<i;s++){const o=t[s];o<16&&(n+="0"),n+=o.toString(16)}return n}static FromHex(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!te.isHex(t))throw new TypeError("Argument 'hexString' is not HEX encoded");t.length%2&&(t=`0${t}`);const n=new Uint8Array(t.length/2);for(let i=0;i<t.length;i=i+2){const s=t.slice(i,i+2);n[i/2]=parseInt(s,16)}return n.buffer}static ToUtf16String(e,t=!1){return Tr.toString(e,t)}static FromUtf16String(e,t=!1){return Tr.fromString(e,t)}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let n=0;n<t;n++)e+="=";return e}static formatString(e){return e?.replace(/[\n\r\t ]/g,"")||""}}te.DEFAULT_UTF8_ENCODING="utf8";function WN(...r){const e=r.map(i=>i.byteLength).reduce((i,s)=>i+s),t=new Uint8Array(e);let n=0;return r.map(i=>new Uint8Array(i)).forEach(i=>{for(const s of i)t[n++]=s}),t.buffer}function g1(r,e){if(!(r&&e)||r.byteLength!==e.byteLength)return!1;const t=new Uint8Array(r),n=new Uint8Array(e);for(let i=0;i<r.byteLength;i++)if(t[i]!==n[i])return!1;return!0}/*!
 Copyright (c) Peculiar Ventures, LLC
*/function js(r,e){let t=0;if(r.length===1)return r[0];for(let n=r.length-1;n>=0;n--)t+=r[r.length-1-n]*Math.pow(2,e*n);return t}function Li(r,e,t=-1){const n=t;let i=r,s=0,o=Math.pow(2,e);for(let a=1;a<8;a++){if(r<o){let c;if(n<0)c=new ArrayBuffer(a),s=a;else{if(n<a)return new ArrayBuffer(0);c=new ArrayBuffer(n),s=n}const l=new Uint8Array(c);for(let u=a-1;u>=0;u--){const d=Math.pow(2,u*e);l[s-u-1]=Math.floor(i/d),i-=l[s-u-1]*d}return c}o*=Math.pow(2,e)}return new ArrayBuffer(0)}function zf(...r){let e=0,t=0;for(const s of r)e+=s.length;const n=new ArrayBuffer(e),i=new Uint8Array(n);for(const s of r)i.set(s,t),t+=s.length;return i}function m1(){const r=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const a=r[0]===255&&r[1]&128,c=r[0]===0&&(r[1]&128)===0;(a||c)&&this.warnings.push("Needlessly long format")}const e=new ArrayBuffer(this.valueHex.byteLength),t=new Uint8Array(e);for(let a=0;a<this.valueHex.byteLength;a++)t[a]=0;t[0]=r[0]&128;const n=js(t,8),i=new ArrayBuffer(this.valueHex.byteLength),s=new Uint8Array(i);for(let a=0;a<this.valueHex.byteLength;a++)s[a]=r[a];return s[0]&=127,js(s,8)-n}function GN(r){const e=r<0?r*-1:r;let t=128;for(let n=1;n<8;n++){if(e<=t){if(r<0){const o=t-e,a=Li(o,8,n),c=new Uint8Array(a);return c[0]|=128,a}let i=Li(e,8,n),s=new Uint8Array(i);if(s[0]&128){const o=i.slice(0),a=new Uint8Array(o);i=new ArrayBuffer(i.byteLength+1),s=new Uint8Array(i);for(let c=0;c<o.byteLength;c++)s[c+1]=a[c];s[0]=0}return i}t*=Math.pow(2,8)}return new ArrayBuffer(0)}function YN(r,e){if(r.byteLength!==e.byteLength)return!1;const t=new Uint8Array(r),n=new Uint8Array(e);for(let i=0;i<t.length;i++)if(t[i]!==n[i])return!1;return!0}function Ht(r,e){const t=r.toString(10);if(e<t.length)return"";const n=e-t.length,i=new Array(n);for(let o=0;o<n;o++)i[o]="0";return i.join("").concat(t)}/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */function eu(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function gm(r){let e=0,t=0;for(let i=0;i<r.length;i++){const s=r[i];e+=s.byteLength}const n=new Uint8Array(e);for(let i=0;i<r.length;i++){const s=r[i];n.set(new Uint8Array(s),t),t+=s.byteLength}return n.buffer}function vn(r,e,t,n){return e instanceof Uint8Array?e.byteLength?t<0?(r.error="Wrong parameter: inputOffset less than zero",!1):n<0?(r.error="Wrong parameter: inputLength less than zero",!1):e.byteLength-t-n<0?(r.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(r.error="Wrong parameter: inputBuffer has zero length",!1):(r.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}class ld{constructor(){this.items=[]}write(e){this.items.push(e)}final(){return gm(this.items)}}const Uo=[new Uint8Array([1])],ob="0123456789",_h="name",ab="valueHexView",QN="isHexOnly",JN="idBlock",XN="tagClass",ZN="tagNumber",eD="isConstructed",tD="fromBER",rD="toBER",nD="local",Lt="",Cr=new ArrayBuffer(0),ud=new Uint8Array(0),_a="EndOfContent",y1="OCTET STRING",w1="BIT STRING";function Hr(r){var e;return e=class extends r{get valueHex(){return this.valueHexView.slice().buffer}set valueHex(n){this.valueHexView=new Uint8Array(n)}constructor(...n){var i;super(...n);const s=n[0]||{};this.isHexOnly=(i=s.isHexOnly)!==null&&i!==void 0?i:!1,this.valueHexView=s.valueHex?G.toUint8Array(s.valueHex):ud}fromBER(n,i,s){const o=n instanceof ArrayBuffer?new Uint8Array(n):n;if(!vn(this,o,i,s))return-1;const a=i+s;return this.valueHexView=o.subarray(i,a),this.valueHexView.length?(this.blockLength=s,a):(this.warnings.push("Zero buffer length"),i)}toBER(n=!1){return this.isHexOnly?n?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",Cr)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:te.ToHex(this.valueHexView)}}},e.NAME="hexBlock",e}class es{static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(e){this.valueBeforeDecodeView=new Uint8Array(e)}constructor({blockLength:e=0,error:t=Lt,warnings:n=[],valueBeforeDecode:i=ud}={}){this.blockLength=e,this.error=t,this.warnings=n,this.valueBeforeDecodeView=G.toUint8Array(i)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:te.ToHex(this.valueBeforeDecodeView)}}}es.NAME="baseBlock";class Ot extends es{fromBER(e,t,n){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(e,t){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}}Ot.NAME="valueBlock";class b1 extends Hr(es){constructor({idBlock:e={}}={}){var t,n,i,s;super(),e?(this.isHexOnly=(t=e.isHexOnly)!==null&&t!==void 0?t:!1,this.valueHexView=e.valueHex?G.toUint8Array(e.valueHex):ud,this.tagClass=(n=e.tagClass)!==null&&n!==void 0?n:-1,this.tagNumber=(i=e.tagNumber)!==null&&i!==void 0?i:-1,this.isConstructed=(s=e.isConstructed)!==null&&s!==void 0?s:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(e=!1){let t=0;switch(this.tagClass){case 1:t|=0;break;case 2:t|=64;break;case 3:t|=128;break;case 4:t|=192;break;default:return this.error="Unknown tag class",Cr}if(this.isConstructed&&(t|=32),this.tagNumber<31&&!this.isHexOnly){const i=new Uint8Array(1);if(!e){let s=this.tagNumber;s&=31,t|=s,i[0]=t}return i.buffer}if(!this.isHexOnly){const i=Li(this.tagNumber,7),s=new Uint8Array(i),o=i.byteLength,a=new Uint8Array(o+1);if(a[0]=t|31,!e){for(let c=0;c<o-1;c++)a[c+1]=s[c]|128;a[o]=s[o-1]}return a.buffer}const n=new Uint8Array(this.valueHexView.byteLength+1);if(n[0]=t|31,!e){const i=this.valueHexView;for(let s=0;s<i.length-1;s++)n[s+1]=i[s]|128;n[this.valueHexView.byteLength]=i[i.length-1]}return n.buffer}fromBER(e,t,n){const i=G.toUint8Array(e);if(!vn(this,i,t,n))return-1;const s=i.subarray(t,t+n);if(s.length===0)return this.error="Zero buffer length",-1;switch(s[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(s[0]&32)===32,this.isHexOnly=!1;const a=s[0]&31;if(a!==31)this.tagNumber=a,this.blockLength=1;else{let c=1,l=this.valueHexView=new Uint8Array(255),u=255;for(;s[c]&128;){if(l[c-1]=s[c]&127,c++,c>=s.length)return this.error="End of input reached before message was fully decoded",-1;if(c===u){u+=255;const h=new Uint8Array(u);for(let p=0;p<l.length;p++)h[p]=l[p];l=this.valueHexView=new Uint8Array(u)}}this.blockLength=c+1,l[c-1]=s[c]&127;const d=new Uint8Array(c);for(let h=0;h<c;h++)d[h]=l[h];l=this.valueHexView=new Uint8Array(c),l.set(d),this.blockLength<=9?this.tagNumber=js(l,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}}b1.NAME="identificationBlock";class v1 extends es{constructor({lenBlock:e={}}={}){var t,n,i;super(),this.isIndefiniteForm=(t=e.isIndefiniteForm)!==null&&t!==void 0?t:!1,this.longFormUsed=(n=e.longFormUsed)!==null&&n!==void 0?n:!1,this.length=(i=e.length)!==null&&i!==void 0?i:0}fromBER(e,t,n){const i=G.toUint8Array(e);if(!vn(this,i,t,n))return-1;const s=i.subarray(t,t+n);if(s.length===0)return this.error="Zero buffer length",-1;if(s[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=s[0]===128,this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(s[0]&128),this.longFormUsed===!1)return this.length=s[0],this.blockLength=1,t+this.blockLength;const o=s[0]&127;if(o>8)return this.error="Too big integer",-1;if(o+1>s.length)return this.error="End of input reached before message was fully decoded",-1;const a=t+1,c=i.subarray(a,a+o);return c[o-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=js(c,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=o+1,t+this.blockLength}toBER(e=!1){let t,n;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),e===!1&&(n=new Uint8Array(t),n[0]=128),t;if(this.longFormUsed){const i=Li(this.length,8);if(i.byteLength>127)return this.error="Too big length",Cr;if(t=new ArrayBuffer(i.byteLength+1),e)return t;const s=new Uint8Array(i);n=new Uint8Array(t),n[0]=i.byteLength|128;for(let o=0;o<i.byteLength;o++)n[o+1]=s[o];return t}return t=new ArrayBuffer(1),e===!1&&(n=new Uint8Array(t),n[0]=this.length),t}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}}v1.NAME="lengthBlock";const X={};class ut extends es{constructor({name:e=Lt,optional:t=!1,primitiveSchema:n,...i}={},s){super(i),this.name=e,this.optional=t,n&&(this.primitiveSchema=n),this.idBlock=new b1(i),this.lenBlock=new v1(i),this.valueBlock=s?new s(i):new Ot(i)}fromBER(e,t,n){const i=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return i===-1?(this.error=this.valueBlock.error,i):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),i)}toBER(e,t){const n=t||new ld;t||S1(this);const i=this.idBlock.toBER(e);if(n.write(i),this.lenBlock.isIndefiniteForm)n.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(e,n),n.write(new ArrayBuffer(2));else{const s=this.valueBlock.toBER(e);this.lenBlock.length=s.byteLength;const o=this.lenBlock.toBER(e);n.write(o),n.write(s)}return t?Cr:n.final()}toJSON(){const e={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}toString(e="ascii"){return e==="ascii"?this.onAsciiEncoding():te.ToHex(this.toBER())}onAsciiEncoding(){const e=this.constructor.NAME,t=te.ToHex(this.valueBlock.valueBeforeDecodeView);return`${e} : ${t}`}isEqual(e){if(this===e)return!0;if(!(e instanceof this.constructor))return!1;const t=this.toBER(),n=e.toBER();return YN(t,n)}}ut.NAME="BaseBlock";function S1(r){var e;if(r instanceof X.Constructed)for(const t of r.valueBlock.value)S1(t)&&(r.lenBlock.isIndefiniteForm=!0);return!!(!((e=r.lenBlock)===null||e===void 0)&&e.isIndefiniteForm)}class mm extends ut{getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}constructor({value:e=Lt,...t}={},n){super(t,n),e&&this.fromString(e)}fromBER(e,t,n){const i=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return i===-1?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),i)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}}mm.NAME="BaseStringBlock";class E1 extends Hr(Ot){constructor({isHexOnly:e=!0,...t}={}){super(t),this.isHexOnly=e}}E1.NAME="PrimitiveValueBlock";var A1;class rc extends ut{constructor(e={}){super(e,E1),this.idBlock.isConstructed=!1}}A1=rc;X.Primitive=A1;rc.NAME="PRIMITIVE";function iD(r,e){if(r instanceof e)return r;const t=new e;return t.idBlock=r.idBlock,t.lenBlock=r.lenBlock,t.warnings=r.warnings,t.valueBeforeDecodeView=r.valueBeforeDecodeView,t}function vo(r,e=0,t=r.length){const n=e;let i=new ut({},Ot);const s=new es;if(!vn(s,r,e,t))return i.error=s.error,{offset:-1,result:i};if(!r.subarray(e,e+t).length)return i.error="Zero buffer length",{offset:-1,result:i};let a=i.idBlock.fromBER(r,e,t);if(i.idBlock.warnings.length&&i.warnings.concat(i.idBlock.warnings),a===-1)return i.error=i.idBlock.error,{offset:-1,result:i};if(e=a,t-=i.idBlock.blockLength,a=i.lenBlock.fromBER(r,e,t),i.lenBlock.warnings.length&&i.warnings.concat(i.lenBlock.warnings),a===-1)return i.error=i.lenBlock.error,{offset:-1,result:i};if(e=a,t-=i.lenBlock.blockLength,!i.idBlock.isConstructed&&i.lenBlock.isIndefiniteForm)return i.error="Indefinite length form used for primitive encoding form",{offset:-1,result:i};let c=ut;switch(i.idBlock.tagClass){case 1:if(i.idBlock.tagNumber>=37&&i.idBlock.isHexOnly===!1)return i.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:i};switch(i.idBlock.tagNumber){case 0:if(i.idBlock.isConstructed&&i.lenBlock.length>0)return i.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:i};c=X.EndOfContent;break;case 1:c=X.Boolean;break;case 2:c=X.Integer;break;case 3:c=X.BitString;break;case 4:c=X.OctetString;break;case 5:c=X.Null;break;case 6:c=X.ObjectIdentifier;break;case 10:c=X.Enumerated;break;case 12:c=X.Utf8String;break;case 13:c=X.RelativeObjectIdentifier;break;case 14:c=X.TIME;break;case 15:return i.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:i};case 16:c=X.Sequence;break;case 17:c=X.Set;break;case 18:c=X.NumericString;break;case 19:c=X.PrintableString;break;case 20:c=X.TeletexString;break;case 21:c=X.VideotexString;break;case 22:c=X.IA5String;break;case 23:c=X.UTCTime;break;case 24:c=X.GeneralizedTime;break;case 25:c=X.GraphicString;break;case 26:c=X.VisibleString;break;case 27:c=X.GeneralString;break;case 28:c=X.UniversalString;break;case 29:c=X.CharacterString;break;case 30:c=X.BmpString;break;case 31:c=X.DATE;break;case 32:c=X.TimeOfDay;break;case 33:c=X.DateTime;break;case 34:c=X.Duration;break;default:{const l=i.idBlock.isConstructed?new X.Constructed:new X.Primitive;l.idBlock=i.idBlock,l.lenBlock=i.lenBlock,l.warnings=i.warnings,i=l}}break;case 2:case 3:case 4:default:c=i.idBlock.isConstructed?X.Constructed:X.Primitive}return i=iD(i,c),a=i.fromBER(r,e,i.lenBlock.isIndefiniteForm?t:i.lenBlock.length),i.valueBeforeDecodeView=r.subarray(n,n+i.blockLength),{offset:a,result:i}}function cn(r){if(!r.byteLength){const e=new ut({},Ot);return e.error="Input buffer has zero length",{offset:-1,result:e}}return vo(G.toUint8Array(r).slice(),0,r.byteLength)}function sD(r,e){return r?1:e}class jn extends Ot{constructor({value:e=[],isIndefiniteForm:t=!1,...n}={}){super(n),this.value=e,this.isIndefiniteForm=t}fromBER(e,t,n){const i=G.toUint8Array(e);if(!vn(this,i,t,n))return-1;if(this.valueBeforeDecodeView=i.subarray(t,t+n),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),t;let s=t;for(;sD(this.isIndefiniteForm,n)>0;){const o=vo(i,s,n);if(o.offset===-1)return this.error=o.result.error,this.warnings.concat(o.result.warnings),-1;if(s=o.offset,this.blockLength+=o.result.blockLength,n-=o.result.blockLength,this.value.push(o.result),this.isIndefiniteForm&&o.result.constructor.NAME===_a)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===_a?this.value.pop():this.warnings.push("No EndOfContent block encoded")),s}toBER(e,t){const n=t||new ld;for(let i=0;i<this.value.length;i++)this.value[i].toBER(e,n);return t?Cr:n.final()}toJSON(){const e={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(const t of this.value)e.value.push(t.toJSON());return e}}jn.NAME="ConstructedValueBlock";var x1;class Ut extends ut{constructor(e={}){super(e,jn),this.idBlock.isConstructed=!0}fromBER(e,t,n){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const i=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return i===-1?(this.error=this.valueBlock.error,i):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),i)}onAsciiEncoding(){const e=[];for(const n of this.valueBlock.value)e.push(n.toString("ascii").split(`
`).map(i=>`  ${i}`).join(`
`));const t=this.idBlock.tagClass===3?`[${this.idBlock.tagNumber}]`:this.constructor.NAME;return e.length?`${t} :
${e.join(`
`)}`:`${t} :`}}x1=Ut;X.Constructed=x1;Ut.NAME="CONSTRUCTED";class _1 extends Ot{fromBER(e,t,n){return t}toBER(e){return Cr}}_1.override="EndOfContentValueBlock";var C1;class ym extends ut{constructor(e={}){super(e,_1),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}}C1=ym;X.EndOfContent=C1;ym.NAME=_a;var I1;class pn extends ut{constructor(e={}){super(e,Ot),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}fromBER(e,t,n){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=n,t+n>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+n}toBER(e,t){const n=new ArrayBuffer(2);if(!e){const i=new Uint8Array(n);i[0]=5,i[1]=0}return t&&t.write(n),n}onAsciiEncoding(){return`${this.constructor.NAME}`}}I1=pn;X.Null=I1;pn.NAME="NULL";class k1 extends Hr(Ot){get value(){for(const e of this.valueHexView)if(e>0)return!0;return!1}set value(e){this.valueHexView[0]=e?255:0}constructor({value:e,...t}={}){super(t),t.valueHex?this.valueHexView=G.toUint8Array(t.valueHex):this.valueHexView=new Uint8Array(1),e&&(this.value=e)}fromBER(e,t,n){const i=G.toUint8Array(e);return vn(this,i,t,n)?(this.valueHexView=i.subarray(t,t+n),n>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,m1.call(this),this.blockLength=n,t+n):-1}toBER(){return this.valueHexView.slice()}toJSON(){return{...super.toJSON(),value:this.value}}}k1.NAME="BooleanValueBlock";var T1;let dd=class extends ut{getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}constructor(e={}){super(e,k1),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.getValue}`}};T1=dd;X.Boolean=T1;dd.NAME="BOOLEAN";class P1 extends Hr(jn){constructor({isConstructed:e=!1,...t}={}){super(t),this.isConstructed=e}fromBER(e,t,n){let i=0;if(this.isConstructed){if(this.isHexOnly=!1,i=jn.prototype.fromBER.call(this,e,t,n),i===-1)return i;for(let s=0;s<this.value.length;s++){const o=this.value[s].constructor.NAME;if(o===_a){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(o!==y1)return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,i=super.fromBER(e,t,n),this.blockLength=n;return i}toBER(e,t){return this.isConstructed?jn.prototype.toBER.call(this,e,t):e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),isConstructed:this.isConstructed}}}P1.NAME="OctetStringValueBlock";var wm;let br=class extends ut{constructor({idBlock:e={},lenBlock:t={},...n}={}){var i,s;(i=n.isConstructed)!==null&&i!==void 0||(n.isConstructed=!!(!((s=n.value)===null||s===void 0)&&s.length)),super({idBlock:{isConstructed:n.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!n.isIndefiniteForm},...n},P1),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,n){if(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,n===0)return this.idBlock.error.length===0&&(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length===0&&(this.blockLength+=this.lenBlock.blockLength),t;if(!this.valueBlock.isConstructed){const s=(e instanceof ArrayBuffer?new Uint8Array(e):e).subarray(t,t+n);try{if(s.byteLength){const o=vo(s,0,s.byteLength);o.offset!==-1&&o.offset===n&&(this.valueBlock.value=[o.result])}}catch{}}return super.fromBER(e,t,n)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return Ut.prototype.onAsciiEncoding.call(this);const e=this.constructor.NAME,t=te.ToHex(this.valueBlock.valueHexView);return`${e} : ${t}`}getValue(){if(!this.idBlock.isConstructed)return this.valueBlock.valueHexView.slice().buffer;const e=[];for(const t of this.valueBlock.value)t instanceof wm&&e.push(t.valueBlock.valueHexView);return G.concat(e)}};wm=br;X.OctetString=wm;br.NAME=y1;class R1 extends Hr(jn){constructor({unusedBits:e=0,isConstructed:t=!1,...n}={}){super(n),this.unusedBits=e,this.isConstructed=t,this.blockLength=this.valueHexView.byteLength}fromBER(e,t,n){if(!n)return t;let i=-1;if(this.isConstructed){if(i=jn.prototype.fromBER.call(this,e,t,n),i===-1)return i;for(const a of this.value){const c=a.constructor.NAME;if(c===_a){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(c!==w1)return this.error="BIT STRING may consists of BIT STRINGs only",-1;const l=a.valueBlock;if(this.unusedBits>0&&l.unusedBits>0)return this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only',-1;this.unusedBits=l.unusedBits}return i}const s=G.toUint8Array(e);if(!vn(this,s,t,n))return-1;const o=s.subarray(t,t+n);if(this.unusedBits=o[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;if(!this.unusedBits){const a=o.subarray(1);try{if(a.byteLength){const c=vo(a,0,a.byteLength);c.offset!==-1&&c.offset===n-1&&(this.value=[c.result])}}catch{}}return this.valueHexView=o.subarray(1),this.blockLength=o.length,t+n}toBER(e,t){if(this.isConstructed)return jn.prototype.toBER.call(this,e,t);if(e)return new ArrayBuffer(this.valueHexView.byteLength+1);if(!this.valueHexView.byteLength)return Cr;const n=new Uint8Array(this.valueHexView.length+1);return n[0]=this.unusedBits,n.set(this.valueHexView,1),n.buffer}toJSON(){return{...super.toJSON(),unusedBits:this.unusedBits,isConstructed:this.isConstructed}}}R1.NAME="BitStringValueBlock";var O1;let ki=class extends ut{constructor({idBlock:e={},lenBlock:t={},...n}={}){var i,s;(i=n.isConstructed)!==null&&i!==void 0||(n.isConstructed=!!(!((s=n.value)===null||s===void 0)&&s.length)),super({idBlock:{isConstructed:n.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!n.isIndefiniteForm},...n},R1),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}fromBER(e,t,n){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,n)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return Ut.prototype.onAsciiEncoding.call(this);{const e=[],t=this.valueBlock.valueHexView;for(const o of t)e.push(o.toString(2).padStart(8,"0"));const n=e.join(""),i=this.constructor.NAME,s=n.substring(0,n.length-this.valueBlock.unusedBits);return`${i} : ${s}`}}};O1=ki;X.BitString=O1;ki.NAME=w1;var B1;function oD(r,e){const t=new Uint8Array([0]),n=new Uint8Array(r),i=new Uint8Array(e);let s=n.slice(0);const o=s.length-1,a=i.slice(0),c=a.length-1;let l=0;const u=c<o?o:c;let d=0;for(let h=u;h>=0;h--,d++){switch(!0){case d<a.length:l=s[o-d]+a[c-d]+t[0];break;default:l=s[o-d]+t[0]}switch(t[0]=l/10,!0){case d>=s.length:s=zf(new Uint8Array([l%10]),s);break;default:s[o-d]=l%10}}return t[0]>0&&(s=zf(t,s)),s}function cb(r){if(r>=Uo.length)for(let e=Uo.length;e<=r;e++){const t=new Uint8Array([0]);let n=Uo[e-1].slice(0);for(let i=n.length-1;i>=0;i--){const s=new Uint8Array([(n[i]<<1)+t[0]]);t[0]=s[0]/10,n[i]=s[0]%10}t[0]>0&&(n=zf(t,n)),Uo.push(n)}return Uo[r]}function aD(r,e){let t=0;const n=new Uint8Array(r),i=new Uint8Array(e),s=n.slice(0),o=s.length-1,a=i.slice(0),c=a.length-1;let l,u=0;for(let d=c;d>=0;d--,u++)switch(l=s[o-u]-a[c-u]-t,!0){case l<0:t=1,s[o-u]=l+10;break;default:t=0,s[o-u]=l}if(t>0)for(let d=o-c+1;d>=0;d--,u++)if(l=s[o-u]-t,l<0)t=1,s[o-u]=l+10;else{t=0,s[o-u]=l;break}return s.slice()}class bm extends Hr(Ot){setValueHex(){this.valueHexView.length>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,this.valueHexView.length>0&&(this._valueDec=m1.call(this)))}constructor({value:e,...t}={}){super(t),this._valueDec=0,t.valueHex&&this.setValueHex(),e!==void 0&&(this.valueDec=e)}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this.valueHexView=new Uint8Array(GN(e))}get valueDec(){return this._valueDec}fromDER(e,t,n,i=0){const s=this.fromBER(e,t,n);if(s===-1)return s;const o=this.valueHexView;return o[0]===0&&(o[1]&128)!==0?this.valueHexView=o.subarray(1):i!==0&&o.length<i&&(i-o.length>1&&(i=o.length+1),this.valueHexView=o.subarray(i-o.length)),s}toDER(e=!1){const t=this.valueHexView;switch(!0){case(t[0]&128)!==0:{const n=new Uint8Array(this.valueHexView.length+1);n[0]=0,n.set(t,1),this.valueHexView=n}break;case(t[0]===0&&(t[1]&128)===0):this.valueHexView=this.valueHexView.subarray(1);break}return this.toBER(e)}fromBER(e,t,n){const i=super.fromBER(e,t,n);return i===-1||this.setValueHex(),i}toBER(e){return e?new ArrayBuffer(this.valueHexView.length):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}toString(){const e=this.valueHexView.length*8-1;let t=new Uint8Array(this.valueHexView.length*8/3),n=0,i;const s=this.valueHexView;let o="",a=!1;for(let c=s.byteLength-1;c>=0;c--){i=s[c];for(let l=0;l<8;l++){if((i&1)===1)switch(n){case e:t=aD(cb(n),t),o="-";break;default:t=oD(t,cb(n))}n++,i>>=1}}for(let c=0;c<t.length;c++)t[c]&&(a=!0),a&&(o+=ob.charAt(t[c]));return a===!1&&(o+=ob.charAt(0)),o}}B1=bm;bm.NAME="IntegerValueBlock";Object.defineProperty(B1.prototype,"valueHex",{set:function(r){this.valueHexView=new Uint8Array(r),this.setValueHex()},get:function(){return this.valueHexView.slice().buffer}});var aa;class ln extends ut{constructor(e={}){super(e,bm),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}toBigInt(){return eu(),BigInt(this.valueBlock.toString())}static fromBigInt(e){eu();const t=BigInt(e),n=new ld,i=t.toString(16).replace(/^-/,""),s=new Uint8Array(te.FromHex(i));if(t<0){const a=new Uint8Array(s.length+(s[0]&128?1:0));a[0]|=128;const l=BigInt(`0x${te.ToHex(a)}`)+t,u=G.toUint8Array(te.FromHex(l.toString(16)));u[0]|=128,n.write(u)}else s[0]&128&&n.write(new Uint8Array([0])),n.write(s);return new aa({valueHex:n.final()})}convertToDER(){const e=new aa({valueHex:this.valueBlock.valueHexView});return e.valueBlock.toDER(),e}convertFromDER(){return new aa({valueHex:this.valueBlock.valueHexView[0]===0?this.valueBlock.valueHexView.subarray(1):this.valueBlock.valueHexView})}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()}`}}aa=ln;X.Integer=aa;ln.NAME="INTEGER";var N1;class hd extends ln{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}}N1=hd;X.Enumerated=N1;hd.NAME="ENUMERATED";class jf extends Hr(Ot){constructor({valueDec:e=-1,isFirstSid:t=!1,...n}={}){super(n),this.valueDec=e,this.isFirstSid=t}fromBER(e,t,n){if(!n)return t;const i=G.toUint8Array(e);if(!vn(this,i,t,n))return-1;const s=i.subarray(t,t+n);this.valueHexView=new Uint8Array(n);for(let a=0;a<n&&(this.valueHexView[a]=s[a]&127,this.blockLength++,(s[a]&128)!==0);a++);const o=new Uint8Array(this.blockLength);for(let a=0;a<this.blockLength;a++)o[a]=this.valueHexView[a];return this.valueHexView=o,(s[this.blockLength-1]&128)!==0?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=js(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}set valueBigInt(e){eu();let t=BigInt(e).toString(2);for(;t.length%7;)t="0"+t;const n=new Uint8Array(t.length/7);for(let i=0;i<n.length;i++)n[i]=parseInt(t.slice(i*7,i*7+7),2)+(i+1<n.length?128:0);this.fromBER(n.buffer,0,n.length)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const i=this.valueHexView,s=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)s[o]=i[o]|128;return s[this.blockLength-1]=i[this.blockLength-1],s.buffer}const t=Li(this.valueDec,7);if(t.byteLength===0)return this.error="Error during encoding SID value",Cr;const n=new Uint8Array(t.byteLength);if(!e){const i=new Uint8Array(t),s=t.byteLength-1;for(let o=0;o<s;o++)n[o]=i[o]|128;n[s]=i[s]}return n}toString(){let e="";if(this.isHexOnly)e=te.ToHex(this.valueHexView);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec,isFirstSid:this.isFirstSid}}}jf.NAME="sidBlock";class D1 extends Ot{constructor({value:e=Lt,...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,n){let i=t;for(;n>0;){const s=new jf;if(i=s.fromBER(e,i,n),i===-1)return this.blockLength=0,this.error=s.error,i;this.value.length===0&&(s.isFirstSid=!0),this.blockLength+=s.blockLength,n-=s.blockLength,this.value.push(s)}return i}toBER(e){const t=[];for(let n=0;n<this.value.length;n++){const i=this.value[n].toBER(e);if(i.byteLength===0)return this.error=this.value[n].error,Cr;t.push(i)}return gm(t)}fromString(e){this.value=[];let t=0,n=0,i="",s=!1;do if(n=e.indexOf(".",t),n===-1?i=e.substring(t):i=e.substring(t,n),t=n+1,s){const o=this.value[0];let a=0;switch(o.valueDec){case 0:break;case 1:a=40;break;case 2:a=80;break;default:this.value=[];return}const c=parseInt(i,10);if(isNaN(c))return;o.valueDec=c+a,s=!1}else{const o=new jf;if(i>Number.MAX_SAFE_INTEGER){eu();const a=BigInt(i);o.valueBigInt=a}else if(o.valueDec=parseInt(i,10),isNaN(o.valueDec))return;this.value.length||(o.isFirstSid=!0,s=!0),this.value.push(o)}while(n!==-1)}toString(){let e="",t=!1;for(let n=0;n<this.value.length;n++){t=this.value[n].isHexOnly;let i=this.value[n].toString();n!==0&&(e=`${e}.`),t?(i=`{${i}}`,this.value[n].isFirstSid?e=`2.{${i} - 80}`:e+=i):e+=i}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}D1.NAME="ObjectIdentifierValueBlock";var L1;class en extends ut{getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}constructor(e={}){super(e,D1),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}L1=en;X.ObjectIdentifier=L1;en.NAME="OBJECT IDENTIFIER";class Hf extends Hr(es){constructor({valueDec:e=0,...t}={}){super(t),this.valueDec=e}fromBER(e,t,n){if(n===0)return t;const i=G.toUint8Array(e);if(!vn(this,i,t,n))return-1;const s=i.subarray(t,t+n);this.valueHexView=new Uint8Array(n);for(let a=0;a<n&&(this.valueHexView[a]=s[a]&127,this.blockLength++,(s[a]&128)!==0);a++);const o=new Uint8Array(this.blockLength);for(let a=0;a<this.blockLength;a++)o[a]=this.valueHexView[a];return this.valueHexView=o,(s[this.blockLength-1]&128)!==0?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=js(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const i=this.valueHexView,s=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)s[o]=i[o]|128;return s[this.blockLength-1]=i[this.blockLength-1],s.buffer}const t=Li(this.valueDec,7);if(t.byteLength===0)return this.error="Error during encoding SID value",Cr;const n=new Uint8Array(t.byteLength);if(!e){const i=new Uint8Array(t),s=t.byteLength-1;for(let o=0;o<s;o++)n[o]=i[o]|128;n[s]=i[s]}return n.buffer}toString(){let e="";return this.isHexOnly?e=te.ToHex(this.valueHexView):e=this.valueDec.toString(),e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}}Hf.NAME="relativeSidBlock";class M1 extends Ot{constructor({value:e=Lt,...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,n){let i=t;for(;n>0;){const s=new Hf;if(i=s.fromBER(e,i,n),i===-1)return this.blockLength=0,this.error=s.error,i;this.blockLength+=s.blockLength,n-=s.blockLength,this.value.push(s)}return i}toBER(e,t){const n=[];for(let i=0;i<this.value.length;i++){const s=this.value[i].toBER(e);if(s.byteLength===0)return this.error=this.value[i].error,Cr;n.push(s)}return gm(n)}fromString(e){this.value=[];let t=0,n=0,i="";do{n=e.indexOf(".",t),n===-1?i=e.substring(t):i=e.substring(t,n),t=n+1;const s=new Hf;if(s.valueDec=parseInt(i,10),isNaN(s.valueDec))return!0;this.value.push(s)}while(n!==-1);return!0}toString(){let e="",t=!1;for(let n=0;n<this.value.length;n++){t=this.value[n].isHexOnly;let i=this.value[n].toString();n!==0&&(e=`${e}.`),t&&(i=`{${i}}`),e+=i}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}M1.NAME="RelativeObjectIdentifierValueBlock";var F1;class vm extends ut{getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}constructor(e={}){super(e,M1),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}F1=vm;X.RelativeObjectIdentifier=F1;vm.NAME="RelativeObjectIdentifier";var U1;class nt extends Ut{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}}U1=nt;X.Sequence=U1;nt.NAME="SEQUENCE";var $1;let un=class extends Ut{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}};$1=un;X.Set=$1;un.NAME="SET";class q1 extends Hr(Ot){constructor({...e}={}){super(e),this.isHexOnly=!0,this.value=Lt}toJSON(){return{...super.toJSON(),value:this.value}}}q1.NAME="StringValueBlock";class K1 extends q1{}K1.NAME="SimpleStringValueBlock";class Jt extends mm{constructor({...e}={}){super(e,K1)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,G.toUint8Array(e))}fromString(e){const t=e.length,n=this.valueBlock.valueHexView=new Uint8Array(t);for(let i=0;i<t;i++)n[i]=e.charCodeAt(i);this.valueBlock.value=e}}Jt.NAME="SIMPLE STRING";class V1 extends Jt{fromBuffer(e){this.valueBlock.valueHexView=G.toUint8Array(e);try{this.valueBlock.value=te.ToUtf8String(e)}catch(t){this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`),this.valueBlock.value=te.ToBinary(e)}}fromString(e){this.valueBlock.valueHexView=new Uint8Array(te.FromUtf8String(e)),this.valueBlock.value=e}}V1.NAME="Utf8StringValueBlock";var z1;class Sn extends V1{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}}z1=Sn;X.Utf8String=z1;Sn.NAME="UTF8String";class j1 extends Jt{fromBuffer(e){this.valueBlock.value=te.ToUtf16String(e),this.valueBlock.valueHexView=G.toUint8Array(e)}fromString(e){this.valueBlock.value=e,this.valueBlock.valueHexView=new Uint8Array(te.FromUtf16String(e))}}j1.NAME="BmpStringValueBlock";var H1;class fd extends j1{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}}H1=fd;X.BmpString=H1;fd.NAME="BMPString";class W1 extends Jt{fromBuffer(e){const t=ArrayBuffer.isView(e)?e.slice().buffer:e.slice(0),n=new Uint8Array(t);for(let i=0;i<n.length;i+=4)n[i]=n[i+3],n[i+1]=n[i+2],n[i+2]=0,n[i+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length,n=this.valueBlock.valueHexView=new Uint8Array(t*4);for(let i=0;i<t;i++){const s=Li(e.charCodeAt(i),8),o=new Uint8Array(s);if(o.length>4)continue;const a=4-o.length;for(let c=o.length-1;c>=0;c--)n[i*4+c+a]=o[c]}this.valueBlock.value=e}}W1.NAME="UniversalStringValueBlock";var G1;class pd extends W1{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}}G1=pd;X.UniversalString=G1;pd.NAME="UniversalString";var Y1;class gd extends Jt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}}Y1=gd;X.NumericString=Y1;gd.NAME="NumericString";var Q1;class md extends Jt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}}Q1=md;X.PrintableString=Q1;md.NAME="PrintableString";var J1;class yd extends Jt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}}J1=yd;X.TeletexString=J1;yd.NAME="TeletexString";var X1;class wd extends Jt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}}X1=wd;X.VideotexString=X1;wd.NAME="VideotexString";var Z1;class bd extends Jt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}}Z1=bd;X.IA5String=Z1;bd.NAME="IA5String";var eA;class vd extends Jt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}}eA=vd;X.GraphicString=eA;vd.NAME="GraphicString";var tA;class nc extends Jt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}}tA=nc;X.VisibleString=tA;nc.NAME="VisibleString";var rA;class Sd extends Jt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}}rA=Sd;X.GeneralString=rA;Sd.NAME="GeneralString";var nA;class Ed extends Jt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}}nA=Ed;X.CharacterString=nA;Ed.NAME="CharacterString";var iA;class ic extends nc{constructor({value:e,valueDate:t,...n}={}){if(super(n),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,e){this.fromString(e),this.valueBlock.valueHexView=new Uint8Array(e.length);for(let i=0;i<e.length;i++)this.valueBlock.valueHexView[i]=e.charCodeAt(i)}t&&(this.fromDate(t),this.valueBlock.valueHexView=new Uint8Array(this.toBuffer())),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,G.toUint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),n=new Uint8Array(t);for(let i=0;i<e.length;i++)n[i]=e.charCodeAt(i);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const n=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig.exec(e);if(n===null){this.error="Wrong input string for conversion";return}const i=parseInt(n[1],10);i>=50?this.year=1900+i:this.year=2e3+i,this.month=parseInt(n[2],10),this.day=parseInt(n[3],10),this.hour=parseInt(n[4],10),this.minute=parseInt(n[5],10),this.second=parseInt(n[6],10)}toString(e="iso"){if(e==="iso"){const t=new Array(7);return t[0]=Ht(this.year<2e3?this.year-1900:this.year-2e3,2),t[1]=Ht(this.month,2),t[2]=Ht(this.day,2),t[3]=Ht(this.hour,2),t[4]=Ht(this.minute,2),t[5]=Ht(this.second,2),t[6]="Z",t.join("")}return super.toString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.toDate().toISOString()}`}toJSON(){return{...super.toJSON(),year:this.year,month:this.month,day:this.day,hour:this.hour,minute:this.minute,second:this.second}}}iA=ic;X.UTCTime=iA;ic.NAME="UTCTime";var sA;class Ad extends ic{constructor(e={}){var t;super(e),(t=this.millisecond)!==null&&t!==void 0||(this.millisecond=0),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromDate(e){super.fromDate(e),this.millisecond=e.getUTCMilliseconds()}toDate(){const e=Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond);return new Date(e)}fromString(e){let t=!1,n="",i="",s=0,o,a=0,c=0;if(e[e.length-1]==="Z")n=e.substring(0,e.length-1),t=!0;else{const d=new Number(e[e.length-1]);if(isNaN(d.valueOf()))throw new Error("Wrong input string for conversion");n=e}if(t){if(n.indexOf("+")!==-1)throw new Error("Wrong input string for conversion");if(n.indexOf("-")!==-1)throw new Error("Wrong input string for conversion")}else{let d=1,h=n.indexOf("+"),p="";if(h===-1&&(h=n.indexOf("-"),d=-1),h!==-1){if(p=n.substring(h+1),n=n.substring(0,h),p.length!==2&&p.length!==4)throw new Error("Wrong input string for conversion");let m=parseInt(p.substring(0,2),10);if(isNaN(m.valueOf()))throw new Error("Wrong input string for conversion");if(a=d*m,p.length===4){if(m=parseInt(p.substring(2,4),10),isNaN(m.valueOf()))throw new Error("Wrong input string for conversion");c=d*m}}}let l=n.indexOf(".");if(l===-1&&(l=n.indexOf(",")),l!==-1){const d=new Number(`0${n.substring(l)}`);if(isNaN(d.valueOf()))throw new Error("Wrong input string for conversion");s=d.valueOf(),i=n.substring(0,l)}else i=n;switch(!0){case i.length===8:if(o=/(\d{4})(\d{2})(\d{2})/ig,l!==-1)throw new Error("Wrong input string for conversion");break;case i.length===10:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})/ig,l!==-1){let d=60*s;this.minute=Math.floor(d),d=60*(d-this.minute),this.second=Math.floor(d),d=1e3*(d-this.second),this.millisecond=Math.floor(d)}break;case i.length===12:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig,l!==-1){let d=60*s;this.second=Math.floor(d),d=1e3*(d-this.second),this.millisecond=Math.floor(d)}break;case i.length===14:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig,l!==-1){const d=1e3*s;this.millisecond=Math.floor(d)}break;default:throw new Error("Wrong input string for conversion")}const u=o.exec(i);if(u===null)throw new Error("Wrong input string for conversion");for(let d=1;d<u.length;d++)switch(d){case 1:this.year=parseInt(u[d],10);break;case 2:this.month=parseInt(u[d],10);break;case 3:this.day=parseInt(u[d],10);break;case 4:this.hour=parseInt(u[d],10)+a;break;case 5:this.minute=parseInt(u[d],10)+c;break;case 6:this.second=parseInt(u[d],10);break;default:throw new Error("Wrong input string for conversion")}if(t===!1){const d=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=d.getUTCFullYear(),this.month=d.getUTCMonth(),this.day=d.getUTCDay(),this.hour=d.getUTCHours(),this.minute=d.getUTCMinutes(),this.second=d.getUTCSeconds(),this.millisecond=d.getUTCMilliseconds()}}toString(e="iso"){if(e==="iso"){const t=[];return t.push(Ht(this.year,4)),t.push(Ht(this.month,2)),t.push(Ht(this.day,2)),t.push(Ht(this.hour,2)),t.push(Ht(this.minute,2)),t.push(Ht(this.second,2)),this.millisecond!==0&&(t.push("."),t.push(Ht(this.millisecond,3))),t.push("Z"),t.join("")}return super.toString(e)}toJSON(){return{...super.toJSON(),millisecond:this.millisecond}}}sA=Ad;X.GeneralizedTime=sA;Ad.NAME="GeneralizedTime";var oA;class Sm extends Sn{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}}oA=Sm;X.DATE=oA;Sm.NAME="DATE";var aA;class Em extends Sn{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}}aA=Em;X.TimeOfDay=aA;Em.NAME="TimeOfDay";var cA;class Am extends Sn{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}}cA=Am;X.DateTime=cA;Am.NAME="DateTime";var lA;class xm extends Sn{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}}lA=xm;X.Duration=lA;xm.NAME="Duration";var uA;class _m extends Sn{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}}uA=_m;X.TIME=uA;_m.NAME="TIME";class Mi{constructor({name:e=Lt,optional:t=!1}={}){this.name=e,this.optional=t}}class Cm extends Mi{constructor({value:e=[],...t}={}){super(t),this.value=e}}class tu extends Mi{constructor({value:e=new Mi,local:t=!1,...n}={}){super(n),this.value=e,this.local=t}}class cD{get data(){return this.dataView.slice().buffer}set data(e){this.dataView=G.toUint8Array(e)}constructor({data:e=ud}={}){this.dataView=G.toUint8Array(e)}fromBER(e,t,n){const i=t+n;return this.dataView=G.toUint8Array(e).subarray(t,i),i}toBER(e){return this.dataView.slice().buffer}}function bi(r,e,t){if(t instanceof Cm){for(const s of t.value)if(bi(r,e,s).verified)return{verified:!0,result:r};{const s={verified:!1,result:{error:"Wrong values for Choice type"}};return t.hasOwnProperty(_h)&&(s.name=t.name),s}}if(t instanceof Mi)return t.hasOwnProperty(_h)&&(r[t.name]=e),{verified:!0,result:r};if(!(r instanceof Object))return{verified:!1,result:{error:"Wrong root object"}};if(!(e instanceof Object))return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(!(t instanceof Object))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(!(JN in t))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(!(tD in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(!(rD in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const n=t.idBlock.toBER(!1);if(n.byteLength===0)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(t.idBlock.fromBER(n,0,n.byteLength)===-1)return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(t.idBlock.hasOwnProperty(XN)===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.tagClass!==e.idBlock.tagClass)return{verified:!1,result:r};if(t.idBlock.hasOwnProperty(ZN)===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.tagNumber!==e.idBlock.tagNumber)return{verified:!1,result:r};if(t.idBlock.hasOwnProperty(eD)===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.isConstructed!==e.idBlock.isConstructed)return{verified:!1,result:r};if(!(QN in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.isHexOnly!==e.idBlock.isHexOnly)return{verified:!1,result:r};if(t.idBlock.isHexOnly){if(!(ab in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const s=t.idBlock.valueHexView,o=e.idBlock.valueHexView;if(s.length!==o.length)return{verified:!1,result:r};for(let a=0;a<s.length;a++)if(s[a]!==o[1])return{verified:!1,result:r}}if(t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Lt),t.name&&(r[t.name]=e)),t instanceof X.Constructed){let s=0,o={verified:!1,result:{error:"Unknown error"}},a=t.valueBlock.value.length;if(a>0&&t.valueBlock.value[0]instanceof tu&&(a=e.valueBlock.value.length),a===0)return{verified:!0,result:r};if(e.valueBlock.value.length===0&&t.valueBlock.value.length!==0){let c=!0;for(let l=0;l<t.valueBlock.value.length;l++)c=c&&(t.valueBlock.value[l].optional||!1);return c?{verified:!0,result:r}:(t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Lt),t.name&&delete r[t.name]),r.error="Inconsistent object length",{verified:!1,result:r})}for(let c=0;c<a;c++)if(c-s>=e.valueBlock.value.length){if(t.valueBlock.value[c].optional===!1){const l={verified:!1,result:r};return r.error="Inconsistent length between ASN.1 data and schema",t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Lt),t.name&&(delete r[t.name],l.name=t.name)),l}}else if(t.valueBlock.value[0]instanceof tu){if(o=bi(r,e.valueBlock.value[c],t.valueBlock.value[0].value),o.verified===!1)if(t.valueBlock.value[0].optional)s++;else return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Lt),t.name&&delete r[t.name]),o;if(_h in t.valueBlock.value[0]&&t.valueBlock.value[0].name.length>0){let l={};nD in t.valueBlock.value[0]&&t.valueBlock.value[0].local?l=e:l=r,typeof l[t.valueBlock.value[0].name]>"u"&&(l[t.valueBlock.value[0].name]=[]),l[t.valueBlock.value[0].name].push(e.valueBlock.value[c])}}else if(o=bi(r,e.valueBlock.value[c-s],t.valueBlock.value[c]),o.verified===!1)if(t.valueBlock.value[c].optional)s++;else return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Lt),t.name&&delete r[t.name]),o;if(o.verified===!1){const c={verified:!1,result:r};return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Lt),t.name&&(delete r[t.name],c.name=t.name)),c}return{verified:!0,result:r}}if(t.primitiveSchema&&ab in e.valueBlock){const s=vo(e.valueBlock.valueHexView);if(s.offset===-1){const o={verified:!1,result:s.result};return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Lt),t.name&&(delete r[t.name],o.name=t.name)),o}return bi(r,s.result,t.primitiveSchema)}return{verified:!0,result:r}}function lD(r,e){if(!(e instanceof Object))return{verified:!1,result:{error:"Wrong ASN.1 schema type"}};const t=vo(G.toUint8Array(r));return t.offset===-1?{verified:!1,result:t.result}:bi(t.result,t.result,e)}const dA=Object.freeze(Object.defineProperty({__proto__:null,Any:Mi,BaseBlock:ut,BaseStringBlock:mm,BitString:ki,BmpString:fd,Boolean:dd,CharacterString:Ed,Choice:Cm,Constructed:Ut,DATE:Sm,DateTime:Am,Duration:xm,EndOfContent:ym,Enumerated:hd,GeneralString:Sd,GeneralizedTime:Ad,GraphicString:vd,HexBlock:Hr,IA5String:bd,Integer:ln,Null:pn,NumericString:gd,ObjectIdentifier:en,OctetString:br,Primitive:rc,PrintableString:md,RawData:cD,RelativeObjectIdentifier:vm,Repeated:tu,Sequence:nt,Set:un,TIME:_m,TeletexString:yd,TimeOfDay:Em,UTCTime:ic,UniversalString:pd,Utf8String:Sn,ValueBlock:Ot,VideotexString:wd,ViewWriter:ld,VisibleString:nc,compareSchema:bi,fromBER:cn,verifySchema:lD},Symbol.toStringTag,{value:"Module"}));var F;(function(r){r[r.Sequence=0]="Sequence",r[r.Set=1]="Set",r[r.Choice=2]="Choice"})(F||(F={}));var A;(function(r){r[r.Any=1]="Any",r[r.Boolean=2]="Boolean",r[r.OctetString=3]="OctetString",r[r.BitString=4]="BitString",r[r.Integer=5]="Integer",r[r.Enumerated=6]="Enumerated",r[r.ObjectIdentifier=7]="ObjectIdentifier",r[r.Utf8String=8]="Utf8String",r[r.BmpString=9]="BmpString",r[r.UniversalString=10]="UniversalString",r[r.NumericString=11]="NumericString",r[r.PrintableString=12]="PrintableString",r[r.TeletexString=13]="TeletexString",r[r.VideotexString=14]="VideotexString",r[r.IA5String=15]="IA5String",r[r.GraphicString=16]="GraphicString",r[r.VisibleString=17]="VisibleString",r[r.GeneralString=18]="GeneralString",r[r.CharacterString=19]="CharacterString",r[r.UTCTime=20]="UTCTime",r[r.GeneralizedTime=21]="GeneralizedTime",r[r.DATE=22]="DATE",r[r.TimeOfDay=23]="TimeOfDay",r[r.DateTime=24]="DateTime",r[r.Duration=25]="Duration",r[r.TIME=26]="TIME",r[r.Null=27]="Null"})(A||(A={}));class xd{constructor(e,t=0){if(this.unusedBits=0,this.value=new ArrayBuffer(0),e)if(typeof e=="number")this.fromNumber(e);else if(G.isBufferSource(e))this.unusedBits=t,this.value=G.toArrayBuffer(e);else throw TypeError("Unsupported type of 'params' argument for BitString")}fromASN(e){if(!(e instanceof ki))throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString");return this.unusedBits=e.valueBlock.unusedBits,this.value=e.valueBlock.valueHex,this}toASN(){return new ki({unusedBits:this.unusedBits,valueHex:this.value})}toSchema(e){return new ki({name:e})}toNumber(){let e="";const t=new Uint8Array(this.value);for(const n of t)e+=n.toString(2).padStart(8,"0");return e=e.split("").reverse().join(""),this.unusedBits&&(e=e.slice(this.unusedBits).padStart(this.unusedBits,"0")),parseInt(e,2)}fromNumber(e){let t=e.toString(2);const n=t.length+7>>3;this.unusedBits=(n<<3)-t.length;const i=new Uint8Array(n);t=t.padStart(n<<3,"0").split("").reverse().join("");let s=0;for(;s<n;)i[s]=parseInt(t.slice(s<<3,(s<<3)+8),2),s++;this.value=i.buffer}}class be{get byteLength(){return this.buffer.byteLength}get byteOffset(){return 0}constructor(e){typeof e=="number"?this.buffer=new ArrayBuffer(e):G.isBufferSource(e)?this.buffer=G.toArrayBuffer(e):Array.isArray(e)?this.buffer=new Uint8Array(e):this.buffer=new ArrayBuffer(0)}fromASN(e){if(!(e instanceof br))throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");return this.buffer=e.valueBlock.valueHex,this}toASN(){return new br({valueHex:this.buffer})}toSchema(e){return new br({name:e})}}const uD={fromASN:r=>r instanceof pn?null:r.valueBeforeDecodeView,toASN:r=>{if(r===null)return new pn;const e=cn(r);if(e.result.error)throw new Error(e.result.error);return e.result}},dD={fromASN:r=>r.valueBlock.valueHexView.byteLength>=4?r.valueBlock.toString():r.valueBlock.valueDec,toASN:r=>new ln({value:+r})},hD={fromASN:r=>r.valueBlock.valueDec,toASN:r=>new hd({value:r})},Le={fromASN:r=>r.valueBlock.valueHexView,toASN:r=>new ln({valueHex:r})},fD={fromASN:r=>r.valueBlock.valueHexView,toASN:r=>new ki({valueHex:r})},pD={fromASN:r=>r.valueBlock.toString(),toASN:r=>new en({value:r})},gD={fromASN:r=>r.valueBlock.value,toASN:r=>new dd({value:r})},ru={fromASN:r=>r.valueBlock.valueHexView,toASN:r=>new br({valueHex:r})},mD={fromASN:r=>new be(r.getValue()),toASN:r=>r.toASN()};function ar(r){return{fromASN:e=>e.valueBlock.value,toASN:e=>new r({value:e})}}const hA=ar(Sn),yD=ar(fd),wD=ar(pd),bD=ar(gd),vD=ar(md),SD=ar(yd),ED=ar(wd),AD=ar(bd),xD=ar(vd),_D=ar(nc),CD=ar(Sd),ID=ar(Ed),kD={fromASN:r=>r.toDate(),toASN:r=>new ic({valueDate:r})},TD={fromASN:r=>r.toDate(),toASN:r=>new Ad({valueDate:r})},PD={fromASN:()=>null,toASN:()=>new pn};function Im(r){switch(r){case A.Any:return uD;case A.BitString:return fD;case A.BmpString:return yD;case A.Boolean:return gD;case A.CharacterString:return ID;case A.Enumerated:return hD;case A.GeneralString:return CD;case A.GeneralizedTime:return TD;case A.GraphicString:return xD;case A.IA5String:return AD;case A.Integer:return dD;case A.Null:return PD;case A.NumericString:return bD;case A.ObjectIdentifier:return pD;case A.OctetString:return ru;case A.PrintableString:return vD;case A.TeletexString:return SD;case A.UTCTime:return kD;case A.UniversalString:return wD;case A.Utf8String:return hA;case A.VideotexString:return ED;case A.VisibleString:return _D;default:return null}}function rn(r){return typeof r=="function"&&r.prototype?r.prototype.toASN&&r.prototype.fromASN?!0:rn(r.prototype):!!(r&&typeof r=="object"&&"toASN"in r&&"fromASN"in r)}function fA(r){var e;if(r){const t=Object.getPrototypeOf(r);return((e=t?.prototype)===null||e===void 0?void 0:e.constructor)===Array?!0:fA(t)}return!1}function RD(r,e){if(!(r&&e)||r.byteLength!==e.byteLength)return!1;const t=new Uint8Array(r),n=new Uint8Array(e);for(let i=0;i<r.byteLength;i++)if(t[i]!==n[i])return!1;return!0}class OD{constructor(){this.items=new WeakMap}has(e){return this.items.has(e)}get(e,t=!1){const n=this.items.get(e);if(!n)throw new Error(`Cannot get schema for '${e.prototype.constructor.name}' target`);if(t&&!n.schema)throw new Error(`Schema '${e.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);return n}cache(e){const t=this.get(e);t.schema||(t.schema=this.create(e,!0))}createDefault(e){const t={type:F.Sequence,items:{}},n=this.findParentSchema(e);return n&&(Object.assign(t,n),t.items=Object.assign({},t.items,n.items)),t}create(e,t){const n=this.items.get(e)||this.createDefault(e),i=[];for(const s in n.items){const o=n.items[s],a=t?s:"";let c;if(typeof o.type=="number"){const u=A[o.type],d=dA[u];if(!d)throw new Error(`Cannot get ASN1 class by name '${u}'`);c=new d({name:a})}else rn(o.type)?c=new o.type().toSchema(a):o.optional?this.get(o.type).type===F.Choice?c=new Mi({name:a}):(c=this.create(o.type,!1),c.name=a):c=new Mi({name:a});const l=!!o.optional||o.defaultValue!==void 0;if(o.repeated){c.name="";const u=o.repeated==="set"?un:nt;c=new u({name:"",value:[new tu({name:a,value:c})]})}if(o.context!==null&&o.context!==void 0)if(o.implicit)if(typeof o.type=="number"||rn(o.type)){const u=o.repeated?Ut:rc;i.push(new u({name:a,optional:l,idBlock:{tagClass:3,tagNumber:o.context}}))}else{this.cache(o.type);const u=!!o.repeated;let d=u?c:this.get(o.type,!0).schema;d="valueBlock"in d?d.valueBlock.value:d.value,i.push(new Ut({name:u?"":a,optional:l,idBlock:{tagClass:3,tagNumber:o.context},value:d}))}else i.push(new Ut({optional:l,idBlock:{tagClass:3,tagNumber:o.context},value:[c]}));else c.optional=l,i.push(c)}switch(n.type){case F.Sequence:return new nt({value:i,name:""});case F.Set:return new un({value:i,name:""});case F.Choice:return new Cm({value:i,name:""});default:throw new Error("Unsupported ASN1 type in use")}}set(e,t){return this.items.set(e,t),this}findParentSchema(e){const t=Object.getPrototypeOf(e);return t?this.items.get(t)||this.findParentSchema(t):null}}const rr=new OD,$=r=>e=>{let t;rr.has(e)?t=rr.get(e):(t=rr.createDefault(e),rr.set(e,t)),Object.assign(t,r)},g=r=>(e,t)=>{let n;rr.has(e.constructor)?n=rr.get(e.constructor):(n=rr.createDefault(e.constructor),rr.set(e.constructor,n));const i=Object.assign({},r);if(typeof i.type=="number"&&!i.converter){const s=Im(r.type);if(!s)throw new Error(`Cannot get default converter for property '${t}' of ${e.constructor.name}`);i.converter=s}n.items[t]=i};class lb extends Error{constructor(){super(...arguments),this.schemas=[]}}class BD{static parse(e,t){const n=cn(e);if(n.result.error)throw new Error(n.result.error);return this.fromASN(n.result,t)}static fromASN(e,t){var n;try{if(rn(t))return new t().fromASN(e);const i=rr.get(t);rr.cache(t);let s=i.schema;if(e.constructor===Ut&&i.type!==F.Choice){s=new Ut({idBlock:{tagClass:3,tagNumber:e.idBlock.tagNumber},value:i.schema.valueBlock.value});for(const c in i.items)delete e[c]}const o=bi({},e,s);if(!o.verified)throw new lb(`Data does not match to ${t.name} ASN1 schema. ${o.result.error}`);const a=new t;if(fA(t)){if(!("value"in e.valueBlock&&Array.isArray(e.valueBlock.value)))throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");const c=i.itemType;if(typeof c=="number"){const l=Im(c);if(!l)throw new Error(`Cannot get default converter for array item of ${t.name} ASN1 schema`);return t.from(e.valueBlock.value,u=>l.fromASN(u))}else return t.from(e.valueBlock.value,l=>this.fromASN(l,c))}for(const c in i.items){const l=o.result[c];if(!l)continue;const u=i.items[c],d=u.type;if(typeof d=="number"||rn(d)){const h=(n=u.converter)!==null&&n!==void 0?n:rn(d)?new d:null;if(!h)throw new Error("Converter is empty");if(u.repeated)if(u.implicit){const p=u.repeated==="sequence"?nt:un,m=new p;m.valueBlock=l.valueBlock;const w=cn(m.toBER(!1));if(w.offset===-1)throw new Error(`Cannot parse the child item. ${w.result.error}`);if(!("value"in w.result.valueBlock&&Array.isArray(w.result.valueBlock.value)))throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");const y=w.result.valueBlock.value;a[c]=Array.from(y,b=>h.fromASN(b))}else a[c]=Array.from(l,p=>h.fromASN(p));else{let p=l;if(u.implicit){let m;if(rn(d))m=new d().toSchema("");else{const w=A[d],y=dA[w];if(!y)throw new Error(`Cannot get '${w}' class from asn1js module`);m=new y}m.valueBlock=p.valueBlock,p=cn(m.toBER(!1)).result}a[c]=h.fromASN(p)}}else if(u.repeated){if(!Array.isArray(l))throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");a[c]=Array.from(l,h=>this.fromASN(h,d))}else a[c]=this.fromASN(l,d)}return a}catch(i){throw i instanceof lb&&i.schemas.push(t.name),i}}}class km{static serialize(e){return e instanceof ut?e.toBER(!1):this.toASN(e).toBER(!1)}static toASN(e){if(e&&typeof e=="object"&&rn(e))return e.toASN();if(!(e&&typeof e=="object"))throw new TypeError("Parameter 1 should be type of Object.");const t=e.constructor,n=rr.get(t);rr.cache(t);let i=[];if(n.itemType){if(!Array.isArray(e))throw new TypeError("Parameter 1 should be type of Array.");if(typeof n.itemType=="number"){const o=Im(n.itemType);if(!o)throw new Error(`Cannot get default converter for array item of ${t.name} ASN1 schema`);i=e.map(a=>o.toASN(a))}else i=e.map(o=>this.toAsnItem({type:n.itemType},"[]",t,o))}else for(const o in n.items){const a=n.items[o],c=e[o];if(c===void 0||a.defaultValue===c||typeof a.defaultValue=="object"&&typeof c=="object"&&RD(this.serialize(a.defaultValue),this.serialize(c)))continue;const l=km.toAsnItem(a,o,t,c);if(typeof a.context=="number")if(a.implicit)if(!a.repeated&&(typeof a.type=="number"||rn(a.type))){const u={};u.valueHex=l instanceof pn?l.valueBeforeDecodeView:l.valueBlock.toBER(),i.push(new rc({optional:a.optional,idBlock:{tagClass:3,tagNumber:a.context},...u}))}else i.push(new Ut({optional:a.optional,idBlock:{tagClass:3,tagNumber:a.context},value:l.valueBlock.value}));else i.push(new Ut({optional:a.optional,idBlock:{tagClass:3,tagNumber:a.context},value:[l]}));else a.repeated?i=i.concat(l):i.push(l)}let s;switch(n.type){case F.Sequence:s=new nt({value:i});break;case F.Set:s=new un({value:i});break;case F.Choice:if(!i[0])throw new Error(`Schema '${t.name}' has wrong data. Choice cannot be empty.`);s=i[0];break}return s}static toAsnItem(e,t,n,i){let s;if(typeof e.type=="number"){const o=e.converter;if(!o)throw new Error(`Property '${t}' doesn't have converter for type ${A[e.type]} in schema '${n.name}'`);if(e.repeated){if(!Array.isArray(i))throw new TypeError("Parameter 'objProp' should be type of Array.");const a=Array.from(i,l=>o.toASN(l)),c=e.repeated==="sequence"?nt:un;s=new c({value:a})}else s=o.toASN(i)}else if(e.repeated){if(!Array.isArray(i))throw new TypeError("Parameter 'objProp' should be type of Array.");const o=Array.from(i,c=>this.toASN(c)),a=e.repeated==="sequence"?nt:un;s=new a({value:o})}else s=this.toASN(i);return s}}class Ce extends Array{constructor(e=[]){if(typeof e=="number")super(e);else{super();for(const t of e)this.push(t)}}}class W{static serialize(e){return km.serialize(e)}static parse(e,t){return BD.parse(e,t)}static toString(e){const t=G.isBufferSource(e)?G.toArrayBuffer(e):W.serialize(e),n=cn(t);if(n.offset===-1)throw new Error(`Cannot decode ASN.1 data. ${n.result.error}`);return n.result.toString()}}function f(r,e,t,n){var i=arguments.length,s=i<3?e:n===null?n=Object.getOwnPropertyDescriptor(e,t):n,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")s=Reflect.decorate(r,e,t,n);else for(var a=r.length-1;a>=0;a--)(o=r[a])&&(s=(i<3?o(s):i>3?o(e,t,s):o(e,t))||s);return i>3&&s&&Object.defineProperty(e,t,s),s}class ub{static isIPv4(e){return/^(\d{1,3}\.){3}\d{1,3}$/.test(e)}static parseIPv4(e){const t=e.split(".");if(t.length!==4)throw new Error("Invalid IPv4 address");return t.map(n=>{const i=parseInt(n,10);if(isNaN(i)||i<0||i>255)throw new Error("Invalid IPv4 address part");return i})}static parseIPv6(e){const n=this.expandIPv6(e).split(":");if(n.length!==8)throw new Error("Invalid IPv6 address");return n.reduce((i,s)=>{const o=parseInt(s,16);if(isNaN(o)||o<0||o>65535)throw new Error("Invalid IPv6 address part");return i.push(o>>8&255),i.push(o&255),i},[])}static expandIPv6(e){if(!e.includes("::"))return e;const t=e.split("::");if(t.length>2)throw new Error("Invalid IPv6 address");const n=t[0]?t[0].split(":"):[],i=t[1]?t[1].split(":"):[],s=8-(n.length+i.length);if(s<0)throw new Error("Invalid IPv6 address");return[...n,...Array(s).fill("0"),...i].join(":")}static formatIPv6(e){const t=[];for(let n=0;n<16;n+=2)t.push((e[n]<<8|e[n+1]).toString(16));return this.compressIPv6(t.join(":"))}static compressIPv6(e){const t=e.split(":");let n=-1,i=0,s=-1,o=0;for(let a=0;a<t.length;a++)t[a]==="0"?(s===-1&&(s=a),o++):(o>i&&(n=s,i=o),s=-1,o=0);if(o>i&&(n=s,i=o),i>1){const a=t.slice(0,n).join(":"),c=t.slice(n+i).join(":");return`${a}::${c}`}return e}static parseCIDR(e){const[t,n]=e.split("/"),i=parseInt(n,10);if(this.isIPv4(t)){if(i<0||i>32)throw new Error("Invalid IPv4 prefix length");return[this.parseIPv4(t),i]}else{if(i<0||i>128)throw new Error("Invalid IPv6 prefix length");return[this.parseIPv6(t),i]}}static decodeIP(e){if(e.length===64&&parseInt(e,16)===0)return"::/0";if(e.length!==16)return e;const t=parseInt(e.slice(8),16).toString(2).split("").reduce((i,s)=>i+ +s,0);let n=e.slice(0,8).replace(/(.{2})/g,i=>`${parseInt(i,16)}.`);return n=n.slice(0,-1),`${n}/${t}`}static toString(e){const t=new Uint8Array(e);if(t.length===4)return Array.from(t).join(".");if(t.length===16)return this.formatIPv6(t);if(t.length===8||t.length===32){const n=t.length/2,i=t.slice(0,n),s=t.slice(n);if(t.every(c=>c===0))return t.length===8?"0.0.0.0/0":"::/0";const a=s.reduce((c,l)=>c+(l.toString(2).match(/1/g)||[]).length,0);return t.length===8?`${Array.from(i).join(".")}/${a}`:`${this.formatIPv6(i)}/${a}`}return this.decodeIP(te.ToHex(e))}static fromString(e){if(e.includes("/")){const[n,i]=this.parseCIDR(e),s=new Uint8Array(n.length);let o=i;for(let c=0;c<s.length;c++)o>=8?(s[c]=255,o-=8):o>0&&(s[c]=255<<8-o,o=0);const a=new Uint8Array(n.length*2);return a.set(n,0),a.set(s,n.length),a.buffer}const t=this.isIPv4(e)?this.parseIPv4(e):this.parseIPv6(e);return new Uint8Array(t).buffer}}var Wf,Gf,Yf;let dt=class{constructor(e={}){Object.assign(this,e)}toString(){return this.bmpString||this.printableString||this.teletexString||this.universalString||this.utf8String||""}};f([g({type:A.TeletexString})],dt.prototype,"teletexString",void 0);f([g({type:A.PrintableString})],dt.prototype,"printableString",void 0);f([g({type:A.UniversalString})],dt.prototype,"universalString",void 0);f([g({type:A.Utf8String})],dt.prototype,"utf8String",void 0);f([g({type:A.BmpString})],dt.prototype,"bmpString",void 0);dt=f([$({type:F.Choice})],dt);let Hs=class extends dt{constructor(e={}){super(e),Object.assign(this,e)}toString(){return this.ia5String||(this.anyValue?te.ToHex(this.anyValue):super.toString())}};f([g({type:A.IA5String})],Hs.prototype,"ia5String",void 0);f([g({type:A.Any})],Hs.prototype,"anyValue",void 0);Hs=f([$({type:F.Choice})],Hs);class _d{constructor(e={}){this.type="",this.value=new Hs,Object.assign(this,e)}}f([g({type:A.ObjectIdentifier})],_d.prototype,"type",void 0);f([g({type:Hs})],_d.prototype,"value",void 0);let Ws=Wf=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,Wf.prototype)}};Ws=Wf=f([$({type:F.Set,itemType:_d})],Ws);let Qf=Gf=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,Gf.prototype)}};Qf=Gf=f([$({type:F.Sequence,itemType:Ws})],Qf);let We=Yf=class extends Qf{constructor(e){super(e),Object.setPrototypeOf(this,Yf.prototype)}};We=Yf=f([$({type:F.Sequence})],We);const ND={fromASN:r=>ub.toString(ru.fromASN(r)),toASN:r=>ru.toASN(ub.fromString(r))};class Ca{constructor(e={}){this.typeId="",this.value=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:A.ObjectIdentifier})],Ca.prototype,"typeId",void 0);f([g({type:A.Any,context:0})],Ca.prototype,"value",void 0);class Tm{constructor(e={}){this.partyName=new dt,Object.assign(this,e)}}f([g({type:dt,optional:!0,context:0,implicit:!0})],Tm.prototype,"nameAssigner",void 0);f([g({type:dt,context:1,implicit:!0})],Tm.prototype,"partyName",void 0);let ue=class{constructor(e={}){Object.assign(this,e)}};f([g({type:Ca,context:0,implicit:!0})],ue.prototype,"otherName",void 0);f([g({type:A.IA5String,context:1,implicit:!0})],ue.prototype,"rfc822Name",void 0);f([g({type:A.IA5String,context:2,implicit:!0})],ue.prototype,"dNSName",void 0);f([g({type:A.Any,context:3,implicit:!0})],ue.prototype,"x400Address",void 0);f([g({type:We,context:4,implicit:!1})],ue.prototype,"directoryName",void 0);f([g({type:Tm,context:5})],ue.prototype,"ediPartyName",void 0);f([g({type:A.IA5String,context:6,implicit:!0})],ue.prototype,"uniformResourceIdentifier",void 0);f([g({type:A.OctetString,context:7,implicit:!0,converter:ND})],ue.prototype,"iPAddress",void 0);f([g({type:A.ObjectIdentifier,context:8,implicit:!0})],ue.prototype,"registeredID",void 0);ue=f([$({type:F.Choice})],ue);const Pm="1.3.6.1.5.5.7",DD=`${Pm}.1`,So=`${Pm}.3`,Cd=`${Pm}.48`,db=`${Cd}.1`,hb=`${Cd}.2`,fb=`${Cd}.3`,pb=`${Cd}.5`,ti="2.5.29";var Jf;const Xf=`${DD}.1`;class sc{constructor(e={}){this.accessMethod="",this.accessLocation=new ue,Object.assign(this,e)}}f([g({type:A.ObjectIdentifier})],sc.prototype,"accessMethod",void 0);f([g({type:ue})],sc.prototype,"accessLocation",void 0);let ws=Jf=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,Jf.prototype)}};ws=Jf=f([$({type:F.Sequence,itemType:sc})],ws);const Zf=`${ti}.35`;class Rm extends be{}class vi{constructor(e={}){e&&Object.assign(this,e)}}f([g({type:Rm,context:0,optional:!0,implicit:!0})],vi.prototype,"keyIdentifier",void 0);f([g({type:ue,context:1,optional:!0,implicit:!0,repeated:"sequence"})],vi.prototype,"authorityCertIssuer",void 0);f([g({type:A.Integer,context:2,optional:!0,implicit:!0,converter:Le})],vi.prototype,"authorityCertSerialNumber",void 0);const pA=`${ti}.19`;class nu{constructor(e={}){this.cA=!1,Object.assign(this,e)}}f([g({type:A.Boolean,defaultValue:!1})],nu.prototype,"cA",void 0);f([g({type:A.Integer,optional:!0})],nu.prototype,"pathLenConstraint",void 0);var ep;let Tt=ep=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,ep.prototype)}};Tt=ep=f([$({type:F.Sequence,itemType:ue})],Tt);var tp;let gb=tp=class extends Tt{constructor(e){super(e),Object.setPrototypeOf(this,tp.prototype)}};gb=tp=f([$({type:F.Sequence})],gb);var rp;const gA=`${ti}.32`;let gn=class{constructor(e={}){Object.assign(this,e)}toString(){return this.ia5String||this.visibleString||this.bmpString||this.utf8String||""}};f([g({type:A.IA5String})],gn.prototype,"ia5String",void 0);f([g({type:A.VisibleString})],gn.prototype,"visibleString",void 0);f([g({type:A.BmpString})],gn.prototype,"bmpString",void 0);f([g({type:A.Utf8String})],gn.prototype,"utf8String",void 0);gn=f([$({type:F.Choice})],gn);class Om{constructor(e={}){this.organization=new gn,this.noticeNumbers=[],Object.assign(this,e)}}f([g({type:gn})],Om.prototype,"organization",void 0);f([g({type:A.Integer,repeated:"sequence"})],Om.prototype,"noticeNumbers",void 0);class Bm{constructor(e={}){Object.assign(this,e)}}f([g({type:Om,optional:!0})],Bm.prototype,"noticeRef",void 0);f([g({type:gn,optional:!0})],Bm.prototype,"explicitText",void 0);let iu=class{constructor(e={}){Object.assign(this,e)}};f([g({type:A.IA5String})],iu.prototype,"cPSuri",void 0);f([g({type:Bm})],iu.prototype,"userNotice",void 0);iu=f([$({type:F.Choice})],iu);class Nm{constructor(e={}){this.policyQualifierId="",this.qualifier=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:A.ObjectIdentifier})],Nm.prototype,"policyQualifierId",void 0);f([g({type:A.Any})],Nm.prototype,"qualifier",void 0);class Id{constructor(e={}){this.policyIdentifier="",Object.assign(this,e)}}f([g({type:A.ObjectIdentifier})],Id.prototype,"policyIdentifier",void 0);f([g({type:Nm,repeated:"sequence",optional:!0})],Id.prototype,"policyQualifiers",void 0);let su=rp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,rp.prototype)}};su=rp=f([$({type:F.Sequence,itemType:Id})],su);let ou=class{constructor(e=0){this.value=e}};f([g({type:A.Integer})],ou.prototype,"value",void 0);ou=f([$({type:F.Choice})],ou);let mb=class extends ou{};mb=f([$({type:F.Choice})],mb);var np;const ip=`${ti}.31`;var pr;(function(r){r[r.unused=1]="unused",r[r.keyCompromise=2]="keyCompromise",r[r.cACompromise=4]="cACompromise",r[r.affiliationChanged=8]="affiliationChanged",r[r.superseded=16]="superseded",r[r.cessationOfOperation=32]="cessationOfOperation",r[r.certificateHold=64]="certificateHold",r[r.privilegeWithdrawn=128]="privilegeWithdrawn",r[r.aACompromise=256]="aACompromise"})(pr||(pr={}));class mA extends xd{toJSON(){const e=[],t=this.toNumber();return t&pr.aACompromise&&e.push("aACompromise"),t&pr.affiliationChanged&&e.push("affiliationChanged"),t&pr.cACompromise&&e.push("cACompromise"),t&pr.certificateHold&&e.push("certificateHold"),t&pr.cessationOfOperation&&e.push("cessationOfOperation"),t&pr.keyCompromise&&e.push("keyCompromise"),t&pr.privilegeWithdrawn&&e.push("privilegeWithdrawn"),t&pr.superseded&&e.push("superseded"),t&pr.unused&&e.push("unused"),e}toString(){return`[${this.toJSON().join(", ")}]`}}let Fi=class{constructor(e={}){Object.assign(this,e)}};f([g({type:ue,context:0,repeated:"sequence",implicit:!0})],Fi.prototype,"fullName",void 0);f([g({type:Ws,context:1,implicit:!0})],Fi.prototype,"nameRelativeToCRLIssuer",void 0);Fi=f([$({type:F.Choice})],Fi);class Eo{constructor(e={}){Object.assign(this,e)}}f([g({type:Fi,context:0,optional:!0})],Eo.prototype,"distributionPoint",void 0);f([g({type:mA,context:1,optional:!0,implicit:!0})],Eo.prototype,"reasons",void 0);f([g({type:ue,context:2,optional:!0,repeated:"sequence",implicit:!0})],Eo.prototype,"cRLIssuer",void 0);let Is=np=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,np.prototype)}};Is=np=f([$({type:F.Sequence,itemType:Eo})],Is);var sp;let yb=sp=class extends Is{constructor(e){super(e),Object.setPrototypeOf(this,sp.prototype)}};yb=sp=f([$({type:F.Sequence,itemType:Eo})],yb);class xt{constructor(e={}){this.onlyContainsUserCerts=xt.ONLY,this.onlyContainsCACerts=xt.ONLY,this.indirectCRL=xt.ONLY,this.onlyContainsAttributeCerts=xt.ONLY,Object.assign(this,e)}}xt.ONLY=!1;f([g({type:Fi,context:0,optional:!0})],xt.prototype,"distributionPoint",void 0);f([g({type:A.Boolean,context:1,defaultValue:xt.ONLY,implicit:!0})],xt.prototype,"onlyContainsUserCerts",void 0);f([g({type:A.Boolean,context:2,defaultValue:xt.ONLY,implicit:!0})],xt.prototype,"onlyContainsCACerts",void 0);f([g({type:mA,context:3,optional:!0,implicit:!0})],xt.prototype,"onlySomeReasons",void 0);f([g({type:A.Boolean,context:4,defaultValue:xt.ONLY,implicit:!0})],xt.prototype,"indirectCRL",void 0);f([g({type:A.Boolean,context:5,defaultValue:xt.ONLY,implicit:!0})],xt.prototype,"onlyContainsAttributeCerts",void 0);var ca;(function(r){r[r.unspecified=0]="unspecified",r[r.keyCompromise=1]="keyCompromise",r[r.cACompromise=2]="cACompromise",r[r.affiliationChanged=3]="affiliationChanged",r[r.superseded=4]="superseded",r[r.cessationOfOperation=5]="cessationOfOperation",r[r.certificateHold=6]="certificateHold",r[r.removeFromCRL=8]="removeFromCRL",r[r.privilegeWithdrawn=9]="privilegeWithdrawn",r[r.aACompromise=10]="aACompromise"})(ca||(ca={}));let op=class{constructor(e=ca.unspecified){this.reason=ca.unspecified,this.reason=e}toJSON(){return ca[this.reason]}toString(){return this.toJSON()}};f([g({type:A.Enumerated})],op.prototype,"reason",void 0);op=f([$({type:F.Choice})],op);var ap;const yA=`${ti}.37`;let au=ap=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,ap.prototype)}};au=ap=f([$({type:F.Sequence,itemType:A.ObjectIdentifier})],au);const LD=`${So}.1`,MD=`${So}.2`,FD=`${So}.3`,UD=`${So}.4`,$D=`${So}.8`,qD=`${So}.9`;let cp=class{constructor(e=new ArrayBuffer(0)){this.value=e}};f([g({type:A.Integer,converter:Le})],cp.prototype,"value",void 0);cp=f([$({type:F.Choice})],cp);let lp=class{constructor(e){this.value=new Date,e&&(this.value=e)}};f([g({type:A.GeneralizedTime})],lp.prototype,"value",void 0);lp=f([$({type:F.Choice})],lp);var up;let wb=up=class extends Tt{constructor(e){super(e),Object.setPrototypeOf(this,up.prototype)}};wb=up=f([$({type:F.Sequence})],wb);const wA=`${ti}.15`;var gr;(function(r){r[r.digitalSignature=1]="digitalSignature",r[r.nonRepudiation=2]="nonRepudiation",r[r.keyEncipherment=4]="keyEncipherment",r[r.dataEncipherment=8]="dataEncipherment",r[r.keyAgreement=16]="keyAgreement",r[r.keyCertSign=32]="keyCertSign",r[r.cRLSign=64]="cRLSign",r[r.encipherOnly=128]="encipherOnly",r[r.decipherOnly=256]="decipherOnly"})(gr||(gr={}));class Ch extends xd{toJSON(){const e=this.toNumber(),t=[];return e&gr.cRLSign&&t.push("crlSign"),e&gr.dataEncipherment&&t.push("dataEncipherment"),e&gr.decipherOnly&&t.push("decipherOnly"),e&gr.digitalSignature&&t.push("digitalSignature"),e&gr.encipherOnly&&t.push("encipherOnly"),e&gr.keyAgreement&&t.push("keyAgreement"),e&gr.keyCertSign&&t.push("keyCertSign"),e&gr.keyEncipherment&&t.push("keyEncipherment"),e&gr.nonRepudiation&&t.push("nonRepudiation"),t}toString(){return`[${this.toJSON().join(", ")}]`}}var dp;class kd{constructor(e={}){this.base=new ue,this.minimum=0,Object.assign(this,e)}}f([g({type:ue})],kd.prototype,"base",void 0);f([g({type:A.Integer,context:0,defaultValue:0,implicit:!0})],kd.prototype,"minimum",void 0);f([g({type:A.Integer,context:1,optional:!0,implicit:!0})],kd.prototype,"maximum",void 0);let cu=dp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,dp.prototype)}};cu=dp=f([$({type:F.Sequence,itemType:kd})],cu);class bA{constructor(e={}){Object.assign(this,e)}}f([g({type:cu,context:0,optional:!0,implicit:!0})],bA.prototype,"permittedSubtrees",void 0);f([g({type:cu,context:1,optional:!0,implicit:!0})],bA.prototype,"excludedSubtrees",void 0);class vA{constructor(e={}){Object.assign(this,e)}}f([g({type:A.Integer,context:0,implicit:!0,optional:!0,converter:Le})],vA.prototype,"requireExplicitPolicy",void 0);f([g({type:A.Integer,context:1,implicit:!0,optional:!0,converter:Le})],vA.prototype,"inhibitPolicyMapping",void 0);var hp;class Dm{constructor(e={}){this.issuerDomainPolicy="",this.subjectDomainPolicy="",Object.assign(this,e)}}f([g({type:A.ObjectIdentifier})],Dm.prototype,"issuerDomainPolicy",void 0);f([g({type:A.ObjectIdentifier})],Dm.prototype,"subjectDomainPolicy",void 0);let bb=hp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,hp.prototype)}};bb=hp=f([$({type:F.Sequence,itemType:Dm})],bb);var fp;const SA=`${ti}.17`;let pp=fp=class extends Tt{constructor(e){super(e),Object.setPrototypeOf(this,fp.prototype)}};pp=fp=f([$({type:F.Sequence})],pp);let mn=class{constructor(e={}){this.type="",this.values=[],Object.assign(this,e)}};f([g({type:A.ObjectIdentifier})],mn.prototype,"type",void 0);f([g({type:A.Any,repeated:"set"})],mn.prototype,"values",void 0);var gp;let vb=gp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,gp.prototype)}};vb=gp=f([$({type:F.Sequence,itemType:mn})],vb);const EA=`${ti}.14`;class Hn extends Rm{}class AA{constructor(e={}){Object.assign(this,e)}}f([g({type:A.GeneralizedTime,context:0,implicit:!0,optional:!0})],AA.prototype,"notBefore",void 0);f([g({type:A.GeneralizedTime,context:1,implicit:!0,optional:!0})],AA.prototype,"notAfter",void 0);var la;(function(r){r[r.keyUpdateAllowed=1]="keyUpdateAllowed",r[r.newExtensions=2]="newExtensions",r[r.pKIXCertificate=4]="pKIXCertificate"})(la||(la={}));class xA extends xd{toJSON(){const e=[],t=this.toNumber();return t&la.pKIXCertificate&&e.push("pKIXCertificate"),t&la.newExtensions&&e.push("newExtensions"),t&la.keyUpdateAllowed&&e.push("keyUpdateAllowed"),e}toString(){return`[${this.toJSON().join(", ")}]`}}class _A{constructor(e={}){this.entrustVers="",this.entrustInfoFlags=new xA,Object.assign(this,e)}}f([g({type:A.GeneralString})],_A.prototype,"entrustVers",void 0);f([g({type:xA})],_A.prototype,"entrustInfoFlags",void 0);var mp;let Sb=mp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,mp.prototype)}};Sb=mp=f([$({type:F.Sequence,itemType:sc})],Sb);class J{constructor(e={}){this.algorithm="",Object.assign(this,e)}isEqual(e){return e instanceof J&&e.algorithm==this.algorithm&&(e.parameters&&this.parameters&&g1(e.parameters,this.parameters)||e.parameters===this.parameters)}}f([g({type:A.ObjectIdentifier})],J.prototype,"algorithm",void 0);f([g({type:A.Any,optional:!0})],J.prototype,"parameters",void 0);class vr{constructor(e={}){this.algorithm=new J,this.subjectPublicKey=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:J})],vr.prototype,"algorithm",void 0);f([g({type:A.BitString})],vr.prototype,"subjectPublicKey",void 0);let ct=class{constructor(e){if(e)if(typeof e=="string"||typeof e=="number"||e instanceof Date){const t=new Date(e);t.getUTCFullYear()>2049?this.generalTime=t:this.utcTime=t}else Object.assign(this,e)}getTime(){const e=this.utcTime||this.generalTime;if(!e)throw new Error("Cannot get time from CHOICE object");return e}};f([g({type:A.UTCTime})],ct.prototype,"utcTime",void 0);f([g({type:A.GeneralizedTime})],ct.prototype,"generalTime",void 0);ct=f([$({type:F.Choice})],ct);class oc{constructor(e){this.notBefore=new ct(new Date),this.notAfter=new ct(new Date),e&&(this.notBefore=new ct(e.notBefore),this.notAfter=new ct(e.notAfter))}}f([g({type:ct})],oc.prototype,"notBefore",void 0);f([g({type:ct})],oc.prototype,"notAfter",void 0);var yp;let or=class CA{constructor(e={}){this.extnID="",this.critical=CA.CRITICAL,this.extnValue=new be,Object.assign(this,e)}};or.CRITICAL=!1;f([g({type:A.ObjectIdentifier})],or.prototype,"extnID",void 0);f([g({type:A.Boolean,defaultValue:or.CRITICAL})],or.prototype,"critical",void 0);f([g({type:be})],or.prototype,"extnValue",void 0);let Qn=yp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,yp.prototype)}};Qn=yp=f([$({type:F.Sequence,itemType:or})],Qn);var Ui;(function(r){r[r.v1=0]="v1",r[r.v2=1]="v2",r[r.v3=2]="v3"})(Ui||(Ui={}));class Xt{constructor(e={}){this.version=Ui.v1,this.serialNumber=new ArrayBuffer(0),this.signature=new J,this.issuer=new We,this.validity=new oc,this.subject=new We,this.subjectPublicKeyInfo=new vr,Object.assign(this,e)}}f([g({type:A.Integer,context:0,defaultValue:Ui.v1})],Xt.prototype,"version",void 0);f([g({type:A.Integer,converter:Le})],Xt.prototype,"serialNumber",void 0);f([g({type:J})],Xt.prototype,"signature",void 0);f([g({type:We})],Xt.prototype,"issuer",void 0);f([g({type:oc})],Xt.prototype,"validity",void 0);f([g({type:We})],Xt.prototype,"subject",void 0);f([g({type:vr})],Xt.prototype,"subjectPublicKeyInfo",void 0);f([g({type:A.BitString,context:1,implicit:!0,optional:!0})],Xt.prototype,"issuerUniqueID",void 0);f([g({type:A.BitString,context:2,implicit:!0,optional:!0})],Xt.prototype,"subjectUniqueID",void 0);f([g({type:Qn,context:3,optional:!0})],Xt.prototype,"extensions",void 0);class $i{constructor(e={}){this.tbsCertificate=new Xt,this.signatureAlgorithm=new J,this.signatureValue=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:Xt})],$i.prototype,"tbsCertificate",void 0);f([g({type:J})],$i.prototype,"signatureAlgorithm",void 0);f([g({type:A.BitString})],$i.prototype,"signatureValue",void 0);class Td{constructor(e={}){this.userCertificate=new ArrayBuffer(0),this.revocationDate=new ct,Object.assign(this,e)}}f([g({type:A.Integer,converter:Le})],Td.prototype,"userCertificate",void 0);f([g({type:ct})],Td.prototype,"revocationDate",void 0);f([g({type:or,optional:!0,repeated:"sequence"})],Td.prototype,"crlEntryExtensions",void 0);class En{constructor(e={}){this.signature=new J,this.issuer=new We,this.thisUpdate=new ct,Object.assign(this,e)}}f([g({type:A.Integer,optional:!0})],En.prototype,"version",void 0);f([g({type:J})],En.prototype,"signature",void 0);f([g({type:We})],En.prototype,"issuer",void 0);f([g({type:ct})],En.prototype,"thisUpdate",void 0);f([g({type:ct,optional:!0})],En.prototype,"nextUpdate",void 0);f([g({type:Td,repeated:"sequence",optional:!0})],En.prototype,"revokedCertificates",void 0);f([g({type:or,optional:!0,context:0,repeated:"sequence"})],En.prototype,"crlExtensions",void 0);class Lm{constructor(e={}){this.tbsCertList=new En,this.signatureAlgorithm=new J,this.signature=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:En})],Lm.prototype,"tbsCertList",void 0);f([g({type:J})],Lm.prototype,"signatureAlgorithm",void 0);f([g({type:A.BitString})],Lm.prototype,"signature",void 0);class Ao{constructor(e={}){this.issuer=new We,this.serialNumber=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:We})],Ao.prototype,"issuer",void 0);f([g({type:A.Integer,converter:Le})],Ao.prototype,"serialNumber",void 0);let Gs=class{constructor(e={}){Object.assign(this,e)}};f([g({type:Hn,context:0,implicit:!0})],Gs.prototype,"subjectKeyIdentifier",void 0);f([g({type:Ao})],Gs.prototype,"issuerAndSerialNumber",void 0);Gs=f([$({type:F.Choice})],Gs);var yn;(function(r){r[r.v0=0]="v0",r[r.v1=1]="v1",r[r.v2=2]="v2",r[r.v3=3]="v3",r[r.v4=4]="v4",r[r.v5=5]="v5"})(yn||(yn={}));let Ia=class extends J{};Ia=f([$({type:F.Sequence})],Ia);let lu=class extends J{};lu=f([$({type:F.Sequence})],lu);let zr=class extends J{};zr=f([$({type:F.Sequence})],zr);let uu=class extends J{};uu=f([$({type:F.Sequence})],uu);let Eb=class extends J{};Eb=f([$({type:F.Sequence})],Eb);let wp=class extends J{};wp=f([$({type:F.Sequence})],wp);let xo=class{constructor(e={}){this.attrType="",this.attrValues=[],Object.assign(this,e)}};f([g({type:A.ObjectIdentifier})],xo.prototype,"attrType",void 0);f([g({type:A.Any,repeated:"set"})],xo.prototype,"attrValues",void 0);var bp;class Wr{constructor(e={}){this.version=yn.v0,this.sid=new Gs,this.digestAlgorithm=new Ia,this.signatureAlgorithm=new lu,this.signature=new be,Object.assign(this,e)}}f([g({type:A.Integer})],Wr.prototype,"version",void 0);f([g({type:Gs})],Wr.prototype,"sid",void 0);f([g({type:Ia})],Wr.prototype,"digestAlgorithm",void 0);f([g({type:xo,repeated:"set",context:0,implicit:!0,optional:!0})],Wr.prototype,"signedAttrs",void 0);f([g({type:lu})],Wr.prototype,"signatureAlgorithm",void 0);f([g({type:be})],Wr.prototype,"signature",void 0);f([g({type:xo,repeated:"set",context:1,implicit:!0,optional:!0})],Wr.prototype,"unsignedAttrs",void 0);let du=bp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,bp.prototype)}};du=bp=f([$({type:F.Set,itemType:Wr})],du);let Ab=class extends ct{};Ab=f([$({type:F.Choice})],Ab);let xb=class extends Wr{};xb=f([$({type:F.Sequence})],xb);class Mm{constructor(e={}){this.acIssuer=new ue,this.acSerial=0,this.attrs=[],Object.assign(this,e)}}f([g({type:ue})],Mm.prototype,"acIssuer",void 0);f([g({type:A.Integer})],Mm.prototype,"acSerial",void 0);f([g({type:mn,repeated:"sequence"})],Mm.prototype,"attrs",void 0);var vp;let hu=vp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,vp.prototype)}};hu=vp=f([$({type:F.Sequence,itemType:A.ObjectIdentifier})],hu);class Pd{constructor(e={}){this.permitUnSpecified=!0,Object.assign(this,e)}}f([g({type:A.Integer,optional:!0})],Pd.prototype,"pathLenConstraint",void 0);f([g({type:hu,implicit:!0,context:0,optional:!0})],Pd.prototype,"permittedAttrs",void 0);f([g({type:hu,implicit:!0,context:1,optional:!0})],Pd.prototype,"excludedAttrs",void 0);f([g({type:A.Boolean,defaultValue:!0})],Pd.prototype,"permitUnSpecified",void 0);class ts{constructor(e={}){this.issuer=new Tt,this.serial=new ArrayBuffer(0),this.issuerUID=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:Tt})],ts.prototype,"issuer",void 0);f([g({type:A.Integer,converter:Le})],ts.prototype,"serial",void 0);f([g({type:A.BitString,optional:!0})],ts.prototype,"issuerUID",void 0);var Sp;(function(r){r[r.publicKey=0]="publicKey",r[r.publicKeyCert=1]="publicKeyCert",r[r.otherObjectTypes=2]="otherObjectTypes"})(Sp||(Sp={}));class rs{constructor(e={}){this.digestedObjectType=Sp.publicKey,this.digestAlgorithm=new J,this.objectDigest=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:A.Enumerated})],rs.prototype,"digestedObjectType",void 0);f([g({type:A.ObjectIdentifier,optional:!0})],rs.prototype,"otherObjectTypeID",void 0);f([g({type:J})],rs.prototype,"digestAlgorithm",void 0);f([g({type:A.BitString})],rs.prototype,"objectDigest",void 0);class Rd{constructor(e={}){Object.assign(this,e)}}f([g({type:Tt,optional:!0})],Rd.prototype,"issuerName",void 0);f([g({type:ts,context:0,implicit:!0,optional:!0})],Rd.prototype,"baseCertificateID",void 0);f([g({type:rs,context:1,implicit:!0,optional:!0})],Rd.prototype,"objectDigestInfo",void 0);let Ys=class{constructor(e={}){Object.assign(this,e)}};f([g({type:ue,repeated:"sequence"})],Ys.prototype,"v1Form",void 0);f([g({type:Rd,context:0,implicit:!0})],Ys.prototype,"v2Form",void 0);Ys=f([$({type:F.Choice})],Ys);class Od{constructor(e={}){this.notBeforeTime=new Date,this.notAfterTime=new Date,Object.assign(this,e)}}f([g({type:A.GeneralizedTime})],Od.prototype,"notBeforeTime",void 0);f([g({type:A.GeneralizedTime})],Od.prototype,"notAfterTime",void 0);class ac{constructor(e={}){Object.assign(this,e)}}f([g({type:ts,implicit:!0,context:0,optional:!0})],ac.prototype,"baseCertificateID",void 0);f([g({type:Tt,implicit:!0,context:1,optional:!0})],ac.prototype,"entityName",void 0);f([g({type:rs,implicit:!0,context:2,optional:!0})],ac.prototype,"objectDigestInfo",void 0);var Ep;(function(r){r[r.v2=1]="v2"})(Ep||(Ep={}));class Ir{constructor(e={}){this.version=Ep.v2,this.holder=new ac,this.issuer=new Ys,this.signature=new J,this.serialNumber=new ArrayBuffer(0),this.attrCertValidityPeriod=new Od,this.attributes=[],Object.assign(this,e)}}f([g({type:A.Integer})],Ir.prototype,"version",void 0);f([g({type:ac})],Ir.prototype,"holder",void 0);f([g({type:Ys})],Ir.prototype,"issuer",void 0);f([g({type:J})],Ir.prototype,"signature",void 0);f([g({type:A.Integer,converter:Le})],Ir.prototype,"serialNumber",void 0);f([g({type:Od})],Ir.prototype,"attrCertValidityPeriod",void 0);f([g({type:mn,repeated:"sequence"})],Ir.prototype,"attributes",void 0);f([g({type:A.BitString,optional:!0})],Ir.prototype,"issuerUniqueID",void 0);f([g({type:Qn,optional:!0})],Ir.prototype,"extensions",void 0);class Bd{constructor(e={}){this.acinfo=new Ir,this.signatureAlgorithm=new J,this.signatureValue=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:Ir})],Bd.prototype,"acinfo",void 0);f([g({type:J})],Bd.prototype,"signatureAlgorithm",void 0);f([g({type:A.BitString})],Bd.prototype,"signatureValue",void 0);var fu;(function(r){r[r.unmarked=1]="unmarked",r[r.unclassified=2]="unclassified",r[r.restricted=4]="restricted",r[r.confidential=8]="confidential",r[r.secret=16]="secret",r[r.topSecret=32]="topSecret"})(fu||(fu={}));class Ap extends xd{}class Fm{constructor(e={}){this.type="",this.value=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:A.ObjectIdentifier,implicit:!0,context:0})],Fm.prototype,"type",void 0);f([g({type:A.Any,implicit:!0,context:1})],Fm.prototype,"value",void 0);class Um{constructor(e={}){this.policyId="",this.classList=new Ap(fu.unclassified),Object.assign(this,e)}}f([g({type:A.ObjectIdentifier})],Um.prototype,"policyId",void 0);f([g({type:Ap,defaultValue:new Ap(fu.unclassified)})],Um.prototype,"classList",void 0);f([g({type:Fm,repeated:"set"})],Um.prototype,"securityCategories",void 0);class Nd{constructor(e={}){Object.assign(this,e)}}f([g({type:be})],Nd.prototype,"cotets",void 0);f([g({type:A.ObjectIdentifier})],Nd.prototype,"oid",void 0);f([g({type:A.Utf8String})],Nd.prototype,"string",void 0);class IA{constructor(e={}){this.values=[],Object.assign(this,e)}}f([g({type:Tt,implicit:!0,context:0,optional:!0})],IA.prototype,"policyAuthority",void 0);f([g({type:Nd,repeated:"sequence"})],IA.prototype,"values",void 0);var xp;class Dd{constructor(e={}){this.targetCertificate=new ts,Object.assign(this,e)}}f([g({type:ts})],Dd.prototype,"targetCertificate",void 0);f([g({type:ue,optional:!0})],Dd.prototype,"targetName",void 0);f([g({type:rs,optional:!0})],Dd.prototype,"certDigestInfo",void 0);let Qs=class{constructor(e={}){Object.assign(this,e)}};f([g({type:ue,context:0,implicit:!0})],Qs.prototype,"targetName",void 0);f([g({type:ue,context:1,implicit:!0})],Qs.prototype,"targetGroup",void 0);f([g({type:Dd,context:2,implicit:!0})],Qs.prototype,"targetCert",void 0);Qs=f([$({type:F.Choice})],Qs);let _p=xp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,xp.prototype)}};_p=xp=f([$({type:F.Sequence,itemType:Qs})],_p);var Cp;let _b=Cp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,Cp.prototype)}};_b=Cp=f([$({type:F.Sequence,itemType:_p})],_b);class kA{constructor(e={}){Object.assign(this,e)}}f([g({type:Tt,implicit:!0,context:0,optional:!0})],kA.prototype,"roleAuthority",void 0);f([g({type:ue,implicit:!0,context:1})],kA.prototype,"roleName",void 0);class $m{constructor(e={}){this.service=new ue,this.ident=new ue,Object.assign(this,e)}}f([g({type:ue})],$m.prototype,"service",void 0);f([g({type:ue})],$m.prototype,"ident",void 0);f([g({type:be,optional:!0})],$m.prototype,"authInfo",void 0);var Ip;class qm{constructor(e={}){this.otherCertFormat="",this.otherCert=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:A.ObjectIdentifier})],qm.prototype,"otherCertFormat",void 0);f([g({type:A.Any})],qm.prototype,"otherCert",void 0);let Js=class{constructor(e={}){Object.assign(this,e)}};f([g({type:$i})],Js.prototype,"certificate",void 0);f([g({type:Bd,context:2,implicit:!0})],Js.prototype,"v2AttrCert",void 0);f([g({type:qm,context:3,implicit:!0})],Js.prototype,"other",void 0);Js=f([$({type:F.Choice})],Js);let pu=Ip=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,Ip.prototype)}};pu=Ip=f([$({type:F.Set,itemType:Js})],pu);class _o{constructor(e={}){this.contentType="",this.content=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:A.ObjectIdentifier})],_o.prototype,"contentType",void 0);f([g({type:A.Any,context:0})],_o.prototype,"content",void 0);let ka=class{constructor(e={}){Object.assign(this,e)}};f([g({type:be})],ka.prototype,"single",void 0);f([g({type:A.Any})],ka.prototype,"any",void 0);ka=f([$({type:F.Choice})],ka);class Ld{constructor(e={}){this.eContentType="",Object.assign(this,e)}}f([g({type:A.ObjectIdentifier})],Ld.prototype,"eContentType",void 0);f([g({type:ka,context:0,optional:!0})],Ld.prototype,"eContent",void 0);let Ta=class{constructor(e={}){Object.assign(this,e)}};f([g({type:be,context:0,implicit:!0,optional:!0})],Ta.prototype,"value",void 0);f([g({type:be,converter:mD,context:0,implicit:!0,optional:!0,repeated:"sequence"})],Ta.prototype,"constructedValue",void 0);Ta=f([$({type:F.Choice})],Ta);class cc{constructor(e={}){this.contentType="",this.contentEncryptionAlgorithm=new uu,Object.assign(this,e)}}f([g({type:A.ObjectIdentifier})],cc.prototype,"contentType",void 0);f([g({type:uu})],cc.prototype,"contentEncryptionAlgorithm",void 0);f([g({type:Ta,optional:!0})],cc.prototype,"encryptedContent",void 0);class Md{constructor(e={}){this.keyAttrId="",Object.assign(this,e)}}f([g({type:A.ObjectIdentifier})],Md.prototype,"keyAttrId",void 0);f([g({type:A.Any,optional:!0})],Md.prototype,"keyAttr",void 0);var kp;class Fd{constructor(e={}){this.subjectKeyIdentifier=new Hn,Object.assign(this,e)}}f([g({type:Hn})],Fd.prototype,"subjectKeyIdentifier",void 0);f([g({type:A.GeneralizedTime,optional:!0})],Fd.prototype,"date",void 0);f([g({type:Md,optional:!0})],Fd.prototype,"other",void 0);let Xs=class{constructor(e={}){Object.assign(this,e)}};f([g({type:Fd,context:0,implicit:!0,optional:!0})],Xs.prototype,"rKeyId",void 0);f([g({type:Ao,optional:!0})],Xs.prototype,"issuerAndSerialNumber",void 0);Xs=f([$({type:F.Choice})],Xs);class Km{constructor(e={}){this.rid=new Xs,this.encryptedKey=new be,Object.assign(this,e)}}f([g({type:Xs})],Km.prototype,"rid",void 0);f([g({type:be})],Km.prototype,"encryptedKey",void 0);let gu=kp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,kp.prototype)}};gu=kp=f([$({type:F.Sequence,itemType:Km})],gu);class Vm{constructor(e={}){this.algorithm=new J,this.publicKey=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:J})],Vm.prototype,"algorithm",void 0);f([g({type:A.BitString})],Vm.prototype,"publicKey",void 0);let qi=class{constructor(e={}){Object.assign(this,e)}};f([g({type:Hn,context:0,implicit:!0,optional:!0})],qi.prototype,"subjectKeyIdentifier",void 0);f([g({type:Vm,context:1,implicit:!0,optional:!0})],qi.prototype,"originatorKey",void 0);f([g({type:Ao,optional:!0})],qi.prototype,"issuerAndSerialNumber",void 0);qi=f([$({type:F.Choice})],qi);class Co{constructor(e={}){this.version=yn.v3,this.originator=new qi,this.keyEncryptionAlgorithm=new zr,this.recipientEncryptedKeys=new gu,Object.assign(this,e)}}f([g({type:A.Integer})],Co.prototype,"version",void 0);f([g({type:qi,context:0})],Co.prototype,"originator",void 0);f([g({type:be,context:1,optional:!0})],Co.prototype,"ukm",void 0);f([g({type:zr})],Co.prototype,"keyEncryptionAlgorithm",void 0);f([g({type:gu})],Co.prototype,"recipientEncryptedKeys",void 0);let Zs=class{constructor(e={}){Object.assign(this,e)}};f([g({type:Hn,context:0,implicit:!0})],Zs.prototype,"subjectKeyIdentifier",void 0);f([g({type:Ao})],Zs.prototype,"issuerAndSerialNumber",void 0);Zs=f([$({type:F.Choice})],Zs);class lc{constructor(e={}){this.version=yn.v0,this.rid=new Zs,this.keyEncryptionAlgorithm=new zr,this.encryptedKey=new be,Object.assign(this,e)}}f([g({type:A.Integer})],lc.prototype,"version",void 0);f([g({type:Zs})],lc.prototype,"rid",void 0);f([g({type:zr})],lc.prototype,"keyEncryptionAlgorithm",void 0);f([g({type:be})],lc.prototype,"encryptedKey",void 0);class uc{constructor(e={}){this.keyIdentifier=new be,Object.assign(this,e)}}f([g({type:be})],uc.prototype,"keyIdentifier",void 0);f([g({type:A.GeneralizedTime,optional:!0})],uc.prototype,"date",void 0);f([g({type:Md,optional:!0})],uc.prototype,"other",void 0);class dc{constructor(e={}){this.version=yn.v4,this.kekid=new uc,this.keyEncryptionAlgorithm=new zr,this.encryptedKey=new be,Object.assign(this,e)}}f([g({type:A.Integer})],dc.prototype,"version",void 0);f([g({type:uc})],dc.prototype,"kekid",void 0);f([g({type:zr})],dc.prototype,"keyEncryptionAlgorithm",void 0);f([g({type:be})],dc.prototype,"encryptedKey",void 0);class hc{constructor(e={}){this.version=yn.v0,this.keyEncryptionAlgorithm=new zr,this.encryptedKey=new be,Object.assign(this,e)}}f([g({type:A.Integer})],hc.prototype,"version",void 0);f([g({type:wp,context:0,optional:!0})],hc.prototype,"keyDerivationAlgorithm",void 0);f([g({type:zr})],hc.prototype,"keyEncryptionAlgorithm",void 0);f([g({type:be})],hc.prototype,"encryptedKey",void 0);class zm{constructor(e={}){this.oriType="",this.oriValue=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:A.ObjectIdentifier})],zm.prototype,"oriType",void 0);f([g({type:A.Any})],zm.prototype,"oriValue",void 0);let Jn=class{constructor(e={}){Object.assign(this,e)}};f([g({type:lc,optional:!0})],Jn.prototype,"ktri",void 0);f([g({type:Co,context:1,implicit:!0,optional:!0})],Jn.prototype,"kari",void 0);f([g({type:dc,context:2,implicit:!0,optional:!0})],Jn.prototype,"kekri",void 0);f([g({type:hc,context:3,implicit:!0,optional:!0})],Jn.prototype,"pwri",void 0);f([g({type:zm,context:4,implicit:!0,optional:!0})],Jn.prototype,"ori",void 0);Jn=f([$({type:F.Choice})],Jn);var Tp;let mu=Tp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,Tp.prototype)}};mu=Tp=f([$({type:F.Set,itemType:Jn})],mu);var Pp;class Ud{constructor(e={}){this.otherRevInfoFormat="",this.otherRevInfo=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:A.ObjectIdentifier})],Ud.prototype,"otherRevInfoFormat",void 0);f([g({type:A.Any})],Ud.prototype,"otherRevInfo",void 0);let yu=class{constructor(e={}){this.other=new Ud,Object.assign(this,e)}};f([g({type:Ud,context:1,implicit:!0})],yu.prototype,"other",void 0);yu=f([$({type:F.Choice})],yu);let wu=Pp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,Pp.prototype)}};wu=Pp=f([$({type:F.Set,itemType:yu})],wu);class jm{constructor(e={}){Object.assign(this,e)}}f([g({type:pu,context:0,implicit:!0,optional:!0})],jm.prototype,"certs",void 0);f([g({type:wu,context:1,implicit:!0,optional:!0})],jm.prototype,"crls",void 0);var Rp;let Op=Rp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,Rp.prototype)}};Op=Rp=f([$({type:F.Set,itemType:xo})],Op);class fc{constructor(e={}){this.version=yn.v0,this.recipientInfos=new mu,this.encryptedContentInfo=new cc,Object.assign(this,e)}}f([g({type:A.Integer})],fc.prototype,"version",void 0);f([g({type:jm,context:0,implicit:!0,optional:!0})],fc.prototype,"originatorInfo",void 0);f([g({type:mu})],fc.prototype,"recipientInfos",void 0);f([g({type:cc})],fc.prototype,"encryptedContentInfo",void 0);f([g({type:Op,context:1,implicit:!0,optional:!0})],fc.prototype,"unprotectedAttrs",void 0);const KD="1.2.840.113549.1.7.2";var Bp;let bu=Bp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,Bp.prototype)}};bu=Bp=f([$({type:F.Set,itemType:Ia})],bu);class Io{constructor(e={}){this.version=yn.v0,this.digestAlgorithms=new bu,this.encapContentInfo=new Ld,this.signerInfos=new du,Object.assign(this,e)}}f([g({type:A.Integer})],Io.prototype,"version",void 0);f([g({type:bu})],Io.prototype,"digestAlgorithms",void 0);f([g({type:Ld})],Io.prototype,"encapContentInfo",void 0);f([g({type:pu,context:0,implicit:!0,optional:!0})],Io.prototype,"certificates",void 0);f([g({type:wu,context:1,implicit:!0,optional:!0})],Io.prototype,"crls",void 0);f([g({type:du})],Io.prototype,"signerInfos",void 0);const Pa="1.2.840.10045.2.1",Hm="1.2.840.10045.4.1",TA="1.2.840.10045.4.3.1",Wm="1.2.840.10045.4.3.2",Gm="1.2.840.10045.4.3.3",Ym="1.2.840.10045.4.3.4",Cb="1.2.840.10045.3.1.7",Ib="1.3.132.0.34",kb="1.3.132.0.35";function pc(r){return new J({algorithm:r})}const VD=pc(Hm);pc(TA);const zD=pc(Wm),jD=pc(Gm),HD=pc(Ym);let Ra=class{constructor(e={}){Object.assign(this,e)}};f([g({type:A.ObjectIdentifier})],Ra.prototype,"fieldType",void 0);f([g({type:A.Any})],Ra.prototype,"parameters",void 0);Ra=f([$({type:F.Sequence})],Ra);class WD extends be{}let eo=class{constructor(e={}){Object.assign(this,e)}};f([g({type:A.OctetString})],eo.prototype,"a",void 0);f([g({type:A.OctetString})],eo.prototype,"b",void 0);f([g({type:A.BitString,optional:!0})],eo.prototype,"seed",void 0);eo=f([$({type:F.Sequence})],eo);var Np;(function(r){r[r.ecpVer1=1]="ecpVer1"})(Np||(Np={}));let wn=class{constructor(e={}){this.version=Np.ecpVer1,Object.assign(this,e)}};f([g({type:A.Integer})],wn.prototype,"version",void 0);f([g({type:Ra})],wn.prototype,"fieldID",void 0);f([g({type:eo})],wn.prototype,"curve",void 0);f([g({type:WD})],wn.prototype,"base",void 0);f([g({type:A.Integer,converter:Le})],wn.prototype,"order",void 0);f([g({type:A.Integer,optional:!0})],wn.prototype,"cofactor",void 0);wn=f([$({type:F.Sequence})],wn);let Xn=class{constructor(e={}){Object.assign(this,e)}};f([g({type:A.ObjectIdentifier})],Xn.prototype,"namedCurve",void 0);f([g({type:A.Null})],Xn.prototype,"implicitCurve",void 0);f([g({type:wn})],Xn.prototype,"specifiedCurve",void 0);Xn=f([$({type:F.Choice})],Xn);class $d{constructor(e={}){this.version=1,this.privateKey=new be,Object.assign(this,e)}}f([g({type:A.Integer})],$d.prototype,"version",void 0);f([g({type:be})],$d.prototype,"privateKey",void 0);f([g({type:Xn,context:0,optional:!0})],$d.prototype,"parameters",void 0);f([g({type:A.BitString,context:1,optional:!0})],$d.prototype,"publicKey",void 0);class vu{constructor(e={}){this.r=new ArrayBuffer(0),this.s=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:A.Integer,converter:Le})],vu.prototype,"r",void 0);f([g({type:A.Integer,converter:Le})],vu.prototype,"s",void 0);const Kt="1.2.840.113549.1.1",Ki=`${Kt}.1`,GD=`${Kt}.7`,YD=`${Kt}.9`,ua=`${Kt}.10`,QD=`${Kt}.2`,JD=`${Kt}.4`,Su=`${Kt}.5`,XD=`${Kt}.14`,Dp=`${Kt}.11`,Eu=`${Kt}.12`,Au=`${Kt}.13`,PA=`${Kt}.15`,RA=`${Kt}.16`,xu="1.3.14.3.2.26",OA="2.16.840.1.101.3.4.2.4",_u="2.16.840.1.101.3.4.2.1",Cu="2.16.840.1.101.3.4.2.2",Iu="2.16.840.1.101.3.4.2.3",ZD="2.16.840.1.101.3.4.2.5",eL="2.16.840.1.101.3.4.2.6",tL="1.2.840.113549.2.2",rL="1.2.840.113549.2.5",qd=`${Kt}.8`;function et(r){return new J({algorithm:r,parameters:null})}et(tL);et(rL);const Vi=et(xu);et(OA);et(_u);et(Cu);et(Iu);et(ZD);et(eL);const BA=new J({algorithm:qd,parameters:W.serialize(Vi)}),NA=new J({algorithm:YD,parameters:W.serialize(ru.toASN(new Uint8Array([218,57,163,238,94,107,75,13,50,85,191,239,149,96,24,144,175,216,7,9]).buffer))});et(Ki);et(QD);et(JD);et(Su);et(PA);et(RA);et(Eu);et(Au);et(PA);et(RA);class Kd{constructor(e={}){this.hashAlgorithm=new J(Vi),this.maskGenAlgorithm=new J({algorithm:qd,parameters:W.serialize(Vi)}),this.pSourceAlgorithm=new J(NA),Object.assign(this,e)}}f([g({type:J,context:0,defaultValue:Vi})],Kd.prototype,"hashAlgorithm",void 0);f([g({type:J,context:1,defaultValue:BA})],Kd.prototype,"maskGenAlgorithm",void 0);f([g({type:J,context:2,defaultValue:NA})],Kd.prototype,"pSourceAlgorithm",void 0);new J({algorithm:GD,parameters:W.serialize(new Kd)});class zi{constructor(e={}){this.hashAlgorithm=new J(Vi),this.maskGenAlgorithm=new J({algorithm:qd,parameters:W.serialize(Vi)}),this.saltLength=20,this.trailerField=1,Object.assign(this,e)}}f([g({type:J,context:0,defaultValue:Vi})],zi.prototype,"hashAlgorithm",void 0);f([g({type:J,context:1,defaultValue:BA})],zi.prototype,"maskGenAlgorithm",void 0);f([g({type:A.Integer,context:2,defaultValue:20})],zi.prototype,"saltLength",void 0);f([g({type:A.Integer,context:3,defaultValue:1})],zi.prototype,"trailerField",void 0);new J({algorithm:ua,parameters:W.serialize(new zi)});class Vd{constructor(e={}){this.digestAlgorithm=new J,this.digest=new be,Object.assign(this,e)}}f([g({type:J})],Vd.prototype,"digestAlgorithm",void 0);f([g({type:be})],Vd.prototype,"digest",void 0);var Lp;class zd{constructor(e={}){this.prime=new ArrayBuffer(0),this.exponent=new ArrayBuffer(0),this.coefficient=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:A.Integer,converter:Le})],zd.prototype,"prime",void 0);f([g({type:A.Integer,converter:Le})],zd.prototype,"exponent",void 0);f([g({type:A.Integer,converter:Le})],zd.prototype,"coefficient",void 0);let Mp=Lp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,Lp.prototype)}};Mp=Lp=f([$({type:F.Sequence,itemType:zd})],Mp);class Gr{constructor(e={}){this.version=0,this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0),this.privateExponent=new ArrayBuffer(0),this.prime1=new ArrayBuffer(0),this.prime2=new ArrayBuffer(0),this.exponent1=new ArrayBuffer(0),this.exponent2=new ArrayBuffer(0),this.coefficient=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:A.Integer})],Gr.prototype,"version",void 0);f([g({type:A.Integer,converter:Le})],Gr.prototype,"modulus",void 0);f([g({type:A.Integer,converter:Le})],Gr.prototype,"publicExponent",void 0);f([g({type:A.Integer,converter:Le})],Gr.prototype,"privateExponent",void 0);f([g({type:A.Integer,converter:Le})],Gr.prototype,"prime1",void 0);f([g({type:A.Integer,converter:Le})],Gr.prototype,"prime2",void 0);f([g({type:A.Integer,converter:Le})],Gr.prototype,"exponent1",void 0);f([g({type:A.Integer,converter:Le})],Gr.prototype,"exponent2",void 0);f([g({type:A.Integer,converter:Le})],Gr.prototype,"coefficient",void 0);f([g({type:Mp,optional:!0})],Gr.prototype,"otherPrimeInfos",void 0);class Qm{constructor(e={}){this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:A.Integer,converter:Le})],Qm.prototype,"modulus",void 0);f([g({type:A.Integer,converter:Le})],Qm.prototype,"publicExponent",void 0);var Fp;(function(r){r[r.Transient=0]="Transient",r[r.Singleton=1]="Singleton",r[r.ResolutionScoped=2]="ResolutionScoped",r[r.ContainerScoped=3]="ContainerScoped"})(Fp||(Fp={}));const Bt=Fp;/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var Up=function(r,e){return Up=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,n){t.__proto__=n}||function(t,n){for(var i in n)n.hasOwnProperty(i)&&(t[i]=n[i])},Up(r,e)};function Jm(r,e){Up(r,e);function t(){this.constructor=r}r.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}function nL(r,e,t,n){function i(s){return s instanceof t?s:new t(function(o){o(s)})}return new(t||(t=Promise))(function(s,o){function a(u){try{l(n.next(u))}catch(d){o(d)}}function c(u){try{l(n.throw(u))}catch(d){o(d)}}function l(u){u.done?s(u.value):i(u.value).then(a,c)}l((n=n.apply(r,[])).next())})}function iL(r,e){var t={label:0,sent:function(){if(s[0]&1)throw s[1];return s[1]},trys:[],ops:[]},n,i,s,o;return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(l){return function(u){return c([l,u])}}function c(l){if(n)throw new TypeError("Generator is already executing.");for(;t;)try{if(n=1,i&&(s=l[0]&2?i.return:l[0]?i.throw||((s=i.return)&&s.call(i),0):i.next)&&!(s=s.call(i,l[1])).done)return s;switch(i=0,s&&(l=[l[0]&2,s.value]),l[0]){case 0:case 1:s=l;break;case 4:return t.label++,{value:l[1],done:!1};case 5:t.label++,i=l[1],l=[0];continue;case 7:l=t.ops.pop(),t.trys.pop();continue;default:if(s=t.trys,!(s=s.length>0&&s[s.length-1])&&(l[0]===6||l[0]===2)){t=0;continue}if(l[0]===3&&(!s||l[1]>s[0]&&l[1]<s[3])){t.label=l[1];break}if(l[0]===6&&t.label<s[1]){t.label=s[1],s=l;break}if(s&&t.label<s[2]){t.label=s[2],t.ops.push(l);break}s[2]&&t.ops.pop(),t.trys.pop();continue}l=e.call(r,t)}catch(u){l=[6,u],i=0}finally{n=s=0}if(l[0]&5)throw l[1];return{value:l[0]?l[1]:void 0,done:!0}}}function Uc(r){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&r[e],n=0;if(t)return t.call(r);if(r&&typeof r.length=="number")return{next:function(){return r&&n>=r.length&&(r=void 0),{value:r&&r[n++],done:!r}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")}function ku(r,e){var t=typeof Symbol=="function"&&r[Symbol.iterator];if(!t)return r;var n=t.call(r),i,s=[],o;try{for(;(e===void 0||e-- >0)&&!(i=n.next()).done;)s.push(i.value)}catch(a){o={error:a}}finally{try{i&&!i.done&&(t=n.return)&&t.call(n)}finally{if(o)throw o.error}}return s}function hi(){for(var r=[],e=0;e<arguments.length;e++)r=r.concat(ku(arguments[e]));return r}var sL="injectionTokens";function oL(r){var e=Reflect.getMetadata("design:paramtypes",r)||[],t=Reflect.getOwnMetadata(sL,r)||{};return Object.keys(t).forEach(function(n){e[+n]=t[n]}),e}function DA(r){return!!r.useClass}function $p(r){return!!r.useFactory}var LA=function(){function r(e){this.wrap=e,this.reflectMethods=["get","getPrototypeOf","setPrototypeOf","getOwnPropertyDescriptor","defineProperty","has","set","deleteProperty","apply","construct","ownKeys"]}return r.prototype.createProxy=function(e){var t=this,n={},i=!1,s,o=function(){return i||(s=e(t.wrap()),i=!0),s};return new Proxy(n,this.createHandler(o))},r.prototype.createHandler=function(e){var t={},n=function(i){t[i]=function(){for(var s=[],o=0;o<arguments.length;o++)s[o]=arguments[o];s[0]=e();var a=Reflect[i];return a.apply(void 0,hi(s))}};return this.reflectMethods.forEach(n),t},r}();function ls(r){return typeof r=="string"||typeof r=="symbol"}function aL(r){return typeof r=="object"&&"token"in r&&"multiple"in r}function Tb(r){return typeof r=="object"&&"token"in r&&"transform"in r}function cL(r){return typeof r=="function"||r instanceof LA}function hl(r){return!!r.useToken}function fl(r){return r.useValue!=null}function lL(r){return DA(r)||fl(r)||hl(r)||$p(r)}var Xm=function(){function r(){this._registryMap=new Map}return r.prototype.entries=function(){return this._registryMap.entries()},r.prototype.getAll=function(e){return this.ensure(e),this._registryMap.get(e)},r.prototype.get=function(e){this.ensure(e);var t=this._registryMap.get(e);return t[t.length-1]||null},r.prototype.set=function(e,t){this.ensure(e),this._registryMap.get(e).push(t)},r.prototype.setAll=function(e,t){this._registryMap.set(e,t)},r.prototype.has=function(e){return this.ensure(e),this._registryMap.get(e).length>0},r.prototype.clear=function(){this._registryMap.clear()},r.prototype.ensure=function(e){this._registryMap.has(e)||this._registryMap.set(e,[])},r}(),uL=function(r){Jm(e,r);function e(){return r!==null&&r.apply(this,arguments)||this}return e}(Xm),$c=function(){function r(){this.scopedResolutions=new Map}return r}();function dL(r,e){if(r===null)return"at position #"+e;var t=r.split(",")[e].trim();return'"'+t+'" at position #'+e}function hL(r,e,t){return t===void 0&&(t="    "),hi([r],e.message.split(`
`).map(function(n){return t+n})).join(`
`)}function fL(r,e,t){var n=ku(r.toString().match(/constructor\(([\w, ]+)\)/)||[],2),i=n[1],s=i===void 0?null:i,o=dL(s,e);return hL("Cannot inject the dependency "+o+' of "'+r.name+'" constructor. Reason:',t)}function pL(r){if(typeof r.dispose!="function")return!1;var e=r.dispose;return!(e.length>0)}var gL=function(r){Jm(e,r);function e(){return r!==null&&r.apply(this,arguments)||this}return e}(Xm),mL=function(r){Jm(e,r);function e(){return r!==null&&r.apply(this,arguments)||this}return e}(Xm),yL=function(){function r(){this.preResolution=new gL,this.postResolution=new mL}return r}(),MA=new Map,wL=function(){function r(e){this.parent=e,this._registry=new uL,this.interceptors=new yL,this.disposed=!1,this.disposables=new Set}return r.prototype.register=function(e,t,n){n===void 0&&(n={lifecycle:Bt.Transient}),this.ensureNotDisposed();var i;if(lL(t)?i=t:i={useClass:t},hl(i))for(var s=[e],o=i;o!=null;){var a=o.useToken;if(s.includes(a))throw new Error("Token registration cycle detected! "+hi(s,[a]).join(" -> "));s.push(a);var c=this._registry.get(a);c&&hl(c.provider)?o=c.provider:o=null}if((n.lifecycle===Bt.Singleton||n.lifecycle==Bt.ContainerScoped||n.lifecycle==Bt.ResolutionScoped)&&(fl(i)||$p(i)))throw new Error('Cannot use lifecycle "'+Bt[n.lifecycle]+'" with ValueProviders or FactoryProviders');return this._registry.set(e,{provider:i,options:n}),this},r.prototype.registerType=function(e,t){return this.ensureNotDisposed(),ls(t)?this.register(e,{useToken:t}):this.register(e,{useClass:t})},r.prototype.registerInstance=function(e,t){return this.ensureNotDisposed(),this.register(e,{useValue:t})},r.prototype.registerSingleton=function(e,t){if(this.ensureNotDisposed(),ls(e)){if(ls(t))return this.register(e,{useToken:t},{lifecycle:Bt.Singleton});if(t)return this.register(e,{useClass:t},{lifecycle:Bt.Singleton});throw new Error('Cannot register a type name as a singleton without a "to" token')}var n=e;return t&&!ls(t)&&(n=t),this.register(e,{useClass:n},{lifecycle:Bt.Singleton})},r.prototype.resolve=function(e,t,n){t===void 0&&(t=new $c),n===void 0&&(n=!1),this.ensureNotDisposed();var i=this.getRegistration(e);if(!i&&ls(e)){if(n)return;throw new Error('Attempted to resolve unregistered dependency token: "'+e.toString()+'"')}if(this.executePreResolutionInterceptor(e,"Single"),i){var s=this.resolveRegistration(i,t);return this.executePostResolutionInterceptor(e,s,"Single"),s}if(cL(e)){var s=this.construct(e,t);return this.executePostResolutionInterceptor(e,s,"Single"),s}throw new Error("Attempted to construct an undefined constructor. Could mean a circular dependency problem. Try using `delay` function.")},r.prototype.executePreResolutionInterceptor=function(e,t){var n,i;if(this.interceptors.preResolution.has(e)){var s=[];try{for(var o=Uc(this.interceptors.preResolution.getAll(e)),a=o.next();!a.done;a=o.next()){var c=a.value;c.options.frequency!="Once"&&s.push(c),c.callback(e,t)}}catch(l){n={error:l}}finally{try{a&&!a.done&&(i=o.return)&&i.call(o)}finally{if(n)throw n.error}}this.interceptors.preResolution.setAll(e,s)}},r.prototype.executePostResolutionInterceptor=function(e,t,n){var i,s;if(this.interceptors.postResolution.has(e)){var o=[];try{for(var a=Uc(this.interceptors.postResolution.getAll(e)),c=a.next();!c.done;c=a.next()){var l=c.value;l.options.frequency!="Once"&&o.push(l),l.callback(e,t,n)}}catch(u){i={error:u}}finally{try{c&&!c.done&&(s=a.return)&&s.call(a)}finally{if(i)throw i.error}}this.interceptors.postResolution.setAll(e,o)}},r.prototype.resolveRegistration=function(e,t){if(this.ensureNotDisposed(),e.options.lifecycle===Bt.ResolutionScoped&&t.scopedResolutions.has(e))return t.scopedResolutions.get(e);var n=e.options.lifecycle===Bt.Singleton,i=e.options.lifecycle===Bt.ContainerScoped,s=n||i,o;return fl(e.provider)?o=e.provider.useValue:hl(e.provider)?o=s?e.instance||(e.instance=this.resolve(e.provider.useToken,t)):this.resolve(e.provider.useToken,t):DA(e.provider)?o=s?e.instance||(e.instance=this.construct(e.provider.useClass,t)):this.construct(e.provider.useClass,t):$p(e.provider)?o=e.provider.useFactory(this):o=this.construct(e.provider,t),e.options.lifecycle===Bt.ResolutionScoped&&t.scopedResolutions.set(e,o),o},r.prototype.resolveAll=function(e,t,n){var i=this;t===void 0&&(t=new $c),n===void 0&&(n=!1),this.ensureNotDisposed();var s=this.getAllRegistrations(e);if(!s&&ls(e)){if(n)return[];throw new Error('Attempted to resolve unregistered dependency token: "'+e.toString()+'"')}if(this.executePreResolutionInterceptor(e,"All"),s){var o=s.map(function(c){return i.resolveRegistration(c,t)});return this.executePostResolutionInterceptor(e,o,"All"),o}var a=[this.construct(e,t)];return this.executePostResolutionInterceptor(e,a,"All"),a},r.prototype.isRegistered=function(e,t){return t===void 0&&(t=!1),this.ensureNotDisposed(),this._registry.has(e)||t&&(this.parent||!1)&&this.parent.isRegistered(e,!0)},r.prototype.reset=function(){this.ensureNotDisposed(),this._registry.clear(),this.interceptors.preResolution.clear(),this.interceptors.postResolution.clear()},r.prototype.clearInstances=function(){var e,t;this.ensureNotDisposed();try{for(var n=Uc(this._registry.entries()),i=n.next();!i.done;i=n.next()){var s=ku(i.value,2),o=s[0],a=s[1];this._registry.setAll(o,a.filter(function(c){return!fl(c.provider)}).map(function(c){return c.instance=void 0,c}))}}catch(c){e={error:c}}finally{try{i&&!i.done&&(t=n.return)&&t.call(n)}finally{if(e)throw e.error}}},r.prototype.createChildContainer=function(){var e,t;this.ensureNotDisposed();var n=new r(this);try{for(var i=Uc(this._registry.entries()),s=i.next();!s.done;s=i.next()){var o=ku(s.value,2),a=o[0],c=o[1];c.some(function(l){var u=l.options;return u.lifecycle===Bt.ContainerScoped})&&n._registry.setAll(a,c.map(function(l){return l.options.lifecycle===Bt.ContainerScoped?{provider:l.provider,options:l.options}:l}))}}catch(l){e={error:l}}finally{try{s&&!s.done&&(t=i.return)&&t.call(i)}finally{if(e)throw e.error}}return n},r.prototype.beforeResolution=function(e,t,n){n===void 0&&(n={frequency:"Always"}),this.interceptors.preResolution.set(e,{callback:t,options:n})},r.prototype.afterResolution=function(e,t,n){n===void 0&&(n={frequency:"Always"}),this.interceptors.postResolution.set(e,{callback:t,options:n})},r.prototype.dispose=function(){return nL(this,void 0,void 0,function(){var e;return iL(this,function(t){switch(t.label){case 0:return this.disposed=!0,e=[],this.disposables.forEach(function(n){var i=n.dispose();i&&e.push(i)}),[4,Promise.all(e)];case 1:return t.sent(),[2]}})})},r.prototype.getRegistration=function(e){return this.isRegistered(e)?this._registry.get(e):this.parent?this.parent.getRegistration(e):null},r.prototype.getAllRegistrations=function(e){return this.isRegistered(e)?this._registry.getAll(e):this.parent?this.parent.getAllRegistrations(e):null},r.prototype.construct=function(e,t){var n=this;if(e instanceof LA)return e.createProxy(function(s){return n.resolve(s,t)});var i=function(){var s=MA.get(e);if(!s||s.length===0){if(e.length===0)return new e;throw new Error('TypeInfo not known for "'+e.name+'"')}var o=s.map(n.resolveParams(t,e));return new(e.bind.apply(e,hi([void 0],o)))}();return pL(i)&&this.disposables.add(i),i},r.prototype.resolveParams=function(e,t){var n=this;return function(i,s){var o,a,c;try{return aL(i)?Tb(i)?i.multiple?(o=n.resolve(i.transform)).transform.apply(o,hi([n.resolveAll(i.token,new $c,i.isOptional)],i.transformArgs)):(a=n.resolve(i.transform)).transform.apply(a,hi([n.resolve(i.token,e,i.isOptional)],i.transformArgs)):i.multiple?n.resolveAll(i.token,new $c,i.isOptional):n.resolve(i.token,e,i.isOptional):Tb(i)?(c=n.resolve(i.transform,e)).transform.apply(c,hi([n.resolve(i.token,e)],i.transformArgs)):n.resolve(i,e)}catch(l){throw new Error(fL(t,s,l))}}},r.prototype.ensureNotDisposed=function(){if(this.disposed)throw new Error("This container has been disposed, you cannot interact with a disposed container")},r}(),ht=new wL;function jd(r){return function(e){MA.set(e,oL(e))}}if(typeof Reflect>"u"||!Reflect.getMetadata)throw new Error(`tsyringe requires a reflect polyfill. Please add 'import "reflect-metadata"' to the top of your entry point.`);var qp;class Hd{constructor(e={}){this.attrId="",this.attrValues=[],Object.assign(e)}}f([g({type:A.ObjectIdentifier})],Hd.prototype,"attrId",void 0);f([g({type:A.Any,repeated:"set"})],Hd.prototype,"attrValues",void 0);let Pb=qp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,qp.prototype)}};Pb=qp=f([$({type:F.Sequence,itemType:Hd})],Pb);var Kp;let Rb=Kp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,Kp.prototype)}};Rb=Kp=f([$({type:F.Sequence,itemType:_o})],Rb);class FA{constructor(e={}){this.certId="",this.certValue=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:A.ObjectIdentifier})],FA.prototype,"certId",void 0);f([g({type:A.Any,context:0})],FA.prototype,"certValue",void 0);class UA{constructor(e={}){this.crlId="",this.crltValue=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:A.ObjectIdentifier})],UA.prototype,"crlId",void 0);f([g({type:A.Any,context:0})],UA.prototype,"crltValue",void 0);class $A extends be{}let Wd=class{constructor(e={}){this.encryptionAlgorithm=new J,this.encryptedData=new $A,Object.assign(this,e)}};f([g({type:J})],Wd.prototype,"encryptionAlgorithm",void 0);f([g({type:$A})],Wd.prototype,"encryptedData",void 0);var Vp,zp;(function(r){r[r.v1=0]="v1"})(zp||(zp={}));class qA extends be{}let jp=Vp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,Vp.prototype)}};jp=Vp=f([$({type:F.Sequence,itemType:mn})],jp);class gc{constructor(e={}){this.version=zp.v1,this.privateKeyAlgorithm=new J,this.privateKey=new qA,Object.assign(this,e)}}f([g({type:A.Integer})],gc.prototype,"version",void 0);f([g({type:J})],gc.prototype,"privateKeyAlgorithm",void 0);f([g({type:qA})],gc.prototype,"privateKey",void 0);f([g({type:jp,implicit:!0,context:0,optional:!0})],gc.prototype,"attributes",void 0);let Ob=class extends gc{};Ob=f([$({type:F.Sequence})],Ob);let Bb=class extends Wd{};Bb=f([$({type:F.Sequence})],Bb);class KA{constructor(e={}){this.secretTypeId="",this.secretValue=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:A.ObjectIdentifier})],KA.prototype,"secretTypeId",void 0);f([g({type:A.Any,context:0})],KA.prototype,"secretValue",void 0);class mc{constructor(e={}){this.mac=new Vd,this.macSalt=new be,this.iterations=1,Object.assign(this,e)}}f([g({type:Vd})],mc.prototype,"mac",void 0);f([g({type:be})],mc.prototype,"macSalt",void 0);f([g({type:A.Integer,defaultValue:1})],mc.prototype,"iterations",void 0);class Gd{constructor(e={}){this.version=3,this.authSafe=new _o,this.macData=new mc,Object.assign(this,e)}}f([g({type:A.Integer})],Gd.prototype,"version",void 0);f([g({type:_o})],Gd.prototype,"authSafe",void 0);f([g({type:mc,optional:!0})],Gd.prototype,"macData",void 0);var Hp;class Yd{constructor(e={}){this.bagId="",this.bagValue=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:A.ObjectIdentifier})],Yd.prototype,"bagId",void 0);f([g({type:A.Any,context:0})],Yd.prototype,"bagValue",void 0);f([g({type:Hd,repeated:"set",optional:!0})],Yd.prototype,"bagAttributes",void 0);let Nb=Hp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,Hp.prototype)}};Nb=Hp=f([$({type:F.Sequence,itemType:Yd})],Nb);var Wp,Gp,Yp;const VA="1.2.840.113549.1.9",zA=`${VA}.7`,Zm=`${VA}.14`;let Tu=class extends dt{constructor(e={}){super(e)}toString(){return this.ia5String||super.toString()}};f([g({type:A.IA5String})],Tu.prototype,"ia5String",void 0);Tu=f([$({type:F.Choice})],Tu);let Db=class extends _o{};Db=f([$({type:F.Sequence})],Db);let Lb=class extends Gd{};Lb=f([$({type:F.Sequence})],Lb);let Mb=class extends Wd{};Mb=f([$({type:F.Sequence})],Mb);let Qp=class{constructor(e=""){this.value=e}toString(){return this.value}};f([g({type:A.IA5String})],Qp.prototype,"value",void 0);Qp=f([$({type:F.Choice})],Qp);let Fb=class extends Tu{};Fb=f([$({type:F.Choice})],Fb);let Ub=class extends dt{};Ub=f([$({type:F.Choice})],Ub);let Jp=class{constructor(e=new Date){this.value=e}};f([g({type:A.GeneralizedTime})],Jp.prototype,"value",void 0);Jp=f([$({type:F.Choice})],Jp);let $b=class extends dt{};$b=f([$({type:F.Choice})],$b);let Xp=class{constructor(e="M"){this.value=e}toString(){return this.value}};f([g({type:A.PrintableString})],Xp.prototype,"value",void 0);Xp=f([$({type:F.Choice})],Xp);let Pu=class{constructor(e=""){this.value=e}toString(){return this.value}};f([g({type:A.PrintableString})],Pu.prototype,"value",void 0);Pu=f([$({type:F.Choice})],Pu);let qb=class extends Pu{};qb=f([$({type:F.Choice})],qb);let Kb=class extends dt{};Kb=f([$({type:F.Choice})],Kb);let Zp=class{constructor(e=""){this.value=e}toString(){return this.value}};f([g({type:A.ObjectIdentifier})],Zp.prototype,"value",void 0);Zp=f([$({type:F.Choice})],Zp);let Vb=class extends ct{};Vb=f([$({type:F.Choice})],Vb);let eg=class{constructor(e=0){this.value=e}toString(){return this.value.toString()}};f([g({type:A.Integer})],eg.prototype,"value",void 0);eg=f([$({type:F.Choice})],eg);let zb=class extends Wr{};zb=f([$({type:F.Sequence})],zb);let Ru=class extends dt{};Ru=f([$({type:F.Choice})],Ru);let jb=Wp=class extends Qn{constructor(e){super(e),Object.setPrototypeOf(this,Wp.prototype)}};jb=Wp=f([$({type:F.Sequence})],jb);let Hb=Gp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,Gp.prototype)}};Hb=Gp=f([$({type:F.Set,itemType:xo})],Hb);let tg=class{constructor(e=""){this.value=e}toString(){return this.value}};f([g({type:A.BmpString})],tg.prototype,"value",void 0);tg=f([$({type:F.Choice})],tg);let rg=class extends J{};rg=f([$({type:F.Sequence})],rg);let Wb=Yp=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,Yp.prototype)}};Wb=Yp=f([$({type:F.Sequence,itemType:rg})],Wb);var ng;let Ou=ng=class extends Ce{constructor(e){super(e),Object.setPrototypeOf(this,ng.prototype)}};Ou=ng=f([$({type:F.Sequence,itemType:mn})],Ou);class ko{constructor(e={}){this.version=0,this.subject=new We,this.subjectPKInfo=new vr,this.attributes=new Ou,Object.assign(this,e)}}f([g({type:A.Integer})],ko.prototype,"version",void 0);f([g({type:We})],ko.prototype,"subject",void 0);f([g({type:vr})],ko.prototype,"subjectPKInfo",void 0);f([g({type:Ou,implicit:!0,context:0})],ko.prototype,"attributes",void 0);class Oa{constructor(e={}){this.certificationRequestInfo=new ko,this.signatureAlgorithm=new J,this.signature=new ArrayBuffer(0),Object.assign(this,e)}}f([g({type:ko})],Oa.prototype,"certificationRequestInfo",void 0);f([g({type:J})],Oa.prototype,"signatureAlgorithm",void 0);f([g({type:A.BitString})],Oa.prototype,"signature",void 0);/*!
 * MIT License
 * 
 * Copyright (c) Peculiar Ventures. All rights reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */const yc="crypto.algorithm";class bL{getAlgorithms(){return ht.resolveAll(yc)}toAsnAlgorithm(e){({...e});for(const t of this.getAlgorithms()){const n=t.toAsnAlgorithm(e);if(n)return n}if(/^[0-9.]+$/.test(e.name)){const t=new J({algorithm:e.name});if("parameters"in e){const n=e;t.parameters=n.parameters}return t}throw new Error("Cannot convert WebCrypto algorithm to ASN.1 algorithm")}toWebAlgorithm(e){for(const n of this.getAlgorithms()){const i=n.toWebAlgorithm(e);if(i)return i}return{name:e.algorithm,parameters:e.parameters}}}const ji="crypto.algorithmProvider";ht.registerSingleton(ji,bL);var pl;const Vt="1.3.36.3.3.2.8.1.1",Gb=`${Vt}.1`,Yb=`${Vt}.2`,Qb=`${Vt}.3`,Jb=`${Vt}.4`,Xb=`${Vt}.5`,Zb=`${Vt}.6`,e0=`${Vt}.7`,t0=`${Vt}.8`,r0=`${Vt}.9`,n0=`${Vt}.10`,i0=`${Vt}.11`,s0=`${Vt}.12`,o0=`${Vt}.13`,a0=`${Vt}.14`,c0="brainpoolP160r1",l0="brainpoolP160t1",u0="brainpoolP192r1",d0="brainpoolP192t1",h0="brainpoolP224r1",f0="brainpoolP224t1",p0="brainpoolP256r1",g0="brainpoolP256t1",m0="brainpoolP320r1",y0="brainpoolP320t1",w0="brainpoolP384r1",b0="brainpoolP384t1",v0="brainpoolP512r1",S0="brainpoolP512t1",Ue="ECDSA";let Ba=pl=class{toAsnAlgorithm(e){switch(e.name.toLowerCase()){case Ue.toLowerCase():if("hash"in e)switch((typeof e.hash=="string"?e.hash:e.hash.name).toLowerCase()){case"sha-1":return VD;case"sha-256":return zD;case"sha-384":return jD;case"sha-512":return HD}else if("namedCurve"in e){let t="";switch(e.namedCurve){case"P-256":t=Cb;break;case"K-256":t=pl.SECP256K1;break;case"P-384":t=Ib;break;case"P-521":t=kb;break;case c0:t=Gb;break;case l0:t=Yb;break;case u0:t=Qb;break;case d0:t=Jb;break;case h0:t=Xb;break;case f0:t=Zb;break;case p0:t=e0;break;case g0:t=t0;break;case m0:t=r0;break;case y0:t=n0;break;case w0:t=i0;break;case b0:t=s0;break;case v0:t=o0;break;case S0:t=a0;break}if(t)return new J({algorithm:Pa,parameters:W.serialize(new Xn({namedCurve:t}))})}}return null}toWebAlgorithm(e){switch(e.algorithm){case Hm:return{name:Ue,hash:{name:"SHA-1"}};case Wm:return{name:Ue,hash:{name:"SHA-256"}};case Gm:return{name:Ue,hash:{name:"SHA-384"}};case Ym:return{name:Ue,hash:{name:"SHA-512"}};case Pa:{if(!e.parameters)throw new TypeError("Cannot get required parameters from EC algorithm");switch(W.parse(e.parameters,Xn).namedCurve){case Cb:return{name:Ue,namedCurve:"P-256"};case pl.SECP256K1:return{name:Ue,namedCurve:"K-256"};case Ib:return{name:Ue,namedCurve:"P-384"};case kb:return{name:Ue,namedCurve:"P-521"};case Gb:return{name:Ue,namedCurve:c0};case Yb:return{name:Ue,namedCurve:l0};case Qb:return{name:Ue,namedCurve:u0};case Jb:return{name:Ue,namedCurve:d0};case Xb:return{name:Ue,namedCurve:h0};case Zb:return{name:Ue,namedCurve:f0};case e0:return{name:Ue,namedCurve:p0};case t0:return{name:Ue,namedCurve:g0};case r0:return{name:Ue,namedCurve:m0};case n0:return{name:Ue,namedCurve:y0};case i0:return{name:Ue,namedCurve:w0};case s0:return{name:Ue,namedCurve:b0};case o0:return{name:Ue,namedCurve:v0};case a0:return{name:Ue,namedCurve:S0}}}}return null}};Ba.SECP256K1="1.3.132.0.10";Ba=pl=f([jd()],Ba);ht.registerSingleton(yc,Ba);const jA=Symbol("name"),HA=Symbol("value");class Ee{constructor(e,t={},n=""){this[jA]=e,this[HA]=n;for(const i in t)this[i]=t[i]}}Ee.NAME=jA;Ee.VALUE=HA;class vL{static toTextObject(e){const t=new Ee("Algorithm Identifier",{},ri.toString(e.algorithm));if(e.parameters)switch(e.algorithm){case Pa:{const n=new Ba().toWebAlgorithm(e);n&&"namedCurve"in n?t["Named Curve"]=n.namedCurve:t.Parameters=e.parameters;break}default:t.Parameters=e.parameters}return t}}class ri{static toString(e){const t=this.items[e];return t||e}}ri.items={[xu]:"sha1",[OA]:"sha224",[_u]:"sha256",[Cu]:"sha384",[Iu]:"sha512",[Ki]:"rsaEncryption",[Su]:"sha1WithRSAEncryption",[XD]:"sha224WithRSAEncryption",[Dp]:"sha256WithRSAEncryption",[Eu]:"sha384WithRSAEncryption",[Au]:"sha512WithRSAEncryption",[Pa]:"ecPublicKey",[Hm]:"ecdsaWithSHA1",[TA]:"ecdsaWithSHA224",[Wm]:"ecdsaWithSHA256",[Gm]:"ecdsaWithSHA384",[Ym]:"ecdsaWithSHA512",[LD]:"TLS WWW server authentication",[MD]:"TLS WWW client authentication",[FD]:"Code Signing",[UD]:"E-mail Protection",[$D]:"Time Stamping",[qD]:"OCSP Signing",[KD]:"Signed Data"};class Hi{static serialize(e){return this.serializeObj(e).join(`
`)}static pad(e=0){return"".padStart(2*e," ")}static serializeObj(e,t=0){const n=[];let i=this.pad(t++),s="";const o=e[Ee.VALUE];o&&(s=` ${o}`),n.push(`${i}${e[Ee.NAME]}:${s}`),i=this.pad(t);for(const a in e){if(typeof a=="symbol")continue;const c=e[a],l=a?`${a}: `:"";if(typeof c=="string"||typeof c=="number"||typeof c=="boolean")n.push(`${i}${l}${c}`);else if(c instanceof Date)n.push(`${i}${l}${c.toUTCString()}`);else if(Array.isArray(c))for(const u of c)u[Ee.NAME]=a,n.push(...this.serializeObj(u,t));else if(c instanceof Ee)c[Ee.NAME]=a,n.push(...this.serializeObj(c,t));else if(G.isBufferSource(c))a?(n.push(`${i}${l}`),n.push(...this.serializeBufferSource(c,t+1))):n.push(...this.serializeBufferSource(c,t));else if("toTextObject"in c){const u=c.toTextObject();u[Ee.NAME]=a,n.push(...this.serializeObj(u,t))}else throw new TypeError("Cannot serialize data in text format. Unsupported type.")}return n}static serializeBufferSource(e,t=0){const n=this.pad(t),i=G.toUint8Array(e),s=[];for(let o=0;o<i.length;){const a=[];for(let c=0;c<16&&o<i.length;c++){c===8&&a.push("");const l=i[o++].toString(16).padStart(2,"0");a.push(l)}s.push(`${n}${a.join(" ")}`)}return s}static serializeAlgorithm(e){return this.algorithmSerializer.toTextObject(e)}}Hi.oidSerializer=ri;Hi.algorithmSerializer=vL;class ni{constructor(...e){if(e.length===1){const t=e[0];this.rawData=W.serialize(t),this.onInit(t)}else{const t=W.parse(e[0],e[1]);this.rawData=G.toArrayBuffer(e[0]),this.onInit(t)}}equal(e){return e instanceof ni?g1(e.rawData,this.rawData):!1}toString(e="text"){switch(e){case"asn":return W.toString(this.rawData);case"text":return Hi.serialize(this.toTextObject());case"hex":return te.ToHex(this.rawData);case"base64":return te.ToBase64(this.rawData);case"base64url":return te.ToBase64Url(this.rawData);default:throw TypeError("Argument 'format' is unsupported value")}}getTextName(){return this.constructor.NAME}toTextObject(){const e=this.toTextObjectEmpty();return e[""]=this.rawData,e}toTextObjectEmpty(e){return new Ee(this.getTextName(),{},e)}}ni.NAME="ASN";class cr extends ni{constructor(...e){let t;G.isBufferSource(e[0])?t=G.toArrayBuffer(e[0]):t=W.serialize(new or({extnID:e[0],critical:e[1],extnValue:new be(G.toArrayBuffer(e[2]))})),super(t,or)}onInit(e){this.type=e.extnID,this.critical=e.critical,this.value=e.extnValue.buffer}toTextObject(){const e=this.toTextObjectWithoutValue();return e[""]=this.value,e}toTextObjectWithoutValue(){const e=this.toTextObjectEmpty(this.critical?"critical":void 0);return e[Ee.NAME]===cr.NAME&&(e[Ee.NAME]=ri.toString(this.type)),e}}var WA;class Fn{static isCryptoKeyPair(e){return e&&e.privateKey&&e.publicKey}static isCryptoKey(e){return e&&e.usages&&e.type&&e.algorithm&&e.extractable!==void 0}constructor(){this.items=new Map,this[WA]="CryptoProvider",typeof self<"u"&&typeof crypto<"u"?this.set(Fn.DEFAULT,crypto):typeof global<"u"&&global.crypto&&global.crypto.subtle&&this.set(Fn.DEFAULT,global.crypto)}clear(){this.items.clear()}delete(e){return this.items.delete(e)}forEach(e,t){return this.items.forEach(e,t)}has(e){return this.items.has(e)}get size(){return this.items.size}entries(){return this.items.entries()}keys(){return this.items.keys()}values(){return this.items.values()}[Symbol.iterator](){return this.items[Symbol.iterator]()}get(e=Fn.DEFAULT){const t=this.items.get(e.toLowerCase());if(!t)throw new Error(`Cannot get Crypto by name '${e}'`);return t}set(e,t){if(typeof e=="string"){if(!t)throw new TypeError("Argument 'value' is required");this.items.set(e.toLowerCase(),t)}else this.items.set(Fn.DEFAULT,e);return this}}WA=Symbol.toStringTag;Fn.DEFAULT="default";const at=new Fn,SL=/^[0-2](?:\.[1-9][0-9]*)+$/;function EL(r){return new RegExp(SL).test(r)}class GA{constructor(e={}){this.items={};for(const t in e)this.register(t,e[t])}get(e){return this.items[e]||null}findId(e){return EL(e)?e:this.get(e)}register(e,t){this.items[e]=t,this.items[t]=e}}const qt=new GA;qt.register("CN","2.5.4.3");qt.register("L","2.5.4.7");qt.register("ST","2.5.4.8");qt.register("O","2.5.4.10");qt.register("OU","2.5.4.11");qt.register("C","2.5.4.6");qt.register("DC","0.9.2342.19200300.100.1.25");qt.register("E","1.2.840.113549.1.9.1");qt.register("G","2.5.4.42");qt.register("I","2.5.4.43");qt.register("SN","2.5.4.4");qt.register("T","2.5.4.12");function AL(r,e){return`\\${te.ToHex(te.FromUtf8String(e)).toUpperCase()}`}function xL(r){return r.replace(/([,+"\\<>;])/g,"\\$1").replace(/^([ #])/,"\\$1").replace(/([ ]$)/,"\\$1").replace(/([\r\n\t])/,AL)}class nr{static isASCII(e){for(let t=0;t<e.length;t++)if(e.charCodeAt(t)>255)return!1;return!0}static isPrintableString(e){return/^[A-Za-z0-9 '()+,-./:=?]*$/g.test(e)}constructor(e,t={}){this.extraNames=new GA,this.asn=new We;for(const n in t)if(Object.prototype.hasOwnProperty.call(t,n)){const i=t[n];this.extraNames.register(n,i)}typeof e=="string"?this.asn=this.fromString(e):e instanceof We?this.asn=e:G.isBufferSource(e)?this.asn=W.parse(e,We):this.asn=this.fromJSON(e)}getField(e){const t=this.extraNames.findId(e)||qt.findId(e),n=[];for(const i of this.asn)for(const s of i)s.type===t&&n.push(s.value.toString());return n}getName(e){return this.extraNames.get(e)||qt.get(e)}toString(){return this.asn.map(e=>e.map(t=>{const n=this.getName(t.type)||t.type,i=t.value.anyValue?`#${te.ToHex(t.value.anyValue)}`:xL(t.value.toString());return`${n}=${i}`}).join("+")).join(", ")}toJSON(){var e;const t=[];for(const n of this.asn){const i={};for(const s of n){const o=this.getName(s.type)||s.type;(e=i[o])!==null&&e!==void 0||(i[o]=[]),i[o].push(s.value.anyValue?`#${te.ToHex(s.value.anyValue)}`:s.value.toString())}t.push(i)}return t}fromString(e){const t=new We,n=/(\d\.[\d.]*\d|[A-Za-z]+)=((?:"")|(?:".*?[^\\]")|(?:[^,+"\\](?=[,+]|$))|(?:[^,+].*?(?:[^\\][,+]))|(?:))([,+])?/g;let i=null,s=",";for(;i=n.exec(`${e},`);){let[,o,a]=i;const c=a[a.length-1];(c===","||c==="+")&&(a=a.slice(0,a.length-1),i[3]=c);const l=i[3];o=this.getTypeOid(o);const u=this.createAttribute(o,a);s==="+"?t[t.length-1].push(u):t.push(new Ws([u])),s=l}return t}fromJSON(e){const t=new We;for(const n of e){const i=new Ws;for(const s in n){const o=this.getTypeOid(s),a=n[s];for(const c of a){const l=this.createAttribute(o,c);i.push(l)}}t.push(i)}return t}getTypeOid(e){if(/[\d.]+/.test(e)||(e=this.getName(e)||""),!e)throw new Error(`Cannot get OID for name type '${e}'`);return e}createAttribute(e,t){const n=new _d({type:e});if(typeof t=="object")for(const i in t)switch(i){case"ia5String":n.value.ia5String=t[i];break;case"utf8String":n.value.utf8String=t[i];break;case"universalString":n.value.universalString=t[i];break;case"bmpString":n.value.bmpString=t[i];break;case"printableString":n.value.printableString=t[i];break}else if(t[0]==="#")n.value.anyValue=te.FromHex(t.slice(1));else{const i=this.processStringValue(t);e===this.getName("E")||e===this.getName("DC")?n.value.ia5String=i:nr.isPrintableString(i)?n.value.printableString=i:n.value.utf8String=i}return n}processStringValue(e){const t=/"(.*?[^\\])?"/.exec(e);return t&&(e=t[1]),e.replace(/\\0a/ig,`
`).replace(/\\0d/ig,"\r").replace(/\\0g/ig,"	").replace(/\\(.)/g,"$1")}toArrayBuffer(){return W.serialize(this.asn)}async getThumbprint(...e){var t;let n,i="SHA-1";return e.length>=1&&!(!((t=e[0])===null||t===void 0)&&t.subtle)?(i=e[0]||i,n=e[1]||at.get()):n=e[0]||at.get(),await n.subtle.digest(i,this.toArrayBuffer())}}const YA="Cannot initialize GeneralName from ASN.1 data.",E0=`${YA} Unsupported string format in use.`,_L=`${YA} Value doesn't match to GUID regular expression.`,A0=/^([0-9a-f]{8})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{12})$/i,x0="1.3.6.1.4.1.311.25.1",_0="1.3.6.1.4.1.311.20.2.3",Ih="dns",kh="dn",Th="email",Ph="ip",Rh="url",Oh="guid",Bh="upn",qc="id";class Un extends ni{constructor(...e){let t;if(e.length===2)switch(e[0]){case kh:{const n=new nr(e[1]).toArrayBuffer(),i=W.parse(n,We);t=new ue({directoryName:i});break}case Ih:t=new ue({dNSName:e[1]});break;case Th:t=new ue({rfc822Name:e[1]});break;case Oh:{const n=new RegExp(A0,"i").exec(e[1]);if(!n)throw new Error("Cannot parse GUID value. Value doesn't match to regular expression");const i=n.slice(1).map((s,o)=>o<3?te.ToHex(new Uint8Array(te.FromHex(s)).reverse()):s).join("");t=new ue({otherName:new Ca({typeId:x0,value:W.serialize(new be(te.FromHex(i)))})});break}case Ph:t=new ue({iPAddress:e[1]});break;case qc:t=new ue({registeredID:e[1]});break;case Bh:{t=new ue({otherName:new Ca({typeId:_0,value:W.serialize(hA.toASN(e[1]))})});break}case Rh:t=new ue({uniformResourceIdentifier:e[1]});break;default:throw new Error("Cannot create GeneralName. Unsupported type of the name")}else G.isBufferSource(e[0])?t=W.parse(e[0],ue):t=e[0];super(t)}onInit(e){if(e.dNSName!=null)this.type=Ih,this.value=e.dNSName;else if(e.rfc822Name!=null)this.type=Th,this.value=e.rfc822Name;else if(e.iPAddress!=null)this.type=Ph,this.value=e.iPAddress;else if(e.uniformResourceIdentifier!=null)this.type=Rh,this.value=e.uniformResourceIdentifier;else if(e.registeredID!=null)this.type=qc,this.value=e.registeredID;else if(e.directoryName!=null)this.type=kh,this.value=new nr(e.directoryName).toString();else if(e.otherName!=null)if(e.otherName.typeId===x0){this.type=Oh;const t=W.parse(e.otherName.value,be),n=new RegExp(A0,"i").exec(te.ToHex(t));if(!n)throw new Error(_L);this.value=n.slice(1).map((i,s)=>s<3?te.ToHex(new Uint8Array(te.FromHex(i)).reverse()):i).join("-")}else if(e.otherName.typeId===_0)this.type=Bh,this.value=W.parse(e.otherName.value,dt).toString();else throw new Error(E0);else throw new Error(E0)}toJSON(){return{type:this.type,value:this.value}}toTextObject(){let e;switch(this.type){case kh:case Ih:case Oh:case Ph:case qc:case Bh:case Rh:e=this.type.toUpperCase();break;case Th:e="Email";break;default:throw new Error("Unsupported GeneralName type")}let t=this.value;return this.type===qc&&(t=ri.toString(t)),new Ee(e,void 0,t)}}class Na extends ni{constructor(e){let t;if(e instanceof Tt)t=e;else if(Array.isArray(e)){const n=[];for(const i of e)if(i instanceof ue)n.push(i);else{const s=W.parse(new Un(i.type,i.value).rawData,ue);n.push(s)}t=new Tt(n)}else if(G.isBufferSource(e))t=W.parse(e,Tt);else throw new Error("Cannot initialize GeneralNames. Incorrect incoming arguments");super(t)}onInit(e){const t=[];for(const n of e){let i=null;try{i=new Un(n)}catch{continue}t.push(i)}this.items=t}toJSON(){return this.items.map(e=>e.toJSON())}toTextObject(){const e=super.toTextObjectEmpty();for(const t of this.items){const n=t.toTextObject();let i=e[n[Ee.NAME]];Array.isArray(i)||(i=[],e[n[Ee.NAME]]=i),i.push(n)}return e}}Na.NAME="GeneralNames";const da="-{5}",Da="\\n",CL=`[^${Da}]+`,IL=`${da}BEGIN (${CL}(?=${da}))${da}`,kL=`${da}END \\1${da}`,to="\\n",TL=`[^:${Da}]+`,PL=`(?:[^${Da}]+${to}(?: +[^${Da}]+${to})*)`,RL="[a-zA-Z0-9=+/]+",OL=`(?:${RL}${to})+`,C0=`${IL}${to}(?:((?:${TL}: ${PL})+))?${to}?(${OL})${kL}`;class Wt{static isPem(e){return typeof e=="string"&&new RegExp(C0,"g").test(e.replace(/\r/g,""))}static decodeWithHeaders(e){e=e.replace(/\r/g,"");const t=new RegExp(C0,"g"),n=[];let i=null;for(;i=t.exec(e);){const s=i[3].replace(new RegExp(`[${Da}]+`,"g"),""),o={type:i[1],headers:[],rawData:te.FromBase64(s)},a=i[2];if(a){const c=a.split(new RegExp(to,"g"));let l=null;for(const u of c){const[d,h]=u.split(/:(.*)/);if(h===void 0){if(!l)throw new Error("Cannot parse PEM string. Incorrect header value");l.value+=d.trim()}else l&&o.headers.push(l),l={key:d,value:h.trim()}}l&&o.headers.push(l)}n.push(o)}return n}static decode(e){return this.decodeWithHeaders(e).map(n=>n.rawData)}static decodeFirst(e){const t=this.decode(e);if(!t.length)throw new RangeError("PEM string doesn't contain any objects");return t[0]}static encode(e,t){if(Array.isArray(e)){const n=new Array;return t?e.forEach(i=>{if(!G.isBufferSource(i))throw new TypeError("Cannot encode array of BufferSource in PEM format. Not all items of the array are BufferSource");n.push(this.encodeStruct({type:t,rawData:G.toArrayBuffer(i)}))}):e.forEach(i=>{if(!("type"in i))throw new TypeError("Cannot encode array of PemStruct in PEM format. Not all items of the array are PemStrut");n.push(this.encodeStruct(i))}),n.join(`
`)}else{if(!t)throw new Error("Required argument 'tag' is missed");return this.encodeStruct({type:t,rawData:G.toArrayBuffer(e)})}}static encodeStruct(e){var t;const n=e.type.toLocaleUpperCase(),i=[];if(i.push(`-----BEGIN ${n}-----`),!((t=e.headers)===null||t===void 0)&&t.length){for(const l of e.headers)i.push(`${l.key}: ${l.value}`);i.push("")}const s=te.ToBase64(e.rawData);let o,a=0;const c=Array();for(;a<s.length&&(s.length-a<64?o=s.substring(a):(o=s.substring(a,a+64),a+=64),o.length!==0);)if(c.push(o),o.length<64)break;return i.push(...c),i.push(`-----END ${n}-----`),i.join(`
`)}}Wt.CertificateTag="CERTIFICATE";Wt.CrlTag="CRL";Wt.CertificateRequestTag="CERTIFICATE REQUEST";Wt.PublicKeyTag="PUBLIC KEY";Wt.PrivateKeyTag="PRIVATE KEY";class bn extends ni{static isAsnEncoded(e){return G.isBufferSource(e)||typeof e=="string"}static toArrayBuffer(e){if(typeof e=="string"){if(Wt.isPem(e))return Wt.decode(e)[0];if(te.isHex(e))return te.FromHex(e);if(te.isBase64(e))return te.FromBase64(e);if(te.isBase64Url(e))return te.FromBase64Url(e);throw new TypeError("Unsupported format of 'raw' argument. Must be one of DER, PEM, HEX, Base64, or Base4Url")}else{const t=te.ToBinary(e);return Wt.isPem(t)?Wt.decode(t)[0]:te.isHex(t)?te.FromHex(t):te.isBase64(t)?te.FromBase64(t):te.isBase64Url(t)?te.FromBase64Url(t):G.toArrayBuffer(e)}}constructor(...e){bn.isAsnEncoded(e[0])?super(bn.toArrayBuffer(e[0]),e[1]):super(e[0])}toString(e="pem"){switch(e){case"pem":return Wt.encode(this.rawData,this.tag);default:return super.toString(e)}}}class Sr extends bn{static async create(e,t=at.get()){if(e instanceof Sr)return e;if(Fn.isCryptoKey(e)){if(e.type!=="public")throw new TypeError("Public key is required");const n=await t.subtle.exportKey("spki",e);return new Sr(n)}else{if(e.publicKey)return e.publicKey;if(G.isBufferSource(e))return new Sr(e);throw new TypeError("Unsupported PublicKeyType")}}constructor(e){bn.isAsnEncoded(e)?super(e,vr):super(e),this.tag=Wt.PublicKeyTag}async export(...e){let t,n=["verify"],i={hash:"SHA-256",...this.algorithm};e.length>1?(i=e[0]||i,n=e[1]||n,t=e[2]||at.get()):t=e[0]||at.get();let s=this.rawData;const o=W.parse(this.rawData,vr);return o.algorithm.algorithm===ua&&(s=BL(o,s)),t.subtle.importKey("spki",s,i,!0,n)}onInit(e){const t=ht.resolve(ji),n=this.algorithm=t.toWebAlgorithm(e.algorithm);switch(e.algorithm.algorithm){case Ki:{const i=W.parse(e.subjectPublicKey,Qm),s=G.toUint8Array(i.modulus);n.publicExponent=G.toUint8Array(i.publicExponent),n.modulusLength=(s[0]?s:s.slice(1)).byteLength<<3;break}}}async getThumbprint(...e){var t;let n,i="SHA-1";return e.length>=1&&!(!((t=e[0])===null||t===void 0)&&t.subtle)?(i=e[0]||i,n=e[1]||at.get()):n=e[0]||at.get(),await n.subtle.digest(i,this.rawData)}async getKeyIdentifier(...e){let t,n="SHA-1";e.length===1?typeof e[0]=="string"?(n=e[0],t=at.get()):t=e[0]:e.length===2?(n=e[0],t=e[1]):t=at.get();const i=W.parse(this.rawData,vr);return await t.subtle.digest(n,i.subjectPublicKey)}toTextObject(){const e=this.toTextObjectEmpty(),t=W.parse(this.rawData,vr);switch(e.Algorithm=Hi.serializeAlgorithm(t.algorithm),t.algorithm.algorithm){case Pa:e["EC Point"]=t.subjectPublicKey;break;case Ki:default:e["Raw Data"]=t.subjectPublicKey}return e}}function BL(r,e){return r.algorithm=new J({algorithm:Ki,parameters:null}),e=W.serialize(r),e}class La extends cr{static async create(e,t=!1,n=at.get()){if("name"in e&&"serialNumber"in e)return new La(e,t);const s=await(await Sr.create(e,n)).getKeyIdentifier(n);return new La(te.ToHex(s),t)}constructor(...e){if(G.isBufferSource(e[0]))super(e[0]);else if(typeof e[0]=="string"){const t=new vi({keyIdentifier:new Rm(te.FromHex(e[0]))});super(Zf,e[1],W.serialize(t))}else{const t=e[0],n=t.name instanceof Na?W.parse(t.name.rawData,Tt):t.name,i=new vi({authorityCertIssuer:n,authorityCertSerialNumber:te.FromHex(t.serialNumber)});super(Zf,e[1],W.serialize(i))}}onInit(e){super.onInit(e);const t=W.parse(e.extnValue,vi);t.keyIdentifier&&(this.keyId=te.ToHex(t.keyIdentifier)),(t.authorityCertIssuer||t.authorityCertSerialNumber)&&(this.certId={name:t.authorityCertIssuer||[],serialNumber:t.authorityCertSerialNumber?te.ToHex(t.authorityCertSerialNumber):""})}toTextObject(){const e=this.toTextObjectWithoutValue(),t=W.parse(this.value,vi);return t.authorityCertIssuer&&(e["Authority Issuer"]=new Na(t.authorityCertIssuer).toTextObject()),t.authorityCertSerialNumber&&(e["Authority Serial Number"]=t.authorityCertSerialNumber),t.keyIdentifier&&(e[""]=t.keyIdentifier),e}}La.NAME="Authority Key Identifier";class ey extends cr{constructor(...e){if(G.isBufferSource(e[0])){super(e[0]);const t=W.parse(this.value,nu);this.ca=t.cA,this.pathLength=t.pathLenConstraint}else{const t=new nu({cA:e[0],pathLenConstraint:e[1]});super(pA,e[2],W.serialize(t)),this.ca=e[0],this.pathLength=e[1]}}toTextObject(){const e=this.toTextObjectWithoutValue();return this.ca&&(e.CA=this.ca),this.pathLength!==void 0&&(e["Path Length"]=this.pathLength),e}}ey.NAME="Basic Constraints";var I0;(function(r){r.serverAuth="1.3.6.1.5.5.7.3.1",r.clientAuth="1.3.6.1.5.5.7.3.2",r.codeSigning="1.3.6.1.5.5.7.3.3",r.emailProtection="1.3.6.1.5.5.7.3.4",r.timeStamping="1.3.6.1.5.5.7.3.8",r.ocspSigning="1.3.6.1.5.5.7.3.9"})(I0||(I0={}));class QA extends cr{constructor(...e){if(G.isBufferSource(e[0])){super(e[0]);const t=W.parse(this.value,au);this.usages=t.map(n=>n)}else{const t=new au(e[0]);super(yA,e[1],W.serialize(t)),this.usages=e[0]}}toTextObject(){const e=this.toTextObjectWithoutValue();return e[""]=this.usages.map(t=>ri.toString(t)).join(", "),e}}QA.NAME="Extended Key Usages";var k0;(function(r){r[r.digitalSignature=1]="digitalSignature",r[r.nonRepudiation=2]="nonRepudiation",r[r.keyEncipherment=4]="keyEncipherment",r[r.dataEncipherment=8]="dataEncipherment",r[r.keyAgreement=16]="keyAgreement",r[r.keyCertSign=32]="keyCertSign",r[r.cRLSign=64]="cRLSign",r[r.encipherOnly=128]="encipherOnly",r[r.decipherOnly=256]="decipherOnly"})(k0||(k0={}));class JA extends cr{constructor(...e){if(G.isBufferSource(e[0])){super(e[0]);const t=W.parse(this.value,Ch);this.usages=t.toNumber()}else{const t=new Ch(e[0]);super(wA,e[1],W.serialize(t)),this.usages=e[0]}}toTextObject(){const e=this.toTextObjectWithoutValue(),t=W.parse(this.value,Ch);return e[""]=t.toJSON().join(", "),e}}JA.NAME="Key Usages";class Qd extends cr{static async create(e,t=!1,n=at.get()){const s=await(await Sr.create(e,n)).getKeyIdentifier(n);return new Qd(te.ToHex(s),t)}constructor(...e){if(G.isBufferSource(e[0])){super(e[0]);const t=W.parse(this.value,Hn);this.keyId=te.ToHex(t)}else{const t=typeof e[0]=="string"?te.FromHex(e[0]):e[0],n=new Hn(t);super(EA,e[1],W.serialize(n)),this.keyId=te.ToHex(t)}}toTextObject(){const e=this.toTextObjectWithoutValue(),t=W.parse(this.value,Hn);return e[""]=t,e}}Qd.NAME="Subject Key Identifier";class XA extends cr{constructor(...e){G.isBufferSource(e[0])?super(e[0]):super(SA,e[1],new Na(e[0]||[]).rawData)}onInit(e){super.onInit(e);const t=W.parse(e.extnValue,pp);this.names=new Na(t)}toTextObject(){const e=this.toTextObjectWithoutValue(),t=this.names.toTextObject();for(const n in t)e[n]=t[n];return e}}XA.NAME="Subject Alternative Name";class lr{static register(e,t){this.items.set(e,t)}static create(e){const t=new cr(e),n=this.items.get(t.type);return n?new n(e):t}}lr.items=new Map;class ZA extends cr{constructor(...e){var t;if(G.isBufferSource(e[0])){super(e[0]);const n=W.parse(this.value,su);this.policies=n.map(i=>i.policyIdentifier)}else{const n=e[0],i=(t=e[1])!==null&&t!==void 0?t:!1,s=new su(n.map(o=>new Id({policyIdentifier:o})));super(gA,i,W.serialize(s)),this.policies=n}}toTextObject(){const e=this.toTextObjectWithoutValue();return e.Policy=this.policies.map(t=>new Ee("",{},ri.toString(t))),e}}ZA.NAME="Certificate Policies";lr.register(gA,ZA);class ex extends cr{constructor(...e){var t;if(G.isBufferSource(e[0]))super(e[0]);else if(Array.isArray(e[0])&&typeof e[0][0]=="string"){const i=e[0].map(o=>new Eo({distributionPoint:new Fi({fullName:[new ue({uniformResourceIdentifier:o})]})})),s=new Is(i);super(ip,e[1],W.serialize(s))}else{const n=new Is(e[0]);super(ip,e[1],W.serialize(n))}(t=this.distributionPoints)!==null&&t!==void 0||(this.distributionPoints=[])}onInit(e){super.onInit(e);const t=W.parse(e.extnValue,Is);this.distributionPoints=t}toTextObject(){const e=this.toTextObjectWithoutValue();return e["Distribution Point"]=this.distributionPoints.map(t=>{var n;const i={};return t.distributionPoint&&(i[""]=(n=t.distributionPoint.fullName)===null||n===void 0?void 0:n.map(s=>new Un(s).toString()).join(", ")),t.reasons&&(i.Reasons=t.reasons.toString()),t.cRLIssuer&&(i["CRL Issuer"]=t.cRLIssuer.map(s=>s.toString()).join(", ")),i}),e}}ex.NAME="CRL Distribution Points";class tx extends cr{constructor(...e){var t,n,i,s;if(G.isBufferSource(e[0]))super(e[0]);else if(e[0]instanceof ws){const o=new ws(e[0]);super(Xf,e[1],W.serialize(o))}else{const o=e[0],a=new ws;Vc(a,o,db,"ocsp"),Vc(a,o,hb,"caIssuers"),Vc(a,o,fb,"timeStamping"),Vc(a,o,pb,"caRepository"),super(Xf,e[1],W.serialize(a))}(t=this.ocsp)!==null&&t!==void 0||(this.ocsp=[]),(n=this.caIssuers)!==null&&n!==void 0||(this.caIssuers=[]),(i=this.timeStamping)!==null&&i!==void 0||(this.timeStamping=[]),(s=this.caRepository)!==null&&s!==void 0||(this.caRepository=[])}onInit(e){super.onInit(e),this.ocsp=[],this.caIssuers=[],this.timeStamping=[],this.caRepository=[],W.parse(e.extnValue,ws).forEach(n=>{switch(n.accessMethod){case db:this.ocsp.push(new Un(n.accessLocation));break;case hb:this.caIssuers.push(new Un(n.accessLocation));break;case fb:this.timeStamping.push(new Un(n.accessLocation));break;case pb:this.caRepository.push(new Un(n.accessLocation));break}})}toTextObject(){const e=this.toTextObjectWithoutValue();return this.ocsp.length&&Kc(e,"OCSP",this.ocsp),this.caIssuers.length&&Kc(e,"CA Issuers",this.caIssuers),this.timeStamping.length&&Kc(e,"Time Stamping",this.timeStamping),this.caRepository.length&&Kc(e,"CA Repository",this.caRepository),e}}tx.NAME="Authority Info Access";function Kc(r,e,t){if(t.length===1)r[e]=t[0].toTextObject();else{const n=new Ee("");t.forEach((i,s)=>{const o=i.toTextObject(),a=`${o[Ee.NAME]} ${s+1}`;let c=n[a];Array.isArray(c)||(c=[],n[a]=c),c.push(o)}),r[e]=n}}function Vc(r,e,t,n){const i=e[n];i&&(Array.isArray(i)?i:[i]).forEach(o=>{typeof o=="string"&&(o=new Un("url",o)),r.push(new sc({accessMethod:t,accessLocation:W.parse(o.rawData,ue)}))})}class To extends ni{constructor(...e){let t;if(G.isBufferSource(e[0]))t=G.toArrayBuffer(e[0]);else{const n=e[0],i=Array.isArray(e[1])?e[1].map(s=>G.toArrayBuffer(s)):[];t=W.serialize(new mn({type:n,values:i}))}super(t,mn)}onInit(e){this.type=e.type,this.values=e.values}toTextObject(){const e=this.toTextObjectWithoutValue();return e.Value=this.values.map(t=>new Ee("",{"":t})),e}toTextObjectWithoutValue(){const e=this.toTextObjectEmpty();return e[Ee.NAME]===To.NAME&&(e[Ee.NAME]=ri.toString(this.type)),e}}To.NAME="Attribute";class rx extends To{constructor(...e){var t;if(G.isBufferSource(e[0]))super(e[0]);else{const n=new Ru({printableString:e[0]});super(zA,[W.serialize(n)])}(t=this.password)!==null&&t!==void 0||(this.password="")}onInit(e){if(super.onInit(e),this.values[0]){const t=W.parse(this.values[0],Ru);this.password=t.toString()}}toTextObject(){const e=this.toTextObjectWithoutValue();return e[Ee.VALUE]=this.password,e}}rx.NAME="Challenge Password";class ty extends To{constructor(...e){var t;if(G.isBufferSource(e[0]))super(e[0]);else{const n=e[0],i=new Qn;for(const s of n)i.push(W.parse(s.rawData,or));super(Zm,[W.serialize(i)])}(t=this.items)!==null&&t!==void 0||(this.items=[])}onInit(e){if(super.onInit(e),this.values[0]){const t=W.parse(this.values[0],Qn);this.items=t.map(n=>lr.create(W.serialize(n)))}}toTextObject(){const e=this.toTextObjectWithoutValue(),t=this.items.map(n=>n.toTextObject());for(const n of t)e[n[Ee.NAME]]=n;return e}}ty.NAME="Extensions";class Jd{static register(e,t){this.items.set(e,t)}static create(e){const t=new To(e),n=this.items.get(t.type);return n?new n(e):t}}Jd.items=new Map;const wc="crypto.signatureFormatter";class NL{toAsnSignature(e,t){return G.toArrayBuffer(t)}toWebSignature(e,t){return G.toArrayBuffer(t)}}var gl;let ig=gl=class{static createPssParams(e,t){const n=gl.getHashAlgorithm(e);return n?new zi({hashAlgorithm:n,maskGenAlgorithm:new J({algorithm:qd,parameters:W.serialize(n)}),saltLength:t}):null}static getHashAlgorithm(e){const t=ht.resolve(ji);return typeof e=="string"?t.toAsnAlgorithm({name:e}):typeof e=="object"&&e&&"name"in e?t.toAsnAlgorithm(e):null}toAsnAlgorithm(e){switch(e.name.toLowerCase()){case"rsassa-pkcs1-v1_5":if("hash"in e){let t;if(typeof e.hash=="string")t=e.hash;else if(e.hash&&typeof e.hash=="object"&&"name"in e.hash&&typeof e.hash.name=="string")t=e.hash.name.toUpperCase();else throw new Error("Cannot get hash algorithm name");switch(t.toLowerCase()){case"sha-1":return new J({algorithm:Su,parameters:null});case"sha-256":return new J({algorithm:Dp,parameters:null});case"sha-384":return new J({algorithm:Eu,parameters:null});case"sha-512":return new J({algorithm:Au,parameters:null})}}else return new J({algorithm:Ki,parameters:null});break;case"rsa-pss":if("hash"in e){if(!("saltLength"in e&&typeof e.saltLength=="number"))throw new Error("Cannot get 'saltLength' from 'alg' argument");const t=gl.createPssParams(e.hash,e.saltLength);if(!t)throw new Error("Cannot create PSS parameters");return new J({algorithm:ua,parameters:W.serialize(t)})}else return new J({algorithm:ua,parameters:null})}return null}toWebAlgorithm(e){switch(e.algorithm){case Ki:return{name:"RSASSA-PKCS1-v1_5"};case Su:return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-1"}};case Dp:return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case Eu:return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}};case Au:return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}};case ua:if(e.parameters){const t=W.parse(e.parameters,zi);return{name:"RSA-PSS",hash:ht.resolve(ji).toWebAlgorithm(t.hashAlgorithm),saltLength:t.saltLength}}else return{name:"RSA-PSS"}}return null}};ig=gl=f([jd()],ig);ht.registerSingleton(yc,ig);let sg=class{toAsnAlgorithm(e){switch(e.name.toLowerCase()){case"sha-1":return new J({algorithm:xu});case"sha-256":return new J({algorithm:_u});case"sha-384":return new J({algorithm:Cu});case"sha-512":return new J({algorithm:Iu})}return null}toWebAlgorithm(e){switch(e.algorithm){case xu:return{name:"SHA-1"};case _u:return{name:"SHA-256"};case Cu:return{name:"SHA-384"};case Iu:return{name:"SHA-512"}}return null}};sg=f([jd()],sg);ht.registerSingleton(yc,sg);class ir{addPadding(e,t){const n=G.toUint8Array(t),i=new Uint8Array(e);return i.set(n,e-n.length),i}removePadding(e,t=!1){let n=G.toUint8Array(e);for(let i=0;i<n.length;i++)if(n[i]){n=n.slice(i);break}if(t&&n[0]>127){const i=new Uint8Array(n.length+1);return i.set(n,1),i.buffer}return n.buffer}toAsnSignature(e,t){if(e.name==="ECDSA"){const n=e.namedCurve,i=ir.namedCurveSize.get(n)||ir.defaultNamedCurveSize,s=new vu,o=G.toUint8Array(t);return s.r=this.removePadding(o.slice(0,i),!0),s.s=this.removePadding(o.slice(i,i+i),!0),W.serialize(s)}return null}toWebSignature(e,t){if(e.name==="ECDSA"){const n=W.parse(t,vu),i=e.namedCurve,s=ir.namedCurveSize.get(i)||ir.defaultNamedCurveSize,o=this.addPadding(s,this.removePadding(n.r)),a=this.addPadding(s,this.removePadding(n.s));return WN(o,a)}return null}}ir.namedCurveSize=new Map;ir.defaultNamedCurveSize=32;const Nh="1.3.101.110",T0="1.3.101.111",Dh="1.3.101.112",P0="1.3.101.113";let og=class{toAsnAlgorithm(e){let t=null;switch(e.name.toLowerCase()){case"ed25519":t=Dh;break;case"x25519":t=Nh;break;case"eddsa":switch(e.namedCurve.toLowerCase()){case"ed25519":t=Dh;break;case"ed448":t=P0;break}break;case"ecdh-es":switch(e.namedCurve.toLowerCase()){case"x25519":t=Nh;break;case"x448":t=T0;break}}return t?new J({algorithm:t}):null}toWebAlgorithm(e){switch(e.algorithm){case Dh:return{name:"Ed25519"};case P0:return{name:"EdDSA",namedCurve:"Ed448"};case Nh:return{name:"X25519"};case T0:return{name:"ECDH-ES",namedCurve:"X448"}}return null}};og=f([jd()],og);ht.registerSingleton(yc,og);class DL extends bn{constructor(e){bn.isAsnEncoded(e)?super(e,Oa):super(e),this.tag=Wt.CertificateRequestTag}onInit(e){this.tbs=W.serialize(e.certificationRequestInfo),this.publicKey=new Sr(e.certificationRequestInfo.subjectPKInfo);const t=ht.resolve(ji);this.signatureAlgorithm=t.toWebAlgorithm(e.signatureAlgorithm),this.signature=e.signature,this.attributes=e.certificationRequestInfo.attributes.map(i=>Jd.create(W.serialize(i)));const n=this.getAttribute(Zm);this.extensions=[],n instanceof ty&&(this.extensions=n.items),this.subjectName=new nr(e.certificationRequestInfo.subject),this.subject=this.subjectName.toString()}getAttribute(e){for(const t of this.attributes)if(t.type===e)return t;return null}getAttributes(e){return this.attributes.filter(t=>t.type===e)}getExtension(e){for(const t of this.extensions)if(t.type===e)return t;return null}getExtensions(e){return this.extensions.filter(t=>t.type===e)}async verify(e=at.get()){const t={...this.publicKey.algorithm,...this.signatureAlgorithm},n=await this.publicKey.export(t,["verify"],e),i=ht.resolveAll(wc).reverse();let s=null;for(const a of i)if(s=a.toWebSignature(t,this.signature),s)break;if(!s)throw Error("Cannot convert WebCrypto signature value to ASN.1 format");return await e.subtle.verify(this.signatureAlgorithm,n,s,this.tbs)}toTextObject(){const e=this.toTextObjectEmpty(),t=W.parse(this.rawData,Oa),n=t.certificationRequestInfo,i=new Ee("",{Version:`${Ui[n.version]} (${n.version})`,Subject:this.subject,"Subject Public Key Info":this.publicKey});if(this.attributes.length){const s=new Ee("");for(const o of this.attributes){const a=o.toTextObject();s[a[Ee.NAME]]=a}i.Attributes=s}return e.Data=i,e.Signature=new Ee("",{Algorithm:Hi.serializeAlgorithm(t.signatureAlgorithm),"":t.signature}),e}}DL.NAME="PKCS#10 Certificate Request";class ry extends bn{constructor(e){bn.isAsnEncoded(e)?super(e,$i):super(e),this.tag=Wt.CertificateTag}onInit(e){const t=e.tbsCertificate;this.tbs=W.serialize(t);let n=new Uint8Array(t.serialNumber);n.length>1&&n[0]===0&&n[1]>127&&(n=n.slice(1)),this.serialNumber=te.ToHex(n),this.subjectName=new nr(t.subject),this.subject=new nr(t.subject).toString(),this.issuerName=new nr(t.issuer),this.issuer=this.issuerName.toString();const i=ht.resolve(ji);this.signatureAlgorithm=i.toWebAlgorithm(e.signatureAlgorithm),this.signature=e.signatureValue;const s=t.validity.notBefore.utcTime||t.validity.notBefore.generalTime;if(!s)throw new Error("Cannot get 'notBefore' value");this.notBefore=s;const o=t.validity.notAfter.utcTime||t.validity.notAfter.generalTime;if(!o)throw new Error("Cannot get 'notAfter' value");this.notAfter=o,this.extensions=[],t.extensions&&(this.extensions=t.extensions.map(a=>lr.create(W.serialize(a)))),this.publicKey=new Sr(t.subjectPublicKeyInfo)}getExtension(e){for(const t of this.extensions)if(typeof e=="string"){if(t.type===e)return t}else if(t instanceof e)return t;return null}getExtensions(e){return this.extensions.filter(t=>typeof e=="string"?t.type===e:t instanceof e)}async verify(e={},t=at.get()){let n,i;const s=e.publicKey;try{if(!s)n={...this.publicKey.algorithm,...this.signatureAlgorithm},i=await this.publicKey.export(n,["verify"],t);else if("publicKey"in s)n={...s.publicKey.algorithm,...this.signatureAlgorithm},i=await s.publicKey.export(n,["verify"],t);else if(s instanceof Sr)n={...s.algorithm,...this.signatureAlgorithm},i=await s.export(n,["verify"],t);else if(G.isBufferSource(s)){const l=new Sr(s);n={...l.algorithm,...this.signatureAlgorithm},i=await l.export(n,["verify"],t)}else n={...s.algorithm,...this.signatureAlgorithm},i=s}catch{return!1}const o=ht.resolveAll(wc).reverse();let a=null;for(const l of o)if(a=l.toWebSignature(n,this.signature),a)break;if(!a)throw Error("Cannot convert ASN.1 signature value to WebCrypto format");const c=await t.subtle.verify(this.signatureAlgorithm,i,a,this.tbs);if(e.signatureOnly)return c;{const u=(e.date||new Date).getTime();return c&&this.notBefore.getTime()<u&&u<this.notAfter.getTime()}}async getThumbprint(...e){let t,n="SHA-1";return e[0]&&(e[0].subtle?t=e[0]:(n=e[0]||n,t=e[1])),t??(t=at.get()),await t.subtle.digest(n,this.rawData)}async isSelfSigned(e=at.get()){return this.subject===this.issuer&&await this.verify({signatureOnly:!0},e)}toTextObject(){const e=this.toTextObjectEmpty(),t=W.parse(this.rawData,$i),n=t.tbsCertificate,i=new Ee("",{Version:`${Ui[n.version]} (${n.version})`,"Serial Number":n.serialNumber,"Signature Algorithm":Hi.serializeAlgorithm(n.signature),Issuer:this.issuer,Validity:new Ee("",{"Not Before":n.validity.notBefore.getTime(),"Not After":n.validity.notAfter.getTime()}),Subject:this.subject,"Subject Public Key Info":this.publicKey});if(n.issuerUniqueID&&(i["Issuer Unique ID"]=n.issuerUniqueID),n.subjectUniqueID&&(i["Subject Unique ID"]=n.subjectUniqueID),this.extensions.length){const s=new Ee("");for(const o of this.extensions){const a=o.toTextObject();s[a[Ee.NAME]]=a}i.Extensions=s}return e.Data=i,e.Signature=new Ee("",{Algorithm:Hi.serializeAlgorithm(t.signatureAlgorithm),"":t.signatureValue}),e}}ry.NAME="Certificate";class LL{static async createSelfSigned(e,t=at.get()){if(!e.keys.privateKey)throw new Error("Bad field 'keys' in 'params' argument. 'privateKey' is empty");if(!e.keys.publicKey)throw new Error("Bad field 'keys' in 'params' argument. 'publicKey' is empty");return this.create({serialNumber:e.serialNumber,subject:e.name,issuer:e.name,notBefore:e.notBefore,notAfter:e.notAfter,publicKey:e.keys.publicKey,signingKey:e.keys.privateKey,signingAlgorithm:e.signingAlgorithm,extensions:e.extensions},t)}static async create(e,t=at.get()){var n;let i;e.publicKey instanceof Sr?i=e.publicKey.rawData:"publicKey"in e.publicKey?i=e.publicKey.publicKey.rawData:G.isBufferSource(e.publicKey)?i=e.publicKey:i=await t.subtle.exportKey("spki",e.publicKey);let s=e.serialNumber?G.toUint8Array(te.FromHex(e.serialNumber)):t.getRandomValues(new Uint8Array(16));if(s[0]>127){const y=new Uint8Array(s.length+1);y[0]=0,y.set(s,1),s=y}const o=e.notBefore||new Date,a=e.notAfter||new Date(o.getTime()+31536e6),c=new $i({tbsCertificate:new Xt({version:Ui.v3,serialNumber:s,validity:new oc({notBefore:o,notAfter:a}),extensions:new Qn(((n=e.extensions)===null||n===void 0?void 0:n.map(y=>W.parse(y.rawData,or)))||[]),subjectPublicKeyInfo:W.parse(i,vr)})});if(e.subject){const y=e.subject instanceof nr?e.subject:new nr(e.subject);c.tbsCertificate.subject=W.parse(y.toArrayBuffer(),We)}if(e.issuer){const y=e.issuer instanceof nr?e.issuer:new nr(e.issuer);c.tbsCertificate.issuer=W.parse(y.toArrayBuffer(),We)}const l={hash:"SHA-256"},u="signingKey"in e?{...l,...e.signingAlgorithm,...e.signingKey.algorithm}:{...l,...e.signingAlgorithm},d=ht.resolve(ji);c.tbsCertificate.signature=c.signatureAlgorithm=d.toAsnAlgorithm(u);const h=W.serialize(c.tbsCertificate),p="signingKey"in e?await t.subtle.sign(u,e.signingKey,h):e.signature,m=ht.resolveAll(wc).reverse();let w=null;for(const y of m)if(w=y.toAsnSignature(u,p),w)break;if(!w)throw Error("Cannot convert ASN.1 signature value to WebCrypto format");return c.signatureValue=w,new ry(W.serialize(c))}}var R0;(function(r){r[r.unspecified=0]="unspecified",r[r.keyCompromise=1]="keyCompromise",r[r.cACompromise=2]="cACompromise",r[r.affiliationChanged=3]="affiliationChanged",r[r.superseded=4]="superseded",r[r.cessationOfOperation=5]="cessationOfOperation",r[r.certificateHold=6]="certificateHold",r[r.removeFromCRL=8]="removeFromCRL",r[r.privilegeWithdrawn=9]="privilegeWithdrawn",r[r.aACompromise=10]="aACompromise"})(R0||(R0={}));lr.register(pA,ey);lr.register(yA,QA);lr.register(wA,JA);lr.register(EA,Qd);lr.register(Zf,La);lr.register(SA,XA);lr.register(ip,ex);lr.register(Xf,tx);Jd.register(zA,rx);Jd.register(Zm,ty);ht.registerSingleton(wc,NL);ht.registerSingleton(wc,ir);ir.namedCurveSize.set("P-256",32);ir.namedCurveSize.set("K-256",32);ir.namedCurveSize.set("P-384",48);ir.namedCurveSize.set("P-521",66);const Jr="/",nx=new TextEncoder().encode(Jr),zc=nx[0];class rt{_buf;constructor(e,t){if(typeof e=="string")this._buf=Z(e);else if(e instanceof Uint8Array)this._buf=e;else throw new Error("Invalid key, should be String of Uint8Array");if(t==null&&(t=!0),t&&this.clean(),this._buf.byteLength===0||this._buf[0]!==zc)throw new Error("Invalid key")}toString(e="utf8"){return ne(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new rt(e.join(Jr))}static random(){return new rt(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||typeof e=="string"?new rt(e):typeof e.uint8Array=="function"?new rt(e.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=nx),this._buf[0]!==zc){const e=new Uint8Array(this._buf.byteLength+1);e.fill(zc,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===zc;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),n=e.list();for(let i=0;i<t.length;i++){if(n.length<i+1)return!1;const s=t[i],o=n[i];if(s<o)return!0;if(s>o)return!1}return t.length<n.length}reverse(){return rt.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(Jr).slice(1)}type(){return ML(this.baseNamespace())}name(){return FL(this.baseNamespace())}instance(e){return new rt(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(Jr)||(e+=Jr),e+=this.type(),new rt(e)}parent(){const e=this.list();return e.length===1?new rt(Jr):new rt(e.slice(0,-1).join(Jr))}child(e){return this.toString()===Jr?e:e.toString()===Jr?this:new rt(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()===this.toString()?!1:e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()===this.toString()?!1:this.toString().startsWith(e.toString())}isTopLevel(){return this.list().length===1}concat(...e){return rt.withNamespaces([...this.namespaces(),...UL(e.map(t=>t.namespaces()))])}}function ML(r){const e=r.split(":");return e.length<2?"":e.slice(0,-1).join(":")}function FL(r){const e=r.split(":");return e[e.length-1]}function UL(r){return[].concat(...r)}class $L extends sr{async listen(){throw new DN("WebRTCTransport.createListener")}getAddrs(){return[]}updateAnnounceAddrs(){}async close(){}}const ix=Object.values(_l).map(r=>r.decoder).reduce((r,e)=>r.or(e)),qL=/^a=fingerprint:(?:\w+-[0-9]+)\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m;function KL(r){return r?.match(qL)?.groups?.fingerprint}function sx(r){const t=r.stringTuples().filter(n=>n[0]===nN).map(n=>n[1])[0];if(t===void 0||t==="")throw new q(`Couldn't find a certhash component of multiaddr: ${r.toString()}`);return t}function VL(r){return Ji(ix.decode(r))}function zL(r){const e=VL(sx(r)),t=HL(e.code),n=e.digest.reduce((s,o)=>s+o.toString(16).padStart(2,"0"),""),i=n.match(/.{1,2}/g);if(i==null)throw new NN(n,r.toString());return`${t} ${i.join(":").toUpperCase()}`}function jL(r){const e=r.split(":").map(i=>parseInt(i,16)),t=Uint8Array.from(e),n=dn(Xi.code,t);return de(`/certhash/${za.encode(n.bytes)}`)}function HL(r){switch(r){case 17:return"sha-1";case 18:return"sha-256";case 19:return"sha-512";default:throw new LN(r)}}function WL(r,e){const{host:t,port:n,family:i}=r.toOptions(),s=zL(r);return{type:"answer",sdp:`v=0
o=- 0 0 IN IP${i} ${t}
s=-
t=0 0
a=ice-lite
m=application ${n} UDP/DTLS/SCTP webrtc-datachannel
c=IN IP${i} ${t}
a=mid:0
a=ice-options:ice2
a=ice-ufrag:${e}
a=ice-pwd:${e}
a=fingerprint:${s}
a=setup:passive
a=sctp-port:5000
a=max-message-size:${cd}
a=candidate:1467250027 1 UDP 1467250027 ${t} ${n} typ host
a=end-of-candidates
`}}function GL(r,e){const{host:t,port:n,family:i}=r.toOptions();return{type:"offer",sdp:`v=0
o=- 0 0 IN IP${i} ${t}
s=-
c=IN IP${i} ${t}
t=0 0
a=ice-options:ice2,trickle
m=application ${n} UDP/DTLS/SCTP webrtc-datachannel
a=mid:0
a=setup:active
a=ice-ufrag:${e}
a=ice-pwd:${e}
a=fingerprint:sha-256 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
a=sctp-port:5000
a=max-message-size:${cd}
a=candidate:1467250027 1 UDP 1467250027 ${t} ${n} typ host
a=end-of-candidates
`}}function O0(r,e){if(r.sdp===void 0)throw new q("Can't munge a missing SDP");const t=r.sdp.includes(`\r
`)?`\r
`:`
`;return r.sdp=r.sdp.replace(/\na=ice-ufrag:[^\n]*\n/,`
a=ice-ufrag:`+e+t).replace(/\na=ice-pwd:[^\n]*\n/,`
a=ice-pwd:`+e+t),r}const Lh=Z("libp2p-webrtc-noise:");function YL(r,e,t){const n=r.trim().toLowerCase().replaceAll(":",""),i=Z(n,"hex"),s=dn(Xi.code,i),o=ix.decode(sx(e)),a=Lh.byteLength+s.bytes.byteLength+o.byteLength;return qr(t==="server"?[Lh,o,s.bytes]:[Lh,s.bytes,o],a)}const QL=dm?"iceconnectionstatechange":"connectionstatechange";async function JL(r,e,t){const n=r.createDataChannel("",{negotiated:!0,id:0});try{if(t.role==="client"){t.log.trace("client creating local offer");const d=await r.createOffer();t.log.trace("client created local offer %s",d.sdp);const h=O0(d,e);t.log.trace("client setting local offer %s",h.sdp),await r.setLocalDescription(h);const p=WL(t.remoteAddr,e);t.log.trace("client setting server description %s",p.sdp),await r.setRemoteDescription(p)}else{const d=GL(t.remoteAddr,e);t.log.trace("server setting client %s %s",d.type,d.sdp),await r.setRemoteDescription(d),t.log.trace("server creating local answer");const h=await r.createAnswer();t.log.trace("server created local answer");const p=O0(h,e);t.log.trace("server setting local description %s",h.sdp),await r.setLocalDescription(p)}if(n.readyState!=="open"&&(t.log.trace("%s wait for handshake channel to open, starting status %s",t.role,n.readyState),await Ur(n,"open",t.signal)),t.log.trace("%s handshake channel opened",t.role),t.role==="server"){const d=r.remoteFingerprint()?.value??"";t.remoteAddr=t.remoteAddr.encapsulate(jL(d))}const i=KL(r.localDescription?.sdp);if(i==null)throw new tc("Could not get fingerprint from local description sdp");t.log.trace("%s performing noise handshake",t.role);const s=YL(i,t.remoteAddr,t.role),o=SE({prologueBytes:s})(t),a=Zl({channel:n,direction:"outbound",handshake:!0,logger:t.logger,...t.dataChannel??{}}),c=new Vf(t,{peerConnection:r,remoteAddr:t.remoteAddr,timeline:{open:Date.now()},metrics:t.events});r.addEventListener(QL,()=>{switch(r.connectionState){case"failed":case"disconnected":case"closed":c.close().catch(d=>{t.log.error("error closing connection",d),c.abort(d)});break;default:break}}),t.events?.increment({peer_connection:!0});const l=new hm(t,{peerConnection:r,metrics:t.events,dataChannelOptions:t.dataChannel});if(t.role==="client")return t.log.trace("%s secure inbound",t.role),await o.secureInbound(a,{remotePeer:t.remotePeerId,signal:t.signal,skipStreamMuxerNegotiation:!0}),t.log.trace("%s upgrade outbound",t.role),await t.upgrader.upgradeOutbound(c,{skipProtection:!0,skipEncryption:!0,muxerFactory:l,signal:t.signal});t.log.trace("%s secure outbound",t.role);const u=await o.secureOutbound(a,{remotePeer:t.remotePeerId,signal:t.signal,skipStreamMuxerNegotiation:!0});c.remoteAddr=c.remoteAddr.encapsulate(`/p2p/${u.remotePeer}`),t.log.trace("%s upgrade inbound",t.role),await t.upgrader.upgradeInbound(c,{skipProtection:!0,skipEncryption:!0,muxerFactory:l,signal:t.signal})}catch(i){throw n.close(),i}}async function XL(r,e,t,n){n==null&&(n=await RTCPeerConnection.generateCertificate({name:"ECDSA",namedCurve:"P-256"}));const i=typeof t=="function"?await t():t;return new RTCPeerConnection({...i??{},certificates:[n]})}async function ZL(r){const e=await XS(r),t=await crypto.subtle.exportKey("pkcs8",e.privateKey);return["-----BEGIN PRIVATE KEY-----",...ne(new Uint8Array(t),"base64pad").split(/(.{64})/).filter(Boolean),"-----END PRIVATE KEY-----"].join(`
`)}class eM{log;metrics;components;init;certificate;privateKey;emitter;renewCertificateTask;constructor(e,t={}){if(this.log=e.logger.forComponent("libp2p:webrtc-direct"),this.components=e,this.init=t,this.emitter=new sr,t.certificateLifespan!=null&&t.certificateRenewalThreshold!=null&&t.certificateRenewalThreshold>=t.certificateLifespan)throw new q("Certificate renewal threshold must be less than certificate lifespan");e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc-direct_dialer_events_total",{label:"event",help:"Total count of WebRTC-direct dial events by type"})})}[zu]=!0;[Symbol.toStringTag]="@libp2p/webrtc-direct";[$t]=["@libp2p/transport"];async start(){this.certificate=await this.getCertificate()}async stop(){this.renewCertificateTask!=null&&clearTimeout(this.renewCertificateTask),this.certificate=void 0}async dial(e,t){this.log("dial %a",e),t.signal.throwIfAborted();let n;const i=e.getPeerId();i!=null&&(n=xr(i));const s=PN(),o=await XL("client",s,typeof this.init.rtcConfiguration=="function"?await this.init.rtcConfiguration():this.init.rtcConfiguration??{});try{return await JL(o,s,{role:"client",log:this.log,logger:this.components.logger,metrics:this.components.metrics,events:this.metrics?.dialerEvents,signal:t.signal,remoteAddr:e,dataChannel:this.init.dataChannel,upgrader:t.upgrader,peerId:this.components.peerId,remotePeerId:n,privateKey:this.components.privateKey})}catch(a){throw o.close(),a}}createListener(e){if(this.certificate==null)throw new pa;return new $L(this.components,{...this.init,...e,certificate:this.certificate,emitter:this.emitter})}listenFilter(e){return e.filter($f.exactMatch)}dialFilter(e){return this.listenFilter(e)}async getCertificate(e){if(tM(this.init.certificate))return this.log("using provided TLS certificate"),this.init.certificate;const t=await this.loadOrCreatePrivateKey(),{pem:n,certhash:i}=await this.loadOrCreateCertificate(t,e);return{privateKey:await ZL(t),pem:n,certhash:i}}async loadOrCreatePrivateKey(){if(this.privateKey!=null)return this.privateKey;const e=this.init.certificateKeychainName??hN,t=this.getKeychain();try{if(t==null)throw this.log("no keychain configured - not checking for stored private key"),new Nn;this.log.trace("checking for stored private key"),this.privateKey=await t.exportKey(e)}catch(n){if(n.name!=="NotFoundError")throw n;this.log.trace("generating private key"),this.privateKey=await JS("ECDSA","P-256"),t!=null?(this.log.trace("storing private key"),await t.importKey(e,this.privateKey)):this.log("no keychain configured - not storing private key")}return this.privateKey}async loadOrCreateCertificate(e,t){if(this.certificate!=null&&t!==!0)return this.certificate;let n;const i=new rt(this.init.certificateDatastoreKey??dN),s=await XS(e);try{if(t===!0)throw this.log.trace("forcing renewal of TLS certificate"),new Nn;this.log.trace("checking for stored TLS certificate"),n=await this.loadCertificate(i,s)}catch(a){if(a.name!=="NotFoundError")throw a;this.log.trace("generating new TLS certificate"),n=await this.createCertificate(i,s)}let o=n.notAfter.getTime()-(this.init.certificateRenewalThreshold??Gw)-Date.now();return o<0&&(o=100),this.log("will renew TLS certificate after %d ms",o),this.renewCertificateTask=setTimeout(()=>{this.log("renewing TLS certificate"),this.getCertificate(!0).then(a=>{this.certificate=a,this.emitter.safeDispatchEvent("certificate:renew",{detail:a})}).catch(a=>{this.log.error("could not renew certificate - %e",a)})},o),{pem:n.toString("pem"),certhash:za.encode((await Xi.digest(new Uint8Array(n.rawData))).bytes)}}async loadCertificate(e,t){const n=await this.components.datastore.get(e),i=new ry(n),s=i.notAfter.getTime()-(this.init.certificateRenewalThreshold??Gw);if(Date.now()>s)throw this.log("stored TLS certificate has expired"),new Nn;this.log("loaded certificate, expires in %d ms",s);const o=await i.publicKey.export(crypto),a=await crypto.subtle.exportKey("raw",o),c=await crypto.subtle.exportKey("raw",t.publicKey);if(!Je(new Uint8Array(a,0,a.byteLength),new Uint8Array(c,0,c.byteLength)))throw this.log("stored TLS certificate public key did not match public key from private key"),new Nn;return this.log("loaded certificate, expiry time is %o",s),i}async createCertificate(e,t){const n=new Date,i=new Date(Date.now()+(this.init.certificateLifespan??fN));n.setMilliseconds(0),i.setMilliseconds(0);const s=await LL.createSelfSigned({serialNumber:(BigInt(Math.random().toString().replace(".",""))*100000n).toString(16),name:"CN=example.com, C=US, L=CA, O=example, ST=CA",notBefore:n,notAfter:i,keys:t,extensions:[new ey(!1,void 0,!0)]},crypto);return this.getKeychain()!=null?(this.log.trace("storing TLS certificate"),await this.components.datastore.put(e,Z(s.toString("pem")))):this.log("no keychain is configured so not storing TLS certificate since the private key will not be reused"),s}getKeychain(){try{return this.components.keychain}catch{}}}function tM(r){return r==null?!1:typeof r.privateKey=="string"&&typeof r.pem=="string"&&typeof r.certhash=="string"}function rM(r){return e=>new eM(e,r)}function nM(r){return e=>new $N(e,r)}const iM=[St("tcp").code,St("dns").code,St("dnsaddr").code,St("dns4").code,St("dns6").code];function B0(r){return ox("sni",r)?.[1]}function N0(r){const e=ox("tcp",r)?.[1];return e==null?"":`:${e}`}function ox(r,e){let t;try{t=St(r).code}catch{return}for(const[n,i]of e)if(n===t&&i!=null)return[n,i]}function D0(r){return r.some(([e,t])=>e===St("tls").code)}function fr(r,e,t){const n=ax[St(r).name];if(n==null)throw new Error(`Can't interpret protocol ${St(r).name}`);const i=n(e,t);return r===St("ip6").code?`[${i}]`:i}const ax={ip4:(r,e)=>r,ip6:(r,e)=>e.length===0?r:`[${r}]`,tcp:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`tcp://${fr(t[0],t[1]??"",e)}:${r}`},udp:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`udp://${fr(t[0],t[1]??"",e)}:${r}`},dnsaddr:(r,e)=>r,dns4:(r,e)=>r,dns6:(r,e)=>r,dns:(r,e)=>r,ipfs:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${fr(t[0],t[1]??"",e)}`},p2p:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${fr(t[0],t[1]??"",e)}`},http:(r,e)=>{const t=D0(e),n=B0(e),i=N0(e);if(t&&n!=null)return`https://${n}${i}`;const s=t?"https://":"http://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=fr(o[0],o[1]??"",e);return a=a.replace("tcp://",""),`${s}${a}`},"http-path":(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");const n=fr(t[0],t[1]??"",e),i=decodeURIComponent(r);return`${n}/${i}`},tls:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return fr(t[0],t[1]??"",e)},sni:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return fr(t[0],t[1]??"",e)},https:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let n=fr(t[0],t[1]??"",e);return n=n.replace("tcp://",""),`https://${n}`},ws:(r,e)=>{const t=D0(e),n=B0(e),i=N0(e);if(t&&n!=null)return`wss://${n}${i}`;const s=t?"wss://":"ws://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=fr(o[0],o[1]??"",e);return a=a.replace("tcp://",""),`${s}${a}`},wss:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let n=fr(t[0],t[1]??"",e);return n=n.replace("tcp://",""),`wss://${n}`}};function sM(r,e){const n=de(r).stringTuples(),i=n.pop();if(i==null)throw new Error("Unexpected end of multiaddr");const s=St(i[0]),o=ax[s.name];if(o==null)throw new Error(`No interpreter found for ${s.name}`);let a=o(i[1]??"",n);return iM.includes(i[0])&&(a=a.replace(/^.*:\/\//,""),i[1]==="443"?a=`https://${a}`:a=`http://${a}`),(a.startsWith("http://")||a.startsWith("https://")||a.startsWith("ws://")||a.startsWith("wss://"))&&(a=new URL(a).toString(),a.endsWith("/")&&(a=a.substring(0,a.length-1))),a}const oM=async r=>{if(r.readyState>=2)throw new Error("socket closed");r.readyState!==1&&await new Promise((e,t)=>{function n(){r.removeEventListener("open",i),r.removeEventListener("error",s)}function i(){n(),e()}function s(o){n(),t(o.error??new Error(`connect ECONNREFUSED ${r.url}`))}r.addEventListener("open",i),r.addEventListener("error",s)})},aM=(r,e)=>(e=e??{},e.closeOnEnd=e.closeOnEnd!==!1,async n=>{for await(const i of n){try{await oM(r)}catch(s){if(s.message==="socket closed")break;throw s}if(r.readyState===r.CLOSING||r.readyState===r.CLOSED)break;r.send(i)}e.closeOnEnd!=null&&r.readyState<=1&&await new Promise((i,s)=>{r.addEventListener("close",o=>{if(o.wasClean||o.code===1006)i();else{const a=Object.assign(new Error("ws error"),{event:o});s(a)}}),setTimeout(()=>{r.close()})})});var us={},$o={},L0;function cM(){if(L0)return $o;L0=1,Object.defineProperty($o,"__esModule",{value:!0});class r{constructor(){this.pullQueue=[],this.pushQueue=[],this.eventHandlers={},this.isPaused=!1,this.isStopped=!1}push(n){if(this.isStopped)return;const i={value:n,done:!1};if(this.pullQueue.length){const s=this.pullQueue.shift();s&&s.resolve(i)}else this.pushQueue.push(Promise.resolve(i)),this.highWaterMark!==void 0&&this.pushQueue.length>=this.highWaterMark&&!this.isPaused&&(this.isPaused=!0,this.eventHandlers.highWater?this.eventHandlers.highWater():console&&console.warn(`EventIterator queue reached ${this.pushQueue.length} items`))}stop(){if(!this.isStopped){this.isStopped=!0,this.remove();for(const n of this.pullQueue)n.resolve({value:void 0,done:!0});this.pullQueue.length=0}}fail(n){if(!this.isStopped)if(this.isStopped=!0,this.remove(),this.pullQueue.length){for(const i of this.pullQueue)i.reject(n);this.pullQueue.length=0}else{const i=Promise.reject(n);i.catch(()=>{}),this.pushQueue.push(i)}}remove(){Promise.resolve().then(()=>{this.removeCallback&&this.removeCallback()})}[Symbol.asyncIterator](){return{next:n=>{const i=this.pushQueue.shift();return i?(this.lowWaterMark!==void 0&&this.pushQueue.length<=this.lowWaterMark&&this.isPaused&&(this.isPaused=!1,this.eventHandlers.lowWater&&this.eventHandlers.lowWater()),i):this.isStopped?Promise.resolve({value:void 0,done:!0}):new Promise((s,o)=>{this.pullQueue.push({resolve:s,reject:o})})},return:()=>(this.isStopped=!0,this.pushQueue.length=0,this.remove(),Promise.resolve({value:void 0,done:!0}))}}}class e{constructor(n,{highWaterMark:i=100,lowWaterMark:s=1}={}){const o=new r;o.highWaterMark=i,o.lowWaterMark=s,o.removeCallback=n({push:a=>o.push(a),stop:()=>o.stop(),fail:a=>o.fail(a),on:(a,c)=>{o.eventHandlers[a]=c}})||(()=>{}),this[Symbol.asyncIterator]=()=>o[Symbol.asyncIterator](),Object.freeze(this)}}return $o.EventIterator=e,$o.default=e,$o}var M0;function lM(){if(M0)return us;M0=1,Object.defineProperty(us,"__esModule",{value:!0});const r=cM();us.EventIterator=r.EventIterator;function e(t,n,i){return new r.EventIterator(({push:s})=>(this.addEventListener(t,s,n),()=>this.removeEventListener(t,s,n)),i)}return us.subscribe=e,us.default=r.EventIterator,us}var uM=lM();function F0(r){return r instanceof ArrayBuffer||r?.constructor?.name==="ArrayBuffer"&&typeof r?.byteLength=="number"}const dM=r=>{r.binaryType="arraybuffer";const e=async()=>{await new Promise((s,o)=>{if(n){s();return}if(i!=null){o(i);return}const a=u=>{r.removeEventListener("open",c),r.removeEventListener("error",l),u()},c=()=>{a(s)},l=u=>{a(()=>{o(u.error??new Error(`connect ECONNREFUSED ${r.url}`))})};r.addEventListener("open",c),r.addEventListener("error",l)})},t=async function*(){const s=new uM.EventIterator(({push:o,stop:a,fail:c})=>{const l=d=>{let h=null;typeof d.data=="string"&&(h=Z(d.data)),F0(d.data)&&(h=new Uint8Array(d.data)),d.data instanceof Uint8Array&&(h=d.data),h!=null&&o(h)},u=d=>{c(d.error??new Error("Socket error"))};return r.addEventListener("message",l),r.addEventListener("error",u),r.addEventListener("close",a),()=>{r.removeEventListener("message",l),r.removeEventListener("error",u),r.removeEventListener("close",a)}},{highWaterMark:1/0});await e();for await(const o of s)yield F0(o)?new Uint8Array(o):o}();let n=r.readyState===1,i;return r.addEventListener("open",()=>{n=!0,i=null}),r.addEventListener("close",()=>{n=!1,i=null}),r.addEventListener("error",s=>{n||(i=s.error??new Error(`connect ECONNREFUSED ${r.url}`))}),Object.assign(t,{connected:e})},hM=(r,e)=>{e=e??{};const t=dM(r);let n=e.remoteAddress,i=e.remotePort;if(r.url!=null)try{const o=new URL(r.url);n=o.hostname,i=parseInt(o.port,10)}catch{}if(n==null||i==null)throw new Error("Remote connection did not have address and/or port");return{sink:aM(r,e),source:t,connected:async()=>{await t.connected()},close:async()=>{(r.readyState===r.CONNECTING||r.readyState===r.OPEN)&&await new Promise(o=>{r.addEventListener("close",()=>{o()}),r.close()})},destroy:()=>{r.terminate!=null?r.terminate():r.close()},remoteAddress:n,remotePort:i,socket:r}},fM=WebSocket,pM={"http:":"ws:","https:":"wss:"},U0="ws:",gM=(r,e)=>{if(r.startsWith("//")&&(r=`${e?.protocol??U0}${r}`),r.startsWith("/")&&e!=null){const n=e.protocol??U0,i=e.host,s=e.port!=null&&i?.endsWith(`:${e.port}`)!==!0?`:${e.port}`:"";r=`${n}//${i}${s}${r}`}const t=new URL(r);for(const[n,i]of Object.entries(pM))t.protocol===n&&(t.protocol=i);return t};function mM(r,e){const t=typeof window>"u"?void 0:window.location;e=e??{};const n=gM(r,t),i=new fM(n.toString(),e.websocket);return hM(i,e)}function cx(r){return r.filter(e=>Yl.exactMatch(e)||Aa.exactMatch(e))}function yM(){throw new Error("WebSocket Servers can not be created in the browser!")}const wM=500;function bM(r,e,t){const n=t.logger.forComponent("libp2p:websockets:maconn"),i=t.metrics,s=t.metricPrefix??"",o={log:n,async sink(a){try{await r.sink(async function*(){for await(const c of a)c instanceof Uint8Array?yield c:yield c.subarray()}())}catch(c){c.type!=="aborted"&&n.error(c)}},source:r.source,remoteAddr:e,timeline:{open:Date.now()},async close(a={}){const c=Date.now();if(a.signal==null){const u=AbortSignal.timeout(wM);a={...a,signal:u}}const l=()=>{const{host:u,port:d}=o.remoteAddr.toOptions();n("timeout closing stream to %s:%s after %dms, destroying it manually",u,d,Date.now()-c),this.abort(new Ri("Socket close timeout"))};a.signal?.addEventListener("abort",l);try{await r.close()}catch(u){n.error("error closing WebSocket gracefully",u),this.abort(u)}finally{a.signal?.removeEventListener("abort",l),o.timeline.close=Date.now()}},abort(a){const{host:c,port:l}=o.remoteAddr.toOptions();n("timeout closing stream to %s:%s due to error",c,l,a),r.destroy(),o.timeline.close=Date.now(),i?.increment({[`${s}error`]:!0})}};return r.socket.addEventListener("close",()=>{i?.increment({[`${s}close`]:!0}),o.timeline.close==null&&(o.timeline.close=Date.now())},{once:!0}),o}class vM{log;init;logger;metrics;components;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:websockets"),this.logger=e.logger,this.components=e,this.init=t,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total",{label:"event",help:"Total count of WebSockets dialer events by type"})})}[zu]=!0;[Symbol.toStringTag]="@libp2p/websockets";[$t]=["@libp2p/transport"];async dial(e,t){this.log("dialing %s",e),t=t??{};const n=await this._connect(e,t),i=bM(n,e,{logger:this.logger,metrics:this.metrics?.dialerEvents});this.log("new outbound connection %s",i.remoteAddr);const s=await t.upgrader.upgradeOutbound(i,t);return this.log("outbound connection %s upgraded",i.remoteAddr),s}async _connect(e,t){t?.signal?.throwIfAborted();const n=e.toOptions();this.log("dialing %s:%s",n.host,n.port);const i=Ve(),s=mM(sM(e),this.init);s.socket.addEventListener("error",()=>{const o=new zv(`Could not connect to ${e.toString()}`);this.log.error("connection error:",o),this.metrics?.dialerEvents.increment({error:!0}),i.reject(o)});try{t.onProgress?.(new ke("websockets:open-connection")),await At(Promise.race([s.connected(),i.promise]),t.signal)}catch(o){throw t.signal?.aborted&&this.metrics?.dialerEvents.increment({abort:!0}),s.close().catch(a=>{this.log.error("error closing raw socket",a)}),o}return this.log("connected %s",e),this.metrics?.dialerEvents.increment({connect:!0}),s}createListener(e){return yM({logger:this.logger,events:this.components.events,metrics:this.components.metrics},{...this.init,...e})}listenFilter(e){return e=Array.isArray(e)?e:[e],this.init?.filter!=null?this.init?.filter(e):cx(e)}dialFilter(e){return this.listenFilter(e)}}function SM(r={}){return e=>new vM(e,r)}function Bu(r){if(typeof r!="object"||r===null)return!1;const e=Object.getPrototypeOf(r);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in r)&&!(Symbol.iterator in r)}const{hasOwnProperty:lx}=Object.prototype,{propertyIsEnumerable:EM}=Object,ro=(r,e,t)=>{Object.defineProperty(r,e,{value:t,writable:!0,enumerable:!0,configurable:!0})},AM=void 0,$0={concatArrays:!1,ignoreUndefined:!1},Xd=r=>{const e=[];for(const t in r)lx.call(r,t)&&e.push(t);if(Object.getOwnPropertySymbols){const t=Object.getOwnPropertySymbols(r);for(const n of t)EM.call(r,n)&&e.push(n)}return e};function Po(r){return Array.isArray(r)?xM(r):Bu(r)?_M(r):r}function xM(r){const e=r.slice(0,0);return Xd(r).forEach(t=>{ro(e,t,Po(r[t]))}),e}function _M(r){const e=Object.getPrototypeOf(r)===null?Object.create(null):{};return Xd(r).forEach(t=>{ro(e,t,Po(r[t]))}),e}const ux=(r,e,t,n)=>(t.forEach(i=>{typeof e[i]>"u"&&n.ignoreUndefined||(i in r&&r[i]!==Object.getPrototypeOf(r)?ro(r,i,ag(r[i],e[i],n)):ro(r,i,Po(e[i])))}),r),CM=(r,e,t)=>{let n=r.slice(0,0),i=0;return[r,e].forEach(s=>{const o=[];for(let a=0;a<s.length;a++)lx.call(s,a)&&(o.push(String(a)),s===r?ro(n,i++,s[a]):ro(n,i++,Po(s[a])));n=ux(n,s,Xd(s).filter(a=>!o.includes(a)),t)}),n};function ag(r,e,t){return t.concatArrays&&Array.isArray(r)&&Array.isArray(e)?CM(r,e,t):!Bu(e)||!Bu(r)?Po(e):ux(r,e,Xd(e),t)}function ny(...r){const e=ag(Po($0),this!==AM&&this||{},$0);let t={_:{}};for(const n of r)if(n!==void 0){if(!Bu(n))throw new TypeError("`"+n+"` is not an Option Object");t=ag(t,{_:n},e)}return t._}var Mh={exports:{}},q0;function IM(){return q0||(q0=1,function(r){var e=Object.prototype.hasOwnProperty,t="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(t=!1));function i(c,l,u){this.fn=c,this.context=l,this.once=u||!1}function s(c,l,u,d,h){if(typeof u!="function")throw new TypeError("The listener must be a function");var p=new i(u,d||c,h),m=t?t+l:l;return c._events[m]?c._events[m].fn?c._events[m]=[c._events[m],p]:c._events[m].push(p):(c._events[m]=p,c._eventsCount++),c}function o(c,l){--c._eventsCount===0?c._events=new n:delete c._events[l]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var l=[],u,d;if(this._eventsCount===0)return l;for(d in u=this._events)e.call(u,d)&&l.push(t?d.slice(1):d);return Object.getOwnPropertySymbols?l.concat(Object.getOwnPropertySymbols(u)):l},a.prototype.listeners=function(l){var u=t?t+l:l,d=this._events[u];if(!d)return[];if(d.fn)return[d.fn];for(var h=0,p=d.length,m=new Array(p);h<p;h++)m[h]=d[h].fn;return m},a.prototype.listenerCount=function(l){var u=t?t+l:l,d=this._events[u];return d?d.fn?1:d.length:0},a.prototype.emit=function(l,u,d,h,p,m){var w=t?t+l:l;if(!this._events[w])return!1;var y=this._events[w],b=arguments.length,_,E;if(y.fn){switch(y.once&&this.removeListener(l,y.fn,void 0,!0),b){case 1:return y.fn.call(y.context),!0;case 2:return y.fn.call(y.context,u),!0;case 3:return y.fn.call(y.context,u,d),!0;case 4:return y.fn.call(y.context,u,d,h),!0;case 5:return y.fn.call(y.context,u,d,h,p),!0;case 6:return y.fn.call(y.context,u,d,h,p,m),!0}for(E=1,_=new Array(b-1);E<b;E++)_[E-1]=arguments[E];y.fn.apply(y.context,_)}else{var R=y.length,S;for(E=0;E<R;E++)switch(y[E].once&&this.removeListener(l,y[E].fn,void 0,!0),b){case 1:y[E].fn.call(y[E].context);break;case 2:y[E].fn.call(y[E].context,u);break;case 3:y[E].fn.call(y[E].context,u,d);break;case 4:y[E].fn.call(y[E].context,u,d,h);break;default:if(!_)for(S=1,_=new Array(b-1);S<b;S++)_[S-1]=arguments[S];y[E].fn.apply(y[E].context,_)}}return!0},a.prototype.on=function(l,u,d){return s(this,l,u,d,!1)},a.prototype.once=function(l,u,d){return s(this,l,u,d,!0)},a.prototype.removeListener=function(l,u,d,h){var p=t?t+l:l;if(!this._events[p])return this;if(!u)return o(this,p),this;var m=this._events[p];if(m.fn)m.fn===u&&(!h||m.once)&&(!d||m.context===d)&&o(this,p);else{for(var w=0,y=[],b=m.length;w<b;w++)(m[w].fn!==u||h&&!m[w].once||d&&m[w].context!==d)&&y.push(m[w]);y.length?this._events[p]=y.length===1?y[0]:y:o(this,p)}return this},a.prototype.removeAllListeners=function(l){var u;return l?(u=t?t+l:l,this._events[u]&&o(this,u)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,r.exports=a}(Mh)),Mh.exports}var kM=IM();const TM=bo(kM);function PM(r,e,t){let n=0,i=r.length;for(;i>0;){const s=Math.trunc(i/2);let o=n+s;t(r[o],e)<=0?(n=++o,i-=s+1):i=s}return n}let RM=class{#e=[];enqueue(e,t){t={priority:0,...t};const n={priority:t.priority,id:t.id,run:e};if(this.size===0||this.#e[this.size-1].priority>=t.priority){this.#e.push(n);return}const i=PM(this.#e,n,(s,o)=>o.priority-s.priority);this.#e.splice(i,0,n)}setPriority(e,t){const n=this.#e.findIndex(s=>s.id===e);if(n===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[i]=this.#e.splice(n,1);this.enqueue(i.run,{priority:t,id:e})}dequeue(){return this.#e.shift()?.run}filter(e){return this.#e.filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return this.#e.length}};class OM extends TM{#e;#r;#t=0;#f;#a;#p=0;#i;#c;#n;#g;#s=0;#l;#o;#m;#b=1n;timeout;constructor(e){if(super(),e={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:RM,...e},!(typeof e.intervalCap=="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString()??""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString()??""}\` (${typeof e.interval})`);this.#e=e.carryoverConcurrencyCount,this.#r=e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0,this.#f=e.intervalCap,this.#a=e.interval,this.#n=new e.queueClass,this.#g=e.queueClass,this.concurrency=e.concurrency,this.timeout=e.timeout,this.#m=e.throwOnTimeout===!0,this.#o=e.autoStart===!1}get#v(){return this.#r||this.#t<this.#f}get#S(){return this.#s<this.#l}#E(){this.#s--,this.#u(),this.emit("next")}#A(){this.#w(),this.#y(),this.#c=void 0}get#x(){const e=Date.now();if(this.#i===void 0){const t=this.#p-e;if(t<0)this.#t=this.#e?this.#s:0;else return this.#c===void 0&&(this.#c=setTimeout(()=>{this.#A()},t)),!0}return!1}#u(){if(this.#n.size===0)return this.#i&&clearInterval(this.#i),this.#i=void 0,this.emit("empty"),this.#s===0&&this.emit("idle"),!1;if(!this.#o){const e=!this.#x;if(this.#v&&this.#S){const t=this.#n.dequeue();return t?(this.emit("active"),t(),e&&this.#y(),!0):!1}}return!1}#y(){this.#r||this.#i!==void 0||(this.#i=setInterval(()=>{this.#w()},this.#a),this.#p=Date.now()+this.#a)}#w(){this.#t===0&&this.#s===0&&this.#i&&(clearInterval(this.#i),this.#i=void 0),this.#t=this.#e?this.#s:0,this.#d()}#d(){for(;this.#u(););}get concurrency(){return this.#l}set concurrency(e){if(!(typeof e=="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);this.#l=e,this.#d()}async#_(e){return new Promise((t,n)=>{e.addEventListener("abort",()=>{n(e.reason)},{once:!0})})}setPriority(e,t){this.#n.setPriority(e,t)}async add(e,t={}){return t.id??=(this.#b++).toString(),t={timeout:this.timeout,throwOnTimeout:this.#m,...t},new Promise((n,i)=>{this.#n.enqueue(async()=>{this.#s++,this.#t++;try{t.signal?.throwIfAborted();let s=e({signal:t.signal});t.timeout&&(s=um(Promise.resolve(s),{milliseconds:t.timeout})),t.signal&&(s=Promise.race([s,this.#_(t.signal)]));const o=await s;n(o),this.emit("completed",o)}catch(s){if(s instanceof l1&&!t.throwOnTimeout){n();return}i(s),this.emit("error",s)}finally{this.#E()}},t),this.emit("add"),this.#u()})}async addAll(e,t){return Promise.all(e.map(async n=>this.add(n,t)))}start(){return this.#o?(this.#o=!1,this.#d(),this):this}pause(){this.#o=!0}clear(){this.#n=new this.#g}async onEmpty(){this.#n.size!==0&&await this.#h("empty")}async onSizeLessThan(e){this.#n.size<e||await this.#h("next",()=>this.#n.size<e)}async onIdle(){this.#s===0&&this.#n.size===0||await this.#h("idle")}async#h(e,t){return new Promise(n=>{const i=()=>{t&&!t()||(this.off(e,i),n())};this.on(e,i)})}get size(){return this.#n.size}sizeBy(e){return this.#n.filter(e).length}get pending(){return this.#s}get isPaused(){return this.#o}}function dx(r){const e=[Zn.A];return r==null?e:Array.isArray(r)?r.length===0?e:r:[r]}const hx=60;function fx(r){return{Status:r.Status??0,TC:r.TC??r.flag_tc??!1,RD:r.RD??r.flag_rd??!1,RA:r.RA??r.flag_ra??!1,AD:r.AD??r.flag_ad??!1,CD:r.CD??r.flag_cd??!1,Question:(r.Question??r.questions??[]).map(e=>({name:e.name,type:Zn[e.type]})),Answer:(r.Answer??r.answers??[]).map(e=>({name:e.name,type:Zn[e.type],TTL:e.TTL??e.ttl??hx,data:e.data instanceof Uint8Array?ne(e.data):e.data}))}}const BM=4;function K0(r,e={}){const t=new OM({concurrency:e.queryConcurrency??BM});return async(n,i={})=>{const s=new URLSearchParams;s.set("name",n),dx(i.types).forEach(a=>{s.append("type",Zn[a])}),i.onProgress?.(new ke("dns:query",{detail:n}));const o=await t.add(async()=>{const a=await fetch(`${r}?${s}`,{headers:{accept:"application/dns-json"},signal:i?.signal});if(a.status!==200)throw new Error(`Unexpected HTTP status: ${a.status} - ${a.statusText}`);const c=fx(await a.json());return i.onProgress?.(new ke("dns:response",{detail:c})),c},{signal:i.signal});if(o==null)throw new Error("No DNS response received");return o}}function NM(){return[K0("https://cloudflare-dns.com/dns-query"),K0("https://dns.google/resolve")]}var Fh,V0;function DM(){return V0||(V0=1,Fh=function(r){if(!r)throw Error("hashlru must have a max value, of type number, greater than 0");var e=0,t=Object.create(null),n=Object.create(null);function i(s,o){t[s]=o,e++,e>=r&&(e=0,n=t,t=Object.create(null))}return{has:function(s){return t[s]!==void 0||n[s]!==void 0},remove:function(s){t[s]!==void 0&&(t[s]=void 0),n[s]!==void 0&&(n[s]=void 0)},get:function(s){var o=t[s];if(o!==void 0)return o;if((o=n[s])!==void 0)return i(s,o),o},set:function(s,o){t[s]!==void 0?t[s]=o:i(s,o)},clear:function(){t=Object.create(null),n=Object.create(null)}}}),Fh}var LM=DM();const MM=bo(LM);class FM{lru;constructor(e){this.lru=MM(e)}get(e,t){let n=!0;const i=[];for(const s of t){const o=this.getAnswers(e,s);if(o.length===0){n=!1;break}i.push(...o)}if(n)return fx({answers:i})}getAnswers(e,t){const n=`${e.toLowerCase()}-${t}`,i=this.lru.get(n);if(i!=null){const s=i.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:Zn[a.type]}));return s.length===0&&this.lru.remove(n),s}return[]}add(e,t){const n=`${e.toLowerCase()}-${t.type}`,i=this.lru.get(n)??[];i.push({expires:Date.now()+(t.TTL??hx)*1e3,value:t}),this.lru.set(n,i)}remove(e,t){const n=`${e.toLowerCase()}-${t}`;this.lru.remove(n)}clear(){this.lru.clear()}}function UM(r){return new FM(r)}const $M=1e3;class qM{resolvers;cache;constructor(e){this.resolvers={},this.cache=UM(e.cacheSize??$M),Object.entries(e.resolvers??{}).forEach(([t,n])=>{Array.isArray(n)||(n=[n]),t.endsWith(".")||(t=`${t}.`),this.resolvers[t]=n}),this.resolvers["."]==null&&(this.resolvers["."]=NM())}async query(e,t={}){const n=dx(t.types),i=t.cached!==!1?this.cache.get(e,n):void 0;if(i!=null)return t.onProgress?.(new ke("dns:cache",{detail:i})),i;const s=`${e.split(".").pop()}.`,o=(this.resolvers[s]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const c of o){if(t.signal?.aborted===!0)break;try{const l=await c(e,{...t,types:n});for(const u of l.Answer)this.cache.add(e,u);return l}catch(l){a.push(l),t.onProgress?.(new ke("dns:error",{detail:l}))}}throw a.length===1?a[0]:new AggregateError(a,`DNS lookup of ${e} ${n} failed`)}}var Zn;(function(r){r[r.A=1]="A",r[r.CNAME=5]="CNAME",r[r.TXT=16]="TXT",r[r.AAAA=28]="AAAA"})(Zn||(Zn={}));function KM(r={}){return new qM(r)}const zt=-1,cg={},VM={},zM=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,zt,"ip6zone"],[43,8,"ipcidr"],[53,zt,"dns",!0],[54,zt,"dns4",!0],[55,zt,"dns6",!0],[56,zt,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,zt,"unix",!1,!0],[421,zt,"ipfs"],[421,zt,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,zt,"garlic64"],[448,0,"tls"],[449,zt,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,zt,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[481,zt,"http-path"],[777,zt,"memory"]];zM.forEach(r=>{const e=jM(...r);VM[e.code]=e,cg[e.name]=e});function jM(r,e,t,n,i){return{code:r,size:e,name:t,resolvable:!!n,path:!!i}}function HM(r){{if(cg[r]!=null)return cg[r];throw new Error(`no protocol with name: ${r}`)}}const WM=32,{code:GM}=HM("dnsaddr");class YM extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}const px=async function(e,t={}){const n=t.maxRecursiveDepth??WM;if(n===0)throw new YM("Max recursive depth reached");const[,i]=e.stringTuples().find(([l])=>l===GM)??[],o=await(t?.dns??KM()).query(`_dnsaddr.${i}`,{signal:t?.signal,types:[Zn.TXT]}),a=e.getPeerId(),c=[];for(const l of o.Answer){const u=l.data.replace(/["']/g,"").trim().split("=")[1];if(u==null||a!=null&&!u.includes(a))continue;const d=de(u);if(u.startsWith("/dnsaddr")){const h=await d.resolve({...t,maxRecursiveDepth:n-1});c.push(...h.map(p=>p.toString()))}else c.push(d.toString())}return c},QM={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter:r=>r},connectionManager:{resolvers:{dnsaddr:px}},transportManager:{faultTolerance:fa.FATAL_ALL}};async function JM(r){const e=ny(QM,r);if(e.connectionProtector===null&&globalThis.process?.env?.LIBP2P_FORCE_PNET!=null)throw new q("Private network is enforced, but no protector was provided");return e}const no=1e3,io=no*60,so=io*60,Wi=so*24,XM=Wi*7,ZM=Wi*365.25;function gx(r,e){try{if(typeof r=="string"&&r.length>0)return e3(r);if(typeof r=="number"&&isFinite(r))return e?.long?r3(r):t3(r);throw new Error("Value is not a string or number.")}catch(t){const n=n3(t)?`${t.message}. value=${JSON.stringify(r)}`:"An unknown error has occured.";throw new Error(n)}}function e3(r){if(r=String(r),r.length>100)throw new Error("Value exceeds the maximum length of 100 characters.");const e=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(r);if(!e)return NaN;const t=parseFloat(e[1]),n=(e[2]||"ms").toLowerCase();switch(n){case"years":case"year":case"yrs":case"yr":case"y":return t*ZM;case"weeks":case"week":case"w":return t*XM;case"days":case"day":case"d":return t*Wi;case"hours":case"hour":case"hrs":case"hr":case"h":return t*so;case"minutes":case"minute":case"mins":case"min":case"m":return t*io;case"seconds":case"second":case"secs":case"sec":case"s":return t*no;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:throw new Error(`The unit ${n} was matched, but no matching case exists.`)}}function t3(r){const e=Math.abs(r);return e>=Wi?`${Math.round(r/Wi)}d`:e>=so?`${Math.round(r/so)}h`:e>=io?`${Math.round(r/io)}m`:e>=no?`${Math.round(r/no)}s`:`${r}ms`}function r3(r){const e=Math.abs(r);return e>=Wi?jc(r,e,Wi,"day"):e>=so?jc(r,e,so,"hour"):e>=io?jc(r,e,io,"minute"):e>=no?jc(r,e,no,"second"):`${r} ms`}function jc(r,e,t,n){const i=e>=t*1.5;return`${Math.round(r/t)} ${n}${i?"s":""}`}function n3(r){return typeof r=="object"&&r!==null&&"message"in r}function i3(r){t.debug=t,t.default=t,t.coerce=c,t.disable=s,t.enable=i,t.enabled=o,t.humanize=gx,t.destroy=l,Object.keys(r).forEach(u=>{t[u]=r[u]}),t.names=[],t.skips=[],t.formatters={};function e(u){let d=0;for(let h=0;h<u.length;h++)d=(d<<5)-d+u.charCodeAt(h),d|=0;return t.colors[Math.abs(d)%t.colors.length]}t.selectColor=e;function t(u){let d,h=null,p,m;function w(...y){if(!w.enabled)return;const b=w,_=Number(new Date),E=_-(d||_);b.diff=E,b.prev=d,b.curr=_,d=_,y[0]=t.coerce(y[0]),typeof y[0]!="string"&&y.unshift("%O");let R=0;y[0]=y[0].replace(/%([a-zA-Z%])/g,(N,T)=>{if(N==="%%")return"%";R++;const B=t.formatters[T];if(typeof B=="function"){const v=y[R];N=B.call(b,v),y.splice(R,1),R--}return N}),t.formatArgs.call(b,y),(b.log||t.log).apply(b,y)}return w.namespace=u,w.useColors=t.useColors(),w.color=t.selectColor(u),w.extend=n,w.destroy=t.destroy,Object.defineProperty(w,"enabled",{enumerable:!0,configurable:!1,get:()=>h!==null?h:(p!==t.namespaces&&(p=t.namespaces,m=t.enabled(u)),m),set:y=>{h=y}}),typeof t.init=="function"&&t.init(w),w}function n(u,d){const h=t(this.namespace+(typeof d>"u"?":":d)+u);return h.log=this.log,h}function i(u){t.save(u),t.namespaces=u,t.names=[],t.skips=[];let d;const h=(typeof u=="string"?u:"").split(/[\s,]+/),p=h.length;for(d=0;d<p;d++)h[d]&&(u=h[d].replace(/\*/g,".*?"),u[0]==="-"?t.skips.push(new RegExp("^"+u.substr(1)+"$")):t.names.push(new RegExp("^"+u+"$")))}function s(){const u=[...t.names.map(a),...t.skips.map(a).map(d=>"-"+d)].join(",");return t.enable(""),u}function o(u){if(u[u.length-1]==="*")return!0;let d,h;for(d=0,h=t.skips.length;d<h;d++)if(t.skips[d].test(u))return!1;for(d=0,h=t.names.length;d<h;d++)if(t.names[d].test(u))return!0;return!1}function a(u){return u.toString().substring(2,u.toString().length-2).replace(/\.\*\?$/,"*")}function c(u){return u instanceof Error?u.stack??u.message:u}function l(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.setupFormatters(t.formatters),t.enable(t.load()),t}var s3={};const Nu=h3(),o3=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function a3(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/)!=null?!1:typeof document<"u"&&document.documentElement?.style?.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/)!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/)}function c3(r){if(r[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+r[0]+(this.useColors?"%c ":" ")+"+"+gx(this.diff),!this.useColors)return;const e="color: "+this.color;r.splice(1,0,e,"color: inherit");let t=0,n=0;r[0].replace(/%[a-zA-Z%]/g,i=>{i!=="%%"&&(t++,i==="%c"&&(n=t))}),r.splice(n,0,e)}const l3=console.debug??console.log??(()=>{});function u3(r){try{r?Nu?.setItem("debug",r):Nu?.removeItem("debug")}catch{}}function d3(){let r;try{r=Nu?.getItem("debug")}catch{}return!r&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(r=s3.DEBUG),r}function h3(){try{return localStorage}catch{}}function f3(r){r.j=function(e){try{return JSON.stringify(e)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}}const Gt=i3({formatArgs:c3,save:u3,load:d3,useColors:a3,setupFormatters:f3,colors:o3,storage:Nu,log:l3});Gt.formatters.b=r=>r==null?"undefined":Qe.baseEncode(r);Gt.formatters.t=r=>r==null?"undefined":Vn.baseEncode(r);Gt.formatters.m=r=>r==null?"undefined":Va.baseEncode(r);Gt.formatters.p=r=>r==null?"undefined":r.toString();Gt.formatters.c=r=>r==null?"undefined":r.toString();Gt.formatters.k=r=>r==null?"undefined":r.toString();Gt.formatters.a=r=>r==null?"undefined":r.toString();Gt.formatters.e=r=>r==null?"undefined":z0(r.stack)??z0(r.message)??r.toString();function p3(r){const e=()=>{};return e.enabled=!1,e.color="",e.diff=0,e.log=()=>{},e.namespace=r,e.destroy=()=>!0,e.extend=()=>e,e}function mx(){return{forComponent(r){return g3(r)}}}function g3(r){let e=p3(`${r}:trace`);return Gt.enabled(`${r}:trace`)&&Gt.names.map(t=>t.toString()).find(t=>t.includes(":trace"))!=null&&(e=Gt(`${r}:trace`)),Object.assign(Gt(r),{error:Gt(`${r}:error`),trace:e})}function z0(r){if(r!=null&&(r=r.trim(),r.length!==0))return r}function m3(r){return r[Symbol.asyncIterator]!=null}function lg(r){if(m3(r))return(async()=>{const t=[];for await(const n of r)t.push(n);return t})();const e=[];for(const t of r)e.push(t);return e}let Ma=class extends Error{static name="AbortError";name="AbortError";constructor(e="The operation was aborted",...t){super(e,...t)}};class y3 extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}class w3{deferred;signal;constructor(e){this.signal=e,this.deferred=Promise.withResolvers(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new Ma)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}}function b3(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class v3{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=b3(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,n)=>t&&n.signal?.aborted===!0,!0)&&(this.controller.abort(new Ma),this.cleanup())}async join(e={}){const t=new w3(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await At(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}}function j0(r,e){let t;const n=function(){const i=function(){t=void 0,r()};clearTimeout(t),t=setTimeout(i,e)};return n.start=()=>{},n.stop=()=>{clearTimeout(t)},n}class H0 extends sr{concurrency;maxSize;queue;pending;sort;autoStart;constructor(e={}){super(),this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.autoStart=e.autoStart??!0,this.sort=e.sort,this.queue=[],this.emitEmpty=j0(this.emitEmpty.bind(this),1),this.emitIdle=j0(this.emitIdle.bind(this),1)}[Symbol.asyncIterator](){return this.toGenerator()}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if(t.status==="queued"){e=t;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.safeDispatchEvent("next"),this.autoStart&&this.tryToStartAnother()}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}start(){this.autoStart===!1&&(this.autoStart=!0,this.tryToStartAnother())}pause(){this.autoStart=!1}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new y3;const n=new v3(e,t);return this.enqueue(n),this.safeDispatchEvent("add"),this.autoStart&&this.tryToStartAnother(),n.join(t).then(i=>(this.safeDispatchEvent("success",{detail:{job:n,result:i}}),i)).catch(i=>{if(n.status==="queued"){for(let s=0;s<this.queue.length;s++)if(this.queue[s]===n){this.queue.splice(s,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:n,error:i}}),i})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new Ma)}),this.clear()}async onEmpty(e){this.size!==0&&await Ur(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await Ur(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await Ur(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=go({objectMode:!0}),n=c=>{c!=null?this.abort():this.clear(),t.end(c)},i=c=>{c.detail!=null&&t.push(c.detail.result)},s=c=>{n(c.detail.error)},o=()=>{n()},a=()=>{n(new Ma("Queue aborted"))};this.addEventListener("success",i),this.addEventListener("failure",s),this.addEventListener("idle",o),e?.signal?.addEventListener("abort",a);try{yield*t}finally{this.removeEventListener("success",i),this.removeEventListener("failure",s),this.removeEventListener("idle",o),e?.signal?.removeEventListener("abort",a),n()}}}const yx="lock:worker:request-read",wx="lock:worker:abort-read-request",bx="lock:worker:release-read",vx="lock:master:grant-read",Sx="lock:master:error-read",Ex="lock:worker:request-write",Ax="lock:worker:abort-write-request",xx="lock:worker:release-write",_x="lock:master:grant-write",Cx="lock:master:error-write",Ix="lock:worker:finalize",kx="mortice",S3={singleProcess:!1},W0=(r,e,t,n,i,s,o,a,c)=>l=>{if(l.data==null)return;const u={type:l.data.type,name:l.data.name,identifier:l.data.identifier};u.type===i&&r.safeDispatchEvent(t,{detail:{name:u.name,identifier:u.identifier,handler:async()=>{e.postMessage({type:c,name:u.name,identifier:u.identifier}),await new Promise(d=>{const h=p=>{if(p?.data==null)return;const m={type:p.data.type,name:p.data.name,identifier:p.data.identifier};m.type===a&&m.identifier===u.identifier&&(e.removeEventListener("message",h),d())};e.addEventListener("message",h)})},onError:d=>{e.postMessage({type:o,name:u.name,identifier:u.identifier,error:{message:d.message,name:d.name,stack:d.stack}})}}}),u.type===s&&r.safeDispatchEvent(n,{detail:{name:u.name,identifier:u.identifier}}),u.type===Ix&&r.safeDispatchEvent("finalizeRequest",{detail:{name:u.name}})},E3=(r=10)=>Math.random().toString().substring(2,r+2);class A3{name;channel;constructor(e){this.name=e,this.channel=new BroadcastChannel(kx)}readLock(e){return this.sendRequest(yx,wx,vx,Sx,bx,e)}writeLock(e){return this.sendRequest(Ex,Ax,_x,Cx,xx,e)}finalize(){this.channel.postMessage({type:Ix,name:this.name}),this.channel.close()}async sendRequest(e,t,n,i,s,o){o?.signal?.throwIfAborted();const a=E3();return this.channel.postMessage({type:e,identifier:a,name:this.name}),new Promise((c,l)=>{const u=()=>{this.channel.postMessage({type:t,identifier:a,name:this.name})};o?.signal?.addEventListener("abort",u,{once:!0});const d=h=>{if(h.data?.identifier===a&&(h.data?.type===n&&(this.channel.removeEventListener("message",d),o?.signal?.removeEventListener("abort",u),c(()=>{this.channel.postMessage({type:s,identifier:a,name:this.name})})),h.data.type===i)){this.channel.removeEventListener("message",d),o?.signal?.removeEventListener("abort",u);const p=new Error;h.data.error!=null&&(p.message=h.data.error.message,p.name=h.data.error.name,p.stack=h.data.error.stack),l(p)}};this.channel.addEventListener("message",d)})}}const x3=r=>{if(r=Object.assign({},S3,r),!!globalThis.document||r.singleProcess){const t=new BroadcastChannel(kx),n=new sr;return t.addEventListener("message",W0(n,t,"requestReadLock","abortReadLockRequest",yx,wx,Sx,bx,vx)),t.addEventListener("message",W0(n,t,"requestWriteLock","abortWriteLockRequest",Ex,Ax,Cx,xx,_x)),n}return new A3(r.name)},Si=new Map;let qo;function Tx(r){return typeof r?.readLock=="function"&&typeof r?.writeLock=="function"}function _3(r){if(qo==null&&(qo=x3(r),!Tx(qo))){const e=qo;e.addEventListener("requestReadLock",t=>{const n=t.detail.name,i=t.detail.identifier,s=Si.get(n);if(s==null)return;const o=new AbortController,a=c=>{c.detail.name!==n||c.detail.identifier!==i||o.abort()};e.addEventListener("abortReadLockRequest",a),s.readLock({signal:o.signal}).then(async c=>{await t.detail.handler().finally(()=>{c()})}).catch(c=>{t.detail.onError(c)}).finally(()=>{e.removeEventListener("abortReadLockRequest",a)})}),e.addEventListener("requestWriteLock",t=>{const n=t.detail.name,i=t.detail.identifier,s=Si.get(n);if(s==null)return;const o=new AbortController,a=c=>{c.detail.name!==n||c.detail.identifier!==i||o.abort()};e.addEventListener("abortWriteLockRequest",a),s.writeLock({signal:o.signal}).then(async c=>{await t.detail.handler().finally(()=>{c()})}).catch(c=>{t.detail.onError(c)}).finally(()=>{e.removeEventListener("abortWriteLockRequest",a)})}),e.addEventListener("finalizeRequest",t=>{const n=t.detail.name,i=Si.get(n);i?.finalize()})}return qo}async function Uh(r,e){let t,n;const i=new Promise((o,a)=>{t=o,n=a}),s=()=>{n(new Ma)};return e?.signal?.addEventListener("abort",s,{once:!0}),r.add(async()=>{await new Promise(o=>{t(()=>{e?.signal?.removeEventListener("abort",s),o()})})},{signal:e?.signal}).catch(o=>{n(o)}),i}const C3=(r,e)=>{let t=Si.get(r);if(t!=null)return t;const n=_3(e);if(Tx(n))return t=n,Si.set(r,t),t;const i=new H0({concurrency:1});let s;return t={async readLock(o){if(s!=null)return Uh(s,o);s=new H0({concurrency:e.concurrency,autoStart:!1});const a=s,c=Uh(s,o);return i.add(async()=>{a.start(),await a.onIdle().then(()=>{s===a&&(s=null)})}),c},async writeLock(o){return s=null,Uh(i,o)},finalize:()=>{Si.delete(r)},queue:i},Si.set(r,t),e.autoFinalize===!0&&i.addEventListener("idle",()=>{t.finalize()},{once:!0}),t},I3={name:"lock",concurrency:1/0,singleProcess:!1,autoFinalize:!1};function k3(r){const e=Object.assign({},I3,r);return C3(e.name,e)}const T3=36e5,P3=216e5;var Ei;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=Oe((i,s,o={})=>{o.lengthDelimited!==!1&&s.fork(),i.key!=null&&i.key!==""&&(s.uint32(10),s.string(i.key)),i.value!=null&&i.value.byteLength>0&&(s.uint32(18),s.bytes(i.value)),o.lengthDelimited!==!1&&s.ldelim()},(i,s,o={})=>{const a={key:"",value:Ie(0)},c=s==null?i.len:i.pos+s;for(;i.pos<c;){const l=i.uint32();switch(l>>>3){case 1:{a.key=i.string();break}case 2:{a.value=i.bytes();break}default:{i.skipType(l&7);break}}}return a})),n),t.encode=i=>Re(i,t.codec()),t.decode=(i,s)=>Pe(i,t.codec(),s)})(r.Peer$metadataEntry||(r.Peer$metadataEntry={})),function(t){let n;t.codec=()=>(n==null&&(n=Oe((i,s,o={})=>{o.lengthDelimited!==!1&&s.fork(),i.key!=null&&i.key!==""&&(s.uint32(10),s.string(i.key)),i.value!=null&&(s.uint32(18),Lu.codec().encode(i.value,s)),o.lengthDelimited!==!1&&s.ldelim()},(i,s,o={})=>{const a={key:""},c=s==null?i.len:i.pos+s;for(;i.pos<c;){const l=i.uint32();switch(l>>>3){case 1:{a.key=i.string();break}case 2:{a.value=Lu.codec().decode(i,i.uint32(),{limits:o.limits?.value});break}default:{i.skipType(l&7);break}}}return a})),n),t.encode=i=>Re(i,t.codec()),t.decode=(i,s)=>Pe(i,t.codec(),s)}(r.Peer$tagsEntry||(r.Peer$tagsEntry={}));let e;r.codec=()=>(e==null&&(e=Oe((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.addresses!=null)for(const s of t.addresses)n.uint32(10),Du.codec().encode(s,n);if(t.protocols!=null)for(const s of t.protocols)n.uint32(18),n.string(s);if(t.publicKey!=null&&(n.uint32(34),n.bytes(t.publicKey)),t.peerRecordEnvelope!=null&&(n.uint32(42),n.bytes(t.peerRecordEnvelope)),t.metadata!=null&&t.metadata.size!==0)for(const[s,o]of t.metadata.entries())n.uint32(50),r.Peer$metadataEntry.codec().encode({key:s,value:o},n);if(t.tags!=null&&t.tags.size!==0)for(const[s,o]of t.tags.entries())n.uint32(58),r.Peer$tagsEntry.codec().encode({key:s,value:o},n);t.updated!=null&&(n.uint32(64),n.uint64Number(t.updated)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(i.limits?.addresses!=null&&s.addresses.length===i.limits.addresses)throw new Ar('Decode error - map field "addresses" had too many elements');s.addresses.push(Du.codec().decode(t,t.uint32(),{limits:i.limits?.addresses$}));break}case 2:{if(i.limits?.protocols!=null&&s.protocols.length===i.limits.protocols)throw new Ar('Decode error - map field "protocols" had too many elements');s.protocols.push(t.string());break}case 4:{s.publicKey=t.bytes();break}case 5:{s.peerRecordEnvelope=t.bytes();break}case 6:{if(i.limits?.metadata!=null&&s.metadata.size===i.limits.metadata)throw new ow('Decode error - map field "metadata" had too many elements');const c=r.Peer$metadataEntry.codec().decode(t,t.uint32());s.metadata.set(c.key,c.value);break}case 7:{if(i.limits?.tags!=null&&s.tags.size===i.limits.tags)throw new ow('Decode error - map field "tags" had too many elements');const c=r.Peer$tagsEntry.codec().decode(t,t.uint32(),{limits:{value:i.limits?.tags$value}});s.tags.set(c.key,c.value);break}case 8:{s.updated=t.uint64Number();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Re(t,r.codec()),r.decode=(t,n)=>Pe(t,r.codec(),n)})(Ei||(Ei={}));var Du;(function(r){let e;r.codec=()=>(e==null&&(e=Oe((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.multiaddr!=null&&t.multiaddr.byteLength>0&&(n.uint32(10),n.bytes(t.multiaddr)),t.isCertified!=null&&(n.uint32(16),n.bool(t.isCertified)),t.observed!=null&&(n.uint32(24),n.uint64Number(t.observed)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={multiaddr:Ie(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.multiaddr=t.bytes();break}case 2:{s.isCertified=t.bool();break}case 3:{s.observed=t.uint64Number();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Re(t,r.codec()),r.decode=(t,n)=>Pe(t,r.codec(),n)})(Du||(Du={}));var Lu;(function(r){let e;r.codec=()=>(e==null&&(e=Oe((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.value!=null&&t.value!==0&&(n.uint32(8),n.uint32(t.value)),t.expiry!=null&&(n.uint32(16),n.uint64(t.expiry)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={value:0},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.value=t.uint32();break}case 2:{s.expiry=t.uint64();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Re(t,r.codec()),r.decode=(t,n)=>Pe(t,r.codec(),n)})(Lu||(Lu={}));function R3(r,e){if(r.publicKey!=null||e.publicKey==null)return r;let t;r.type==="RSA"&&(t=r.toMultihash());const n=Gn(e.publicKey,t);return ya(n)}function O3(r,e,t){const n=Ei.decode(e);return Ho(r,n,t)}function Ho(r,e,t){const n=new Map,i=BigInt(Date.now());for(const[s,o]of e.tags.entries())o.expiry!=null&&o.expiry<i||n.set(s,o);return{...e,id:R3(r,e),addresses:e.addresses.filter(({observed:s})=>s!=null&&s>Date.now()-t).map(({multiaddr:s,isCertified:o})=>({multiaddr:de(s),isCertified:o??!1})),metadata:e.metadata,peerRecordEnvelope:e.peerRecordEnvelope??void 0,tags:n}}function B3(r,e){return N3(r.addresses,e.addresses)&&D3(r.protocols,e.protocols)&&L3(r.publicKey,e.publicKey)&&M3(r.peerRecordEnvelope,e.peerRecordEnvelope)&&F3(r.metadata,e.metadata)&&U3(r.tags,e.tags)}function N3(r,e){return Rx(r,e,(t,n)=>!(t.isCertified!==n.isCertified||!Je(t.multiaddr,n.multiaddr)))}function D3(r,e){return Rx(r,e,(t,n)=>t===n)}function L3(r,e){return Px(r,e)}function M3(r,e){return Px(r,e)}function F3(r,e){return Ox(r,e,(t,n)=>Je(t,n))}function U3(r,e){return Ox(r,e,(t,n)=>t.value===n.value&&t.expiry===n.expiry)}function Px(r,e){return r==null&&e==null?!0:r!=null&&e!=null?Je(r,e):!1}function Rx(r,e,t){if(r.length!==e.length)return!1;for(let n=0;n<r.length;n++)if(!t(r[n],e[n]))return!1;return!0}function Ox(r,e,t){if(r.size!==e.size)return!1;for(const[n,i]of r.entries()){const s=e.get(n);if(s==null||!t(i,s))return!1}return!0}const Bx="/peers/";function Hc(r){if(!Xo(r)||r.type==null)throw new q("Invalid PeerId");const e=r.toCID().toString();return new rt(`${Bx}${e}`)}async function $3(r,e,t,n,i){const s=new Map;for(const o of t){if(o==null)continue;if(o.multiaddr instanceof Uint8Array&&(o.multiaddr=de(o.multiaddr)),!rd(o.multiaddr))throw new q("Multiaddr was invalid");if(!await e(r,o.multiaddr,i))continue;const a=o.isCertified??!1,c=o.multiaddr.toString(),l=s.get(c);l!=null?o.isCertified=l.isCertified||a:s.set(c,{multiaddr:o.multiaddr,isCertified:a})}return[...s.values()].sort((o,a)=>o.multiaddr.toString().localeCompare(a.multiaddr.toString())).map(({isCertified:o,multiaddr:a})=>{const c=a.getPeerId();return r.equals(c)&&(a=a.decapsulate(de(`/p2p/${r}`))),{isCertified:o,multiaddr:a.bytes}})}async function $h(r,e,t,n){if(e==null)throw new q("Invalid PeerData");if(e.publicKey!=null&&r.publicKey!=null&&!e.publicKey.equals(r.publicKey))throw new q("publicKey bytes do not match peer id publicKey bytes");const i=n.existingPeer?.peer;if(i!=null&&!r.equals(i.id))throw new q("peer id did not match existing peer id");let s=i?.addresses??[],o=new Set(i?.protocols??[]),a=i?.metadata??new Map,c=i?.tags??new Map,l=i?.peerRecordEnvelope;if(t==="patch"){if((e.multiaddrs!=null||e.addresses!=null)&&(s=[],e.multiaddrs!=null&&s.push(...e.multiaddrs.map(h=>({isCertified:!1,multiaddr:h}))),e.addresses!=null&&s.push(...e.addresses)),e.protocols!=null&&(o=new Set(e.protocols)),e.metadata!=null){const h=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);a=Wc(h,{validate:G0})}if(e.tags!=null){const h=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags);c=Wc(h,{validate:Y0,map:Q0})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}if(t==="merge"){if(e.multiaddrs!=null&&s.push(...e.multiaddrs.map(h=>({isCertified:!1,multiaddr:h}))),e.addresses!=null&&s.push(...e.addresses),e.protocols!=null&&(o=new Set([...o,...e.protocols])),e.metadata!=null){const h=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);for(const[p,m]of h)m==null?a.delete(p):a.set(p,m);a=Wc([...a.entries()],{validate:G0})}if(e.tags!=null){const h=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags),p=new Map(c);for(const[m,w]of h)w==null?p.delete(m):p.set(m,w);c=Wc([...p.entries()],{validate:Y0,map:Q0})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}let u;i?.id.publicKey!=null?u=on(i.id.publicKey):e.publicKey!=null?u=on(e.publicKey):r.publicKey!=null&&(u=on(r.publicKey));const d={addresses:await $3(r,n.addressFilter??(async()=>!0),s,n.existingPeer?.peerPB.addresses,n),protocols:[...o.values()].sort((h,p)=>h.localeCompare(p)),metadata:a,tags:c,publicKey:u,peerRecordEnvelope:l};return d.addresses.forEach(h=>{h.observed=n.existingPeer?.peerPB.addresses?.find(p=>Je(p.multiaddr,p.multiaddr))?.observed??Date.now()}),r.type!=="RSA"&&delete d.publicKey,d}function Wc(r,e){const t=new Map;for(const[n,i]of r)i!=null&&e.validate(n,i);for(const[n,i]of r.sort(([s],[o])=>s.localeCompare(o)))i!=null&&t.set(n,e.map?.(n,i)??i);return t}function G0(r,e){if(typeof r!="string")throw new q("Metadata key must be a string");if(!(e instanceof Uint8Array))throw new q("Metadata value must be a Uint8Array")}function Y0(r,e){if(typeof r!="string")throw new q("Tag name must be a string");if(e.value!=null){if(parseInt(`${e.value}`,10)!==e.value)throw new q("Tag value must be an integer");if(e.value<0||e.value>100)throw new q("Tag value must be between 0-100")}if(e.ttl!=null){if(parseInt(`${e.ttl}`,10)!==e.ttl)throw new q("Tag ttl must be an integer");if(e.ttl<0)throw new q("Tag ttl must be between greater than 0")}}function Q0(r,e){let t;e.expiry!=null&&(t=e.expiry),e.ttl!=null&&(t=BigInt(Date.now()+Number(e.ttl)));const n={value:e.value??0};return t!=null&&(n.expiry=t),n}function Nx(r){const e=r.toString().split("/")[2],t=Be.parse(e,Vn);return Qa(t)}function qh(r,e,t){const n=Nx(r);return O3(n,e,t)}function q3(r,e){return{prefix:Bx,filters:(r.filters??[]).map(t=>({key:n,value:i})=>t(qh(n,i,e))),orders:(r.orders??[]).map(t=>(n,i)=>t(qh(n.key,n.value,e),qh(i.key,i.value,e)))}}class K3{peerId;datastore;locks;addressFilter;log;maxAddressAge;maxPeerAge;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.locks=iB({name:"libp2p_peer_store_locks",metrics:e.metrics}),this.maxAddressAge=t.maxAddressAge??T3,this.maxPeerAge=t.maxPeerAge??P3}getLock(e){let t=this.locks.get(e);return t==null&&(t={refs:0,lock:k3({name:e.toString(),singleProcess:!0})},this.locks.set(e,t)),t.refs++,t}maybeRemoveLock(e,t){t.refs--,t.refs===0&&(t.lock.finalize(),this.locks.delete(e))}async getReadLock(e,t){const n=this.getLock(e);try{const i=await n.lock.readLock(t);return()=>{i(),this.maybeRemoveLock(e,n)}}catch(i){throw this.maybeRemoveLock(e,n),i}}async getWriteLock(e,t){const n=this.getLock(e);try{const i=await n.lock.writeLock(t);return()=>{i(),this.maybeRemoveLock(e,n)}}catch(i){throw this.maybeRemoveLock(e,n),i}}async has(e,t){try{return await this.load(e,t),!0}catch(n){if(n.name!=="NotFoundError")throw n}return!1}async delete(e,t){this.peerId.equals(e)||await this.datastore.delete(Hc(e),t)}async load(e,t){const n=Hc(e),i=await this.datastore.get(n,t),s=Ei.decode(i);if(this.#t(e,s))throw await this.datastore.delete(n,t),new Nn;return Ho(e,s,this.peerId.equals(e)?1/0:this.maxAddressAge)}async save(e,t,n){const i=await this.#e(e,n),s=await $h(e,t,"patch",{...n,addressFilter:this.addressFilter});return this.#r(e,s,i)}async patch(e,t,n){const i=await this.#e(e,n),s=await $h(e,t,"patch",{...n,addressFilter:this.addressFilter,existingPeer:i});return this.#r(e,s,i)}async merge(e,t,n){const i=await this.#e(e,n),s=await $h(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:i});return this.#r(e,s,i)}async*all(e){for await(const{key:t,value:n}of this.datastore.query(q3(e??{},this.maxAddressAge),e)){const i=Nx(t);if(i.equals(this.peerId))continue;const s=Ei.decode(n);if(this.#t(i,s)){await this.datastore.delete(t,e);continue}yield Ho(i,s,this.peerId.equals(i)?1/0:this.maxAddressAge)}}async#e(e,t){try{const n=Hc(e),i=await this.datastore.get(n,t),s=Ei.decode(i);if(this.#t(e,s))throw await this.datastore.delete(n,t),new Nn;return{peerPB:s,peer:Ho(e,s,this.maxAddressAge)}}catch(n){n.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",n)}}async#r(e,t,n,i){t.updated=Date.now();const s=Ei.encode(t);return await this.datastore.put(Hc(e),s,i),{peer:Ho(e,t,this.maxAddressAge),previous:n?.peer,updated:n==null||!B3(t,n.peerPB)}}#t(e,t){if(t.updated==null)return!0;if(this.peerId.equals(e))return!1;const n=t.updated<Date.now()-this.maxPeerAge,i=Date.now()-this.maxAddressAge,s=t.addresses.filter(o=>o.observed!=null&&o.observed>i);return n&&s.length===0}}class V3{store;events;peerId;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new K3(e,t)}[Symbol.toStringTag]="@libp2p/peer-store";async forEach(e,t){for await(const n of this.store.all(t))e(n)}async all(e){return lg(this.store.all(e))}async delete(e,t){const n=await this.store.getReadLock(e,t);try{await this.store.delete(e,t)}finally{n()}}async has(e,t){const n=await this.store.getReadLock(e,t);try{return await this.store.has(e,t)}finally{this.log.trace("has release read lock"),n?.()}}async get(e,t){const n=await this.store.getReadLock(e,t);try{return await this.store.load(e,t)}finally{n?.()}}async getInfo(e,t){const n=await this.get(e,t);return{id:n.id,multiaddrs:n.addresses.map(({multiaddr:i})=>i)}}async save(e,t,n){const i=await this.store.getWriteLock(e,n);try{const s=await this.store.save(e,t,n);return this.#e(e,s),s.peer}finally{i?.()}}async patch(e,t,n){const i=await this.store.getWriteLock(e,n);try{const s=await this.store.patch(e,t,n);return this.#e(e,s),s.peer}finally{i?.()}}async merge(e,t,n){const i=await this.store.getWriteLock(e,n);try{const s=await this.store.merge(e,t,n);return this.#e(e,s),s.peer}finally{i?.()}}async consumePeerRecord(e,t,n){const i=Xo(t)?t:Xo(t?.expectedPeer)?t.expectedPeer:void 0,s=Xo(t)||t===void 0?n:t,o=await Lr.openAndCertify(e,Yt.DOMAIN,s),a=Qa(o.publicKey.toCID());if(i?.equals(a)===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",i,a),!1;const c=Yt.createFromProtobuf(o.payload);let l;try{l=await this.get(a,s)}catch(u){if(u.name!=="NotFoundError")throw u}if(l?.peerRecordEnvelope!=null){const u=Lr.createFromProtobuf(l.peerRecordEnvelope),d=Yt.createFromProtobuf(u.payload);if(d.seqNumber>=c.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",d.seqNumber,c.seqNumber),!1}return await this.patch(c.peerId,{peerRecordEnvelope:e,addresses:c.multiaddrs.map(u=>({isCertified:!0,multiaddr:u}))},s),!0}#e(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))}}function z3(r,e={}){return new V3(r,e)}class Mu extends Error{static name="NotFoundError";static code="ERR_NOT_FOUND";name=Mu.name;code=Mu.code;constructor(e="Not Found"){super(e)}}function j3(r){return r[Symbol.asyncIterator]!=null}function ds(r,e){let t=0;if(j3(r))return async function*(){for await(const c of r)await e(c,t++)&&(yield c)}();const n=IE(r),{value:i,done:s}=n.next();if(s===!0)return function*(){}();const o=e(i,t++);if(typeof o.then=="function")return async function*(){await o&&(yield i);for(const c of n)await e(c,t++)&&(yield c)}();const a=e;return function*(){o===!0&&(yield i);for(const c of n)a(c,t++)&&(yield c)}()}function H3(r){return r[Symbol.asyncIterator]!=null}function J0(r,e){return H3(r)?async function*(){yield*(await lg(r)).sort(e)}():function*(){yield*lg(r).sort(e)}()}function W3(r){return r[Symbol.asyncIterator]!=null}function X0(r,e){return W3(r)?async function*(){let t=0;if(!(e<1)){for await(const n of r)if(yield n,t++,t===e)return}}():function*(){let t=0;if(!(e<1)){for(const n of r)if(yield n,t++,t===e)return}}()}class G3{put(e,t,n){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:n,value:i}of e)await this.put(n,i,t),yield n}async*getMany(e,t={}){for await(const n of e)yield{key:n,value:await this.get(n,t)}}async*deleteMany(e,t={}){for await(const n of e)await this.delete(n,t),yield n}batch(){let e=[],t=[];return{put(n,i){e.push({key:n,value:i})},delete(n){t.push(n)},commit:async n=>{await qf(this.putMany(e,n)),e=[],await qf(this.deleteMany(t,n)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let n=this._all(e,t);if(e.prefix!=null){const i=e.prefix;n=ds(n,s=>s.key.toString().startsWith(i))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((i,s)=>ds(i,s),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((i,s)=>J0(i,s),n)),e.offset!=null){let i=0;const s=e.offset;n=ds(n,()=>i++>=s)}return e.limit!=null&&(n=X0(n,e.limit)),n}queryKeys(e,t){let n=this._allKeys(e,t);if(e.prefix!=null){const i=e.prefix;n=ds(n,s=>s.toString().startsWith(i))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((i,s)=>ds(i,s),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((i,s)=>J0(i,s),n)),e.offset!=null){const i=e.offset;let s=0;n=ds(n,()=>s++>=i)}return e.limit!=null&&(n=X0(n,e.limit)),n}}class Y3 extends G3{data;constructor(){super(),this.data=new Map}put(e,t,n){return n?.signal?.throwIfAborted(),this.data.set(e.toString(),t),e}get(e,t){t?.signal?.throwIfAborted();const n=this.data.get(e.toString());if(n==null)throw new Mu;return n}has(e,t){return t?.signal?.throwIfAborted(),this.data.has(e.toString())}delete(e,t){t?.signal?.throwIfAborted(),this.data.delete(e.toString())}*_all(e,t){t?.signal?.throwIfAborted();for(const[n,i]of this.data.entries())yield{key:new rt(n),value:i},t?.signal?.throwIfAborted()}*_allKeys(e,t){t?.signal?.throwIfAborted();for(const n of this.data.keys())yield new rt(n),t?.signal?.throwIfAborted()}}class Q3 extends Map{metric;constructor(e){super();const{name:t,metrics:n}=e;this.metric=n.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function jr(r){const{name:e,metrics:t}=r;let n;return t!=null?n=new Q3({name:e,metrics:t}):n=new Map,n}const Z0=864e13,J3=448,Kh=449,X3=53,Z3=54,e6=55,t6=56;class r6{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=jr({name:"libp2p_address_manager_dns_mappings",metrics:e.metrics})}has(e){const t=this.findHost(e);for(const n of this.mappings.values())if(n.domain===t)return!0;return!1}add(e,t){t.forEach(n=>{this.log("add DNS mapping %s to %s",n,e);const i=ec(n)===!0;this.mappings.set(n,{domain:e,verified:i,expires:i?Z0-Date.now():0,lastVerified:i?Z0-Date.now():void 0})})}remove(e){const t=this.findHost(e);let n=!1;for(const[i,s]of this.mappings.entries())s.domain===t&&(this.log("removing %s to %s DNS mapping %e",i,s.domain,new Error("where")),this.mappings.delete(i),n=n||s.verified);return n}getAll(e){const t=[];for(let n=0;n<e.length;n++){const s=e[n].multiaddr.stringTuples(),o=s[0][1];if(o!=null)for(const[a,c]of this.mappings.entries()){if(o!==a)continue;this.maybeAddSNITuple(s,c.domain)&&(e.splice(n,1),n--,t.push({multiaddr:de(`/${s.map(u=>[St(u[0]).name,u[1]].join("/")).join("/")}`),verified:c.verified,type:"dns-mapping",expires:c.expires,lastVerified:c.lastVerified}))}}return t}maybeAddSNITuple(e,t){for(let n=0;n<e.length;n++)if(e[n][0]===J3&&e[n+1]?.[0]!==Kh)return e.splice(n+1,0,[Kh,t]),!0;return!1}confirm(e,t){const n=this.findHost(e);let i=!1;for(const[s,o]of this.mappings.entries())o.domain===n&&(this.log("marking %s to %s DNS mapping as verified",s,o.domain),i=o.verified,o.verified=!0,o.expires=Date.now()+t,o.lastVerified=Date.now());return i}unconfirm(e,t){const n=this.findHost(e);let i=!1;for(const[s,o]of this.mappings.entries())o.domain===n&&(this.log("removing verification of %s to %s DNS mapping",s,o.domain),i=i||o.verified,o.verified=!1,o.expires=Date.now()+t);return i}findHost(e){for(const t of e.stringTuples())if(t[0]===Kh||t[0]===X3||t[0]===Z3||t[0]===e6||t[0]===t6)return t[1]}}const Vh=4,zh=41,jh=6,n6=273;class i6{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=jr({name:"libp2p_address_manager_ip_mappings",metrics:e.metrics})}has(e){const t=e.stringTuples();for(const n of this.mappings.values())for(const i of n)if(i.externalIp===t[0][1])return!0;return!1}add(e,t,n,i=t,s="tcp"){const o=`${e}-${t}-${s}`,a=this.mappings.get(o)??[],c={internalIp:e,internalPort:t,externalIp:n,externalPort:i,externalFamily:Ni(n)?4:6,protocol:s,verified:!1,expires:0};a.push(c),this.mappings.set(o,a)}remove(e){const t=e.stringTuples(),n=t[0][1]??"",i=t[1][0]===jh?"tcp":"udp",s=parseInt(t[1][1]??"0");let o=!1;for(const[a,c]of this.mappings.entries()){for(let l=0;l<c.length;l++){const u=c[l];u.externalIp===n&&u.externalPort===s&&u.protocol===i&&(this.log("removing %s:%s to %s:%s %s IP mapping",u.externalIp,u.externalPort,n,s,i),o=o||u.verified,c.splice(l,1),l--)}c.length===0&&this.mappings.delete(a)}return o}getAll(e){const t=[];for(const{multiaddr:n}of e){const i=n.stringTuples();let s;if((i[0][0]===Vh||i[0][0]===zh)&&i[1][0]===jh?s=`${i[0][1]}-${i[1][1]}-tcp`:(i[0][0]===Vh||i[0][0]===zh)&&i[1][0]===n6&&(s=`${i[0][1]}-${i[1][1]}-udp`),s==null)continue;const o=this.mappings.get(s);if(o!=null)for(const a of o)i[0][0]=a.externalFamily===4?Vh:zh,i[0][1]=a.externalIp,i[1][1]=`${a.externalPort}`,t.push({multiaddr:de(`/${i.map(c=>[St(c[0]).name,c[1]].join("/")).join("/")}`),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return t}confirm(e,t){const i=e.stringTuples()[0][1];let s=!1;for(const o of this.mappings.values())for(const a of o)a.externalIp===i&&(this.log("marking %s to %s IP mapping as verified",a.internalIp,a.externalIp),s=a.verified,a.verified=!0,a.expires=Date.now()+t,a.lastVerified=Date.now());return s}unconfirm(e,t){const n=e.stringTuples(),i=n[0][1]??"",s=n[1][0]===jh?"tcp":"udp",o=parseInt(n[1][1]??"0");let a=!1;for(const c of this.mappings.values())for(let l=0;l<c.length;l++){const u=c[l];u.externalIp===i&&u.externalPort===o&&u.protocol===s&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",u.externalIp,u.externalPort,i,o,s),a=a||u.verified,u.verified=!1,u.expires=Date.now()+t)}return a}}function s6(r){try{for(const{code:e,value:t}of r.getComponents())if(e!==mo&&t!=null){if(e===Us)return t.startsWith("169.254.");if(e===Mr)return t.toLowerCase().startsWith("fe80")}}catch{}return!1}const o6={maxObservedAddresses:10};class a6{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=jr({name:"libp2p_address_manager_observed_addresses",metrics:e.metrics}),this.maxObservedAddresses=t.maxObservedAddresses??o6.maxObservedAddresses}has(e){return this.addresses.has(e.toString())}removePrefixed(e){for(const t of this.addresses.keys())t.toString().startsWith(e)&&this.addresses.delete(t)}add(e){this.addresses.size!==this.maxObservedAddresses&&(Di(e)||s6(e)||(this.log("adding observed address %a",e),this.addresses.set(e.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([e,t])=>({multiaddr:de(e),verified:t.verified,type:"observed",expires:t.expires,lastVerified:t.lastVerified}))}remove(e){const t=this.addresses.get(e.toString())?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(e.toString()),t}confirm(e,t){const n=e.toString(),i=this.addresses.get(n)??{verified:!1,expires:Date.now()+t,lastVerified:Date.now()},s=i.verified;return i.verified=!0,i.expires=Date.now()+t,i.lastVerified=Date.now(),this.log("marking observed address %a as verified",n),this.addresses.set(n,i),s}}const c6=[Us,Mr,Xg,Zg,td,em];function ev(r){try{for(const{code:e}of r.getComponents())if(e!==mo)return c6.includes(e)}catch{}return!1}const l6={maxObservedAddresses:10};class u6{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=jr({name:"libp2p_address_manager_transport_addresses",metrics:e.metrics}),this.maxObservedAddresses=t.maxObservedAddresses??l6.maxObservedAddresses}get(e,t){if(Di(e))return{multiaddr:e,verified:!0,type:"transport",expires:Date.now()+t,lastVerified:Date.now()};const n=this.toKey(e);let i=this.addresses.get(n);return i==null&&(i={verified:!ev(e),expires:0},this.addresses.set(n,i)),{multiaddr:e,verified:i.verified,type:"transport",expires:i.expires,lastVerified:i.lastVerified}}has(e){const t=this.toKey(e);return this.addresses.has(t)}remove(e){const t=this.toKey(e),n=this.addresses.get(t)?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(t),n}confirm(e,t){const n=this.toKey(e),i=this.addresses.get(n)??{verified:!1,expires:0,lastVerified:0},s=i.verified;return i.verified=!0,i.expires=Date.now()+t,i.lastVerified=Date.now(),this.addresses.set(n,i),s}unconfirm(e,t){const n=this.toKey(e),i=this.addresses.get(n)??{verified:!1,expires:0},s=i.verified;return i.verified=!1,i.expires=Date.now()+t,this.addresses.set(n,i),s}toKey(e){if(ev(e)){const t=e.toOptions();return`${t.host}-${t.port}-${t.transport}`}return e.toString()}}const tv=6e4,rv={addressVerificationTTL:tv*10,addressVerificationRetry:tv*5},d6=r=>r;function Hh(r,e){const t=r.getPeerId();return t!=null&&xr(t).equals(e)&&(r=r.decapsulate(de(`/p2p/${e.toString()}`))),r}class h6{log;components;listen;announce;appendAnnounce;announceFilter;observed;dnsMappings;ipMappings;transportAddresses;observedAddressFilter;addressVerificationTTL;addressVerificationRetry;constructor(e,t={}){const{listen:n=[],announce:i=[],appendAnnounce:s=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=n.map(o=>o.toString()),this.announce=new Set(i.map(o=>o.toString())),this.appendAnnounce=new Set(s.map(o=>o.toString())),this.observed=new a6(e,t),this.dnsMappings=new r6(e,t),this.ipMappings=new i6(e,t),this.transportAddresses=new u6(e,t),this.announceFilter=t.announceFilter??d6,this.observedAddressFilter=Vs(1024),this.addressVerificationTTL=t.addressVerificationTTL??rv.addressVerificationTTL,this.addressVerificationRetry=t.addressVerificationRetry??rv.addressVerificationRetry,this._updatePeerStoreAddresses=xa(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),e.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}[Symbol.toStringTag]="@libp2p/address-manager";_updatePeerStoreAddresses(){const e=this.getAddresses().map(t=>t.getPeerId()===this.components.peerId.toString()?t.decapsulate(`/p2p/${this.components.peerId.toString()}`):t);this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch(t=>{this.log.error("error updating addresses",t)})}getListenAddrs(){return Array.from(this.listen).map(e=>de(e))}getAnnounceAddrs(){return Array.from(this.announce).map(e=>de(e))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(e=>de(e))}getObservedAddrs(){return this.observed.getAll().map(e=>e.multiaddr)}addObservedAddr(e){const t=e.stringTuples(),n=`${t[0][1]}:${t[1][1]}`;this.observedAddressFilter.has(n)||(this.observedAddressFilter.add(n),e=Hh(e,this.components.peerId),!this.ipMappings.has(e)&&(this.dnsMappings.has(e)||this.observed.add(e)))}confirmObservedAddr(e,t){e=Hh(e,this.components.peerId);let n=!0;(t?.type==="transport"||this.transportAddresses.has(e))&&!this.transportAddresses.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="dns-mapping"||this.dnsMappings.has(e))&&!this.dnsMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="ip-mapping"||this.ipMappings.has(e))&&!this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="observed"||this.observed.has(e))&&(this.maybeUpgradeToIPMapping(e)?(this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL),n=!1):!this.observed.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1)),n||this._updatePeerStoreAddresses()}removeObservedAddr(e,t){e=Hh(e,this.components.peerId),this.observed.has(e)&&this.observed.remove(e),this.transportAddresses.has(e)&&this.transportAddresses.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.dnsMappings.has(e)&&this.dnsMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.ipMappings.has(e)&&this.ipMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry)}getAddresses(){const e=new Set,t=this.getAddressesWithMetadata().filter(n=>{if(!n.verified)return!1;const i=n.multiaddr.toString();return e.has(i)?!1:(e.add(i),!0)}).map(n=>n.multiaddr);return this.announceFilter(t.map(n=>{const i=de(n);return i.getComponents().pop()?.value===this.components.peerId.toString()?i:i.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const e=this.getAnnounceAddrs();if(e.length>0)return this.components.transportManager.getListeners().forEach(i=>{i.updateAnnounceAddrs(e)}),e.map(i=>({multiaddr:i,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let t=[];t=t.concat(this.components.transportManager.getAddrs().map(i=>this.transportAddresses.get(i,this.addressVerificationTTL)));const n=this.getAppendAnnounceAddrs();return n.length>0&&(this.components.transportManager.getListeners().forEach(i=>{i.updateAnnounceAddrs(n)}),t=t.concat(n.map(i=>({multiaddr:i,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),t=t.concat(this.observed.getAll()),t=t.concat(this.ipMappings.getAll(t)),t=t.concat(this.dnsMappings.getAll(t)),t}addDNSMapping(e,t){this.dnsMappings.add(e,t)}removeDNSMapping(e){this.dnsMappings.remove(de(`/dns/${e}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(e,t,n,i=t,s="tcp"){this.ipMappings.add(e,t,n,i,s),this.observed.removePrefixed(`/ip${Ni(n)?4:6}/${n}/${s}/${i}`)}removePublicAddressMapping(e,t,n,i=t,s="tcp"){this.ipMappings.remove(de(`/ip${Ni(n)?4:6}/${n}/${s}/${i}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(e){if(this.ipMappings.has(e))return!1;const t=e.toOptions();if(t.family===6||t.host==="127.0.0.1"||ec(t.host)===!0)return!1;const n=this.components.transportManager.getListeners(),i=[s=>Aa.exactMatch(s)||Yl.exactMatch(s),s=>Gl.exactMatch(s),s=>BO.exactMatch(s)];for(const s of i){if(!s(e))continue;const o=n.filter(l=>l.getAddrs().filter(u=>u.toOptions().family===4&&s(u)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(l=>l.toOptions().host!=="127.0.0.1").pop();if(a==null)continue;const c=a.toOptions();return this.observed.remove(e),this.ipMappings.add(c.host,c.port,t.host,t.port,t.transport),!0}return!1}}var nv;(function(r){r.NOT_STARTED_YET="The libp2p node is not started yet",r.NOT_FOUND="Not found"})(nv||(nv={}));class f6 extends Error{constructor(e="Missing service"){super(e),this.name="MissingServiceError"}}class p6 extends Error{constructor(e="Unmet service dependencies"){super(e),this.name="UnmetServiceDependenciesError"}}class Wh extends Error{constructor(e="No content routers available"){super(e),this.name="NoContentRoutersError"}}class iv extends Error{constructor(e="No peer routers available"){super(e),this.name="NoPeerRoutersError"}}class g6 extends Error{constructor(e="Should not try to find self"){super(e),this.name="QueriedForSelfError"}}class m6 extends Error{constructor(e="Unhandled protocol error"){super(e),this.name="UnhandledProtocolError"}}class y6 extends Error{constructor(e="Duplicate protocol handler error"){super(e),this.name="DuplicateProtocolHandlerError"}}class sv extends Error{constructor(e="Dial denied error"){super(e),this.name="DialDeniedError"}}class w6 extends Error{constructor(e="No transport was configured to listen on this address"){super(e),this.name="UnsupportedListenAddressError"}}class b6 extends Error{constructor(e="Configured listen addresses could not be listened on"){super(e),this.name="UnsupportedListenAddressesError"}}class v6 extends Error{constructor(e="No valid addresses"){super(e),this.name="NoValidAddressesError"}}class S6 extends Error{constructor(e="Connection intercepted"){super(e),this.name="ConnectionInterceptedError"}}class E6 extends Error{constructor(e="Connection denied"){super(e),this.name="ConnectionDeniedError"}}class Gc extends Error{constructor(e="Stream is not multiplexed"){super(e),this.name="MuxerUnavailableError"}}class Yc extends Error{constructor(e="Encryption failed"){super(e),this.name="EncryptionFailedError"}}class A6 extends Error{constructor(e="Transport unavailable"){super(e),this.name="TransportUnavailableError"}}class x6{components={};_started=!1;constructor(e={}){this.components={};for(const[t,n]of Object.entries(e))this.components[t]=n;this.components.logger==null&&(this.components.logger=mx())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter(t=>kg(t)).map(async t=>{await t[e]?.()}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const _6=["metrics","connectionProtector","dns"],C6=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function I6(r={}){const e=new x6(r);return new Proxy(e,{get(n,i,s){if(typeof i=="string"&&!C6.includes(i)){const o=e.components[i];if(o==null&&!_6.includes(i))throw new f6(`${i} not set`);return o}return Reflect.get(n,i,s)},set(n,i,s){return typeof i=="string"?e.components[i]=s:Reflect.set(n,i,s),!0}})}function k6(r){const e={};for(const t of Object.values(r.components))for(const n of T6(t))e[n]=!0;for(const t of Object.values(r.components))for(const n of P6(t))if(e[n]!==!0)throw new p6(`Service "${R6(t)}" required capability "${n}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function T6(r){return Array.isArray(r?.[$t])?r[$t]:[]}function P6(r){return Array.isArray(r?.[Os])?r[Os]:[]}function R6(r){return r?.[Symbol.toStringTag]??r?.toString()??"unknown"}const O6=4,B6=41;function N6(r={}){return{denyDialPeer:async()=>!1,denyDialMultiaddr:async e=>{if(Aa.matches(e))return!1;const t=e.stringTuples();return t[0][0]===O6||t[0][0]===B6?!!ec(`${t[0][1]}`):!1},denyInboundConnection:async()=>!1,denyOutboundConnection:async()=>!1,denyInboundEncryptedConnection:async()=>!1,denyOutboundEncryptedConnection:async()=>!1,denyInboundUpgradedConnection:async()=>!1,denyOutboundUpgradedConnection:async()=>!1,filterMultiaddrForPeer:async()=>!0,...r}}const ov=()=>{const r=new Error("Delay aborted");return r.name="AbortError",r},D6=new WeakMap;function L6({clearTimeout:r,setTimeout:e}={}){return(t,{value:n,signal:i}={})=>{if(i?.aborted)return Promise.reject(ov());let s,o,a;const c=r??clearTimeout,l=()=>{c(s),a(ov())},u=()=>{i&&i.removeEventListener("abort",l)},d=new Promise((h,p)=>{o=()=>{u(),h(n)},a=p,s=(e??setTimeout)(o,t)});return i&&i.addEventListener("abort",l,{once:!0}),D6.set(d,()=>{c(s),s=null,o()}),d}}const Dx=L6();class M6{memoryStorage;points;duration;blockDuration;execEvenly;execEvenlyMinDelayMs;keyPrefix;constructor(e={}){this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.execEvenly=e.execEvenly??!1,this.execEvenlyMinDelayMs=e.execEvenlyMinDelayMs??this.duration*1e3/this.points,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new F6}async consume(e,t=1,n={}){const i=this.getKey(e),s=this._getKeySecDuration(n);let o=this.memoryStorage.incrby(i,t,s);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+t&&(o=this.memoryStorage.set(i,o.consumedPoints,this.blockDuration)),new oB("Rate limit exceeded",o);if(this.execEvenly&&o.msBeforeNext>0&&!o.isFirstInDuration){let a=Math.ceil(o.msBeforeNext/(o.remainingPoints+2));a<this.execEvenlyMinDelayMs&&(a=o.consumedPoints*this.execEvenlyMinDelayMs),await Dx(a)}return o}penalty(e,t=1,n={}){const i=this.getKey(e),s=this._getKeySecDuration(n),o=this.memoryStorage.incrby(i,t,s);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(e,t=1,n={}){const i=this.getKey(e),s=this._getKeySecDuration(n),o=this.memoryStorage.incrby(i,-t,s);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(e,t){const n=t*1e3,i=this.points+1;return this.memoryStorage.set(this.getKey(e),i,t),{remainingPoints:0,msBeforeNext:n===0?-1:n,consumedPoints:i,isFirstInDuration:!1}}set(e,t,n=0){const i=(n>=0?n:this.duration)*1e3;return this.memoryStorage.set(this.getKey(e),t,n),{remainingPoints:0,msBeforeNext:i===0?-1:i,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return t!=null&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return e?.customDuration!=null&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class F6{storage;constructor(){this.storage=new Map}incrby(e,t,n){const i=this.storage.get(e);if(i!=null){const s=i.expiresAt!=null?i.expiresAt.getTime()-new Date().getTime():-1;return i.expiresAt==null||s>0?(i.value+=t,{remainingPoints:0,msBeforeNext:s,consumedPoints:i.value,isFirstInDuration:!1}):this.set(e,t,n)}return this.set(e,t,n)}set(e,t,n){const i=n*1e3,s=this.storage.get(e);s!=null&&clearTimeout(s.timeoutId);const o={value:t,expiresAt:i>0?new Date(Date.now()+i):void 0};return this.storage.set(e,o),i>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(e)},i),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:i===0?-1:i,consumedPoints:o.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(t!=null)return{remainingPoints:0,msBeforeNext:t.expiresAt!=null?t.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}delete(e){const t=this.storage.get(e);return t!=null?(t.timeoutId!=null&&clearTimeout(t.timeoutId),this.storage.delete(e),!0):!1}}function Lx(r){if(Xo(r))return{peerId:r,multiaddrs:[]};let e=Array.isArray(r)?r:[r],t;if(e.length>0){const n=e[0].getPeerId();t=n==null?void 0:xr(n),e.forEach(i=>{if(!rd(i))throw new _g("Invalid multiaddr");const s=i.getPeerId();if(s==null){if(t!=null)throw new q("Multiaddrs must all have the same peer id or have no peer id")}else{const o=xr(s);if(t?.equals(o)!==!0)throw new q("Multiaddrs must all have the same peer id or have no peer id")}})}return e=e.filter(n=>!kO.exactMatch(n)),{peerId:t,multiaddrs:e}}const U6=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function $6(r,e){const t=r?.streams?.map(i=>i.protocol)??[],n=e?.closableProtocols??U6;if(!(t.filter(i=>i!=null&&!n.includes(i)).length>0))try{await r?.close(e)}catch(i){r?.abort(i)}}async function q6(r,e){let t=!1;for(const i of tm.keys())if(t=r.protoNames().includes(i),t)break;if(!t)return[r];const n=await r.resolve(e);return e.log("resolved %s to",r,n.map(i=>i.toString())),n}function ug(r){try{let e;if(typeof r=="string"?e=de(r):e=r,!e.protoNames().includes("ipcidr")){const n=e.protoNames().includes("ip6")?"/ipcidr/128":"/ipcidr/32";e=e.encapsulate(n)}return wO(e)}catch{throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${r}`)}}class K6{connectionManager;peerStore;allow;events;log;constructor(e,t={}){this.allow=(t.allow??[]).map(n=>ug(n)),this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(e=>{this.log.error("error while pruning connections %e",e)})}async _maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length,n=this.connectionManager.getMaxConnections();if(this.log("checking max connections limit %d/%d",t,n),t<=n)return;const i=new wo;for(const c of e){const l=c.remotePeer;if(!i.has(l)){i.set(l,0);try{const u=await this.peerStore.get(l);i.set(l,[...u.tags.values()].reduce((d,h)=>d+h.value,0))}catch(u){u.name!=="NotFoundError"&&this.log.error("error loading peer tags",u)}}}const s=this.sortConnections(e,i),o=Math.max(t-n,0),a=[];for(const c of s)if(this.log("too many connections open - closing a connection to %p",c.remotePeer),this.allow.some(u=>u.contains(c.remoteAddr.nodeAddress().address))||a.push(c),a.length===o)break;await Promise.all(a.map(async c=>{await $6(c,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:a})}sortConnections(e,t){return e.sort((n,i)=>{const s=n.timeline.open,o=i.timeline.open;return s<o?1:s>o?-1:0}).sort((n,i)=>n.direction==="outbound"&&i.direction==="inbound"?1:n.direction==="inbound"&&i.direction==="outbound"?-1:0).sort((n,i)=>n.streams.length>i.streams.length?1:n.streams.length<i.streams.length?-1:0).sort((n,i)=>{const s=t.get(n.remotePeer)??0,o=t.get(i.remotePeer)??0;return s>o?1:s<o?-1:0})}}const Mx=1e4,V6=1e4,av=1e4,Fx=25,z6=5,j6=10,H6=5,W6="last-dial-failure",G6="last-dial-success",Ux=500,Y6=100,$x=50;class Q6 extends r1{constructor(e={}){super({...e,sort:(t,n)=>t.options.priority>n.options.priority?-1:t.options.priority<n.options.priority?1:0})}}function J6(r){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(r)||/^::1$/.test(r)}function cv(r){if(!a1(r))return!1;const{address:e}=r.nodeAddress();return J6(e)}function X6(r,e){const t=Gl.exactMatch(r.multiaddr),n=Gl.exactMatch(e.multiaddr);if(t&&!n)return-1;if(!t&&n)return 1;const i=Yl.exactMatch(r.multiaddr),s=Yl.exactMatch(e.multiaddr);if(i&&!s)return-1;if(!i&&s)return 1;const o=Aa.exactMatch(r.multiaddr),a=Aa.exactMatch(e.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=Jl.exactMatch(r.multiaddr),l=Jl.exactMatch(e.multiaddr);if(c&&!l)return-1;if(!c&&l)return 1;const u=$f.exactMatch(r.multiaddr),d=$f.exactMatch(e.multiaddr);if(u&&!d)return-1;if(!u&&d)return 1;const h=Dw.exactMatch(r.multiaddr),p=Dw.exactMatch(e.multiaddr);return h&&!p?-1:!h&&p?1:0}function Z6(r,e){const t=cv(r.multiaddr),n=cv(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function e8(r,e){const t=Di(r.multiaddr),n=Di(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function t8(r,e){return r.isCertified&&!e.isCertified?-1:!r.isCertified&&e.isCertified?1:0}function r8(r,e){const t=Yn.exactMatch(r.multiaddr),n=Yn.exactMatch(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function n8(r){return r.sort(X6).sort(t8).sort(r8).sort(e8).sort(Z6)}const Qc={maxParallelDials:$x,maxDialQueueLength:Ux,maxPeerAddrsToDial:Fx,dialTimeout:Mx};class i8{queue;components;addressSorter;maxPeerAddrsToDial;maxDialQueueLength;dialTimeout;shutDownController;connections;log;constructor(e,t={}){this.addressSorter=t.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??Qc.maxPeerAddrsToDial,this.maxDialQueueLength=t.maxDialQueueLength??Qc.maxDialQueueLength,this.dialTimeout=t.dialTimeout??Qc.dialTimeout,this.connections=t.connections??new wo,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.shutDownController=new AbortController,this.shutDownController.signal;for(const[n,i]of Object.entries(t.resolvers??{}))tm.set(n,i);this.queue=new Q6({concurrency:t.maxParallelDials??Qc.maxParallelDials,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("error",n=>{n.detail?.name!==Ri.name&&this.log.error("error in dial queue - %e",n.detail)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){const{peerId:n,multiaddrs:i}=Lx(e),s=Array.from(this.connections.values()).flat().find(a=>t.force===!0?!1:a.remotePeer.equals(n)?!0:i.find(c=>c.equals(a.remoteAddr)));if(s?.status==="open")return this.log("already connected to %a",s.remoteAddr),t.onProgress?.(new ke("dial-queue:already-connected")),s;const o=this.queue.queue.find(a=>{if(n?.equals(a.options.peerId)===!0)return!0;const c=a.options.multiaddrs;if(c==null)return!1;for(const l of i)if(c.has(l.toString()))return!0;return!1});if(o!=null){this.log("joining existing dial target for %p",n);for(const a of i)o.options.multiaddrs.add(a.toString());return t.onProgress?.(new ke("dial-queue:already-in-dial-queue")),o.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new Zo("Dial queue is full");return this.log("creating dial target for %p",n,i.map(a=>a.toString())),t.onProgress?.(new ke("dial-queue:add-to-dial-queue")),this.queue.add(async a=>{a.onProgress?.(new ke("dial-queue:start-dial"));const c=Vr([this.shutDownController.signal,a.signal]);try{return await this.dialPeer(a,c)}finally{c.clear()}},{peerId:n,priority:t.priority??qx,multiaddrs:new Set(i.map(a=>a.toString())),signal:t.signal??AbortSignal.timeout(this.dialTimeout),onProgress:t.onProgress})}async dialPeer(e,t){const n=e.peerId,i=e.multiaddrs,s=new Set;let o=e.multiaddrs.size===0,a=0,c=0;const l=[];for(this.log("starting dial to %p",n);o||i.size>0;){c++,o=!1;const u=[],d=new Set(e.multiaddrs);i.clear(),this.log("calculating addrs to dial %p from %s",n,[...d]);const h=await this.calculateMultiaddrs(n,d,{...e,signal:t});for(const p of h){if(s.has(p.multiaddr.toString())){this.log.trace("skipping previously failed multiaddr %a while dialing %p",p.multiaddr,n);continue}u.push(p)}this.log("%s dial to %p with %s",c===1?"starting":"continuing",n,u.map(p=>p.multiaddr.toString())),e?.onProgress?.(new ke("dial-queue:calculated-addresses",u));for(const p of u){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,e.peerId),new Zo("Peer had more than maxPeerAddrsToDial");a++;try{const m=await this.components.transportManager.dial(p.multiaddr,{...e,signal:t});this.log("dial to %a succeeded",p.multiaddr);try{await this.components.peerStore.merge(m.remotePeer,{multiaddrs:[m.remoteAddr],metadata:{[G6]:Z(Date.now().toString())}})}catch(w){this.log.error("could not update last dial failure key for %p",n,w)}return m}catch(m){if(this.log.error("dial failed to %a",p.multiaddr,m),s.add(p.multiaddr.toString()),n!=null)try{await this.components.peerStore.merge(n,{metadata:{[W6]:Z(Date.now().toString())}})}catch(w){this.log.error("could not update last dial failure key for %p",n,w)}if(t.aborted)throw new Ig(m.message);l.push(m)}}}throw l.length===1?l[0]:new AggregateError(l,"All multiaddr dials failed")}async calculateMultiaddrs(e,t=new Set,n={}){const i=[...t].map(d=>({multiaddr:de(d),isCertified:!1}));if(e!=null){if(this.components.peerId.equals(e))throw new Zo("Tried to dial self");if(await this.components.connectionGater.denyDialPeer?.(e)===!0)throw new sv("The dial request is blocked by gater.allowDialPeer");if(i.length===0){this.log("loading multiaddrs for %p",e);try{const d=await this.components.peerStore.get(e);i.push(...d.addresses),this.log("loaded multiaddrs for %p",e,i.map(({multiaddr:h})=>h.toString()))}catch(d){if(d.name!=="NotFoundError")throw d}}if(i.length===0){this.log("looking up multiaddrs for %p in the peer routing",e);try{const d=await this.components.peerRouting.findPeer(e,n);this.log("found multiaddrs for %p in the peer routing",e,i.map(({multiaddr:h})=>h.toString())),i.push(...d.multiaddrs.map(h=>({multiaddr:h,isCertified:!1})))}catch(d){d.name==="NoPeerRoutersError"?this.log("no peer routers configured",e):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",e,d)}}}let s=(await Promise.all(i.map(async d=>{const h=await q6(d.multiaddr,{dns:this.components.dns,...n,log:this.log});return h.length===1&&h[0].equals(d.multiaddr)?d:h.map(p=>({multiaddr:p,isCertified:!1}))}))).flat();if(e!=null){const d=`/p2p/${e.toString()}`;s=s.map(h=>h.multiaddr.getComponents().pop()?.name!=="p2p"?{multiaddr:h.multiaddr.encapsulate(d),isCertified:h.isCertified}:h)}const o=s.filter(d=>{if(this.components.transportManager.dialTransportForMultiaddr(d.multiaddr)==null)return!1;const h=d.multiaddr.getPeerId();return e!=null&&h!=null?e.equals(h):!0}),a=new Map;for(const d of o){const h=d.multiaddr.toString(),p=a.get(h);if(p!=null){p.isCertified=p.isCertified||d.isCertified||!1;continue}a.set(h,d)}const c=[...a.values()];if(c.length===0)throw new v6("The dial request has no valid addresses");const l=[];for(const d of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(d.multiaddr)||l.push(d);const u=this.addressSorter==null?n8(l):l.sort(this.addressSorter);if(u.length===0)throw new sv("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",e??"unknown peer",s.map(({multiaddr:d})=>d.toString())),this.log.trace("addresses for %p after filtering",e??"unknown peer",u.map(({multiaddr:d})=>d.toString())),u}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const n=await this.calculateMultiaddrs(void 0,new Set(e.map(i=>i.toString())),t);return t.runOnLimitedConnection===!1?n.find(i=>!Yn.matches(i.multiaddr))!=null:!0}catch(n){this.log.trace("error calculating if multiaddr(s) were dialable",n)}return!1}}var Gh={},Yh,lv;function s8(){if(lv)return Yh;lv=1;function r(e,t){typeof t=="boolean"&&(t={forever:t}),this._originalTimeouts=JSON.parse(JSON.stringify(e)),this._timeouts=e,this._options=t||{},this._maxRetryTime=t&&t.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}return Yh=r,r.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},r.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},r.prototype.retry=function(e){if(this._timeout&&clearTimeout(this._timeout),!e)return!1;var t=new Date().getTime();if(e&&t-this._operationStart>=this._maxRetryTime)return this._errors.push(e),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(e);var n=this._timeouts.shift();if(n===void 0)if(this._cachedTimeouts)this._errors.splice(0,this._errors.length-1),n=this._cachedTimeouts.slice(-1);else return!1;var i=this;return this._timer=setTimeout(function(){i._attempts++,i._operationTimeoutCb&&(i._timeout=setTimeout(function(){i._operationTimeoutCb(i._attempts)},i._operationTimeout),i._options.unref&&i._timeout.unref()),i._fn(i._attempts)},n),this._options.unref&&this._timer.unref(),!0},r.prototype.attempt=function(e,t){this._fn=e,t&&(t.timeout&&(this._operationTimeout=t.timeout),t.cb&&(this._operationTimeoutCb=t.cb));var n=this;this._operationTimeoutCb&&(this._timeout=setTimeout(function(){n._operationTimeoutCb()},n._operationTimeout)),this._operationStart=new Date().getTime(),this._fn(this._attempts)},r.prototype.try=function(e){console.log("Using RetryOperation.try() is deprecated"),this.attempt(e)},r.prototype.start=function(e){console.log("Using RetryOperation.start() is deprecated"),this.attempt(e)},r.prototype.start=r.prototype.try,r.prototype.errors=function(){return this._errors},r.prototype.attempts=function(){return this._attempts},r.prototype.mainError=function(){if(this._errors.length===0)return null;for(var e={},t=null,n=0,i=0;i<this._errors.length;i++){var s=this._errors[i],o=s.message,a=(e[o]||0)+1;e[o]=a,a>=n&&(t=s,n=a)}return t},Yh}var uv;function o8(){return uv||(uv=1,function(r){var e=s8();r.operation=function(t){var n=r.timeouts(t);return new e(n,{forever:t&&(t.forever||t.retries===1/0),unref:t&&t.unref,maxRetryTime:t&&t.maxRetryTime})},r.timeouts=function(t){if(t instanceof Array)return[].concat(t);var n={retries:10,factor:2,minTimeout:1*1e3,maxTimeout:1/0,randomize:!1};for(var i in t)n[i]=t[i];if(n.minTimeout>n.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var s=[],o=0;o<n.retries;o++)s.push(this.createTimeout(o,n));return t&&t.forever&&!s.length&&s.push(this.createTimeout(o,n)),s.sort(function(a,c){return a-c}),s},r.createTimeout=function(t,n){var i=n.randomize?Math.random()+1:1,s=Math.round(i*Math.max(n.minTimeout,1)*Math.pow(n.factor,t));return s=Math.min(s,n.maxTimeout),s},r.wrap=function(t,n,i){if(n instanceof Array&&(i=n,n=null),!i){i=[];for(var s in t)typeof t[s]=="function"&&i.push(s)}for(var o=0;o<i.length;o++){var a=i[o],c=t[a];t[a]=function(u){var d=r.operation(n),h=Array.prototype.slice.call(arguments,1),p=h.pop();h.push(function(m){d.retry(m)||(m&&(arguments[0]=d.mainError()),p.apply(this,arguments))}),d.attempt(function(){u.apply(t,h)})}.bind(t,c),t[a].options=n}}}(Gh)),Gh}var Qh,dv;function a8(){return dv||(dv=1,Qh=o8()),Qh}var c8=a8();const l8=bo(c8),u8=Object.prototype.toString,d8=r=>u8.call(r)==="[object Error]",h8=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Load failed","Network request failed","fetch failed","terminated"]);function f8(r){return r&&d8(r)&&r.name==="TypeError"&&typeof r.message=="string"?r.message==="Load failed"?r.stack===void 0:h8.has(r.message):!1}class p8 extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,{message:e}=e):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}const hv=(r,e,t)=>{const n=t.retries-(e-1);return r.attemptNumber=e,r.retriesLeft=n,r};async function g8(r,e){return new Promise((t,n)=>{e={...e},e.onFailedAttempt??=()=>{},e.shouldRetry??=()=>!0,e.retries??=10;const i=l8.operation(e),s=()=>{i.stop(),n(e.signal?.reason)};e.signal&&!e.signal.aborted&&e.signal.addEventListener("abort",s,{once:!0});const o=()=>{e.signal?.removeEventListener("abort",s),i.stop()};i.attempt(async a=>{try{const c=await r(a);o(),t(c)}catch(c){try{if(!(c instanceof Error))throw new TypeError(`Non-error was thrown: "${c}". You should only throw errors.`);if(c instanceof p8)throw c.originalError;if(c instanceof TypeError&&!f8(c))throw c;if(hv(c,a,e),await e.shouldRetry(c)||(i.stop(),n(c)),await e.onFailedAttempt(c),!i.retry(c))throw i.mainError()}catch(l){hv(l,a,e),o(),n(l)}}})})}class m8{log;queue;started;peerStore;retries;retryInterval;backoffFactor;connectionManager;events;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.queue=new ad({concurrency:t.maxParallelReconnects??H6,metricName:"libp2p_reconnect_queue",metrics:e.metrics}),this.started=!1,this.retries=t.retries??5,this.backoffFactor=t.backoffFactor,this.retryInterval=t.retryInterval,this.events=e.events,e.events.addEventListener("peer:disconnect",n=>{this.maybeReconnect(n.detail).catch(i=>{this.log.error("failed to maybe reconnect to %p - %e",n.detail,i)})})}async maybeReconnect(e){if(!this.started)return;const t=await this.peerStore.get(e);fv(t)&&(this.queue.has(e)||this.queue.add(async n=>{await g8(async i=>{if(this.started)try{await this.connectionManager.openConnection(e,{signal:n?.signal})}catch(s){throw this.log("reconnecting to %p attempt %d of %d failed - %e",e,i,this.retries,s),s}},{signal:n?.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:e}).catch(async n=>{this.log.error("failed to reconnect to %p - %e",e,n);const i={};[...t.tags.keys()].forEach(s=>{s.startsWith(xg)&&(i[s]=void 0)}),await this.peerStore.merge(e,{tags:i}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:e})}).catch(async n=>{this.log.error("failed to remove keep-alive tag from %p - %e",e,n)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>fv(t)]});await Promise.all(e.map(async t=>{await this.connectionManager.openConnection(t.id).catch(n=>{this.log.error(n)})}))}).catch(e=>{this.log.error(e)})}stop(){this.started=!1,this.queue.abort()}}function fv(r){for(const e of r.tags.keys())if(e.startsWith(xg))return!0;return!1}const qx=50,Jh={maxConnections:Y6,inboundConnectionThreshold:z6,maxIncomingPendingConnections:j6};class y8{started;connections;allow;deny;maxIncomingPendingConnections;incomingPendingConnections;outboundPendingConnections;maxConnections;dialQueue;reconnectQueue;connectionPruner;inboundConnectionRateLimiter;peerStore;metrics;events;log;peerId;constructor(e,t={}){if(this.maxConnections=t.maxConnections??Jh.maxConnections,this.maxConnections<1)throw new q("Connection Manager maxConnections must be greater than 0");this.connections=new wo,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(t.allow??[]).map(n=>ug(n)),this.deny=(t.deny??[]).map(n=>ug(n)),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??Jh.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new M6({points:t.inboundConnectionThreshold??Jh.inboundConnectionThreshold,duration:1}),this.connectionPruner=new K6({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{allow:t.allow?.map(n=>de(n))}),this.dialQueue=new i8(e,{addressSorter:t.addressSorter,maxParallelDials:t.maxParallelDials??$x,maxDialQueueLength:t.maxDialQueueLength??Ux,maxPeerAddrsToDial:t.maxPeerAddrsToDial??Fx,dialTimeout:t.dialTimeout??Mx,resolvers:t.resolvers??{dnsaddr:px},connections:this.connections}),this.reconnectQueue=new m8({events:e.events,peerStore:e.peerStore,logger:e.logger,connectionManager:this},{retries:t.reconnectRetries,retryInterval:t.reconnectRetryInterval,backoffFactor:t.reconnectBackoffFactor,maxParallelReconnects:t.maxParallelReconnects})}[Symbol.toStringTag]="@libp2p/connection-manager";async start(){this.metrics?.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const e={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const t of this.connections.values())for(const n of t)e[n.direction]++;return e}}),this.metrics?.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const e={};for(const t of this.connections.values())for(const n of t)for(const i of n.streams){const s=`${i.direction} ${i.protocol??"unnegotiated"}`;e[s]=(e[s]??0)+1}return e}}),this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const e={};for(const n of this.connections.values())for(const i of n){const s={};for(const o of i.streams){const a=`${o.direction} ${o.protocol??"unnegotiated"}`;s[a]=(s[a]??0)+1}for(const[o,a]of Object.entries(s))e[o]=e[o]??[],e[o].push(a)}const t={};for(let[n,i]of Object.entries(e)){i=i.sort((o,a)=>o-a);const s=Math.floor(i.length*.9);t[n]=i[s]}return t}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await Gv(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await Yv(this.reconnectQueue,this.dialQueue,this.connectionPruner);const e=[];for(const t of this.connections.values())for(const n of t)e.push((async()=>{try{await n.close()}catch(i){this.log.error(i)}})());this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}setMaxConnections(e){if(this.maxConnections<1)throw new q("Connection Manager maxConnections must be greater than 0");let t=!1;e<this.maxConnections&&(t=!0),this.maxConnections=e,t&&this.connectionPruner.maybePruneConnections()}onConnect(e){this._onConnect(e).catch(t=>{this.log.error(t)})}async _onConnect(e){const{detail:t}=e;if(!this.started){await t.close();return}if(t.status!=="open")return;const n=t.remotePeer,i=!this.connections.has(n),s=this.connections.get(n)??[];s.push(t),this.connections.set(n,s),n.publicKey!=null&&n.type==="RSA"&&await this.peerStore.patch(n,{publicKey:n.publicKey}),i&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e,n=t.remotePeer,s=(this.connections.get(n)??[]).filter(o=>o.id!==t.id);this.connections.set(n,s),s.length===0&&(this.log("onDisconnect remove all connections for peer %p",n),this.connections.delete(n),this.events.safeDispatchEvent("peer:disconnect",{detail:t.remotePeer}))}getConnections(e){if(e!=null)return this.connections.get(e)??[];let t=[];for(const n of this.connections.values())t=t.concat(n);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){if(!this.started)throw new pa("Not started");this.outboundPendingConnections++;try{t.signal?.throwIfAborted();const{peerId:n}=Lx(e);if(this.peerId.equals(n))throw new jv("Can not dial self");if(n!=null&&t.force!==!0){this.log("dial %p",n);const a=this.getConnections(n).find(c=>c.limits==null);if(a!=null)return this.log("had an existing non-limited connection to %p",n),t.onProgress?.(new ke("dial-queue:already-connected")),a}const i=await this.dialQueue.dial(e,{...t,priority:t.priority??qx});if(i.status!=="open")throw new Vv("Remote closed connection during opening");let s=this.connections.get(i.remotePeer);s==null&&(s=[],this.connections.set(i.remotePeer,s));let o=!1;for(const a of s)if(a.id===i.id&&(o=!0),t.force!==!0&&a.id!==i.id&&a.remoteAddr.equals(i.remoteAddr))return i.abort(new _g("Duplicate multiaddr connection")),a;return o||s.push(i),i}finally{this.outboundPendingConnections--}}async closeConnections(e,t={}){const n=this.connections.get(e)??[];await Promise.all(n.map(async i=>{try{await i.close(t)}catch(s){i.abort(s)}}))}async acceptIncomingConnection(e){if(this.deny.some(i=>i.contains(e.remoteAddr.nodeAddress().address)))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some(i=>i.contains(e.remoteAddr.nodeAddress().address)))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(e.remoteAddr.isThinWaistAddress()){const i=e.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(i,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,i),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map(n=>de(n))}))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}class Xh{movingAverage;variance;deviation;forecast;timeSpan;previousTime;constructor(e){this.timeSpan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timeSpan)}push(e,t=Date.now()){if(this.previousTime!=null){const n=this.alpha(t,this.previousTime),i=e-this.movingAverage,s=n*i;this.movingAverage=n*e+(1-n)*this.movingAverage,this.variance=(1-n)*(this.variance+i*s),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+n*i}else this.movingAverage=e;this.previousTime=t}}const w8=1.2,b8=2,v8=5e3,S8=6e4,E8=5e3;class A8{success;failure;next;metric;timeoutMultiplier;failureMultiplier;minTimeout;maxTimeout;constructor(e={}){const t=e.interval??E8;this.success=new Xh(t),this.failure=new Xh(t),this.next=new Xh(t),this.failureMultiplier=e.failureMultiplier??b8,this.timeoutMultiplier=e.timeoutMultiplier??w8,this.minTimeout=e.minTimeout??v8,this.maxTimeout=e.maxTimeout??S8,e.metricName!=null&&(this.metric=e.metrics?.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){let t=Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier));t<this.minTimeout&&(t=this.minTimeout),t>this.maxTimeout&&(t=this.maxTimeout);const n=AbortSignal.timeout(t),i=Vr([e.signal,n]);return i.start=Date.now(),i.timeout=t,i}cleanUp(e){const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),this.metric?.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),this.metric?.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}const x8=1e4,_8="1.0.0",C8="ping",I8="ipfs",pv=32,k8=!0;class T8{protocol;components;log;heartbeatInterval;pingIntervalMs;abortController;timeout;abortConnectionOnPingFailure;constructor(e,t={}){this.components=e,this.protocol=`/${t.protocolPrefix??I8}/${C8}/${_8}`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??x8,this.abortConnectionOnPingFailure=t.abortConnectionOnPingFailure??k8,this.timeout=new A8({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}[Symbol.toStringTag]="@libp2p/connection-monitor";[$t]=["@libp2p/connection-monitor"];start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(e=>{Promise.resolve().then(async()=>{let t=Date.now();try{const n=this.timeout.getTimeoutSignal({signal:this.abortController?.signal}),i=await e.newStream(this.protocol,{signal:n,runOnLimitedConnection:!0}),s=Ll(i);t=Date.now(),await Promise.all([s.write(Ds(pv),{signal:n}),s.read({bytes:pv,signal:n})]),e.rtt=Date.now()-t,await s.unwrap().close({signal:n})}catch(n){if(n.name!=="UnsupportedProtocolError")throw n;e.rtt=(Date.now()-t)/2}}).catch(t=>{this.log.error("error during heartbeat",t),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),e.abort(t)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){this.abortController?.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}class P8{routers;started;components;constructor(e,t){this.routers=t.routers??[],this.started=!1,this.components=e,this.findProviders=e.metrics?.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],i)=>({...i,cid:n.toString()}),getAttributesFromYieldedValue:(n,i)=>({...i,providers:[...Array.isArray(i.providers)?i.providers:[],n.id.toString()]})})??this.findProviders,this.provide=e.metrics?.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],i)=>({...i,cid:n.toString()})})??this.provide,this.cancelReprovide=e.metrics?.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],i)=>({...i,cid:n.toString()})})??this.cancelReprovide,this.put=e.metrics?.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([n])=>({key:ne(n,"base36")})})??this.put,this.get=e.metrics?.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([n])=>({key:ne(n,"base36")})})??this.get}[Symbol.toStringTag]="@libp2p/content-routing";isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(this.routers.length===0)throw new Wh("No content routers available");const n=this,i=new Ii;for await(const s of Ml(...n.routers.filter(o=>o.findProviders instanceof Function).map(o=>o.findProviders(e,t))))s!=null&&(s.multiaddrs.length>0&&await this.components.peerStore.merge(s.id,{multiaddrs:s.multiaddrs},t),!i.has(s.id)&&(i.add(s.id),yield s))}async provide(e,t={}){if(this.routers.length===0)throw new Wh("No content routers available");await Promise.all(this.routers.filter(n=>n.provide instanceof Function).map(async n=>{await n.provide(e,t)}))}async cancelReprovide(e,t={}){if(this.routers.length===0)throw new Wh("No content routers available");await Promise.all(this.routers.filter(n=>n.cancelReprovide instanceof Function).map(async n=>{await n.cancelReprovide(e,t)}))}async put(e,t,n){if(!this.isStarted())throw new pa;await Promise.all(this.routers.filter(i=>i.put instanceof Function).map(async i=>{await i.put(e,t,n)}))}async get(e,t){if(!this.isStarted())throw new pa;return Promise.any(this.routers.filter(n=>n.get instanceof Function).map(async n=>n.get(e,t)))}}class R8{log;peerId;peerStore;routers;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[],this.findPeer=e.metrics?.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],i)=>({...i,peer:n.toString()})})??this.findPeer,this.getClosestPeers=e.metrics?.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],i)=>({...i,key:ne(n,"base36")}),getAttributesFromYieldedValue:(n,i)=>({...i,peers:[...Array.isArray(i.peers)?i.peers:[],n.id.toString()]})})??this.getClosestPeers}[Symbol.toStringTag]="@libp2p/peer-routing";async findPeer(e,t){if(this.routers.length===0)throw new iv("No peer routers available");if(e.toString()===this.peerId.toString())throw new g6("Should not try to find self");const n=this,i=Ml(...this.routers.filter(s=>s.findPeer instanceof Function).map(s=>async function*(){try{yield await s.findPeer(e,t)}catch(o){n.log.error(o)}}()));for await(const s of i)if(s!=null)return s.multiaddrs.length>0&&await this.peerStore.merge(s.id,{multiaddrs:s.multiaddrs},t),s;throw new Nn}async*getClosestPeers(e,t={}){if(this.routers.length===0)throw new iv("No peer routers available");const n=this,i=Vs(1024);for await(const s of n1(async function*(){const o=Ml(...n.routers.filter(a=>a.getClosestPeers instanceof Function).map(a=>a.getClosestPeers(e,t)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await n.findPeer(a.id,{...t,useCache:!1})}catch(c){n.log.error("could not find peer multiaddrs",c);return}return a}}()))s!=null&&(s.multiaddrs.length>0&&await this.peerStore.merge(s.id,{multiaddrs:s.multiaddrs},t),!i.has(s.id.toMultihash().bytes)&&(i.add(s.id.toMultihash().bytes),yield s))}}class O8 extends sr{peerRouting;log;walking;walkers;shutdownController;walkController;needNext;constructor(e){super(),this.log=e.logger.forComponent("libp2p:random-walk"),this.peerRouting=e.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}[Symbol.toStringTag]="@libp2p/random-walk";start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(e){this.walking||this.startWalk(),this.walkers++;const t=Vr([this.shutdownController.signal,e?.signal]);try{for(;;)this.needNext?.resolve(),this.needNext=Ve(),yield(await Ur(this,"walk:peer",t,{errorEvent:"walk:error"})).detail}finally{t.clear(),this.walkers--,this.walkers===0&&(this.walkController?.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const e=Vr([this.walkController.signal,this.shutdownController.signal]),t=Date.now();let n=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const i=Ds(32);let s=Date.now();for await(const o of this.peerRouting.getClosestPeers(i,{signal:e}))e.aborted&&this.log("aborting walk"),e.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",o.id,Date.now()-s,this.walkers),n++,this.safeDispatchEvent("walk:peer",{detail:o}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await At(this.needNext.promise,e)),s=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",i,this.walkers,n)}catch(i){this.log.error("random walk errored",i),this.safeDispatchEvent("walk:error",{detail:i})}this.log("no walkers left, ended walk")}).catch(i=>{this.log.error("random walk errored",i)}).finally(()=>{this.log("finished walk, found %d peers after %dms",n,Date.now()-t),this.walking=!1})}}const Kx=32,Vx=64;class B8{log;topologies;handlers;components;constructor(e){this.components=e,this.log=e.logger.forComponent("libp2p:registrar"),this.topologies=new Map,e.metrics?.registerMetricGroup("libp2p_registrar_topologies",{calculate:()=>{const t={};for(const[n,i]of this.topologies)t[n]=i.size;return t}}),this.handlers=jr({name:"libp2p_registrar_protocol_handlers",metrics:e.metrics}),this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}[Symbol.toStringTag]="@libp2p/registrar";getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(t==null)throw new m6(`No handler registered for protocol ${e}`);return t}getTopologies(e){const t=this.topologies.get(e);return t==null?[]:[...t.values()]}async handle(e,t,n){if(this.handlers.has(e)&&n?.force!==!0)throw new y6(`Handler already registered for protocol ${e}`);const i=ny.bind({ignoreUndefined:!0})({maxInboundStreams:Kx,maxOutboundStreams:Vx},n);this.handlers.set(e,{handler:t,options:i}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]},n)}async unhandle(e,t){(Array.isArray(e)?e:[e]).forEach(i=>{this.handlers.delete(i)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()},t)}async register(e,t){if(t==null)throw new q("invalid topology");const n=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let i=this.topologies.get(e);return i==null&&(i=new Map,this.topologies.set(e,i)),i.set(n,t),n}unregister(e){for(const[t,n]of this.topologies.entries())n.has(e)&&(n.delete(e),n.size===0&&this.topologies.delete(t))}_onDisconnect(e){const t=e.detail,n={signal:AbortSignal.timeout(5e3)};this.components.peerStore.get(t,n).then(i=>{for(const s of i.protocols){const o=this.topologies.get(s);if(o!=null)for(const a of o.values())a.filter?.has(t)!==!1&&(a.filter?.remove(t),a.onDisconnect?.(t))}}).catch(i=>{i.name!=="NotFoundError"&&this.log.error("could not inform topologies of disconnecting peer %p",t,i)})}_onPeerUpdate(e){const{peer:t,previous:n}=e.detail,i=(n?.protocols??[]).filter(s=>!t.protocols.includes(s));for(const s of i){const o=this.topologies.get(s);if(o!=null)for(const a of o.values())a.filter?.has(t.id)!==!1&&(a.filter?.remove(t.id),a.onDisconnect?.(t.id))}}_onPeerIdentify(e){const t=e.detail.protocols,n=e.detail.connection,i=e.detail.peerId;for(const s of t){const o=this.topologies.get(s);if(o!=null)for(const a of o.values())n.limits!=null&&a.notifyOnLimitedConnection!==!0||a.filter?.has(i)!==!0&&(a.filter?.add(i),a.onConnect?.(i,n))}}}class N8{log;components;transports;listeners;faultTolerance;started;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=jr({name:"libp2p_transport_manager_transports",metrics:this.components.metrics}),this.listeners=jr({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??fa.FATAL_ALL}[Symbol.toStringTag]="@libp2p/transport-manager";add(e){const t=e[Symbol.toStringTag];if(t==null)throw new q("Transport must have a valid tag");if(this.transports.has(t))throw new q(`There is already a transport with the tag ${t}`);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,n]of this.listeners)for(this.log("closing listeners for %s",t);n.length>0;){const i=n.pop();i!=null&&e.push(i.close())}await Promise.all(e),this.log("all listeners closed");for(const t of this.listeners.keys())this.listeners.set(t,[]);this.started=!1}async dial(e,t){const n=this.dialTransportForMultiaddr(e);if(n==null)throw new A6(`No transport available for address ${String(e)}`);return t?.onProgress?.(new ke("transport-manager:selected-transport",n[Symbol.toStringTag])),n.dial(e,{...t,upgrader:this.components.upgrader})}getAddrs(){let e=[];for(const t of this.listeners.values())for(const n of t)e=[...e,...n.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values())if(t.dialFilter([e]).length>0)return t}listenTransportForMultiaddr(e){for(const t of this.transports.values())if(t.listenFilter([e]).length>0)return t}async listen(e){if(!this.isStarted())throw new pa("Not started");if(e==null||e.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const t={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};e.forEach(s=>{t.errors.set(s.toString(),new w6)});const n=[];for(const[s,o]of this.transports.entries()){const a=o.listenFilter(e);for(const c of a){this.log("creating listener for %s on %a",s,c);const l=o.createListener({upgrader:this.components.upgrader});let u=this.listeners.get(s)??[];u==null&&(u=[],this.listeners.set(s,u)),u.push(l),l.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:l})}),l.addEventListener("close",()=>{const d=u.findIndex(h=>h===l);u.splice(d,1),this.components.events.safeDispatchEvent("transport:close",{detail:l})}),Bw.matches(c)?t.ipv4.attempts++:Nw.matches(c)&&t.ipv6.attempts++,n.push(l.listen(c).then(()=>{t.errors.delete(c.toString()),Bw.matches(c)&&t.ipv4.success++,Nw.matches(c)&&t.ipv6.success++},d=>{throw this.log.error("transport %s could not listen on address %a - %e",s,c,d),t.errors.set(c.toString(),d),d}))}}const i=await Promise.allSettled(n);if(!(i.length>0&&i.every(s=>s.status==="fulfilled"))){if(this.ipv6Unsupported(t)){this.log("all IPv4 addresses succeed but all IPv6 failed");return}if(this.faultTolerance===fa.NO_FATAL){this.log("failed to listen on any address but fault tolerance allows this");return}throw new b6(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...t.errors.entries()].map(([s,o])=>`
  ${s}: ${`${o.stack??o}`.split(`
`).join(`
  `)}
`).join("")}`)}}ipv6Unsupported(e){if(e.ipv4.attempts===0||e.ipv6.attempts===0)return!1;const t=e.ipv4.attempts===e.ipv4.success,n=e.ipv6.success===0;return t&&n}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const n=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const i=t.pop();i!=null&&n.push(i.close())}await Promise.all(n),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}const Mt="/multistream/1.0.0",iy=1024,D8=Z(`
`);async function Wo(r,e,t){await r.write(e,t)}async function L8(r,e,t){await r.writeV(e,t)}async function M8(r,e){const t=await r.read(e);if(t.byteLength===0||t.get(t.byteLength-1)!==D8[0])throw e.log.error("Invalid mss message - missing newline",t),new bt("Missing newline");return t.sublist(0,-1)}async function ks(r,e){const t=await M8(r,e);return ne(t.subarray())}async function Zh(r,e,t){if(e=Array.isArray(e)?[...e]:[e],e.length===1&&t.negotiateFully===!1)return F8(r,e[0],t);const n=Ls(r,{...t,maxDataLength:iy}),i=e.shift();if(i==null)throw new Error("At least one protocol must be specified");t.log.trace('select: write ["%s", "%s"]',Mt,i);const s=Z(`${Mt}
`),o=Z(`${i}
`);await L8(n,[s,o],t),t.log.trace("select: reading multistream-select header");let a=await ks(n,t);if(t.log.trace('select: read "%s"',a),a===Mt&&(t.log.trace("select: reading protocol response"),a=await ks(n,t),t.log.trace('select: read "%s"',a)),a===i)return{stream:n.unwrap(),protocol:i};for(const c of e){t.log.trace('select: write "%s"',c),await Wo(n,Z(`${c}
`),t),t.log.trace("select: reading protocol response");const l=await ks(n,t);if(t.log.trace('select: read "%s" for "%s"',l,c),l===c)return{stream:n.unwrap(),protocol:c}}throw new Cg("protocol selection failed")}function F8(r,e,t){const n=r.sink.bind(r),i=r.source;let s=!1,o=!1;const a=Ve();let c=!1,l=!1;const u=Ve();let d=!1,h=!1;const p=Ve(),m=Ls({sink:n,source:i},{...t,maxDataLength:iy});r.sink=async _=>{const{sink:E}=m.unwrap();await E(async function*(){let R=!1;for await(const S of _){if(l&&await u.promise,c)yield S;else{l=!0,t.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink',Mt,e,S.byteLength);const N=`${e}
`;yield new ye(Uint8Array.from([19]),Z(`${Mt}
`),_s(N.length),Z(N),S).subarray(),t.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink',Mt,e,S.byteLength),c=!0,l=!1,u.resolve(),w().catch(T=>{t.log.error("could not finish optimistic protocol negotiation of %s",e,T)})}R=!0}R||await w()}())};async function w(){if(o){t.log.trace("optimistic: already negotiating %s stream",e),await a.promise;return}o=!0;try{c||(t.log.trace("optimistic: doing send protocol for %s stream",e),await y()),d||(t.log.trace("optimistic: doing read protocol for %s stream",e),await b())}finally{o=!1,s=!0,a.resolve()}}async function y(){if(l){await u.promise;return}l=!0;try{t.log.trace('optimistic: write ["%s", "%s", data] in source',Mt,e),await m.writeV([Z(`${Mt}
`),Z(`${e}
`)]),t.log.trace('optimistic: wrote ["%s", "%s", data] in source',Mt,e)}finally{c=!0,l=!1,u.resolve()}}async function b(){if(h){await p.promise;return}h=!0;try{t.log.trace("optimistic: reading multistream select header");let _=await ks(m,t);if(t.log.trace('optimistic: read multistream select header "%s"',_),_===Mt&&(_=await ks(m,t)),t.log.trace('optimistic: read protocol "%s", expecting "%s"',_,e),_!==e)throw new Cg("protocol selection failed")}finally{d=!0,h=!1,p.resolve()}}if(r.source=async function*(){await w(),t.log.trace('optimistic: reading data from "%s" stream',e),yield*m.unwrap().source}(),r.closeRead!=null){const _=r.closeRead.bind(r);r.closeRead=async E=>{s||await w().catch(R=>{t.log.error("could not negotiate protocol before close read",R)}),await _(E)}}if(r.closeWrite!=null){const _=r.closeWrite.bind(r);r.closeWrite=async E=>{s||await w().catch(R=>{t.log.error("could not negotiate protocol before close write",R)}),await _(E)}}if(r.close!=null){const _=r.close.bind(r);r.close=async E=>{const R=[];l&&R.push(u.promise),h&&R.push(p.promise),R.length>0?await At(Promise.all(R),E?.signal):(s=!0,o=!1,a.resolve()),await _(E)}}return{stream:r,protocol:e}}async function ef(r,e,t){e=Array.isArray(e)?e:[e],t.log.trace("handle: available protocols %s",e);const n=Ls(r,{...t,maxDataLength:iy,maxLengthLength:2});for(;;){t.log.trace("handle: reading incoming string");const i=await ks(n,t);if(t.log.trace('handle: read "%s"',i),i===Mt){t.log.trace('handle: respond with "%s" for "%s"',Mt,i),await Wo(n,Z(`${Mt}
`),t),t.log.trace('handle: responded with "%s" for "%s"',Mt,i);continue}if(e.includes(i))return t.log.trace('handle: respond with "%s" for "%s"',i,i),await Wo(n,Z(`${i}
`),t),t.log.trace('handle: responded with "%s" for "%s"',i,i),{stream:n.unwrap(),protocol:i};if(i==="ls"){const s=new ye(...e.map(o=>Nl.single(Z(`${o}
`))),Z(`
`));t.log.trace('handle: respond with "%s" for %s',e,i),await Wo(n,s,t),t.log.trace('handle: responded with "%s" for %s',e,i);continue}t.log.trace('handle: respond with "na" for "%s"',i),await Wo(n,Z(`na
`),t),t.log('handle: responded with "na" for "%s"',i)}}const U8=500;class $8{id;remoteAddr;remotePeer;direction;timeline;multiplexer;encryption;status;limits;log;tags;_newStream;_close;_abort;_getStreams;constructor(e){const{remoteAddr:t,remotePeer:n,newStream:i,close:s,abort:o,getStreams:a}=e;this.id=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`,this.remoteAddr=t,this.remotePeer=n,this.direction=e.direction,this.status="open",this.timeline=e.timeline,this.multiplexer=e.multiplexer,this.encryption=e.encryption,this.limits=e.limits,this.log=e.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`),this.remoteAddr.getPeerId()==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),this._newStream=i,this._close=s,this._abort=o,this._getStreams=a,this.tags=[]}[Symbol.toStringTag]="Connection";[iC]=!0;get streams(){return this._getStreams()}async newStream(e,t){if(this.status==="closing")throw new aC("the connection is being closed");if(this.status==="closed")throw new Vv("the connection is closed");if(Array.isArray(e)||(e=[e]),this.limits!=null&&t?.runOnLimitedConnection!==!0)throw new Hv("Cannot open protocol stream on limited connection");const n=await this._newStream(e,t);return n.direction="outbound",n}async close(e={}){if(!(this.status==="closed"||this.status==="closing")){if(this.log("closing connection to %a",this.remoteAddr),this.status="closing",e.signal==null){const t=AbortSignal.timeout(U8);e={...e,signal:t}}try{this.log.trace("closing underlying transport"),await this._close(e),this.log.trace("updating timeline with close time"),this.status="closed",this.timeline.close=Date.now()}catch(t){this.log.error("error encountered during graceful close of connection to %a",this.remoteAddr,t),this.abort(t)}}}abort(e){this.status!=="closed"&&(this.log.error("aborting connection to %a due to error",this.remoteAddr,e),this.status="closing",this._abort(e),this.status="closed",this.timeline.close=Date.now())}}function q8(r){return new $8(r)}function K8(r,e){try{const{options:t}=e.getHandler(r);return t.maxInboundStreams}catch(t){if(t.name!=="UnhandledProtocolError")throw t}return Kx}function V8(r,e,t={}){try{const{options:n}=e.getHandler(r);if(n.maxOutboundStreams!=null)return n.maxOutboundStreams}catch(n){if(n.name!=="UnhandledProtocolError")throw n}return t.maxOutboundStreams??Vx}function gv(r,e,t){let n=0;return t.streams.forEach(i=>{i.direction===e&&i.protocol===r&&n++}),n}class z8{components;connectionEncrypters;streamMuxers;inboundUpgradeTimeout;inboundStreamProtocolNegotiationTimeout;outboundStreamProtocolNegotiationTimeout;events;metrics;constructor(e,t){this.components=e,this.connectionEncrypters=jr({name:"libp2p_upgrader_connection_encrypters",metrics:this.components.metrics}),t.connectionEncrypters.forEach(n=>{this.connectionEncrypters.set(n.protocol,n)}),this.streamMuxers=jr({name:"libp2p_upgrader_stream_multiplexers",metrics:this.components.metrics}),t.streamMuxers.forEach(n=>{this.streamMuxers.set(n.protocol,n)}),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??V6,this.inboundStreamProtocolNegotiationTimeout=t.inboundStreamProtocolNegotiationTimeout??av,this.outboundStreamProtocolNegotiationTimeout=t.outboundStreamProtocolNegotiationTimeout??av,this.events=e.events,this.metrics={dials:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),inboundErrors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),outboundErrors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")}}[Symbol.toStringTag]="@libp2p/upgrader";async shouldBlockConnection(e,...t){const n=this.components.connectionGater[e];if(n==null)return;if(await n.apply(this.components.connectionGater,t)===!0)throw new S6(`The multiaddr connection is blocked by gater.${e}`)}createInboundAbortSignal(e){return Vr([AbortSignal.timeout(this.inboundUpgradeTimeout),e])}async upgradeInbound(e,t){let n=!1;const i=this.createInboundAbortSignal(t.signal);try{if(this.metrics.dials?.increment({inbound:!0}),n=await At(this.components.connectionManager.acceptIncomingConnection(e),i),!n)throw new E6("Connection denied");await At(this.shouldBlockConnection("denyInboundConnection",e),i),await this._performUpgrade(e,"inbound",{...t,signal:i})}catch(s){throw this.metrics.errors?.increment({inbound:!0}),this.metrics.inboundErrors?.increment({[s.name??"Error"]:!0}),s}finally{i.clear(),n&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t){try{this.metrics.dials?.increment({outbound:!0});const n=e.remoteAddr.getPeerId();let i;n!=null&&(i=xr(n),await At(this.shouldBlockConnection("denyOutboundConnection",i,e),t.signal));let s="outbound";return t.initiator===!1&&(s="inbound"),await this._performUpgrade(e,s,t)}catch(n){throw this.metrics.errors?.increment({outbound:!0}),this.metrics.outboundErrors?.increment({[n.name??"Error"]:!0}),n}}async _performUpgrade(e,t,n){let i,s,o,a,c;this.components.metrics?.trackMultiaddrConnection(e),e.log.trace("starting the %s connection upgrade",t);let l=e;if(n?.skipProtection!==!0){const u=this.components.connectionProtector;u!=null&&(e.log("protecting the %s connection",t),l=await u.protect(e,n))}try{if(i=l,n?.skipEncryption!==!0){n?.onProgress?.(new ke(`upgrader:encrypt-${t}-connection`)),{conn:i,remotePeer:s,protocol:c,streamMuxer:a}=await(t==="inbound"?this._encryptInbound(l,n):this._encryptOutbound(l,n));const u={...l,...i};await this.shouldBlockConnection(t==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",s,u)}else{const u=e.remoteAddr.getPeerId();if(u==null)throw new _g(`${t} connection that skipped encryption must have a peer id`);const d=xr(u);c="native",s=d}if(s.equals(this.components.peerId)){const u=new jv("Can not dial self");throw e.abort(u),u}if(o=i,n?.muxerFactory!=null)a=n.muxerFactory;else if(a==null&&this.streamMuxers.size>0){n?.onProgress?.(new ke(`upgrader:multiplex-${t}-connection`));const u=await(t==="inbound"?this._multiplexInbound({...l,...i},this.streamMuxers,n):this._multiplexOutbound({...l,...i},this.streamMuxers,n));a=u.muxerFactory,o=u.stream}}catch(u){throw e.log.error("failed to upgrade inbound connection %s %a - %e",t==="inbound"?"from":"to",e.remoteAddr,u),u}return await this.shouldBlockConnection(t==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",s,e),e.log("successfully upgraded %s connection",t),this._createConnection({cryptoProtocol:c,direction:t,maConn:e,upgradedConn:o,muxerFactory:a,remotePeer:s,limits:n?.limits})}_createConnection(e){const{cryptoProtocol:t,direction:n,maConn:i,upgradedConn:s,remotePeer:o,muxerFactory:a,limits:c}=e;let l,u,d;a!=null&&(l=a.createStreamMuxer({direction:n,onIncomingStream:m=>{if(d==null)return;const w=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);Promise.resolve().then(async()=>{const y=this.components.registrar.getProtocols(),{stream:b,protocol:_}=await ef(m,y,{signal:w,log:m.log,yieldBytes:!1});if(d==null)return;d.log("incoming stream opened on %s",_);const E=K8(_,this.components.registrar);if(gv(_,"inbound",d)===E){const S=new hC(`Too many inbound protocol streams for protocol "${_}" - limit ${E}`);throw m.abort(S),S}m.source=b.source,m.sink=b.sink,m.protocol=_,b.closeWrite!=null&&(m.closeWrite=b.closeWrite),b.closeRead!=null&&(m.closeRead=b.closeRead),b.close!=null&&(m.close=b.close),await this.components.peerStore.merge(o,{protocols:[_]},{signal:w}),this.components.metrics?.trackProtocolStream(m,d),this._onStream({connection:d,stream:m,protocol:_})}).catch(async y=>{d.log.error("error handling incoming stream id %s - %e",m.id,y),m.timeline.close==null&&await m.close({signal:w}).catch(b=>m.abort(b))})}}),u=async(m,w={})=>{if(l==null)throw new Gc("Connection is not multiplexed");d.log.trace("starting new stream for protocols %s",m);const y=await l.newStream();d.log.trace("started new stream %s for protocols %s",y.id,m);try{if(w.signal==null){y.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",m);const S=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);w={...w,signal:S}}y.log.trace("selecting protocol from protocols %s",m);const{stream:b,protocol:_}=await Zh(y,m,{...w,log:y.log,yieldBytes:!0});y.log.trace("selected protocol %s",_);const E=V8(_,this.components.registrar,w),R=gv(_,"outbound",d);if(R>=E){const S=new Wv(`Too many outbound protocol streams for protocol "${_}" - ${R}/${E}`);throw y.abort(S),S}return await this.components.peerStore.merge(o,{protocols:[_]}),y.source=b.source,y.sink=b.sink,y.protocol=_,b.closeWrite!=null&&(y.closeWrite=b.closeWrite),b.closeRead!=null&&(y.closeRead=b.closeRead),b.close!=null&&(y.close=b.close),this.components.metrics?.trackProtocolStream(y,d),y}catch(b){throw d.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",n==="inbound"?"from":"to",e.maConn.remoteAddr,m,b),y.timeline.close==null&&y.abort(b),b}},Promise.all([l.sink(s.source),s.sink(l.source)]).catch(m=>{d.log.error("error piping data through muxer - %e",m)}));const h=i.timeline;i.timeline=new Proxy(h,{set:(...m)=>(m[1]==="close"&&m[2]!=null&&h.close==null&&(async()=>{try{d.status==="open"&&await d.close()}catch(w){d.log.error("error closing connection after timeline close %e",w)}finally{this.events.safeDispatchEvent("connection:close",{detail:d})}})().catch(w=>{d.log.error("error thrown while dispatching connection:close event %e",w)}),Reflect.set(...m))}),i.timeline.upgraded=Date.now();const p=()=>{throw new Gc("Connection is not multiplexed")};return d=q8({remoteAddr:i.remoteAddr,remotePeer:o,status:"open",direction:n,timeline:i.timeline,multiplexer:l?.protocol,encryption:t,limits:c,logger:this.components.logger,newStream:u??p,getStreams:()=>l?.streams??[],close:async m=>{await l?.close(m),await i.close(m)},abort:m=>{i.abort(m),l?.abort(m)}}),this.events.safeDispatchEvent("connection:open",{detail:d}),d.__maConnTimeline=h,d}_onStream(e){const{connection:t,stream:n,protocol:i}=e,{handler:s,options:o}=this.components.registrar.getHandler(i);if(t.limits!=null&&o.runOnLimitedConnection!==!0)throw new Hv("Cannot open protocol stream on limited connection");s({connection:t,stream:n})}async _encryptInbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{const{stream:i,protocol:s}=await ef(e,n,{...t,log:e.log}),o=this.connectionEncrypters.get(s);if(o==null)throw new Yc(`no crypto module found for ${s}`);return e.log("encrypting inbound connection to %a using %s",e.remoteAddr,s),{...await o.secureInbound(i,t),protocol:s}}catch(i){throw e.log.error("encrypting inbound connection from %a failed",e.remoteAddr,i),new Yc(i.message)}}async _encryptOutbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{e.log.trace("selecting encrypter from %s",n);const{stream:i,protocol:s}=await Zh(e,n,{...t,log:e.log,yieldBytes:!0}),o=this.connectionEncrypters.get(s);if(o==null)throw new Yc(`no crypto module found for ${s}`);return e.log("encrypting outbound connection to %a using %s",e.remoteAddr,s),{...await o.secureOutbound(i,t),protocol:s}}catch(i){throw e.log.error("encrypting outbound connection to %a failed",e.remoteAddr,i),new Yc(i.message)}}async _multiplexOutbound(e,t,n){const i=Array.from(t.keys());e.log("outbound selecting muxer %s",i);try{e.log.trace("selecting stream muxer from %s",i);const{stream:s,protocol:o}=await Zh(e,i,{...n,log:e.log,yieldBytes:!0});e.log("selected %s as muxer protocol",o);const a=t.get(o);return{stream:s,muxerFactory:a}}catch(s){throw e.log.error("error multiplexing outbound connection",s),new Gc(String(s))}}async _multiplexInbound(e,t,n){const i=Array.from(t.keys());e.log("inbound handling muxers %s",i);try{const{stream:s,protocol:o}=await ef(e,i,{...n,log:e.log}),a=t.get(o);return{stream:s,muxerFactory:a}}catch(s){throw e.log.error("error multiplexing inbound connection",s),new Gc(String(s))}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}const zx="2.8.11",jx="js-libp2p";function j8(r,e){return`${r??jx}/${e??zx} browser/${globalThis.navigator.userAgent}`}class H8 extends sr{peerId;peerStore;contentRouting;peerRouting;metrics;services;logger;status;components;log;constructor(e){super(),this.status="stopped";const t=new sr,n=t.dispatchEvent.bind(t);t.dispatchEvent=l=>{const u=n(l),d=this.dispatchEvent(new CustomEvent(l.type,{detail:l.detail}));return u||d},this.peerId=e.peerId,this.logger=e.logger??mx(),this.log=this.logger.forComponent("libp2p"),this.services={};const i=e.nodeInfo?.name??jx,s=e.nodeInfo?.version??zx,o=this.components=I6({peerId:e.peerId,privateKey:e.privateKey,nodeInfo:{name:i,version:s,userAgent:e.nodeInfo?.userAgent??j8(i,s)},logger:this.logger,events:t,datastore:e.datastore??new Y3,connectionGater:N6(e.connectionGater),dns:e.dns});e.metrics!=null&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),this.peerStore=this.configureComponent("peerStore",z3(o,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),o.events.addEventListener("peer:update",l=>{if(l.detail.previous==null){const u={id:l.detail.peer.id,multiaddrs:l.detail.peer.addresses.map(d=>d.multiaddr)};o.events.safeDispatchEvent("peer:discovery",{detail:u})}}),e.connectionProtector!=null&&this.configureComponent("connectionProtector",e.connectionProtector(o)),this.components.upgrader=new z8(this.components,{connectionEncrypters:(e.connectionEncrypters??[]).map((l,u)=>this.configureComponent(`connection-encryption-${u}`,l(this.components))),streamMuxers:(e.streamMuxers??[]).map((l,u)=>this.configureComponent(`stream-muxers-${u}`,l(this.components))),inboundUpgradeTimeout:e.connectionManager?.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:e.connectionManager?.inboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:e.connectionManager?.outboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout}),this.configureComponent("transportManager",new N8(this.components,e.transportManager)),this.configureComponent("connectionManager",new y8(this.components,e.connectionManager)),e.connectionMonitor?.enabled!==!1&&this.configureComponent("connectionMonitor",new T8(this.components,e.connectionMonitor)),this.configureComponent("registrar",new B8(this.components)),this.configureComponent("addressManager",new h6(this.components,e.addresses));const a=(e.peerRouters??[]).map((l,u)=>this.configureComponent(`peer-router-${u}`,l(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new R8(this.components,{routers:a}));const c=(e.contentRouters??[]).map((l,u)=>this.configureComponent(`content-router-${u}`,l(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new P8(this.components,{routers:c})),this.configureComponent("randomWalk",new O8(this.components)),(e.peerDiscovery??[]).forEach((l,u)=>{this.configureComponent(`peer-discovery-${u}`,l(this.components)).addEventListener("peer",h=>{this.#e(h)})}),e.transports?.forEach((l,u)=>{this.components.transportManager.add(this.configureComponent(`transport-${u}`,l(this.components)))}),e.services!=null)for(const l of Object.keys(e.services)){const u=e.services[l],d=u(this.components);if(d==null){this.log.error("service factory %s returned null or undefined instance",l);continue}this.services[l]=d,this.configureComponent(l,d),d[Ny]!=null&&(this.log("registering service %s for content routing",l),c.push(d[Ny])),d[Ly]!=null&&(this.log("registering service %s for peer routing",l),a.push(d[Ly])),d[Dy]!=null&&(this.log("registering service %s for peer discovery",l),d[Dy].addEventListener?.("peer",h=>{this.#e(h)}))}k6(o)}configureComponent(e,t){return t==null&&this.log.error("component %s was null or undefined",e),this.components[e]=t,t}async start(){if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await this.components.beforeStart?.(),await this.components.start(),await this.components.afterStart?.(),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started")}catch(e){throw this.log.error("An error occurred starting libp2p",e),this.status="started",await this.stop(),e}}}async stop(){this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await this.components.beforeStop?.(),await this.components.stop(),await this.components.afterStop?.(),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new Ii;for(const t of this.components.connectionManager.getConnections())e.add(t.remotePeer);return Array.from(e)}async dial(e,t={}){return this.components.connectionManager.openConnection(e,{priority:75,...t})}async dialProtocol(e,t,n={}){if(t==null)throw new q("no protocols were provided to open a stream");if(t=Array.isArray(t)?t:[t],t.length===0)throw new q("no protocols were provided to open a stream");return(await this.dial(e,n)).newStream(t,n)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e,t={}){rd(e)&&(e=xr(e.getPeerId()??"")),await this.components.connectionManager.closeConnections(e,t)}async getPublicKey(e,t={}){if(this.log("getPublicKey %p",e),e.publicKey!=null)return e.publicKey;try{const o=await this.peerStore.get(e,t);if(o.id.publicKey!=null)return o.id.publicKey}catch(o){if(o.name!=="NotFoundError")throw o}const n=qr([Z("/pk/"),e.toMultihash().bytes]),i=await this.contentRouting.get(n,t),s=Gn(i);return await this.peerStore.patch(e,{publicKey:s},t),s}async handle(e,t,n){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async i=>{await this.components.registrar.handle(i,t,n)}))}async unhandle(e,t){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async n=>{await this.components.registrar.unhandle(n,t)}))}async register(e,t,n){return this.components.registrar.register(e,t,n)}unregister(e){this.components.registrar.unregister(e)}async isDialable(e,t={}){return this.components.connectionManager.isDialable(e,t)}#e(e){const{detail:t}=e;if(t.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(t.id,{multiaddrs:t.multiaddrs}).catch(n=>{this.log.error(n)})}}async function W8(r={}){r.privateKey??=await JS("Ed25519");const e=new H8({...await JM(r),peerId:CT(r.privateKey)});return r.start!==!1&&await e.start(),e}function G8(r,e,t){let n,i,s=!1;function o(){const l={signal:i.signal};if(t?.timeout!=null){const u=Vr([i.signal,AbortSignal.timeout(t.timeout)]);l.signal=u}s=!0,Promise.resolve().then(async()=>{await r(l)}).catch(()=>{}).finally(()=>{s=!1,!i.signal.aborted&&(n=setTimeout(o,e))})}const a=xa(o,t?.debounce??100);let c=!1;return{setInterval:l=>{e!==l&&(e=l,n!=null&&(clearTimeout(n),n=setTimeout(o,e)))},setTimeout:l=>{t??={},t.timeout=l},run:()=>{s||(clearTimeout(n),a())},start:()=>{c||(c=!0,i=new AbortController,i.signal,t?.runImmediately===!0?queueMicrotask(()=>{o()}):n=setTimeout(o,e))},stop:()=>{clearTimeout(n),i?.abort(),c=!1}}}const Y8="libp2p",Q8="autonat",J8="1.0.0",X8=3e4,Z8=2,e4=20,t4=80,r4=8192;var Me;(function(r){(function(i){i.DIAL="DIAL",i.DIAL_RESPONSE="DIAL_RESPONSE"})(r.MessageType||(r.MessageType={}));let e;(function(i){i[i.DIAL=0]="DIAL",i[i.DIAL_RESPONSE=1]="DIAL_RESPONSE"})(e||(e={})),function(i){i.codec=()=>hn(e)}(r.MessageType||(r.MessageType={})),function(i){i.OK="OK",i.E_DIAL_ERROR="E_DIAL_ERROR",i.E_DIAL_REFUSED="E_DIAL_REFUSED",i.E_BAD_REQUEST="E_BAD_REQUEST",i.E_INTERNAL_ERROR="E_INTERNAL_ERROR"}(r.ResponseStatus||(r.ResponseStatus={}));let t;(function(i){i[i.OK=0]="OK",i[i.E_DIAL_ERROR=100]="E_DIAL_ERROR",i[i.E_DIAL_REFUSED=101]="E_DIAL_REFUSED",i[i.E_BAD_REQUEST=200]="E_BAD_REQUEST",i[i.E_INTERNAL_ERROR=300]="E_INTERNAL_ERROR"})(t||(t={})),function(i){i.codec=()=>hn(t)}(r.ResponseStatus||(r.ResponseStatus={})),function(i){let s;i.codec=()=>(s==null&&(s=Oe((o,a,c={})=>{if(c.lengthDelimited!==!1&&a.fork(),o.id!=null&&(a.uint32(10),a.bytes(o.id)),o.addrs!=null)for(const l of o.addrs)a.uint32(18),a.bytes(l);c.lengthDelimited!==!1&&a.ldelim()},(o,a,c={})=>{const l={addrs:[]},u=a==null?o.len:o.pos+a;for(;o.pos<u;){const d=o.uint32();switch(d>>>3){case 1:{l.id=o.bytes();break}case 2:{if(c.limits?.addrs!=null&&l.addrs.length===c.limits.addrs)throw new Ar('Decode error - map field "addrs" had too many elements');l.addrs.push(o.bytes());break}default:{o.skipType(d&7);break}}}return l})),s),i.encode=o=>Re(o,i.codec()),i.decode=(o,a)=>Pe(o,i.codec(),a)}(r.PeerInfo||(r.PeerInfo={})),function(i){let s;i.codec=()=>(s==null&&(s=Oe((o,a,c={})=>{c.lengthDelimited!==!1&&a.fork(),o.peer!=null&&(a.uint32(10),r.PeerInfo.codec().encode(o.peer,a)),c.lengthDelimited!==!1&&a.ldelim()},(o,a,c={})=>{const l={},u=a==null?o.len:o.pos+a;for(;o.pos<u;){const d=o.uint32();switch(d>>>3){case 1:{l.peer=r.PeerInfo.codec().decode(o,o.uint32(),{limits:c.limits?.peer});break}default:{o.skipType(d&7);break}}}return l})),s),i.encode=o=>Re(o,i.codec()),i.decode=(o,a)=>Pe(o,i.codec(),a)}(r.Dial||(r.Dial={})),function(i){let s;i.codec=()=>(s==null&&(s=Oe((o,a,c={})=>{c.lengthDelimited!==!1&&a.fork(),o.status!=null&&(a.uint32(8),r.ResponseStatus.codec().encode(o.status,a)),o.statusText!=null&&(a.uint32(18),a.string(o.statusText)),o.addr!=null&&(a.uint32(26),a.bytes(o.addr)),c.lengthDelimited!==!1&&a.ldelim()},(o,a,c={})=>{const l={},u=a==null?o.len:o.pos+a;for(;o.pos<u;){const d=o.uint32();switch(d>>>3){case 1:{l.status=r.ResponseStatus.codec().decode(o);break}case 2:{l.statusText=o.string();break}case 3:{l.addr=o.bytes();break}default:{o.skipType(d&7);break}}}return l})),s),i.encode=o=>Re(o,i.codec()),i.decode=(o,a)=>Pe(o,i.codec(),a)}(r.DialResponse||(r.DialResponse={}));let n;r.codec=()=>(n==null&&(n=Oe((i,s,o={})=>{o.lengthDelimited!==!1&&s.fork(),i.type!=null&&(s.uint32(8),r.MessageType.codec().encode(i.type,s)),i.dial!=null&&(s.uint32(18),r.Dial.codec().encode(i.dial,s)),i.dialResponse!=null&&(s.uint32(26),r.DialResponse.codec().encode(i.dialResponse,s)),o.lengthDelimited!==!1&&s.ldelim()},(i,s,o={})=>{const a={},c=s==null?i.len:i.pos+s;for(;i.pos<c;){const l=i.uint32();switch(l>>>3){case 1:{a.type=r.MessageType.codec().decode(i);break}case 2:{a.dial=r.Dial.codec().decode(i,i.uint32(),{limits:o.limits?.dial});break}case 3:{a.dialResponse=r.DialResponse.codec().decode(i,i.uint32(),{limits:o.limits?.dialResponse});break}default:{i.skipType(l&7);break}}}return a})),n),r.encode=i=>Re(i,r.codec()),r.decode=(i,s)=>Pe(i,r.codec(),s)})(Me||(Me={}));const n4=4,i4=8;class s4{components;protocol;timeout;maxInboundStreams;maxOutboundStreams;maxMessageSize;started;log;topologyId;dialResults;findPeers;addressFilter;connectionThreshold;constructor(e,t){this.components=e,this.log=e.logger.forComponent("libp2p:auto-nat"),this.started=!1,this.protocol=`/${t.protocolPrefix??Y8}/${Q8}/${J8}`,this.timeout=t.timeout??X8,this.maxInboundStreams=t.maxInboundStreams??Z8,this.maxOutboundStreams=t.maxOutboundStreams??e4,this.connectionThreshold=t.connectionThreshold??t4,this.maxMessageSize=t.maxMessageSize??r4,this.dialResults=jr({name:"libp2p_autonat_dial_results",metrics:e.metrics}),this.findPeers=G8(this.findRandomPeers.bind(this),6e4),this.addressFilter=Vs(1024)}[Symbol.toStringTag]="@libp2p/autonat";[$t]=["@libp2p/autonat"];get[Os](){return["@libp2p/identify"]}isStarted(){return this.started}async start(){this.started||(await this.components.registrar.handle(this.protocol,e=>{this.handleIncomingAutonatStream(e).catch(t=>{this.log.error("error handling incoming autonat stream - %e",t)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams}),this.topologyId=await this.components.registrar.register(this.protocol,{onConnect:(e,t)=>{this.verifyExternalAddresses(t).catch(n=>{this.log.error("could not verify addresses - %e",n)})}}),this.findPeers.start(),this.started=!0)}async stop(){await this.components.registrar.unhandle(this.protocol),this.topologyId!=null&&await this.components.registrar.unhandle(this.topologyId),this.dialResults.clear(),this.findPeers.stop(),this.started=!1}allAddressesAreVerified(){return this.components.addressManager.getAddressesWithMetadata().every(e=>e.expires>Date.now()?!0:e.verified)}async findRandomPeers(e){if(this.allAddressesAreVerified())return;const t=Vr([AbortSignal.timeout(1e4),e?.signal]);try{this.log("starting random walk to find peers to run AutoNAT");for await(const n of this.components.randomWalk.walk({signal:t})){if(!await this.components.connectionManager.isDialable(n.multiaddrs)){this.log.trace("random peer %p was not dialable %s",n.id,n.multiaddrs.map(i=>i.toString()).join(", "));continue}try{this.log.trace("dial random peer %p",n.id),await this.components.connectionManager.openConnection(n.multiaddrs,{signal:t})}catch{}if(this.allAddressesAreVerified()){this.log("stopping random walk, all addresses are verified");return}if(!this.hasConnectionCapacity()){this.log("stopping random walk, too close to max connections");return}}}catch{}}async handleIncomingAutonatStream(e){const t=AbortSignal.timeout(this.timeout),n=Qt(e.stream,{maxDataLength:this.maxMessageSize}).pb(Me);try{const i=await n.read({signal:t}),s=await this.handleAutonatMessage(i,e.connection,{signal:t});await n.write(s,{signal:t}),await n.unwrap().unwrap().close({signal:t})}catch(i){this.log.error("error handling incoming autonat stream - %e",i),e.stream.abort(i)}}async handleAutonatMessage(e,t,n){const i=this.components.addressManager.getAddresses().map(d=>d.toOptions().host),s=e.dial;if(s==null)return this.log.error("dial was missing from message"),{type:Me.MessageType.DIAL_RESPONSE,dialResponse:{status:Me.ResponseStatus.E_BAD_REQUEST,statusText:"No Dial message found in message"}};let o;const a=s.peer;if(a?.id==null)return this.log.error("PeerId missing from message"),{type:Me.MessageType.DIAL_RESPONSE,dialResponse:{status:Me.ResponseStatus.E_BAD_REQUEST,statusText:"missing peer info"}};try{const d=Ji(a.id);o=po(d)}catch(d){return this.log.error("invalid PeerId - %e",d),{type:Me.MessageType.DIAL_RESPONSE,dialResponse:{status:Me.ResponseStatus.E_BAD_REQUEST,statusText:"bad peer id"}}}if(this.log("incoming request from %p",o),!t.remotePeer.equals(o))return this.log("target peer %p did not equal sending peer %p",o,t.remotePeer),{type:Me.MessageType.DIAL_RESPONSE,dialResponse:{status:Me.ResponseStatus.E_BAD_REQUEST,statusText:"peer id mismatch"}};const c=a.addrs.map(d=>de(d)).filter(d=>{const h=d.toOptions();return Di(d)?!1:h.host!==t.remoteAddr.toOptions().host?(this.log.trace("not dialing %a - target host did not match remote host %a",d,t.remoteAddr),!1):i.includes(h.host)?!1:this.components.transportManager.dialTransportForMultiaddr(d)==null?(this.log.trace("not dialing %a - transport unsupported",d),!1):!0}).map(d=>(d.getPeerId()==null&&(d=d.encapsulate(`/p2p/${o.toString()}`)),d));if(c.length===0)return this.log("refused to dial all multiaddrs for %p from message",o),{type:Me.MessageType.DIAL_RESPONSE,dialResponse:{status:Me.ResponseStatus.E_DIAL_REFUSED,statusText:"no dialable addresses"}};this.log("dial multiaddrs %s for peer %p",c.map(d=>d.toString()).join(", "),o);let l="",u=c[0];for(const d of c){let h;u=d;try{if(h=await this.components.connectionManager.openConnection(d,n),!h.remoteAddr.equals(d))throw this.log.error("tried to dial %a but dialed %a",d,h.remoteAddr),new Error("Unexpected remote address");return this.log("successfully dialed %p via %a",o,d),{type:Me.MessageType.DIAL_RESPONSE,dialResponse:{status:Me.ResponseStatus.OK,addr:h.remoteAddr.decapsulateCode(St("p2p").code).bytes}}}catch(p){this.log.error("could not dial %p - %e",o,p),l=p.message}finally{h!=null&&await h.close()}}return{type:Me.MessageType.DIAL_RESPONSE,dialResponse:{status:Me.ResponseStatus.E_DIAL_ERROR,statusText:l,addr:u.bytes}}}getFirstUnverifiedMultiaddr(e,t){const n=this.components.addressManager.getAddressesWithMetadata().sort((i,s)=>i.type==="observed"&&s.type!=="observed"?1:s.type==="observed"&&i.type!=="observed"?-1:0).filter(i=>!(!(i.expires<Date.now())||i.multiaddr.toOptions().family===6&&(!t||!o1(i.multiaddr))||Di(i.multiaddr)));for(const i of n){const s=i.multiaddr.toString();let o=this.dialResults.get(s);if(o!=null){if(o.networkSegments.includes(e)){this.log.trace("%a already has a network segment result from %s",o.multiaddr,e);continue}if(o.queue.size>10){this.log.trace("%a already has enough peers queued",o.multiaddr);continue}}if(o==null){const a=i.expires<Date.now();if(a&&this.addressFilter.remove?.(s),this.addressFilter.has(s))continue;this.addressFilter.add(s),this.log.trace("creating dial result %s %s",a?"to revalidate":"for",s),o={multiaddr:i.multiaddr,success:0,failure:0,networkSegments:[],verifyingPeers:qO(),queue:new ad({concurrency:3,maxSize:50}),type:i.type,lastVerified:i.lastVerified},this.dialResults.set(s,o)}return o}}removeOutdatedMultiaddrResults(){const e=new Set(this.components.addressManager.getAddressesWithMetadata().filter(({expires:t})=>t<Date.now()).map(({multiaddr:t})=>t.toString()));for(const t of this.dialResults.keys())e.has(t)||(this.log.trace("remove results for %a",t),this.dialResults.delete(t))}async verifyExternalAddresses(e){if(!this.isStarted())return;this.removeOutdatedMultiaddrResults();const n=(await this.components.peerStore.get(e.remotePeer)).addresses.some(({multiaddr:o})=>o.toOptions().family===6),i=this.getNetworkSegment(e.remoteAddr),s=this.getFirstUnverifiedMultiaddr(i,n);if(s==null){this.log.trace("no unverified public addresses found for peer %p to verify, not requesting verification",e.remotePeer);return}if(!this.hasConnectionCapacity()){s.lastVerified!=null?(this.log("automatically re-verifying %a because we are too close to the connection limit",s.multiaddr),this.confirmAddress(s)):this.log("skipping verifying %a because we are too close to the connection limit",s.multiaddr);return}s.queue.add(async o=>{await this.askPeerToVerify(e,i,o)},{peerId:e.remotePeer,multiaddr:s.multiaddr}).catch(o=>{s?.result==null&&this.log.error("error from %p verifying address %a - %e",e.remotePeer,s?.multiaddr,o)})}async askPeerToVerify(e,t,n){let i=this.dialResults.get(n.multiaddr.toString());if(i==null){this.log("%a was verified while %p was queued",n.multiaddr,e.remotePeer);return}const s=AbortSignal.timeout(this.timeout);this.log.trace("asking %p to verify multiaddr %s",e.remotePeer,n.multiaddr);const o=await e.newStream(this.protocol,{signal:s});try{const a=Qt(o).pb(Me),[,c]=await Promise.all([a.write({type:Me.MessageType.DIAL,dial:{peer:{id:this.components.peerId.toMultihash().bytes,addrs:[n.multiaddr.bytes]}}},{signal:s}),a.read({signal:s})]);if(c.type!==Me.MessageType.DIAL_RESPONSE||c.dialResponse==null){this.log("invalid autonat response from %p - %j",e.remotePeer,c);return}const l=c.dialResponse.status;if(this.log.trace("autonat response from %p for %a is %s",e.remotePeer,n.multiaddr,l),l!==Me.ResponseStatus.OK&&l!==Me.ResponseStatus.E_DIAL_ERROR)return;if(i=this.dialResults.get(n.multiaddr.toString()),i==null){this.log.trace("peer reported %a as %s but there is no result object",n.multiaddr,c.dialResponse.status);return}if(i.networkSegments.includes(t)){this.log.trace("%a results included network segment %s",n.multiaddr,t);return}if(i.result!=null){this.log.trace("already resolved result for %a, ignoring response from",n.multiaddr,e.remotePeer);return}if(i.verifyingPeers.has(e.remotePeer)){this.log.trace("peer %p has already verified %a, ignoring response",e.remotePeer,n.multiaddr);return}if(i.verifyingPeers.add(e.remotePeer),i.networkSegments.push(t),l===Me.ResponseStatus.OK){if(i.success++,i.type!=="observed"){this.confirmAddress(i);return}}else l===Me.ResponseStatus.E_DIAL_ERROR&&i.failure++;this.log("%a success %d failure %d",i.multiaddr,i.success,i.failure),i.success===n4&&this.confirmAddress(i),i.failure===i4&&this.unconfirmAddress(i)}finally{try{await o.close({signal:s})}catch(a){o.abort(a)}}}hasConnectionCapacity(){const t=this.components.connectionManager.getConnections().length,n=this.components.connectionManager.getMaxConnections();return t/n*100<this.connectionThreshold}confirmAddress(e){this.log("%s address %a is externally dialable",e.type,e.multiaddr),this.components.addressManager.confirmObservedAddr(e.multiaddr),this.dialResults.delete(e.multiaddr.toString()),e.result=!0,e.queue.abort()}unconfirmAddress(e){this.log("%s address %a is not externally dialable",e.type,e.multiaddr),this.components.addressManager.removeObservedAddr(e.multiaddr),this.dialResults.delete(e.multiaddr.toString()),e.result=!1,e.queue.abort()}getNetworkSegment(e){const t=e.toOptions();return t.family===4?t.host.split(".")[0].padStart(3,"0"):t.host.split(":")[0].padStart(4,"0")}}function o4(r={}){return e=>new s4(e,r)}var tf,mv;function a4(){if(mv)return tf;mv=1;function r(t){return t>=55296&&t<=56319}function e(t){return t>=56320&&t<=57343}return tf=function(n,i,s){if(typeof i!="string")throw new Error("Input must be string");for(var o=i.length,a=0,c,l,u=0;u<o;u+=1){if(c=i.charCodeAt(u),l=i[u],r(c)&&e(i.charCodeAt(u+1))&&(u+=1,l+=i[u]),a+=n(l),a===s)return i.slice(0,u+1);if(a>s)return i.slice(0,u-l.length+1)}return i},tf}var rf,yv;function c4(){if(yv)return rf;yv=1;function r(t){return t>=55296&&t<=56319}function e(t){return t>=56320&&t<=57343}return rf=function(n){if(typeof n!="string")throw new Error("Input must be string");for(var i=n.length,s=0,o=null,a=null,c=0;c<i;c++)o=n.charCodeAt(c),e(o)?a!=null&&r(a)?s+=1:s+=3:o<=127?s+=1:o>=128&&o<=2047?s+=2:o>=2048&&o<=65535&&(s+=3),a=o;return s},rf}var nf,wv;function l4(){if(wv)return nf;wv=1;var r=a4(),e=c4();return nf=r.bind(null,e),nf}var sf,bv;function u4(){if(bv)return sf;bv=1;var r=l4(),e=/[\/\?<>\\:\*\|"]/g,t=/[\x00-\x1f\x80-\x9f]/g,n=/^\.+$/,i=/^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i,s=/[\. ]+$/;function o(a,c){if(typeof a!="string")throw new Error("Input must be string");var l=a.replace(e,c).replace(t,c).replace(n,c).replace(i,c).replace(s,c);return r(l,255)}return sf=function(a,c){var l=c&&c.replacement||"",u=o(a,l);return l===""?u:o(u,"")},sf}var d4=u4();const h4=bo(d4),of={alg:"A128GCM",ext:!0,k:"scm9jmO_4BJAgdwWGVulLg",key_ops:["encrypt","decrypt"],kty:"oct"};function Hx(r){const e="AES-GCM";let t=16;const n=12,i="SHA-256",s=16,o=32767,a=Pt.get();t*=8;async function c(d,h){const p=a.getRandomValues(new Uint8Array(s)),m=a.getRandomValues(new Uint8Array(n)),w={name:e,iv:m};typeof h=="string"&&(h=Z(h));let y;if(h.length===0){y=await a.subtle.importKey("jwk",of,{name:"AES-GCM"},!0,["encrypt"]);try{const _={name:"PBKDF2",salt:p,iterations:o,hash:{name:i}},E=await a.subtle.importKey("raw",h,{name:"PBKDF2"},!1,["deriveKey"]);y=await a.subtle.deriveKey(_,E,{name:e,length:t},!0,["encrypt"])}catch{y=await a.subtle.importKey("jwk",of,{name:"AES-GCM"},!0,["encrypt"])}}else{const _={name:"PBKDF2",salt:p,iterations:o,hash:{name:i}},E=await a.subtle.importKey("raw",h,{name:"PBKDF2"},!1,["deriveKey"]);y=await a.subtle.deriveKey(_,E,{name:e,length:t},!0,["encrypt"])}const b=await a.subtle.encrypt(w,y,d);return qr([p,w.iv,new Uint8Array(b)])}async function l(d,h){const p=d.subarray(0,s),m=d.subarray(s,s+n),w=d.subarray(s+n),y={name:e,iv:m};typeof h=="string"&&(h=Z(h));let b;if(h.length===0)try{const E={name:"PBKDF2",salt:p,iterations:o,hash:{name:i}},R=await a.subtle.importKey("raw",h,{name:"PBKDF2"},!1,["deriveKey"]);b=await a.subtle.deriveKey(E,R,{name:e,length:t},!0,["decrypt"])}catch{b=await a.subtle.importKey("jwk",of,{name:"AES-GCM"},!0,["decrypt"])}else{const E={name:"PBKDF2",salt:p,iterations:o,hash:{name:i}},R=await a.subtle.importKey("raw",h,{name:"PBKDF2"},!1,["deriveKey"]);b=await a.subtle.deriveKey(E,R,{name:e,length:t},!0,["decrypt"])}const _=await a.subtle.decrypt(y,b,w);return new Uint8Array(_)}return{encrypt:c,decrypt:l}}const f4=16,dg=32,hg=1e4;async function Zd(r,e){const n=await Hx().encrypt(r,e);return Va.encode(n)}async function vv(r,e,t){if(r.type==="RSA")return y4(r,e,t);if(r.type==="Ed25519")return p4(r,e,t);if(r.type==="secp256k1")return g4(r,e,t);if(r.type==="ECDSA")return m4(r,e,t);throw new uo}async function p4(r,e,t="libp2p-key"){if(t==="libp2p-key")return Zd(Ya(r),e);throw new q(`export format '${t}' is not supported`)}async function g4(r,e,t="libp2p-key"){if(t==="libp2p-key")return Zd(Ya(r),e);throw new q("Export format is not supported")}async function m4(r,e,t="libp2p-key"){if(t==="libp2p-key")return Zd(Ya(r),e);throw new q(`export format '${t}' is not supported`)}async function y4(r,e,t="pkcs-8"){if(t==="pkcs-8")return w4(r,e);if(t==="libp2p-key")return Zd(Ya(r),e);throw new q("Export format is not supported")}async function w4(r,e){const t=Pt.get(),i=new nt({value:[new ln({value:0}),new nt({value:[new en({value:"1.2.840.113549.1.1.1"}),new pn]}),new br({valueHex:r.raw})]}).toBER(),s=new Uint8Array(i,0,i.byteLength),o=Ds(f4),a=await XE(om,e,o,{c:hg,dkLen:dg}),c=Ds(16),l=await t.subtle.importKey("raw",a,"AES-CBC",!1,["encrypt"]),u=await t.subtle.encrypt({name:"AES-CBC",iv:c},l,s),d=new nt({value:[new br({valueHex:o}),new ln({value:hg}),new ln({value:dg}),new nt({value:[new en({value:"1.2.840.113549.2.11"}),new pn]})]}),h=new nt({value:[new en({value:"1.2.840.113549.1.5.13"}),new nt({value:[new nt({value:[new en({value:"1.2.840.113549.1.5.12"}),d]}),new nt({value:[new en({value:"2.16.840.1.101.3.4.1.42"}),new br({valueHex:c})]})]})]}),m=new nt({value:[h,new br({valueHex:u})]}).toBER(),w=new Uint8Array(m,0,m.byteLength);return["-----BEGIN ENCRYPTED PRIVATE KEY-----",...ne(w,"base64pad").split(/(.{64})/).filter(Boolean),"-----END ENCRYPTED PRIVATE KEY-----"].join(`
`)}async function Sv(r,e){try{const t=await b4(r,e);return bT(t)}catch{}if(!r.includes("BEGIN"))throw new q("Encrypted key was not a libp2p-key or a PEM file");return v4(r,e)}async function b4(r,e){const t=Va.decode(r);return Hx().decrypt(t,e)}async function v4(r,e){const t=Pt.get();let n;if(r.includes("-----BEGIN ENCRYPTED PRIVATE KEY-----")){const s=Z(r.replace("-----BEGIN ENCRYPTED PRIVATE KEY-----","").replace("-----END ENCRYPTED PRIVATE KEY-----","").replace(/\n/g,"").trim(),"base64pad"),{result:o}=cn(s),{iv:a,salt:c,iterations:l,keySize:u,cipherText:d}=S4(o),h=await XE(om,e,c,{c:l,dkLen:u}),p=await t.subtle.importKey("raw",h,"AES-CBC",!1,["decrypt"]),m=ha(await t.subtle.decrypt({name:"AES-CBC",iv:a},p,d)),{result:w}=cn(m);n=Ev(w)}else if(r.includes("-----BEGIN PRIVATE KEY-----")){const s=Z(r.replace("-----BEGIN PRIVATE KEY-----","").replace("-----END PRIVATE KEY-----","").replace(/\n/g,"").trim(),"base64pad"),{result:o}=cn(s);n=Ev(o)}else throw new q("Could not parse private key from PEM data");const i=vT(n);if(i.type!=="RSA")throw new q("Could not parse RSA private key from PEM data");return i}function S4(r){const e=r.valueBlock.value[0];if(e.valueBlock.value[0].toString()!=="OBJECT IDENTIFIER : 1.2.840.113549.1.5.13")throw new q("Only pkcs5PBES2 encrypted private keys are supported");const n=e.valueBlock.value[1].valueBlock.value[0];if(n.valueBlock.value[0].toString()!=="OBJECT IDENTIFIER : 1.2.840.113549.1.5.12")throw new q("Only pkcs5PBKDF2 key derivation functions are supported");const s=n.valueBlock.value[1],o=ha(s.valueBlock.value[0].getValue());let a=hg,c=dg;if(s.valueBlock.value.length===3)a=Number(s.valueBlock.value[1].toBigInt()),c=Number(s.valueBlock.value[2].toBigInt());else if(s.valueBlock.value.length===2)throw new q("Could not derive key size and iterations from PEM file - please use @libp2p/rsa to re-import your key");const l=e.valueBlock.value[1].valueBlock.value[1],u=l.valueBlock.value[0].toString();if(u!=="OBJECT IDENTIFIER : 1.2.840.113549.3.7"){if(u!=="OBJECT IDENTIFIER : 1.3.14.3.2.7"){if(u!=="OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.2"){if(u!=="OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.22"){if(u!=="OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.42")throw new q("Only AES-CBC encryption schemes are supported")}}}}const d=ha(l.valueBlock.value[1].getValue());return{cipherText:ha(r.valueBlock.value[1].getValue()),salt:o,iterations:a,keySize:c,iv:d}}function Ev(r){return ha(r.valueBlock.value[2].getValue())}function ha(r){return new Uint8Array(r,0,r.byteLength)}const E4="/pkcs8/",fg="/info/",Ko=new WeakMap,oi={minKeyLength:112/8,minSaltLength:128/8,minIterationCount:1e3},af={dek:{keyLength:512/8,iterationCount:1e4,salt:"you should override this value with a crypto secure random number",hash:"sha2-512"}};function hs(r){return r==null||typeof r!="string"?!1:r===h4(r.trim())&&r.length>0}async function ot(){const t=Math.random()*800+200;await new Promise(n=>setTimeout(n,t))}function ai(r){return new rt(E4+r)}function fs(r){return new rt(fg+r)}async function A4(r){const e=Ya(r),t=await Xi.digest(e);return Qe.encode(t.bytes).substring(1)}class x4{components;init;log;self;constructor(e,t){if(this.components=e,this.log=e.logger.forComponent("libp2p:keychain"),this.init=ny(af,t),this.self=t.selfKey??"self",this.init.pass!=null&&this.init.pass?.length<20)throw new Error("pass must be least 20 characters");if(this.init.dek?.keyLength!=null&&this.init.dek.keyLength<oi.minKeyLength)throw new Error(`dek.keyLength must be least ${oi.minKeyLength} bytes`);if(this.init.dek?.salt?.length!=null&&this.init.dek.salt.length<oi.minSaltLength)throw new Error(`dek.saltLength must be least ${oi.minSaltLength} bytes`);if(this.init.dek?.iterationCount!=null&&this.init.dek.iterationCount<oi.minIterationCount)throw new Error(`dek.iterationCount must be least ${oi.minIterationCount}`);const n=this.init.pass!=null&&this.init.dek?.salt!=null?$w(this.init.pass,this.init.dek?.salt,this.init.dek?.iterationCount,this.init.dek?.keyLength,this.init.dek?.hash):"";Ko.set(this,{dek:n})}[Symbol.toStringTag]="@libp2p/keychain";[$t]=["@libp2p/keychain"];static generateOptions(){const e=Object.assign({},af),t=Math.ceil(oi.minSaltLength/3)*3;return e.dek.salt=ne(Ds(t),"base64"),e}static get options(){return af}async findKeyByName(e){if(!hs(e))throw await ot(),new q(`Invalid key name '${e}'`);const t=fs(e);try{const n=await this.components.datastore.get(t);return JSON.parse(ne(n))}catch(n){throw await ot(),this.log.error(n),new Nn(`Key '${e}' does not exist.`)}}async findKeyById(e){try{const t={prefix:fg};for await(const n of this.components.datastore.query(t)){const i=JSON.parse(ne(n.value));if(i.id===e)return i}throw new q(`Key with id '${e}' does not exist.`)}catch(t){throw await ot(),t}}async importKey(e,t){if(!hs(e))throw await ot(),new q(`Invalid key name '${e}'`);if(t==null)throw await ot(),new q("Key is required");const n=ai(e);if(await this.components.datastore.has(n))throw await ot(),new q(`Key '${e}' already exists`);let s,o;try{s=await A4(t);const l=Ko.get(this);if(l==null)throw new q("dek missing");const u=l.dek;o=await vv(t,u,t.type==="RSA"?"pkcs-8":"libp2p-key")}catch(l){throw await ot(),l}const a={name:e,id:s},c=this.components.datastore.batch();return c.put(n,Z(o)),c.put(fs(e),Z(JSON.stringify(a))),await c.commit(),a}async exportKey(e){if(!hs(e))throw await ot(),new q(`Invalid key name '${e}'`);const t=ai(e);try{const n=await this.components.datastore.get(t),i=ne(n),s=Ko.get(this);if(s==null)throw new q("dek missing");const o=s.dek;return await Sv(i,o)}catch(n){throw await ot(),n}}async removeKey(e){if(!hs(e)||e===this.self)throw await ot(),new q(`Invalid key name '${e}'`);const t=ai(e),n=await this.findKeyByName(e),i=this.components.datastore.batch();return i.delete(t),i.delete(fs(e)),await i.commit(),n}async listKeys(){const e={prefix:fg},t=[];for await(const n of this.components.datastore.query(e))t.push(JSON.parse(ne(n.value)));return t}async renameKey(e,t){if(!hs(e)||e===this.self)throw await ot(),new q(`Invalid old key name '${e}'`);if(!hs(t)||t===this.self)throw await ot(),new q(`Invalid new key name '${t}'`);const n=ai(e),i=ai(t),s=fs(e),o=fs(t);if(await this.components.datastore.has(i))throw await ot(),new q(`Key '${t}' already exists`);try{const c=await this.components.datastore.get(n),l=await this.components.datastore.get(s),u=JSON.parse(ne(l));u.name=t;const d=this.components.datastore.batch();return d.put(i,c),d.put(o,Z(JSON.stringify(u))),d.delete(n),d.delete(s),await d.commit(),u}catch(c){throw await ot(),c}}async rotateKeychainPass(e,t){if(typeof e!="string")throw await ot(),new q(`Invalid old pass type '${typeof e}'`);if(typeof t!="string")throw await ot(),new q(`Invalid new pass type '${typeof t}'`);if(t.length<20)throw await ot(),new q(`Invalid pass length ${t.length}`);this.log("recreating keychain");const n=Ko.get(this);if(n==null)throw new q("dek missing");const i=n.dek;this.init.pass=t;const s=t!=null&&this.init.dek?.salt!=null?$w(t,this.init.dek.salt,this.init.dek?.iterationCount,this.init.dek?.keyLength,this.init.dek?.hash):"";Ko.set(this,{dek:s});const o=await this.listKeys();for(const a of o){const c=await this.components.datastore.get(ai(a.name)),l=ne(c),u=await Sv(l,i),d=s.toString(),h=await vv(u,d,u.type==="RSA"?"pkcs-8":"libp2p-key"),p=this.components.datastore.batch(),m={name:a.name,id:a.id};p.put(ai(a.name),Z(h)),p.put(fs(a.name),Z(JSON.stringify(m))),await p.commit()}this.log("keychain reconstructed")}}function _4(r={}){return e=>new x4(e,r)}var Or;(function(r){(function(n){n.UNUSED="UNUSED",n.CONNECT="CONNECT",n.SYNC="SYNC"})(r.Type||(r.Type={}));let e;(function(n){n[n.UNUSED=0]="UNUSED",n[n.CONNECT=100]="CONNECT",n[n.SYNC=300]="SYNC"})(e||(e={})),function(n){n.codec=()=>hn(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=Oe((n,i,s={})=>{if(s.lengthDelimited!==!1&&i.fork(),n.type!=null&&(i.uint32(8),r.Type.codec().encode(n.type,i)),n.observedAddresses!=null)for(const o of n.observedAddresses)i.uint32(18),i.bytes(o);s.lengthDelimited!==!1&&i.ldelim()},(n,i,s={})=>{const o={observedAddresses:[]},a=i==null?n.len:n.pos+i;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{if(s.limits?.observedAddresses!=null&&o.observedAddresses.length===s.limits.observedAddresses)throw new Ar('Decode error - map field "observedAddresses" had too many elements');o.observedAddresses.push(n.bytes());break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>Re(n,r.codec()),r.decode=(n,i)=>Pe(n,r.codec(),i)})(Or||(Or={}));function Av(r,e){return Yn.matches(r)||e.dialTransportForMultiaddr(r)==null?!1:TO.matches(r)?!0:RO.matches(r)?ec(r.toOptions().host)===!1:!1}const xv=1024*4,_v=100,Jc={timeout:5e3,retries:3,maxInboundStreams:1,maxOutboundStreams:1};class C4{started;timeout;retries;maxInboundStreams;maxOutboundStreams;peerStore;registrar;connectionManager;addressManager;transportManager;topologyId;log;constructor(e,t){this.log=e.logger.forComponent("libp2p:dcutr"),this.started=!1,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.connectionManager=e.connectionManager,this.transportManager=e.transportManager,this.timeout=t.timeout??Jc.timeout,this.retries=t.retries??Jc.retries,this.maxInboundStreams=t.maxInboundStreams??Jc.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??Jc.maxOutboundStreams}[Symbol.toStringTag]="@libp2p/dcutr";[Os]=["@libp2p/identify"];isStarted(){return this.started}async start(){this.started||(this.topologyId=await this.registrar.register(Xc,{notifyOnLimitedConnection:!0,onConnect:(e,t)=>{Yn.exactMatch(t.remoteAddr)&&t.direction==="inbound"&&this.upgradeInbound(t).catch(n=>{this.log.error("error during outgoing DCUtR attempt",n)})}}),await this.registrar.handle(Xc,e=>{this.handleIncomingUpgrade(e.stream,e.connection).catch(t=>{this.log.error("error during incoming DCUtR attempt",t),e.stream.abort(t)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:!0}),this.started=!0)}async stop(){await this.registrar.unhandle(Xc),this.topologyId!=null&&this.registrar.unregister(this.topologyId),this.started=!1}async upgradeInbound(e){if(await this.attemptUnilateralConnectionUpgrade(e))return;let t;for(let n=0;n<this.retries;n++){const i={signal:AbortSignal.timeout(this.timeout)};try{t=await e.newStream([Xc],{signal:i.signal,runOnLimitedConnection:!0});const s=Qt(t,{maxDataLength:xv}).pb(Or);this.log("B sending connect to %p",e.remotePeer);const o=Date.now();await s.write({type:Or.Type.CONNECT,observedAddresses:this.addressManager.getAddresses().map(d=>d.bytes)},i),this.log("B receiving connect from %p",e.remotePeer);const a=await s.read(i);if(a.type!==Or.Type.CONNECT)throw this.log("A sent wrong message type"),new bt("DCUtR message type was incorrect");const c=this.getDialableMultiaddrs(a.observedAddresses);if(c.length===0)throw this.log("A did not have any dialable multiaddrs"),new bt("DCUtR connect message had no multiaddrs");const l=Date.now()-o;this.log("A sending sync, rtt %dms",l),await s.write({type:Or.Type.SYNC,observedAddresses:[]},i),this.log("A waiting for half RTT"),await Dx(l/2),this.log("B dialing",c);const u=await this.connectionManager.openConnection(c,{signal:i.signal,priority:_v,force:!0,initiator:!1});this.log("DCUtR to %p succeeded to address %a, closing relayed connection",e.remotePeer,u.remoteAddr),await e.close(i);break}catch(s){if(this.log.error("error while attempting DCUtR on attempt %d of %d",n+1,this.retries,s),t?.abort(s),n===this.retries)throw s}finally{t!=null&&await t.close(i)}}}async attemptUnilateralConnectionUpgrade(e){const n=(await this.peerStore.get(e.remotePeer)).addresses.map(i=>{const s=i.multiaddr;return s.getPeerId()==null?s.encapsulate(`/p2p/${e.remotePeer}`):s}).filter(i=>Av(i,this.transportManager));if(n.length>0){const i=AbortSignal.timeout(this.timeout);try{this.log("attempting unilateral connection upgrade to %a",n);const s=await this.connectionManager.openConnection(n,{signal:i,force:!0});if(Yn.exactMatch(s.remoteAddr))throw new Error("Could not open a new, non-limited, connection");return this.log("unilateral connection upgrade to %p succeeded via %a, closing relayed connection",e.remotePeer,s.remoteAddr),await e.close({signal:i}),!0}catch(s){this.log.error("unilateral connection upgrade to %p on addresses %a failed",e.remotePeer,n,s)}}else this.log("peer %p has no public addresses, not attempting unilateral connection upgrade",e.remotePeer);return!1}async handleIncomingUpgrade(e,t){const n={signal:AbortSignal.timeout(this.timeout)};try{const i=Qt(e,{maxDataLength:xv}).pb(Or);this.log("A receiving connect");const s=await i.read(n);if(s.type!==Or.Type.CONNECT)throw this.log("B sent wrong message type"),new bt("DCUtR message type was incorrect");if(s.observedAddresses.length===0)throw this.log("B sent no multiaddrs"),new bt("DCUtR connect message had no multiaddrs");const o=this.getDialableMultiaddrs(s.observedAddresses);if(o.length===0)throw this.log("B had no dialable multiaddrs"),new bt("DCUtR connect message had no dialable multiaddrs");if(this.log("A sending connect"),await i.write({type:Or.Type.CONNECT,observedAddresses:this.addressManager.getAddresses().map(l=>l.bytes)}),this.log("A receiving sync"),(await i.read(n)).type!==Or.Type.SYNC)throw new bt("DCUtR message type was incorrect");this.log("A dialing",o);const c=await this.connectionManager.openConnection(o,{signal:n.signal,priority:_v,force:!0});this.log("DCUtR to %p succeeded via %a, closing relayed connection",t.remotePeer,c.remoteAddr),await t.close(n)}catch(i){this.log.error("incoming DCUtR from %p failed",t.remotePeer,i),e.abort(i)}finally{await e.close(n)}}getDialableMultiaddrs(e){const t=[];for(const n of e)if(!(n==null||n.length===0))try{const i=de(n);if(!Av(i,this.transportManager))continue;t.push(i)}catch{}return t}}const Xc="/libp2p/dcutr";function I4(r={}){return e=>new C4(e,r)}class k4{mode;connections;activeTransfer;finished;selectedFile;activePeerId;activeStream;transferConnectionId;constructor(){this.mode="idle",this.connections=new Map,this.activeTransfer=!1,this.finished=!1,this.selectedFile=null,this.activePeerId=null,this.activeStream=null,this.transferConnectionId=null}setMode(e){this.mode=e}getMode(){return this.mode}reset(){this.mode="idle",this.connections.clear(),this.activeTransfer=!1,this.finished=!1,this.selectedFile=null,this.activePeerId=null,this.activeStream=null,this.transferConnectionId=null}addConnection(e,t){const n=this.connections.get(e.toString())||new Map;n.set(t.id,t),this.connections.set(e.toString(),n)}removeConnection(e,t){const n=this.connections.get(e);n?.delete(t),n&&this.connections.set(e,n)}removeAllConnectionsWithPeer(e){this.connections.delete(e)}getConnectionsForPeer(e){return this.connections.get(e)}getAllConnections(){return Array.from(this.connections.values())}setActiveTransfer(){this.activeTransfer=!0}clearActiveTransfer(){this.activeTransfer=!1}isTransferActive(){return!!this.activeTransfer}setTransferConnectionId(e){this.transferConnectionId=e}getTransferConnectionId(){return this.transferConnectionId}setSelectedFile(e){this.selectedFile=e}getSelectedFile(){return this.selectedFile}clearSelectedFile(){this.selectedFile=null}setActivePeer(e){this.activePeerId=e}getActivePeer(){return this.activePeerId}setActiveStream(e){this.activeStream=e}getActiveStream(){return this.activeStream}isFinished(){return this.finished||!1}declareFinished(){this.finished=!0}}class T4{node;appState;errorHandler;config;fileTransferHandler;connectionUpgrades;retryAttempts;constructor(e,t,n,i,s){this.node=e,this.appState=t,this.errorHandler=n,this.config=i,this.fileTransferHandler=s,this.connectionUpgrades=new Map,this.retryAttempts=new Map}async onConnectionEstablished(e){const t=e.detail,n=t.remotePeer,i=n.toString(),s=t.remoteAddr.toString();console.log(`Connection OPENED with: ${i} on ${s}`),this.appState.addConnection(n,t),await this.handleConnectionType(t,i,s)}async onConnectionClosed(e){const t=e.detail.remotePeer.toString(),n=e.detail.id;this.connectionUpgrades.delete(n),this.appState.isTransferActive()&&t===this.appState.getActivePeer()&&this.appState.getTransferConnectionId()===n&&!this.appState.isFinished()&&(this.errorHandler.reconnecting(),this.appState.getMode()==="sender"?await this.onSenderConnectionError(e):this.appState.getMode()==="receiver"&&await this.onReceiverConnectionError(t)),this.appState.removeConnection(t,n)}async onReceiverConnectionError(e){const t=new Promise(i=>{const s=o=>{o.detail.remotePeer.toString()===e&&this.appState.isTransferActive()&&(this.node.removeEventListener("connection:open",s),i())};this.node.addEventListener("connection:open",s)}),n=new Promise(i=>{setTimeout(()=>{i()},3e4)});try{await Promise.race([t,n])}catch{}await this.fileTransferHandler.transferComplete(),this.errorHandler.tryAgainError()}async onSenderConnectionError(e){const t=e.detail.remotePeer.toString(),n=2e3;let i=this.retryAttempts.get(t)||0;for(;i<4;){console.log(`Attempting to reconnect to ${t}...`);try{await this.dialPeer(e.detail.remotePeer,{signal:AbortSignal.timeout(5e3)}),this.errorHandler.reconnected();break}catch{i++,this.retryAttempts.set(t,i),await new Promise(o=>setTimeout(o,n*i))}}i>=4&&(this.appState.declareFinished(),await this.node.stop(),this.errorHandler.tryAgainError())}async dialPeer(e,t={}){try{return await this.node.dial(e,t)}catch(n){throw n}}async closePeer(e){const t=this.appState.getConnectionsForPeer(e.toString());if(t)for(const n of t.values())n&&(await n.close(),t.delete(n.id))}async handleConnectionType(e,t,n){const i=this.config.getRelayAddress();if(n.includes("/webrtc")){if(console.log(n.includes("/webrtc"),"WebRTC connection established"),this.appState.getMode()==="sender"&&this.appState.getSelectedFile()!=null){const s=de(n),o=await this.node.dialProtocol(s,this.config.getFileTransferProtocol());this.appState.setTransferConnectionId(e.id),this.appState.setActivePeer(t),this.appState.setActiveStream(o),this.fileTransferHandler.startFileTransfer(),console.log("Starting file transfer with",t)}}else n===i&&console.log(`Direct relay connection established for ${t}`)}}/**
 * @license
 * web-streams-polyfill v4.1.0
 * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
 * This code is released under the MIT license.
 * SPDX-License-Identifier: MIT
 */function Fa(){}function it(r){return typeof r=="object"&&r!==null||typeof r=="function"}const Wx=Fa;function we(r,e){try{Object.defineProperty(r,"name",{value:e,configurable:!0})}catch{}}const sy=Promise,P4=Promise.resolve.bind(sy),R4=Promise.prototype.then,O4=Promise.reject.bind(sy),B4=P4;function _t(r){return new sy(r)}function Ae(r){return _t(e=>e(r))}function oe(r){return O4(r)}function Nr(r,e,t){return R4.call(r,e,t)}function _r(r,e,t){Nr(Nr(r,e,t),void 0,Wx)}function cf(r,e){_r(r,e)}function pg(r,e){_r(r,void 0,e)}function Ti(r,e,t){return Nr(r,e,t)}function bc(r){Nr(r,void 0,Wx)}let Pi=r=>{if(typeof queueMicrotask=="function")Pi=queueMicrotask;else{const e=Ae(void 0);Pi=t=>Nr(e,t)}return Pi(r)};function oo(r,e,t){if(typeof r!="function")throw new TypeError("Argument is not a function");return Function.prototype.apply.call(r,e,t)}function Ro(r,e,t){try{return Ae(oo(r,e,t))}catch(n){return oe(n)}}class ur{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push(e){const t=this._back;let n=t;t._elements.length===16383&&(n={_elements:[],_next:void 0}),t._elements.push(e),n!==t&&(this._back=n,t._next=n),++this._size}shift(){const e=this._front;let t=e;const n=this._cursor;let i=n+1;const s=e._elements,o=s[n];return i===16384&&(t=e._next,i=0),--this._size,this._cursor=i,e!==t&&(this._front=t),s[n]=void 0,o}forEach(e){let t=this._cursor,n=this._front,i=n._elements;for(;!(t===i.length&&n._next===void 0||t===i.length&&(n=n._next,i=n._elements,t=0,i.length===0));)e(i[t]),++t}peek(){const e=this._front,t=this._cursor;return e._elements[t]}}const Gx=Symbol("[[AbortSteps]]"),Yx=Symbol("[[ErrorSteps]]"),oy=Symbol("[[CancelSteps]]"),ay=Symbol("[[PullSteps]]"),cy=Symbol("[[ReleaseSteps]]");function Qx(r,e){r._ownerReadableStream=e,e._reader=r,e._state==="readable"?gg(r):e._state==="closed"?function(t){gg(t),Xx(t)}(r):Jx(r,e._storedError)}function ly(r,e){return yr(r._ownerReadableStream,e)}function nn(r){const e=r._ownerReadableStream;e._state==="readable"?uy(r,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):function(t,n){Jx(t,n)}(r,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),e._readableStreamController[cy](),e._reader=void 0,r._ownerReadableStream=void 0}function Fu(r){return new TypeError("Cannot "+r+" a stream using a released reader")}function gg(r){r._closedPromise=_t((e,t)=>{r._closedPromise_resolve=e,r._closedPromise_reject=t})}function Jx(r,e){gg(r),uy(r,e)}function uy(r,e){r._closedPromise_reject!==void 0&&(bc(r._closedPromise),r._closedPromise_reject(e),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0)}function Xx(r){r._closedPromise_resolve!==void 0&&(r._closedPromise_resolve(void 0),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0)}const Cv=Number.isFinite||function(r){return typeof r=="number"&&isFinite(r)},N4=Math.trunc||function(r){return r<0?Math.ceil(r):Math.floor(r)};function $n(r,e){if(r!==void 0&&typeof(t=r)!="object"&&typeof t!="function")throw new TypeError(`${e} is not an object.`);var t}function ii(r,e){if(typeof r!="function")throw new TypeError(`${e} is not a function.`)}function Zx(r,e){if(!function(t){return typeof t=="object"&&t!==null||typeof t=="function"}(r))throw new TypeError(`${e} is not an object.`)}function Gi(r,e,t){if(r===void 0)throw new TypeError(`Parameter ${e} is required in '${t}'.`)}function Iv(r,e,t){if(r===void 0)throw new TypeError(`${e} is required in '${t}'.`)}function e_(r){return Number(r)}function kv(r){return r===0?0:r}function dy(r,e){const t=Number.MAX_SAFE_INTEGER;let n=Number(r);if(n=kv(n),!Cv(n))throw new TypeError(`${e} is not a finite number`);if(n=function(i){return kv(N4(i))}(n),n<0||n>t)throw new TypeError(`${e} is outside the accepted range of 0 to ${t}, inclusive`);return Cv(n)&&n!==0?n:0}function hy(r,e){if(!Tn(r))throw new TypeError(`${e} is not a ReadableStream.`)}function Ts(r){return new fi(r)}function t_(r,e){r._reader._readRequests.push(e)}function fy(r,e,t){const n=r._reader._readRequests.shift();t?n._closeSteps():n._chunkSteps(e)}function eh(r){return r._reader._readRequests.length}function r_(r){const e=r._reader;return e!==void 0&&!!qn(e)}class fi{constructor(e){if(Gi(e,1,"ReadableStreamDefaultReader"),hy(e,"First parameter"),Kn(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");Qx(this,e),this._readRequests=new ur}get closed(){return qn(this)?this._closedPromise:oe(Zc("closed"))}cancel(e=void 0){return qn(this)?this._ownerReadableStream===void 0?oe(Fu("cancel")):ly(this,e):oe(Zc("cancel"))}read(){if(!qn(this))return oe(Zc("read"));if(this._ownerReadableStream===void 0)return oe(Fu("read from"));let e,t;const n=_t((i,s)=>{e=i,t=s});return Ua(this,{_chunkSteps:i=>e({value:i,done:!1}),_closeSteps:()=>e({value:void 0,done:!0}),_errorSteps:i=>t(i)}),n}releaseLock(){if(!qn(this))throw Zc("releaseLock");this._ownerReadableStream!==void 0&&function(e){nn(e);const t=new TypeError("Reader was released");n_(e,t)}(this)}}function qn(r){return!!it(r)&&!!Object.prototype.hasOwnProperty.call(r,"_readRequests")&&r instanceof fi}function Ua(r,e){const t=r._ownerReadableStream;t._disturbed=!0,t._state==="closed"?e._closeSteps():t._state==="errored"?e._errorSteps(t._storedError):t._readableStreamController[ay](e)}function n_(r,e){const t=r._readRequests;r._readRequests=new ur,t.forEach(n=>{n._errorSteps(e)})}function Zc(r){return new TypeError(`ReadableStreamDefaultReader.prototype.${r} can only be used on a ReadableStreamDefaultReader`)}var lf,uf,df;function Go(r){return r.slice()}function i_(r,e,t,n,i){new Uint8Array(r).set(new Uint8Array(t,n,i),e)}Object.defineProperties(fi.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),we(fi.prototype.cancel,"cancel"),we(fi.prototype.read,"read"),we(fi.prototype.releaseLock,"releaseLock"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(fi.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0});let Yi=r=>(Yi=typeof r.transfer=="function"?e=>e.transfer():typeof structuredClone=="function"?e=>structuredClone(e,{transfer:[e]}):e=>e,Yi(r)),Qi=r=>(Qi=typeof r.detached=="boolean"?e=>e.detached:e=>e.byteLength===0,Qi(r));function s_(r,e,t){if(r.slice)return r.slice(e,t);const n=t-e,i=new ArrayBuffer(n);return i_(i,0,r,e,n),i}function Yo(r,e){const t=r[e];if(t!=null){if(typeof t!="function")throw new TypeError(`${String(e)} is not a function`);return t}}function Tv(r){try{const e=r.done,t=r.value;return Nr(B4(t),n=>({done:e,value:n}))}catch(e){return oe(e)}}const vc=(df=(lf=Symbol.asyncIterator)!==null&&lf!==void 0?lf:(uf=Symbol.for)===null||uf===void 0?void 0:uf.call(Symbol,"Symbol.asyncIterator"))!==null&&df!==void 0?df:"@@asyncIterator";function o_(r,e="sync",t){if(t===void 0)if(e==="async"){if((t=Yo(r,vc))===void 0)return function(i){const s={next(){let o;try{o=a_(i)}catch(a){return oe(a)}return Tv(o)},return(o){let a;try{const c=Yo(i.iterator,"return");if(c===void 0)return Ae({done:!0,value:o});a=oo(c,i.iterator,[o])}catch(c){return oe(c)}return it(a)?Tv(a):oe(new TypeError("The iterator.return() method must return an object"))}};return{iterator:s,nextMethod:s.next,done:!1}}(o_(r,"sync",Yo(r,Symbol.iterator)))}else t=Yo(r,Symbol.iterator);if(t===void 0)throw new TypeError("The object is not iterable");const n=oo(t,r,[]);if(!it(n))throw new TypeError("The iterator method must return an object");return{iterator:n,nextMethod:n.next,done:!1}}function a_(r){const e=oo(r.nextMethod,r.iterator,[]);if(!it(e))throw new TypeError("The iterator.next() method must return an object");return e}class c_{constructor(e,t){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=e,this._preventCancel=t}next(){const e=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?Ti(this._ongoingPromise,e,e):e(),this._ongoingPromise}return(e){const t=()=>this._returnSteps(e);return this._ongoingPromise=this._ongoingPromise?Ti(this._ongoingPromise,t,t):t(),this._ongoingPromise}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:!0});const e=this._reader;let t,n;const i=_t((s,o)=>{t=s,n=o});return Ua(e,{_chunkSteps:s=>{this._ongoingPromise=void 0,Pi(()=>t({value:s,done:!1}))},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,nn(e),t({value:void 0,done:!0})},_errorSteps:s=>{this._ongoingPromise=void 0,this._isFinished=!0,nn(e),n(s)}}),i}_returnSteps(e){if(this._isFinished)return Promise.resolve({value:e,done:!0});this._isFinished=!0;const t=this._reader;if(!this._preventCancel){const n=ly(t,e);return nn(t),Ti(n,()=>({value:e,done:!0}))}return nn(t),Ae({value:e,done:!0})}}const l_={next(){return Pv(this)?this._asyncIteratorImpl.next():oe(Rv("next"))},return(r){return Pv(this)?this._asyncIteratorImpl.return(r):oe(Rv("return"))},[vc](){return this}};function Pv(r){if(!it(r)||!Object.prototype.hasOwnProperty.call(r,"_asyncIteratorImpl"))return!1;try{return r._asyncIteratorImpl instanceof c_}catch{return!1}}function Rv(r){return new TypeError(`ReadableStreamAsyncIterator.${r} can only be used on a ReadableSteamAsyncIterator`)}Object.defineProperty(l_,vc,{enumerable:!1});const u_=Number.isNaN||function(r){return r!=r};function Ov(r){const e=s_(r.buffer,r.byteOffset,r.byteOffset+r.byteLength);return new Uint8Array(e)}function mg(r){const e=r._queue.shift();return r._queueTotalSize-=e.size,r._queueTotalSize<0&&(r._queueTotalSize=0),e.value}function py(r,e,t){if(typeof(n=t)!="number"||u_(n)||n<0||t===1/0)throw new RangeError("Size must be a finite, non-NaN, non-negative number.");var n;r._queue.push({value:e,size:t}),r._queueTotalSize+=t}function si(r){r._queue=new ur,r._queueTotalSize=0}function d_(r){return r===DataView}class bs{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!hf(this))throw ff("view");return this._view}respond(e){if(!hf(this))throw ff("respond");if(Gi(e,1,"respond"),e=dy(e,"First parameter"),this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");if(Qi(this._view.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");bl(this._associatedReadableByteStreamController,e)}respondWithNewView(e){if(!hf(this))throw ff("respondWithNewView");if(Gi(e,1,"respondWithNewView"),!ArrayBuffer.isView(e))throw new TypeError("You can only respond with array buffer views");if(this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");if(Qi(e.buffer))throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");vl(this._associatedReadableByteStreamController,e)}}Object.defineProperties(bs.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),we(bs.prototype.respond,"respond"),we(bs.prototype.respondWithNewView,"respondWithNewView"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(bs.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});class Rn{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!pi(this))throw Vo("byobRequest");return wg(this)}get desiredSize(){if(!pi(this))throw Vo("desiredSize");return E_(this)}close(){if(!pi(this))throw Vo("close");if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const e=this._controlledReadableByteStream._state;if(e!=="readable")throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`);Qo(this)}enqueue(e){if(!pi(this))throw Vo("enqueue");if(Gi(e,1,"enqueue"),!ArrayBuffer.isView(e))throw new TypeError("chunk must be an array buffer view");if(e.byteLength===0)throw new TypeError("chunk must have non-zero byteLength");if(e.buffer.byteLength===0)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw new TypeError("stream is closed or draining");const t=this._controlledReadableByteStream._state;if(t!=="readable")throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be enqueued to`);wl(this,e)}error(e=void 0){if(!pi(this))throw Vo("error");er(this,e)}[oy](e){h_(this),si(this);const t=this._cancelAlgorithm(e);return th(this),t}[ay](e){const t=this._controlledReadableByteStream;if(this._queueTotalSize>0)return void S_(this,e);const n=this._autoAllocateChunkSize;if(n!==void 0){let i;try{i=new ArrayBuffer(n)}catch(o){return void e._errorSteps(o)}const s={buffer:i,bufferByteLength:n,byteOffset:0,byteLength:n,bytesFilled:0,minimumFill:1,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(s)}t_(t,e),ns(this)}[cy](){if(this._pendingPullIntos.length>0){const e=this._pendingPullIntos.peek();e.readerType="none",this._pendingPullIntos=new ur,this._pendingPullIntos.push(e)}}}function pi(r){return!!it(r)&&!!Object.prototype.hasOwnProperty.call(r,"_controlledReadableByteStream")&&r instanceof Rn}function hf(r){return!!it(r)&&!!Object.prototype.hasOwnProperty.call(r,"_associatedReadableByteStreamController")&&r instanceof bs}function ns(r){if(function(t){const n=t._controlledReadableByteStream;return n._state!=="readable"||t._closeRequested||!t._started?!1:!!(r_(n)&&eh(n)>0||my(n)&&__(n)>0||E_(t)>0)}(r)){if(r._pulling)return void(r._pullAgain=!0);r._pulling=!0,_r(r._pullAlgorithm(),()=>(r._pulling=!1,r._pullAgain&&(r._pullAgain=!1,ns(r)),null),t=>(er(r,t),null))}}function h_(r){gy(r),r._pendingPullIntos=new ur}function f_(r,e){let t=!1;r._state==="closed"&&(t=!0);const n=p_(e);e.readerType==="default"?fy(r,n,t):function(i,s,o){const a=i._reader,c=a._readIntoRequests.shift();o?c._closeSteps(s):c._chunkSteps(s)}(r,n,t)}function ml(r,e){for(let t=0;t<e.length;++t)f_(r,e[t])}function p_(r){const e=r.bytesFilled,t=r.elementSize;return new r.viewConstructor(r.buffer,r.byteOffset,e/t)}function yl(r,e,t,n){r._queue.push({buffer:e,byteOffset:t,byteLength:n}),r._queueTotalSize+=n}function g_(r,e,t,n){let i;try{i=s_(e,t,t+n)}catch(s){throw er(r,s),s}yl(r,i,0,n)}function m_(r,e){e.bytesFilled>0&&g_(r,e.buffer,e.byteOffset,e.bytesFilled),Ps(r)}function y_(r,e){const t=Math.min(r._queueTotalSize,e.byteLength-e.bytesFilled),n=e.bytesFilled+t;let i=t,s=!1;const o=n-n%e.elementSize;o>=e.minimumFill&&(i=o-e.bytesFilled,s=!0);const a=r._queue;for(;i>0;){const c=a.peek(),l=Math.min(i,c.byteLength),u=e.byteOffset+e.bytesFilled;i_(e.buffer,u,c.buffer,c.byteOffset,l),c.byteLength===l?a.shift():(c.byteOffset+=l,c.byteLength-=l),r._queueTotalSize-=l,w_(r,l,e),i-=l}return s}function w_(r,e,t){t.bytesFilled+=e}function b_(r){r._queueTotalSize===0&&r._closeRequested?(th(r),Sc(r._controlledReadableByteStream)):ns(r)}function gy(r){r._byobRequest!==null&&(r._byobRequest._associatedReadableByteStreamController=void 0,r._byobRequest._view=null,r._byobRequest=null)}function yg(r){const e=[];for(;r._pendingPullIntos.length>0&&r._queueTotalSize!==0;){const t=r._pendingPullIntos.peek();y_(r,t)&&(Ps(r),e.push(t))}return e}function D4(r,e,t,n){const i=r._controlledReadableByteStream,s=e.constructor,o=function(h){return d_(h)?1:h.BYTES_PER_ELEMENT}(s),{byteOffset:a,byteLength:c}=e,l=t*o;let u;try{u=Yi(e.buffer)}catch(h){return void n._errorSteps(h)}const d={buffer:u,bufferByteLength:u.byteLength,byteOffset:a,byteLength:c,bytesFilled:0,minimumFill:l,elementSize:o,viewConstructor:s,readerType:"byob"};if(r._pendingPullIntos.length>0)return r._pendingPullIntos.push(d),void Bv(i,n);if(i._state!=="closed"){if(r._queueTotalSize>0){if(y_(r,d)){const h=p_(d);return b_(r),void n._chunkSteps(h)}if(r._closeRequested){const h=new TypeError("Insufficient bytes to fill elements in the given buffer");return er(r,h),void n._errorSteps(h)}}r._pendingPullIntos.push(d),Bv(i,n),ns(r)}else{const h=new s(d.buffer,d.byteOffset,0);n._closeSteps(h)}}function v_(r,e){const t=r._pendingPullIntos.peek();gy(r),r._controlledReadableByteStream._state==="closed"?function(n,i){i.readerType==="none"&&Ps(n);const s=n._controlledReadableByteStream;if(my(s)){const o=[];for(let a=0;a<__(s);++a)o.push(Ps(n));ml(s,o)}}(r,t):function(n,i,s){if(w_(0,i,s),s.readerType==="none"){m_(n,s);const c=yg(n);return void ml(n._controlledReadableByteStream,c)}if(s.bytesFilled<s.minimumFill)return;Ps(n);const o=s.bytesFilled%s.elementSize;if(o>0){const c=s.byteOffset+s.bytesFilled;g_(n,s.buffer,c-o,o)}s.bytesFilled-=o;const a=yg(n);f_(n._controlledReadableByteStream,s),ml(n._controlledReadableByteStream,a)}(r,e,t),ns(r)}function Ps(r){return r._pendingPullIntos.shift()}function th(r){r._pullAlgorithm=void 0,r._cancelAlgorithm=void 0}function Qo(r){const e=r._controlledReadableByteStream;if(!r._closeRequested&&e._state==="readable")if(r._queueTotalSize>0)r._closeRequested=!0;else{if(r._pendingPullIntos.length>0){const t=r._pendingPullIntos.peek();if(t.bytesFilled%t.elementSize!=0){const n=new TypeError("Insufficient bytes to fill elements in the given buffer");throw er(r,n),n}}th(r),Sc(e)}}function wl(r,e){const t=r._controlledReadableByteStream;if(r._closeRequested||t._state!=="readable")return;const{buffer:n,byteOffset:i,byteLength:s}=e;if(Qi(n))throw new TypeError("chunk's buffer is detached and so cannot be enqueued");const o=Yi(n);if(r._pendingPullIntos.length>0){const a=r._pendingPullIntos.peek();if(Qi(a.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");gy(r),a.buffer=Yi(a.buffer),a.readerType==="none"&&m_(r,a)}if(r_(t))(function(a){const c=a._controlledReadableByteStream._reader;for(;c._readRequests.length>0;){if(a._queueTotalSize===0)return;S_(a,c._readRequests.shift())}})(r),eh(t)===0?yl(r,o,i,s):(r._pendingPullIntos.length>0&&Ps(r),fy(t,new Uint8Array(o,i,s),!1));else if(my(t)){yl(r,o,i,s);const a=yg(r);ml(r._controlledReadableByteStream,a)}else yl(r,o,i,s);ns(r)}function er(r,e){const t=r._controlledReadableByteStream;t._state==="readable"&&(h_(r),si(r),th(r),j_(t,e))}function S_(r,e){const t=r._queue.shift();r._queueTotalSize-=t.byteLength,b_(r);const n=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);e._chunkSteps(n)}function wg(r){if(r._byobRequest===null&&r._pendingPullIntos.length>0){const e=r._pendingPullIntos.peek(),t=new Uint8Array(e.buffer,e.byteOffset+e.bytesFilled,e.byteLength-e.bytesFilled),n=Object.create(bs.prototype);(function(i,s,o){i._associatedReadableByteStreamController=s,i._view=o})(n,r,t),r._byobRequest=n}return r._byobRequest}function E_(r){const e=r._controlledReadableByteStream._state;return e==="errored"?null:e==="closed"?0:r._strategyHWM-r._queueTotalSize}function bl(r,e){const t=r._pendingPullIntos.peek();if(r._controlledReadableByteStream._state==="closed"){if(e!==0)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}else{if(e===0)throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");if(t.bytesFilled+e>t.byteLength)throw new RangeError("bytesWritten out of range")}t.buffer=Yi(t.buffer),v_(r,e)}function vl(r,e){const t=r._pendingPullIntos.peek();if(r._controlledReadableByteStream._state==="closed"){if(e.byteLength!==0)throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream")}else if(e.byteLength===0)throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");if(t.byteOffset+t.bytesFilled!==e.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(t.bufferByteLength!==e.buffer.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");if(t.bytesFilled+e.byteLength>t.byteLength)throw new RangeError("The region specified by view is larger than byobRequest");const n=e.byteLength;t.buffer=Yi(e.buffer),v_(r,n)}function A_(r,e,t,n,i,s,o){e._controlledReadableByteStream=r,e._pullAgain=!1,e._pulling=!1,e._byobRequest=null,e._queue=e._queueTotalSize=void 0,si(e),e._closeRequested=!1,e._started=!1,e._strategyHWM=s,e._pullAlgorithm=n,e._cancelAlgorithm=i,e._autoAllocateChunkSize=o,e._pendingPullIntos=new ur,r._readableStreamController=e,_r(Ae(t()),()=>(e._started=!0,ns(e),null),a=>(er(e,a),null))}function ff(r){return new TypeError(`ReadableStreamBYOBRequest.prototype.${r} can only be used on a ReadableStreamBYOBRequest`)}function Vo(r){return new TypeError(`ReadableByteStreamController.prototype.${r} can only be used on a ReadableByteStreamController`)}function L4(r,e){if((r=`${r}`)!="byob")throw new TypeError(`${e} '${r}' is not a valid enumeration value for ReadableStreamReaderMode`);return r}function x_(r){return new gi(r)}function Bv(r,e){r._reader._readIntoRequests.push(e)}function __(r){return r._reader._readIntoRequests.length}function my(r){const e=r._reader;return e!==void 0&&!!Ai(e)}Object.defineProperties(Rn.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),we(Rn.prototype.close,"close"),we(Rn.prototype.enqueue,"enqueue"),we(Rn.prototype.error,"error"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Rn.prototype,Symbol.toStringTag,{value:"ReadableByteStreamController",configurable:!0});class gi{constructor(e){if(Gi(e,1,"ReadableStreamBYOBReader"),hy(e,"First parameter"),Kn(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");if(!pi(e._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");Qx(this,e),this._readIntoRequests=new ur}get closed(){return Ai(this)?this._closedPromise:oe(el("closed"))}cancel(e=void 0){return Ai(this)?this._ownerReadableStream===void 0?oe(Fu("cancel")):ly(this,e):oe(el("cancel"))}read(e,t={}){if(!Ai(this))return oe(el("read"));if(!ArrayBuffer.isView(e))return oe(new TypeError("view must be an array buffer view"));if(e.byteLength===0)return oe(new TypeError("view must have non-zero byteLength"));if(e.buffer.byteLength===0)return oe(new TypeError("view's buffer must have non-zero byteLength"));if(Qi(e.buffer))return oe(new TypeError("view's buffer has been detached"));let n;try{n=function(c,l){var u;return $n(c,l),{min:dy((u=c?.min)!==null&&u!==void 0?u:1,`${l} has member 'min' that`)}}(t,"options")}catch(c){return oe(c)}const i=n.min;if(i===0)return oe(new TypeError("options.min must be greater than 0"));if(function(c){return d_(c.constructor)}(e)){if(i>e.byteLength)return oe(new RangeError("options.min must be less than or equal to view's byteLength"))}else if(i>e.length)return oe(new RangeError("options.min must be less than or equal to view's length"));if(this._ownerReadableStream===void 0)return oe(Fu("read from"));let s,o;const a=_t((c,l)=>{s=c,o=l});return C_(this,e,i,{_chunkSteps:c=>s({value:c,done:!1}),_closeSteps:c=>s({value:c,done:!0}),_errorSteps:c=>o(c)}),a}releaseLock(){if(!Ai(this))throw el("releaseLock");this._ownerReadableStream!==void 0&&function(e){nn(e);const t=new TypeError("Reader was released");I_(e,t)}(this)}}function Ai(r){return!!it(r)&&!!Object.prototype.hasOwnProperty.call(r,"_readIntoRequests")&&r instanceof gi}function C_(r,e,t,n){const i=r._ownerReadableStream;i._disturbed=!0,i._state==="errored"?n._errorSteps(i._storedError):D4(i._readableStreamController,e,t,n)}function I_(r,e){const t=r._readIntoRequests;r._readIntoRequests=new ur,t.forEach(n=>{n._errorSteps(e)})}function el(r){return new TypeError(`ReadableStreamBYOBReader.prototype.${r} can only be used on a ReadableStreamBYOBReader`)}function bg(r,e){const{highWaterMark:t}=r;if(t===void 0)return e;if(u_(t)||t<0)throw new RangeError("Invalid highWaterMark");return t}function k_(r){const{size:e}=r;return e||(()=>1)}function T_(r,e){$n(r,e);const t=r?.highWaterMark,n=r?.size;return{highWaterMark:t===void 0?void 0:e_(t),size:n===void 0?void 0:M4(n,`${e} has member 'size' that`)}}function M4(r,e){return ii(r,e),t=>e_(r(t))}function F4(r,e,t){return ii(r,t),n=>Ro(r,e,[n])}function U4(r,e,t){return ii(r,t),()=>Ro(r,e,[])}function $4(r,e,t){return ii(r,t),n=>oo(r,e,[n])}function q4(r,e,t){return ii(r,t),(n,i)=>Ro(r,e,[n,i])}function P_(r,e){if(!vs(r))throw new TypeError(`${e} is not a WritableStream.`)}Object.defineProperties(gi.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),we(gi.prototype.cancel,"cancel"),we(gi.prototype.read,"read"),we(gi.prototype.releaseLock,"releaseLock"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(gi.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});class On{constructor(e={},t={}){e===void 0?e=null:Zx(e,"First parameter");const n=T_(t,"Second parameter"),i=function(o,a){$n(o,a);const c=o?.abort,l=o?.close,u=o?.start,d=o?.type,h=o?.write;return{abort:c===void 0?void 0:F4(c,o,`${a} has member 'abort' that`),close:l===void 0?void 0:U4(l,o,`${a} has member 'close' that`),start:u===void 0?void 0:$4(u,o,`${a} has member 'start' that`),write:h===void 0?void 0:q4(h,o,`${a} has member 'write' that`),type:d}}(e,"First parameter");if(K4(this),i.type!==void 0)throw new RangeError("Invalid type is specified");const s=k_(n);(function(o,a,c,l){const u=Object.create($u.prototype);let d,h,p,m;d=a.start!==void 0?()=>a.start(u):()=>{},h=a.write!==void 0?w=>a.write(w,u):()=>Ae(void 0),p=a.close!==void 0?()=>a.close():()=>Ae(void 0),m=a.abort!==void 0?w=>a.abort(w):()=>Ae(void 0),z4(o,u,d,h,p,m,c,l)})(this,i,bg(n,1),s)}get locked(){if(!vs(this))throw rl("locked");return Rs(this)}abort(e=void 0){return vs(this)?Rs(this)?oe(new TypeError("Cannot abort a stream that already has a writer")):Uu(this,e):oe(rl("abort"))}close(){return vs(this)?Rs(this)?oe(new TypeError("Cannot close a stream that already has a writer")):Dr(this)?oe(new TypeError("Cannot close an already-closing stream")):O_(this):oe(rl("close"))}getWriter(){if(!vs(this))throw rl("getWriter");return R_(this)}}function R_(r){return new Pn(r)}function K4(r){r._state="writable",r._storedError=void 0,r._writer=void 0,r._writableStreamController=void 0,r._writeRequests=new ur,r._inFlightWriteRequest=void 0,r._closeRequest=void 0,r._inFlightCloseRequest=void 0,r._pendingAbortRequest=void 0,r._backpressure=!1}function vs(r){return!!it(r)&&!!Object.prototype.hasOwnProperty.call(r,"_writableStreamController")&&r instanceof On}function Rs(r){return r._writer!==void 0}function Uu(r,e){var t;if(r._state==="closed"||r._state==="errored")return Ae(void 0);r._writableStreamController._abortReason=e,(t=r._writableStreamController._abortController)===null||t===void 0||t.abort(e);const n=r._state;if(n==="closed"||n==="errored")return Ae(void 0);if(r._pendingAbortRequest!==void 0)return r._pendingAbortRequest._promise;let i=!1;n==="erroring"&&(i=!0,e=void 0);const s=_t((o,a)=>{r._pendingAbortRequest={_promise:void 0,_resolve:o,_reject:a,_reason:e,_wasAlreadyErroring:i}});return r._pendingAbortRequest._promise=s,i||yy(r,e),s}function O_(r){const e=r._state;if(e==="closed"||e==="errored")return oe(new TypeError(`The stream (in ${e} state) is not in the writable state and cannot be closed`));const t=_t((s,o)=>{const a={_resolve:s,_reject:o};r._closeRequest=a}),n=r._writer;var i;return n!==void 0&&r._backpressure&&e==="writable"&&Ey(n),py(i=r._writableStreamController,M_,0),rh(i),t}function vg(r,e){r._state!=="writable"?wy(r):yy(r,e)}function yy(r,e){const t=r._writableStreamController;r._state="erroring",r._storedError=e;const n=r._writer;n!==void 0&&N_(n,e),!function(i){return!(i._inFlightWriteRequest===void 0&&i._inFlightCloseRequest===void 0)}(r)&&t._started&&wy(r)}function wy(r){r._state="errored",r._writableStreamController[Yx]();const e=r._storedError;if(r._writeRequests.forEach(n=>{n._reject(e)}),r._writeRequests=new ur,r._pendingAbortRequest===void 0)return void tl(r);const t=r._pendingAbortRequest;if(r._pendingAbortRequest=void 0,t._wasAlreadyErroring)return t._reject(e),void tl(r);_r(r._writableStreamController[Gx](t._reason),()=>(t._resolve(),tl(r),null),n=>(t._reject(n),tl(r),null))}function Dr(r){return r._closeRequest!==void 0||r._inFlightCloseRequest!==void 0}function tl(r){r._closeRequest!==void 0&&(r._closeRequest._reject(r._storedError),r._closeRequest=void 0);const e=r._writer;e!==void 0&&Sy(e,r._storedError)}function by(r,e){const t=r._writer;t!==void 0&&e!==r._backpressure&&(e?function(n){nh(n)}(t):Ey(t)),r._backpressure=e}Object.defineProperties(On.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),we(On.prototype.abort,"abort"),we(On.prototype.close,"close"),we(On.prototype.getWriter,"getWriter"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(On.prototype,Symbol.toStringTag,{value:"WritableStream",configurable:!0});class Pn{constructor(e){if(Gi(e,1,"WritableStreamDefaultWriter"),P_(e,"First parameter"),Rs(e))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=e,e._writer=this;const t=e._state;if(t==="writable")!Dr(e)&&e._backpressure?nh(this):Nv(this),Sl(this);else if(t==="erroring")Eg(this,e._storedError),Sl(this);else if(t==="closed")Nv(this),Sl(n=this),q_(n);else{const i=e._storedError;Eg(this,i),$_(this,i)}var n}get closed(){return ci(this)?this._closedPromise:oe(li("closed"))}get desiredSize(){if(!ci(this))throw li("desiredSize");if(this._ownerWritableStream===void 0)throw Jo("desiredSize");return function(e){const t=e._ownerWritableStream,n=t._state;return n==="errored"||n==="erroring"?null:n==="closed"?0:F_(t._writableStreamController)}(this)}get ready(){return ci(this)?this._readyPromise:oe(li("ready"))}abort(e=void 0){return ci(this)?this._ownerWritableStream===void 0?oe(Jo("abort")):function(t,n){return Uu(t._ownerWritableStream,n)}(this,e):oe(li("abort"))}close(){if(!ci(this))return oe(li("close"));const e=this._ownerWritableStream;return e===void 0?oe(Jo("close")):Dr(e)?oe(new TypeError("Cannot close an already-closing stream")):B_(this)}releaseLock(){if(!ci(this))throw li("releaseLock");this._ownerWritableStream!==void 0&&D_(this)}write(e=void 0){return ci(this)?this._ownerWritableStream===void 0?oe(Jo("write to")):L_(this,e):oe(li("write"))}}function ci(r){return!!it(r)&&!!Object.prototype.hasOwnProperty.call(r,"_ownerWritableStream")&&r instanceof Pn}function B_(r){return O_(r._ownerWritableStream)}function V4(r,e){r._closedPromiseState==="pending"?Sy(r,e):function(t,n){$_(t,n)}(r,e)}function N_(r,e){r._readyPromiseState==="pending"?K_(r,e):function(t,n){Eg(t,n)}(r,e)}function D_(r){const e=r._ownerWritableStream,t=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");N_(r,t),V4(r,t),e._writer=void 0,r._ownerWritableStream=void 0}function L_(r,e){const t=r._ownerWritableStream,n=t._writableStreamController,i=function(a,c){if(a._strategySizeAlgorithm===void 0)return 1;try{return a._strategySizeAlgorithm(c)}catch(l){return Sg(a,l),1}}(n,e);if(t!==r._ownerWritableStream)return oe(Jo("write to"));const s=t._state;if(s==="errored")return oe(t._storedError);if(Dr(t)||s==="closed")return oe(new TypeError("The stream is closing or closed and cannot be written to"));if(s==="erroring")return oe(t._storedError);const o=function(a){return _t((c,l)=>{const u={_resolve:c,_reject:l};a._writeRequests.push(u)})}(t);return function(a,c,l){try{py(a,c,l)}catch(d){return void Sg(a,d)}const u=a._controlledWritableStream;!Dr(u)&&u._state==="writable"&&by(u,vy(a)),rh(a)}(n,e,i),o}Object.defineProperties(Pn.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),we(Pn.prototype.abort,"abort"),we(Pn.prototype.close,"close"),we(Pn.prototype.releaseLock,"releaseLock"),we(Pn.prototype.write,"write"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Pn.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});const M_={};class $u{constructor(){throw new TypeError("Illegal constructor")}get abortReason(){if(!pf(this))throw gf("abortReason");return this._abortReason}get signal(){if(!pf(this))throw gf("signal");if(this._abortController===void 0)throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");return this._abortController.signal}error(e=void 0){if(!pf(this))throw gf("error");this._controlledWritableStream._state==="writable"&&U_(this,e)}[Gx](e){const t=this._abortAlgorithm(e);return qu(this),t}[Yx](){si(this)}}function pf(r){return!!it(r)&&!!Object.prototype.hasOwnProperty.call(r,"_controlledWritableStream")&&r instanceof $u}function z4(r,e,t,n,i,s,o,a){e._controlledWritableStream=r,r._writableStreamController=e,e._queue=void 0,e._queueTotalSize=void 0,si(e),e._abortReason=void 0,e._abortController=function(){if(typeof AbortController=="function")return new AbortController}(),e._started=!1,e._strategySizeAlgorithm=a,e._strategyHWM=o,e._writeAlgorithm=n,e._closeAlgorithm=i,e._abortAlgorithm=s;const c=vy(e);by(r,c),_r(Ae(t()),()=>(e._started=!0,rh(e),null),l=>(e._started=!0,vg(r,l),null))}function qu(r){r._writeAlgorithm=void 0,r._closeAlgorithm=void 0,r._abortAlgorithm=void 0,r._strategySizeAlgorithm=void 0}function F_(r){return r._strategyHWM-r._queueTotalSize}function rh(r){const e=r._controlledWritableStream;if(!r._started||e._inFlightWriteRequest!==void 0)return;if(e._state==="erroring")return void wy(e);if(r._queue.length===0)return;const t=r._queue.peek().value;t===M_?function(n){const i=n._controlledWritableStream;(function(o){o._inFlightCloseRequest=o._closeRequest,o._closeRequest=void 0})(i),mg(n);const s=n._closeAlgorithm();qu(n),_r(s,()=>(function(o){o._inFlightCloseRequest._resolve(void 0),o._inFlightCloseRequest=void 0,o._state==="erroring"&&(o._storedError=void 0,o._pendingAbortRequest!==void 0&&(o._pendingAbortRequest._resolve(),o._pendingAbortRequest=void 0)),o._state="closed";const a=o._writer;a!==void 0&&q_(a)}(i),null),o=>(function(a,c){a._inFlightCloseRequest._reject(c),a._inFlightCloseRequest=void 0,a._pendingAbortRequest!==void 0&&(a._pendingAbortRequest._reject(c),a._pendingAbortRequest=void 0),vg(a,c)}(i,o),null))}(r):function(n,i){const s=n._controlledWritableStream;(function(a){a._inFlightWriteRequest=a._writeRequests.shift()})(s);const o=n._writeAlgorithm(i);_r(o,()=>{(function(c){c._inFlightWriteRequest._resolve(void 0),c._inFlightWriteRequest=void 0})(s);const a=s._state;if(mg(n),!Dr(s)&&a==="writable"){const c=vy(n);by(s,c)}return rh(n),null},a=>(s._state==="writable"&&qu(n),function(c,l){c._inFlightWriteRequest._reject(l),c._inFlightWriteRequest=void 0,vg(c,l)}(s,a),null))}(r,t)}function Sg(r,e){r._controlledWritableStream._state==="writable"&&U_(r,e)}function vy(r){return F_(r)<=0}function U_(r,e){const t=r._controlledWritableStream;qu(r),yy(t,e)}function rl(r){return new TypeError(`WritableStream.prototype.${r} can only be used on a WritableStream`)}function gf(r){return new TypeError(`WritableStreamDefaultController.prototype.${r} can only be used on a WritableStreamDefaultController`)}function li(r){return new TypeError(`WritableStreamDefaultWriter.prototype.${r} can only be used on a WritableStreamDefaultWriter`)}function Jo(r){return new TypeError("Cannot "+r+" a stream using a released writer")}function Sl(r){r._closedPromise=_t((e,t)=>{r._closedPromise_resolve=e,r._closedPromise_reject=t,r._closedPromiseState="pending"})}function $_(r,e){Sl(r),Sy(r,e)}function Sy(r,e){r._closedPromise_reject!==void 0&&(bc(r._closedPromise),r._closedPromise_reject(e),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0,r._closedPromiseState="rejected")}function q_(r){r._closedPromise_resolve!==void 0&&(r._closedPromise_resolve(void 0),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0,r._closedPromiseState="resolved")}function nh(r){r._readyPromise=_t((e,t)=>{r._readyPromise_resolve=e,r._readyPromise_reject=t}),r._readyPromiseState="pending"}function Eg(r,e){nh(r),K_(r,e)}function Nv(r){nh(r),Ey(r)}function K_(r,e){r._readyPromise_reject!==void 0&&(bc(r._readyPromise),r._readyPromise_reject(e),r._readyPromise_resolve=void 0,r._readyPromise_reject=void 0,r._readyPromiseState="rejected")}function Ey(r){r._readyPromise_resolve!==void 0&&(r._readyPromise_resolve(void 0),r._readyPromise_resolve=void 0,r._readyPromise_reject=void 0,r._readyPromiseState="fulfilled")}Object.defineProperties($u.prototype,{abortReason:{enumerable:!0},signal:{enumerable:!0},error:{enumerable:!0}}),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty($u.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});const Dv=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof global<"u"?global:void 0,j4=function(){const r=Dv?.DOMException;return function(e){if(typeof e!="function"&&typeof e!="object"||e.name!=="DOMException")return!1;try{return new e,!0}catch{return!1}}(r)?r:void 0}()||function(){const r=function(e,t){this.message=e||"",this.name=t||"Error",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)};return we(r,"DOMException"),r.prototype=Object.create(Error.prototype),Object.defineProperty(r.prototype,"constructor",{value:r,writable:!0,configurable:!0}),r}();function Lv(r,e,t,n,i,s){const o=Ts(r),a=R_(e);r._disturbed=!0;let c=!1,l=Ae(void 0);return _t((u,d)=>{let h;if(s!==void 0){if(h=()=>{const S=s.reason!==void 0?s.reason:new j4("Aborted","AbortError"),N=[];n||N.push(()=>e._state==="writable"?Uu(e,S):Ae(void 0)),i||N.push(()=>r._state==="readable"?yr(r,S):Ae(void 0)),_(()=>Promise.all(N.map(T=>T())),!0,S)},s.aborted)return void h();s.addEventListener("abort",h)}var p,m,w;if(b(r,o._closedPromise,S=>(n?E(!0,S):_(()=>Uu(e,S),!0,S),null)),b(e,a._closedPromise,S=>(i?E(!0,S):_(()=>yr(r,S),!0,S),null)),p=r,m=o._closedPromise,w=()=>(t?E():_(()=>function(S){const N=S._ownerWritableStream,T=N._state;return Dr(N)||T==="closed"?Ae(void 0):T==="errored"?oe(N._storedError):B_(S)}(a)),null),p._state==="closed"?w():cf(m,w),Dr(e)||e._state==="closed"){const S=new TypeError("the destination writable stream closed before all data could be piped to it");i?E(!0,S):_(()=>yr(r,S),!0,S)}function y(){const S=l;return Nr(l,()=>S!==l?y():void 0)}function b(S,N,T){S._state==="errored"?T(S._storedError):pg(N,T)}function _(S,N,T){function B(){return _r(S(),()=>R(N,T),v=>R(!0,v)),null}c||(c=!0,e._state!=="writable"||Dr(e)?B():cf(y(),B))}function E(S,N){c||(c=!0,e._state!=="writable"||Dr(e)?R(S,N):cf(y(),()=>R(S,N)))}function R(S,N){return D_(a),nn(o),s!==void 0&&s.removeEventListener("abort",h),S?d(N):u(void 0),null}bc(_t((S,N)=>{(function T(B){B?S():Nr(c?Ae(!0):Nr(a._readyPromise,()=>_t((v,I)=>{Ua(o,{_chunkSteps:C=>{l=Nr(L_(a,C),void 0,Fa),v(!1)},_closeSteps:()=>v(!0),_errorSteps:I})})),T,N)})(!1)}))})}class Bn{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!nl(this))throw il("desiredSize");return Ay(this)}close(){if(!nl(this))throw il("close");if(!lo(this))throw new TypeError("The stream is not in a state that permits close");ao(this)}enqueue(e=void 0){if(!nl(this))throw il("enqueue");if(!lo(this))throw new TypeError("The stream is not in a state that permits enqueue");return co(this,e)}error(e=void 0){if(!nl(this))throw il("error");ei(this,e)}[oy](e){si(this);const t=this._cancelAlgorithm(e);return Ku(this),t}[ay](e){const t=this._controlledReadableStream;if(this._queue.length>0){const n=mg(this);this._closeRequested&&this._queue.length===0?(Ku(this),Sc(t)):$a(this),e._chunkSteps(n)}else t_(t,e),$a(this)}[cy](){}}function nl(r){return!!it(r)&&!!Object.prototype.hasOwnProperty.call(r,"_controlledReadableStream")&&r instanceof Bn}function $a(r){if(V_(r)){if(r._pulling)return void(r._pullAgain=!0);r._pulling=!0,_r(r._pullAlgorithm(),()=>(r._pulling=!1,r._pullAgain&&(r._pullAgain=!1,$a(r)),null),e=>(ei(r,e),null))}}function V_(r){const e=r._controlledReadableStream;return!lo(r)||!r._started?!1:Kn(e)&&eh(e)>0?!0:Ay(r)>0}function Ku(r){r._pullAlgorithm=void 0,r._cancelAlgorithm=void 0,r._strategySizeAlgorithm=void 0}function ao(r){if(!lo(r))return;const e=r._controlledReadableStream;r._closeRequested=!0,r._queue.length===0&&(Ku(r),Sc(e))}function co(r,e){if(!lo(r))return;const t=r._controlledReadableStream;if(Kn(t)&&eh(t)>0)fy(t,e,!1);else{let n;try{n=r._strategySizeAlgorithm(e)}catch(i){throw ei(r,i),i}try{py(r,e,n)}catch(i){throw ei(r,i),i}}$a(r)}function ei(r,e){const t=r._controlledReadableStream;t._state==="readable"&&(si(r),Ku(r),j_(t,e))}function Ay(r){const e=r._controlledReadableStream._state;return e==="errored"?null:e==="closed"?0:r._strategyHWM-r._queueTotalSize}function lo(r){const e=r._controlledReadableStream._state;return!r._closeRequested&&e==="readable"}function z_(r,e,t,n,i,s,o){e._controlledReadableStream=r,e._queue=void 0,e._queueTotalSize=void 0,si(e),e._started=!1,e._closeRequested=!1,e._pullAgain=!1,e._pulling=!1,e._strategySizeAlgorithm=o,e._strategyHWM=s,e._pullAlgorithm=n,e._cancelAlgorithm=i,r._readableStreamController=e,_r(Ae(t()),()=>(e._started=!0,$a(e),null),a=>(ei(e,a),null))}function il(r){return new TypeError(`ReadableStreamDefaultController.prototype.${r} can only be used on a ReadableStreamDefaultController`)}function H4(r,e){return pi(r._readableStreamController)?function(t){let n,i,s,o,a,c=Ts(t),l=!1,u=!1,d=!1,h=!1,p=!1;const m=_t(T=>{a=T});function w(T){pg(T._closedPromise,B=>(T!==c||(er(s._readableStreamController,B),er(o._readableStreamController,B),h&&p||a(void 0)),null))}function y(){Ai(c)&&(nn(c),c=Ts(t),w(c)),Ua(c,{_chunkSteps:T=>{Pi(()=>{u=!1,d=!1;const B=T;let v=T;if(!h&&!p)try{v=Ov(T)}catch(I){return er(s._readableStreamController,I),er(o._readableStreamController,I),void a(yr(t,I))}h||wl(s._readableStreamController,B),p||wl(o._readableStreamController,v),l=!1,u?_():d&&E()})},_closeSteps:()=>{l=!1,h||Qo(s._readableStreamController),p||Qo(o._readableStreamController),s._readableStreamController._pendingPullIntos.length>0&&bl(s._readableStreamController,0),o._readableStreamController._pendingPullIntos.length>0&&bl(o._readableStreamController,0),h&&p||a(void 0)},_errorSteps:()=>{l=!1}})}function b(T,B){qn(c)&&(nn(c),c=x_(t),w(c));const v=B?o:s,I=B?s:o;C_(c,T,1,{_chunkSteps:C=>{Pi(()=>{u=!1,d=!1;const P=B?p:h;if(B?h:p)P||vl(v._readableStreamController,C);else{let O;try{O=Ov(C)}catch(L){return er(v._readableStreamController,L),er(I._readableStreamController,L),void a(yr(t,L))}P||vl(v._readableStreamController,C),wl(I._readableStreamController,O)}l=!1,u?_():d&&E()})},_closeSteps:C=>{l=!1;const P=B?p:h,O=B?h:p;P||Qo(v._readableStreamController),O||Qo(I._readableStreamController),C!==void 0&&(P||vl(v._readableStreamController,C),!O&&I._readableStreamController._pendingPullIntos.length>0&&bl(I._readableStreamController,0)),P&&O||a(void 0)},_errorSteps:()=>{l=!1}})}function _(){if(l)return u=!0,Ae(void 0);l=!0;const T=wg(s._readableStreamController);return T===null?y():b(T._view,!1),Ae(void 0)}function E(){if(l)return d=!0,Ae(void 0);l=!0;const T=wg(o._readableStreamController);return T===null?y():b(T._view,!0),Ae(void 0)}function R(T){if(h=!0,n=T,p){const B=Go([n,i]),v=yr(t,B);a(v)}return m}function S(T){if(p=!0,i=T,h){const B=Go([n,i]),v=yr(t,B);a(v)}return m}function N(){}return s=Fv(N,_,R),o=Fv(N,E,S),w(c),[s,o]}(r):function(t,n){const i=Ts(t);let s,o,a,c,l,u=!1,d=!1,h=!1,p=!1;const m=_t(E=>{l=E});function w(){return u?(d=!0,Ae(void 0)):(u=!0,Ua(i,{_chunkSteps:E=>{Pi(()=>{d=!1;const R=E,S=E;h||co(a._readableStreamController,R),p||co(c._readableStreamController,S),u=!1,d&&w()})},_closeSteps:()=>{u=!1,h||ao(a._readableStreamController),p||ao(c._readableStreamController),h&&p||l(void 0)},_errorSteps:()=>{u=!1}}),Ae(void 0))}function y(E){if(h=!0,s=E,p){const R=Go([s,o]),S=yr(t,R);l(S)}return m}function b(E){if(p=!0,o=E,h){const R=Go([s,o]),S=yr(t,R);l(S)}return m}function _(){}return a=Vu(_,w,y),c=Vu(_,w,b),pg(i._closedPromise,E=>(ei(a._readableStreamController,E),ei(c._readableStreamController,E),h&&p||l(void 0),null)),[a,c]}(r)}function W4(r){return it(e=r)&&e.getReader!==void 0?function(t){let n;function i(){let o;try{o=t.read()}catch(a){return oe(a)}return Ti(o,a=>{if(!it(a))throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");if(a.done)ao(n._readableStreamController);else{const c=a.value;co(n._readableStreamController,c)}})}function s(o){try{return Ae(t.cancel(o))}catch(a){return oe(a)}}return n=Vu(Fa,i,s,0),n}(r.getReader()):function(t){let n;const i=o_(t,"async");function s(){let a;try{a=a_(i)}catch(c){return oe(c)}return Ti(Ae(a),c=>{if(!it(c))throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");if(c.done)ao(n._readableStreamController);else{const l=c.value;co(n._readableStreamController,l)}})}function o(a){const c=i.iterator;let l;try{l=Yo(c,"return")}catch(u){return oe(u)}return l===void 0?Ae(void 0):Ti(Ro(l,c,[a]),u=>{if(!it(u))throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object")})}return n=Vu(Fa,s,o,0),n}(r);var e}function G4(r,e,t){return ii(r,t),n=>Ro(r,e,[n])}function Y4(r,e,t){return ii(r,t),n=>Ro(r,e,[n])}function Q4(r,e,t){return ii(r,t),n=>oo(r,e,[n])}function J4(r,e){if((r=`${r}`)!="bytes")throw new TypeError(`${e} '${r}' is not a valid enumeration value for ReadableStreamType`);return r}function Mv(r,e){$n(r,e);const t=r?.preventAbort,n=r?.preventCancel,i=r?.preventClose,s=r?.signal;return s!==void 0&&function(o,a){if(!function(c){if(typeof c!="object"||c===null)return!1;try{return typeof c.aborted=="boolean"}catch{return!1}}(o))throw new TypeError(`${a} is not an AbortSignal.`)}(s,`${e} has member 'signal' that`),{preventAbort:!!t,preventCancel:!!n,preventClose:!!i,signal:s}}Object.defineProperties(Bn.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),we(Bn.prototype.close,"close"),we(Bn.prototype.enqueue,"enqueue"),we(Bn.prototype.error,"error"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Bn.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});let It=class{constructor(e={},t={}){e===void 0?e=null:Zx(e,"First parameter");const n=T_(t,"Second parameter"),i=function(s,o){$n(s,o);const a=s,c=a?.autoAllocateChunkSize,l=a?.cancel,u=a?.pull,d=a?.start,h=a?.type;return{autoAllocateChunkSize:c===void 0?void 0:dy(c,`${o} has member 'autoAllocateChunkSize' that`),cancel:l===void 0?void 0:G4(l,a,`${o} has member 'cancel' that`),pull:u===void 0?void 0:Y4(u,a,`${o} has member 'pull' that`),start:d===void 0?void 0:Q4(d,a,`${o} has member 'start' that`),type:h===void 0?void 0:J4(h,`${o} has member 'type' that`)}}(e,"First parameter");if(xy(this),i.type==="bytes"){if(n.size!==void 0)throw new RangeError("The strategy for a byte stream cannot have a size function");(function(s,o,a){const c=Object.create(Rn.prototype);let l,u,d;l=o.start!==void 0?()=>o.start(c):()=>{},u=o.pull!==void 0?()=>o.pull(c):()=>Ae(void 0),d=o.cancel!==void 0?p=>o.cancel(p):()=>Ae(void 0);const h=o.autoAllocateChunkSize;if(h===0)throw new TypeError("autoAllocateChunkSize must be greater than 0");A_(s,c,l,u,d,a,h)})(this,i,bg(n,0))}else{const s=k_(n);(function(o,a,c,l){const u=Object.create(Bn.prototype);let d,h,p;d=a.start!==void 0?()=>a.start(u):()=>{},h=a.pull!==void 0?()=>a.pull(u):()=>Ae(void 0),p=a.cancel!==void 0?m=>a.cancel(m):()=>Ae(void 0),z_(o,u,d,h,p,c,l)})(this,i,bg(n,1),s)}}get locked(){if(!Tn(this))throw ui("locked");return Kn(this)}cancel(e=void 0){return Tn(this)?Kn(this)?oe(new TypeError("Cannot cancel a stream that already has a reader")):yr(this,e):oe(ui("cancel"))}getReader(e=void 0){if(!Tn(this))throw ui("getReader");return function(t,n){$n(t,n);const i=t?.mode;return{mode:i===void 0?void 0:L4(i,`${n} has member 'mode' that`)}}(e,"First parameter").mode===void 0?Ts(this):x_(this)}pipeThrough(e,t={}){if(!Tn(this))throw ui("pipeThrough");Gi(e,1,"pipeThrough");const n=function(s,o){$n(s,o);const a=s?.readable;Iv(a,"readable","ReadableWritablePair"),hy(a,`${o} has member 'readable' that`);const c=s?.writable;return Iv(c,"writable","ReadableWritablePair"),P_(c,`${o} has member 'writable' that`),{readable:a,writable:c}}(e,"First parameter"),i=Mv(t,"Second parameter");if(Kn(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(Rs(n.writable))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");return bc(Lv(this,n.writable,i.preventClose,i.preventAbort,i.preventCancel,i.signal)),n.readable}pipeTo(e,t={}){if(!Tn(this))return oe(ui("pipeTo"));if(e===void 0)return oe("Parameter 1 is required in 'pipeTo'.");if(!vs(e))return oe(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));let n;try{n=Mv(t,"Second parameter")}catch(i){return oe(i)}return Kn(this)?oe(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):Rs(e)?oe(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):Lv(this,e,n.preventClose,n.preventAbort,n.preventCancel,n.signal)}tee(){if(!Tn(this))throw ui("tee");return Go(H4(this))}values(e=void 0){if(!Tn(this))throw ui("values");return function(t,n){const i=Ts(t),s=new c_(i,n),o=Object.create(l_);return o._asyncIteratorImpl=s,o}(this,function(t,n){return $n(t,n),{preventCancel:!!t?.preventCancel}}(e,"First parameter").preventCancel)}[vc](e){return this.values(e)}static from(e){return W4(e)}};function Vu(r,e,t,n=1,i=()=>1){const s=Object.create(It.prototype);return xy(s),z_(s,Object.create(Bn.prototype),r,e,t,n,i),s}function Fv(r,e,t){const n=Object.create(It.prototype);return xy(n),A_(n,Object.create(Rn.prototype),r,e,t,0,void 0),n}function xy(r){r._state="readable",r._reader=void 0,r._storedError=void 0,r._disturbed=!1}function Tn(r){return!!it(r)&&!!Object.prototype.hasOwnProperty.call(r,"_readableStreamController")&&r instanceof It}function Kn(r){return r._reader!==void 0}function yr(r,e){if(r._disturbed=!0,r._state==="closed")return Ae(void 0);if(r._state==="errored")return oe(r._storedError);Sc(r);const t=r._reader;if(t!==void 0&&Ai(t)){const n=t._readIntoRequests;t._readIntoRequests=new ur,n.forEach(i=>{i._closeSteps(void 0)})}return Ti(r._readableStreamController[oy](e),Fa)}function Sc(r){r._state="closed";const e=r._reader;if(e!==void 0&&(Xx(e),qn(e))){const t=e._readRequests;e._readRequests=new ur,t.forEach(n=>{n._closeSteps()})}}function j_(r,e){r._state="errored",r._storedError=e;const t=r._reader;t!==void 0&&(uy(t,e),qn(t)?n_(t,e):I_(t,e))}function ui(r){return new TypeError(`ReadableStream.prototype.${r} can only be used on a ReadableStream`)}Object.defineProperties(It,{from:{enumerable:!0}}),Object.defineProperties(It.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),we(It.from,"from"),we(It.prototype.cancel,"cancel"),we(It.prototype.getReader,"getReader"),we(It.prototype.pipeThrough,"pipeThrough"),we(It.prototype.pipeTo,"pipeTo"),we(It.prototype.tee,"tee"),we(It.prototype.values,"values"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(It.prototype,Symbol.toStringTag,{value:"ReadableStream",configurable:!0}),Object.defineProperty(It.prototype,vc,{value:It.prototype.values,writable:!0,configurable:!0});const X4=r=>r.byteLength;we(X4,"size");const Z4=()=>1;we(Z4,"size");function eF(r,e){ei(r._readable._readableStreamController,e),_y(r,e)}function _y(r,e){rF(r._transformStreamController),Sg(r._writable._writableStreamController,e),tF(r)}function tF(r){r._backpressure&&H_(r,!1)}function H_(r,e){r._backpressureChangePromise!==void 0&&r._backpressureChangePromise_resolve(),r._backpressureChangePromise=_t(t=>{r._backpressureChangePromise_resolve=t}),r._backpressure=e}class ps{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!sl(this))throw ol("desiredSize");return Ay(this._controlledTransformStream._readable._readableStreamController)}enqueue(e=void 0){if(!sl(this))throw ol("enqueue");nF(this,e)}error(e=void 0){if(!sl(this))throw ol("error");var t;t=e,eF(this._controlledTransformStream,t)}terminate(){if(!sl(this))throw ol("terminate");(function(e){const t=e._controlledTransformStream;ao(t._readable._readableStreamController);const n=new TypeError("TransformStream terminated");_y(t,n)})(this)}}function sl(r){return!!it(r)&&!!Object.prototype.hasOwnProperty.call(r,"_controlledTransformStream")&&r instanceof ps}function rF(r){r._transformAlgorithm=void 0,r._flushAlgorithm=void 0,r._cancelAlgorithm=void 0}function nF(r,e){const t=r._controlledTransformStream,n=t._readable._readableStreamController;if(!lo(n))throw new TypeError("Readable side is not in a state that permits enqueue");try{co(n,e)}catch(s){throw _y(t,s),t._readable._storedError}(function(s){return!V_(s)})(n)!==t._backpressure&&H_(t,!0)}function ol(r){return new TypeError(`TransformStreamDefaultController.prototype.${r} can only be used on a TransformStreamDefaultController`)}Object.defineProperties(ps.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),we(ps.prototype.enqueue,"enqueue"),we(ps.prototype.error,"error"),we(ps.prototype.terminate,"terminate"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(ps.prototype,Symbol.toStringTag,{value:"TransformStreamDefaultController",configurable:!0});var mf={exports:{}};/*! streamsaver. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */var Uv;function iF(){return Uv||(Uv=1,function(r){((e,t)=>{r.exports=t()})("streamSaver",()=>{const e=typeof window=="object"?window:this;e.HTMLElement||console.warn("streamsaver is meant to run on browsers main thread");let t=null,n=!1;const i=m=>{try{m()}catch{}},s=e.WebStreamsPolyfill||{},o=e.isSecureContext;let a=/constructor/i.test(e.HTMLElement)||!!e.safari||!!e.WebKitPoint;const c=o||"MozAppearance"in document.documentElement.style?"iframe":"navigate",l={createWriteStream:p,WritableStream:e.WritableStream||s.WritableStream,supported:!0,version:{full:"2.0.5",major:2,minor:0,dot:5},mitm:"https://jimmywarting.github.io/StreamSaver.js/mitm.html?version=2.0.0"};function u(m){if(!m)throw new Error("meh");const w=document.createElement("iframe");return w.hidden=!0,w.src=m,w.loaded=!1,w.name="iframe",w.isIframe=!0,w.postMessage=(...y)=>w.contentWindow.postMessage(...y),w.addEventListener("load",()=>{w.loaded=!0},{once:!0}),document.body.appendChild(w),w}function d(m){const w="width=200,height=100",y=document.createDocumentFragment(),b={frame:e.open(m,"popup",w),loaded:!1,isIframe:!1,isPopup:!0,remove(){b.frame.close()},addEventListener(...E){y.addEventListener(...E)},dispatchEvent(...E){y.dispatchEvent(...E)},removeEventListener(...E){y.removeEventListener(...E)},postMessage(...E){b.frame.postMessage(...E)}},_=E=>{E.source===b.frame&&(b.loaded=!0,e.removeEventListener("message",_),b.dispatchEvent(new Event("load")))};return e.addEventListener("message",_),b}try{new Response(new ReadableStream),o&&!("serviceWorker"in navigator)&&(a=!0)}catch{a=!0}i(()=>{const{readable:m}=new TransformStream,w=new MessageChannel;w.port1.postMessage(m,[m]),w.port1.close(),w.port2.close(),n=!0,Object.defineProperty(l,"TransformStream",{configurable:!1,writable:!1,value:TransformStream})});function h(){t||(t=o?u(l.mitm):d(l.mitm))}function p(m,w,y){let b={size:null,pathname:null,writableStrategy:void 0,readableStrategy:void 0},_=0,E=null,R=null,S=null;if(Number.isFinite(w)?([y,w]=[w,y],console.warn("[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream"),b.size=y,b.writableStrategy=w):w&&w.highWaterMark?(console.warn("[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream"),b.size=y,b.writableStrategy=w):b=w||{},!a){h(),R=new MessageChannel,m=encodeURIComponent(m.replace(/\//g,":")).replace(/['()]/g,escape).replace(/\*/g,"%2A");const T={transferringReadable:n,pathname:b.pathname||Math.random().toString().slice(-6)+"/"+m,headers:{"Content-Type":"application/octet-stream; charset=utf-8","Content-Disposition":"attachment; filename*=UTF-8''"+m}};b.size&&(T.headers["Content-Length"]=b.size);const B=[T,"*",[R.port2]];if(n){const v=c==="iframe"?void 0:{transform(C,P){if(!(C instanceof Uint8Array))throw new TypeError("Can only write Uint8Arrays");_+=C.length,P.enqueue(C),E&&(location.href=E,E=null)},flush(){E&&(location.href=E)}};S=new l.TransformStream(v,b.writableStrategy,b.readableStrategy);const I=S.readable;R.port1.postMessage({readableStream:I},[I])}R.port1.onmessage=v=>{v.data.download?c==="navigate"?(t.remove(),t=null,_?location.href=v.data.download:E=v.data.download):(t.isPopup&&(t.remove(),t=null,c==="iframe"&&u(l.mitm)),u(v.data.download)):v.data.abort&&(N=[],R.port1.postMessage("abort"),R.port1.onmessage=null,R.port1.close(),R.port2.close(),R=null)},t.loaded?t.postMessage(...B):t.addEventListener("load",()=>{t.postMessage(...B)},{once:!0})}let N=[];return!a&&S&&S.writable||new l.WritableStream({write(T){if(!(T instanceof Uint8Array))throw new TypeError("Can only write Uint8Arrays");if(a){N.push(T);return}R.port1.postMessage(T),_+=T.length,E&&(location.href=E,E=null)},close(){if(a){const T=new Blob(N,{type:"application/octet-stream; charset=utf-8"}),B=document.createElement("a");B.href=URL.createObjectURL(T),B.download=m,B.click()}else R.port1.postMessage("end")},abort(){N=[],R.port1.postMessage("abort"),R.port1.onmessage=null,R.port1.close(),R.port2.close(),R=null}},b.writableStrategy)}return l})}(mf)),mf.exports}var sF=iF();const yf=bo(sF);class oF{node;appState;progressTracker;uiManager;protocol;wakeLock=null;hash;transferProgressBytes;receivedFileStream=null;receivedFileWriter=null;fileNameFromHeader;fileSizeFromHeader;fileTypeFromHeader;fileHashFromHeader;headerReceived;receivedBytesTotal;constructor(e,t,n,i){this.node=e,this.appState=t,this.progressTracker=n,this.uiManager=i,this.protocol="/fileferry/filetransfer/1.0.0",this.wakeLock=null,this.hash=2166136261,this.transferProgressBytes=0,this.receivedFileStream=null,this.receivedFileWriter=null,this.fileNameFromHeader="downloaded_file",this.fileSizeFromHeader=0,this.fileTypeFromHeader="application/octet-stream",this.fileHashFromHeader=0,this.headerReceived=!1,this.receivedBytesTotal=0,yf.WritableStream=On,yf.mitm="https://fileferry.xyz/streamsaver/mitm.html",window.WritableStream=On}setupFileTransferProtocol(){const e=async({stream:t,connection:n})=>{this.getWakelock(),this.appState.setActivePeer(n.remotePeer.toString()),this.appState.setTransferConnectionId(n.id),this.appState.isTransferActive()?(console.log("Resuming file transfer after reconnection."),this.appState.setActiveStream(t)):(this.appState.setActiveStream(t),this.appState.setActiveTransfer()),await this.handleFileTransfer()};this.node.handle(this.protocol,e)}async startFileTransfer(){try{const e=this.appState.getActiveStream(),t=this.appState.getSelectedFile();if(!e||!t)throw new Error("No active stream or file to start transfer.");this.appState.isTransferActive()?(console.log("Resuming file transfer after reconnection."),await this.sendFileToStream(e,t)):(this.appState.setActiveTransfer(),await this.sendFileToStream(e,t)),this.appState.isFinished()&&await this.transferComplete()}catch{}}async handleFileTransfer(){try{const e=this.appState.getActiveStream();if(!e)throw new Error("No active stream to handle transfer.");await this.receiveFileFromStream(e),this.appState.isFinished()&&await this.transferComplete()}catch{}}async sendFileToStream(e,t,n=16384){try{const i=await this.createFileHeader(t),s=new TextEncoder().encode(i+`
`);let o=0;const a=e.channel,c=a.bufferedAmountLowThreshold||1024*64,l=async function*(){yield new ye(s),await new Promise(u=>setTimeout(u,1));for(let u=0;u<t.size;u+=n){const d=t.slice(u,Math.min(u+n,t.size)),h=new Uint8Array(await d.arrayBuffer());if(o<this.transferProgressBytes){o+=h.length;continue}yield new ye(h),a.bufferedAmount>c&&await new Promise(p=>{a.addEventListener("bufferedamountlow",()=>p(),{once:!0})}),o+=h.length,this.transferProgressBytes+=h.length,this.progressTracker.updateProgress(this.transferProgressBytes,t.size,"send")}}.bind(this);await Yg(l(),e.sink),this.progressTracker.updateProgress(this.transferProgressBytes,t.size,"send",!0),this.transferProgressBytes=0}catch(i){throw i}}async createFileHeader(e){return JSON.stringify({name:e.name,size:e.size,type:e.type||"application/octet-stream",hash:await this.senderHash()})}async receiveFileFromStream(e){try{for await(const t of e.source){if(!t||t.length===0)continue;const n=t.subarray();if(this.headerReceived)this.receivedFileWriter!=null&&(await this.receivedFileWriter.write(n),this.hash=this.fnv1aHash(n,this.hash),this.receivedBytesTotal+=n.length,this.progressTracker.updateProgress(this.receivedBytesTotal,this.fileSizeFromHeader,"receive"));else{const i=this.parseFileHeader(n);i.header&&(this.fileNameFromHeader=i.header.name||this.fileNameFromHeader,this.fileSizeFromHeader=i.header.size||this.fileSizeFromHeader,this.fileTypeFromHeader=i.header.type||this.fileTypeFromHeader,this.fileHashFromHeader=Number(i.header.hash)||this.fileHashFromHeader,this.headerReceived=!0,console.log(`Receiving file: ${this.fileNameFromHeader} (${this.fileSizeFromHeader} bytes)`),this.receivedFileStream===null&&(this.receivedFileStream=yf.createWriteStream(this.fileNameFromHeader,{size:this.fileSizeFromHeader})),this.receivedFileWriter===null&&(this.receivedFileWriter=this.receivedFileStream.getWriter())),i.bodyData&&i.bodyData.length>0&&this.receivedFileWriter!=null&&(await this.receivedFileWriter.write(i.bodyData),this.receivedBytesTotal+=i.bodyData.length,this.progressTracker.updateProgress(this.receivedBytesTotal,this.fileSizeFromHeader,"receive"))}if(this.headerReceived&&this.receivedBytesTotal>=this.fileSizeFromHeader&&this.fileSizeFromHeader>0){this.progressTracker.updateProgress(this.receivedBytesTotal,this.fileSizeFromHeader,"receive",!0),this.uiManager.showReceivedFileDetails(this.fileNameFromHeader,this.fileSizeFromHeader),this.receivedFileWriter!=null&&(this.hash!=this.fileHashFromHeader?(this.uiManager.showErrorPopup("Sorry mate, the file's hash does not match. The file may be corrupted."),await this.receivedFileWriter.abort("File hash mismatch")):await this.receivedFileWriter.close(),this.receivedFileWriter=null),this.appState.clearActiveTransfer(),await this.closeActiveStream();break}}}catch(t){throw t}}async closeActiveStream(){const e=this.appState.getActiveStream();e&&(await e.close(),this.appState.setActiveStream(null))}parseFileHeader(e){try{const t=new TextDecoder("utf-8",{fatal:!1}).decode(e),n=t.indexOf(`
`);if(n!==-1){const i=t.substring(0,n),o=new TextEncoder().encode(i+`
`).length;try{const a=JSON.parse(i),c=o<e.byteLength?e.subarray(o):null;return{header:a,bodyData:c}}catch{return{header:null,bodyData:e}}}return{header:null,bodyData:e}}catch{return{header:null,bodyData:e}}}async getWakelock(){if("wakeLock"in navigator){async function e(){let t=null;try{return t=await navigator.wakeLock.request("screen"),t}catch{return null}}this.wakeLock=await e()||null}}async releaseWakelock(){this.wakeLock?.release().catch(e=>{})}fnv1aHash(e,t){let n=t;for(let i of e)n=(i^n)*16777619&4294967295;return n}async senderHash(){const e=this.appState.getSelectedFile(),t=16384;if(e===null)return 0;const n=async function*(){for(let s=0;s<e.size;s+=t){const a=await e.slice(s,Math.min(s+t,e.size)).arrayBuffer();yield new Uint8Array(a)}}.bind(this);let i=this.hash;for await(const s of n())i=this.fnv1aHash(s,i);return i}async transferComplete(){if(this.appState.isTransferActive()&&this.appState.getMode()==="receiver")try{this.receivedFileWriter?.close(),this.closeActiveStream()}catch{}this.appState.declareFinished(),await this.node.stop(),this.releaseWakelock()}}class aF{geoLocUrl;hostUrl;geoUserUrl;cacheKey;cacheDuration;constructor(){this.geoLocUrl="https://raw.githubusercontent.com/pradt2/always-online-stun/master/geoip_cache.txt",this.hostUrl="https://raw.githubusercontent.com/pradt2/always-online-stun/master/valid_hosts.txt",this.geoUserUrl="https://geoip.fileferry.xyz",this.cacheKey="userGeoData",this.cacheDuration=48*60*60*1e3}async getClosestStunServer(){try{const e=await this.fetchGeoData(),t=await this.getUserGeoData(),n=await this.fetchStunServers();return this.findClosestServer(t,e,n)}catch(e){console.error("Error in getClosestStunServer:",e),this.clearExpiredCache();return}}async fetchGeoData(){return await(await fetch(this.geoLocUrl)).json()}async getUserGeoData(){const e=this.getCachedGeoData();if(e)return e;const t=await fetch(this.geoUserUrl);if(!t.ok)throw new Error(`Failed to fetch user geo data: ${t.status} ${t.statusText}`);const n=await t.json();return this.setCachedGeoData(n),n}calculateDistance(e,t,n,i){return Math.sqrt(Math.pow(e-n,2)+Math.pow(t-i,2))}findClosestServer(e,t,n){const{lat:i,lon:s}=e;return n.trim().split(`
`).map(o=>{const a=o.split(":")[0];if(!t[a])return[o,1/0];const[c,l]=t[a];if(typeof c!="number"||typeof l!="number")return[o,1/0];const u=this.calculateDistance(i,s,c,l);return[o,u]}).reduce(([o,a],[c,l])=>a<=l?[o,a]:[c,l])[0]}getCachedGeoData(){const e=localStorage.getItem(this.cacheKey);if(e){const t=JSON.parse(e);if(t.expiry&&t.expiry>Date.now())return t.data;localStorage.removeItem(this.cacheKey)}return null}setCachedGeoData(e){const t={data:e,expiry:Date.now()+this.cacheDuration};localStorage.setItem(this.cacheKey,JSON.stringify(t))}clearExpiredCache(){localStorage.removeItem(this.cacheKey)}async fetchStunServers(){return await(await fetch(this.hostUrl)).text()}validateStunServer(e){return!!(e&&e.includes(":")&&e.split(":").length===2)}}var al={exports:{}},$v;function cF(){return $v||($v=1,function(r,e){var t=globalThis.require&&e||{};(function(n,i){let s=globalThis.crypto;i._sep=/[\s,:-]+/,i._mword="mnemonic",i._normalize=function(o){return o.normalize("NFKD").trim().toLowerCase()},i.generate=async function(o=128){let a=o/8,c=s.getRandomValues(new Uint8Array(a));return await i.encode(c)},i.encode=async function(o){let a=8*o.length,c=a/32;o=new Uint8Array(o);let l=await s.subtle.digest("SHA-256",o),u=new Uint8Array(l),d="";o.forEach(function(b){let _=b.toString(2).padStart(8,"0");d+=_});let p=u[0].toString(2);p=p.padStart(8,"0");let m=p.slice(0,c);d+=m;let w=[];for(let b=0;b<a+c;b+=11){let _=parseInt(d.slice(b,b+11).padStart(8,"0"),2);w.push(_)}return w.map(function(b){return i.base2048[b]}).join(" ")},i.verify=async function(o){return await i.decode(o),!0},i.checksum=i.verify,i.decode=async function(o,a){o=i._normalize(o);let c=[];o.split(i._sep).forEach(function(E){let R=i.base2048.indexOf(E);if(R<0){let S=new Error(`dashphrase.js: decode failed: unknown word '${E}'`);throw S.code="E_UNKNOWN_WORD",S}c.push(R)});let u=c.map(function(E){return E.toString(2).padStart(11,"0")}).join(""),d=Math.floor(u.length/32),h=u.length-d,p=u.slice(-d),m=[];for(let E=0;E<h;E+=8){let R=u.slice(E,E+8),S=parseInt(R,2);S>=0&&m.push(S)}let w=Uint8Array.from(m),y=await s.subtle.digest("SHA-256",w),_=new Uint8Array(y)[0].toString(2).padStart(8,"0").slice(0,d);if(_!==p&&a?.verify!==!1){let E=new Error(`dashphrase.js: bad checksum: expected '${_}' but got '${p}'`);throw E.code="E_BAD_CHECKSUM",E}return w},i.toSeed=async function(o,a="",c={}){c.verify!==!1&&await i.verify(o),o=i._normalize(o),a=a.normalize("NFKD");let u=new TextEncoder().encode(o),d=new TextEncoder().encode(i._mword+a),w=await i._pbkdf2(u,d,2048,512,"SHA-512");return new Uint8Array(w)},i.pbkdf2=i.toSeed,i._pbkdf2=async function(a,c,l,u,d){let h=!1,p=await s.subtle.importKey("raw",a,{name:"PBKDF2"},h,["deriveKey"]);h=!0;let m=await s.subtle.deriveKey({name:"PBKDF2",salt:c,iterations:l,hash:d},p,{name:"HMAC",hash:d,length:u},h,["sign","verify"]),w=await s.subtle.exportKey("raw",m);return new Uint8Array(w)},i._sha256=async function(o,a=""){o=i._normalize(o),a=a.normalize("NFKD");let c=new TextEncoder().encode(o),l=new TextEncoder().encode(a),u=new Uint8Array(c.length+l.length),d=0;for(let p=0;p<c.length;p+=1)u[d]=c[p],d+=1;for(let p=0;p<l.length;p+=1)u[d]=l[p],d+=1;let h=await s.subtle.digest("SHA-256",u);return new Uint8Array(h)},i.CATMONIC="cat swing flag economy stadium alone churn speed unique patch report train",i.ZOOMONIC="zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",i.ZECRET="TREZOR",i.ZEED="ac27495480225222079d7be181583751e86f571027b0497b5b5d11218e0a8a13332572917f0f8e5a589620c6f15b11c61dee327651a14c34e18231052e48c069",i.base2048="abandon ability able about above absent absorb abstract absurd abuse access accident account accuse achieve acid acoustic acquire across act action actor actress actual adapt add addict address adjust admit adult advance advice aerobic affair afford afraid again age agent agree ahead aim air airport aisle alarm album alcohol alert alien all alley allow almost alone alpha already also alter always amateur amazing among amount amused analyst anchor ancient anger angle angry animal ankle announce annual another answer antenna antique anxiety any apart apology appear apple approve april arch arctic area arena argue arm armed armor army around arrange arrest arrive arrow art artefact artist artwork ask aspect assault asset assist assume asthma athlete atom attack attend attitude attract auction audit august aunt author auto autumn average avocado avoid awake aware away awesome awful awkward axis baby bachelor bacon badge bag balance balcony ball bamboo banana banner bar barely bargain barrel base basic basket battle beach bean beauty because become beef before begin behave behind believe below belt bench benefit best betray better between beyond bicycle bid bike bind biology bird birth bitter black blade blame blanket blast bleak bless blind blood blossom blouse blue blur blush board boat body boil bomb bone bonus book boost border boring borrow boss bottom bounce box boy bracket brain brand brass brave bread breeze brick bridge brief bright bring brisk broccoli broken bronze broom brother brown brush bubble buddy budget buffalo build bulb bulk bullet bundle bunker burden burger burst bus business busy butter buyer buzz cabbage cabin cable cactus cage cake call calm camera camp can canal cancel candy cannon canoe canvas canyon capable capital captain car carbon card cargo carpet carry cart case cash casino castle casual cat catalog catch category cattle caught cause caution cave ceiling celery cement census century cereal certain chair chalk champion change chaos chapter charge chase chat cheap check cheese chef cherry chest chicken chief child chimney choice choose chronic chuckle chunk churn cigar cinnamon circle citizen city civil claim clap clarify claw clay clean clerk clever click client cliff climb clinic clip clock clog close cloth cloud clown club clump cluster clutch coach coast coconut code coffee coil coin collect color column combine come comfort comic common company concert conduct confirm congress connect consider control convince cook cool copper copy coral core corn correct cost cotton couch country couple course cousin cover coyote crack cradle craft cram crane crash crater crawl crazy cream credit creek crew cricket crime crisp critic crop cross crouch crowd crucial cruel cruise crumble crunch crush cry crystal cube culture cup cupboard curious current curtain curve cushion custom cute cycle dad damage damp dance danger daring dash daughter dawn day deal debate debris decade december decide decline decorate decrease deer defense define defy degree delay deliver demand demise denial dentist deny depart depend deposit depth deputy derive describe desert design desk despair destroy detail detect develop device devote diagram dial diamond diary dice diesel diet differ digital dignity dilemma dinner dinosaur direct dirt disagree discover disease dish dismiss disorder display distance divert divide divorce dizzy doctor document dog doll dolphin domain donate donkey donor door dose double dove draft dragon drama drastic draw dream dress drift drill drink drip drive drop drum dry duck dumb dune during dust dutch duty dwarf dynamic eager eagle early earn earth easily east easy echo ecology economy edge edit educate effort egg eight either elbow elder electric elegant element elephant elevator elite else embark embody embrace emerge emotion employ empower empty enable enact end endless endorse enemy energy enforce engage engine enhance enjoy enlist enough enrich enroll ensure enter entire entry envelope episode equal equip era erase erode erosion error erupt escape essay essence estate eternal ethics evidence evil evoke evolve exact example excess exchange excite exclude excuse execute exercise exhaust exhibit exile exist exit exotic expand expect expire explain expose express extend extra eye eyebrow fabric face faculty fade faint faith fall false fame family famous fan fancy fantasy farm fashion fat fatal father fatigue fault favorite feature february federal fee feed feel female fence festival fetch fever few fiber fiction field figure file film filter final find fine finger finish fire firm first fiscal fish fit fitness fix flag flame flash flat flavor flee flight flip float flock floor flower fluid flush fly foam focus fog foil fold follow food foot force forest forget fork fortune forum forward fossil foster found fox fragile frame frequent fresh friend fringe frog front frost frown frozen fruit fuel fun funny furnace fury future gadget gain galaxy gallery game gap garage garbage garden garlic garment gas gasp gate gather gauge gaze general genius genre gentle genuine gesture ghost giant gift giggle ginger giraffe girl give glad glance glare glass glide glimpse globe gloom glory glove glow glue goat goddess gold good goose gorilla gospel gossip govern gown grab grace grain grant grape grass gravity great green grid grief grit grocery group grow grunt guard guess guide guilt guitar gun gym habit hair half hammer hamster hand happy harbor hard harsh harvest hat have hawk hazard head health heart heavy hedgehog height hello helmet help hen hero hidden high hill hint hip hire history hobby hockey hold hole holiday hollow home honey hood hope horn horror horse hospital host hotel hour hover hub huge human humble humor hundred hungry hunt hurdle hurry hurt husband hybrid ice icon idea identify idle ignore ill illegal illness image imitate immense immune impact impose improve impulse inch include income increase index indicate indoor industry infant inflict inform inhale inherit initial inject injury inmate inner innocent input inquiry insane insect inside inspire install intact interest into invest invite involve iron island isolate issue item ivory jacket jaguar jar jazz jealous jeans jelly jewel job join joke journey joy judge juice jump jungle junior junk just kangaroo keen keep ketchup key kick kid kidney kind kingdom kiss kit kitchen kite kitten kiwi knee knife knock know lab label labor ladder lady lake lamp language laptop large later latin laugh laundry lava law lawn lawsuit layer lazy leader leaf learn leave lecture left leg legal legend leisure lemon lend length lens leopard lesson letter level liar liberty library license life lift light like limb limit link lion liquid list little live lizard load loan lobster local lock logic lonely long loop lottery loud lounge love loyal lucky luggage lumber lunar lunch luxury lyrics machine mad magic magnet maid mail main major make mammal man manage mandate mango mansion manual maple marble march margin marine market marriage mask mass master match material math matrix matter maximum maze meadow mean measure meat mechanic medal media melody melt member memory mention menu mercy merge merit merry mesh message metal method middle midnight milk million mimic mind minimum minor minute miracle mirror misery miss mistake mix mixed mixture mobile model modify mom moment monitor monkey monster month moon moral more morning mosquito mother motion motor mountain mouse move movie much muffin mule multiply muscle museum mushroom music must mutual myself mystery myth naive name napkin narrow nasty nation nature near neck need negative neglect neither nephew nerve nest net network neutral never news next nice night noble noise nominee noodle normal north nose notable note nothing notice novel now nuclear number nurse nut oak obey object oblige obscure observe obtain obvious occur ocean october odor off offer office often oil okay old olive olympic omit once one onion online only open opera opinion oppose option orange orbit orchard order ordinary organ orient original orphan ostrich other outdoor outer output outside oval oven over own owner oxygen oyster ozone pact paddle page pair palace palm panda panel panic panther paper parade parent park parrot party pass patch path patient patrol pattern pause pave payment peace peanut pear peasant pelican pen penalty pencil people pepper perfect permit person pet phone photo phrase physical piano picnic picture piece pig pigeon pill pilot pink pioneer pipe pistol pitch pizza place planet plastic plate play please pledge pluck plug plunge poem poet point polar pole police pond pony pool popular portion position possible post potato pottery poverty powder power practice praise predict prefer prepare present pretty prevent price pride primary print priority prison private prize problem process produce profit program project promote proof property prosper protect proud provide public pudding pull pulp pulse pumpkin punch pupil puppy purchase purity purpose purse push put puzzle pyramid quality quantum quarter question quick quit quiz quote rabbit raccoon race rack radar radio rail rain raise rally ramp ranch random range rapid rare rate rather raven raw razor ready real reason rebel rebuild recall receive recipe record recycle reduce reflect reform refuse region regret regular reject relax release relief rely remain remember remind remove render renew rent reopen repair repeat replace report require rescue resemble resist resource response result retire retreat return reunion reveal review reward rhythm rib ribbon rice rich ride ridge rifle right rigid ring riot ripple risk ritual rival river road roast robot robust rocket romance roof rookie room rose rotate rough round route royal rubber rude rug rule run runway rural sad saddle sadness safe sail salad salmon salon salt salute same sample sand satisfy satoshi sauce sausage save say scale scan scare scatter scene scheme school science scissors scorpion scout scrap screen script scrub sea search season seat second secret section security seed seek segment select sell seminar senior sense sentence series service session settle setup seven shadow shaft shallow share shed shell sheriff shield shift shine ship shiver shock shoe shoot shop short shoulder shove shrimp shrug shuffle shy sibling sick side siege sight sign silent silk silly silver similar simple since sing siren sister situate six size skate sketch ski skill skin skirt skull slab slam sleep slender slice slide slight slim slogan slot slow slush small smart smile smoke smooth snack snake snap sniff snow soap soccer social sock soda soft solar soldier solid solution solve someone song soon sorry sort soul sound soup source south space spare spatial spawn speak special speed spell spend sphere spice spider spike spin spirit split spoil sponsor spoon sport spot spray spread spring spy square squeeze squirrel stable stadium staff stage stairs stamp stand start state stay steak steel stem step stereo stick still sting stock stomach stone stool story stove strategy street strike strong struggle student stuff stumble style subject submit subway success such sudden suffer sugar suggest suit summer sun sunny sunset super supply supreme sure surface surge surprise surround survey suspect sustain swallow swamp swap swarm swear sweet swift swim swing switch sword symbol symptom syrup system table tackle tag tail talent talk tank tape target task taste tattoo taxi teach team tell ten tenant tennis tent term test text thank that theme then theory there they thing this thought three thrive throw thumb thunder ticket tide tiger tilt timber time tiny tip tired tissue title toast tobacco today toddler toe together toilet token tomato tomorrow tone tongue tonight tool tooth top topic topple torch tornado tortoise toss total tourist toward tower town toy track trade traffic tragic train transfer trap trash travel tray treat tree trend trial tribe trick trigger trim trip trophy trouble truck true truly trumpet trust truth try tube tuition tumble tuna tunnel turkey turn turtle twelve twenty twice twin twist two type typical ugly umbrella unable unaware uncle uncover under undo unfair unfold unhappy uniform unique unit universe unknown unlock until unusual unveil update upgrade uphold upon upper upset urban urge usage use used useful useless usual utility vacant vacuum vague valid valley valve van vanish vapor various vast vault vehicle velvet vendor venture venue verb verify version very vessel veteran viable vibrant vicious victory video view village vintage violin virtual virus visa visit visual vital vivid vocal voice void volcano volume vote voyage wage wagon wait walk wall walnut want warfare warm warrior wash wasp waste water wave way wealth weapon wear weasel weather web wedding weekend weird welcome west wet whale what wheat wheel when where whip whisper wide width wife wild will win window wine wing wink winner winter wire wisdom wise wish witness wolf woman wonder wood wool word work world worry worth wrap wreck wrestle wrist write wrong yard year yellow you young youth zebra zero zone zoo".normalize("NFKD").split(" "),n.DashPhrase=i})(globalThis.window||{},t),r.exports=t}(al,al.exports)),al.exports}var lF=cF();const uF=bo(lF);class dF{apiUrl;constructor(e){this.apiUrl=e}async generatePhrase(){const e=await uF.generate(16);return[self.crypto.getRandomValues(new Uint32Array(1))[0]%100,...e.split(" ")].join("-")}async registerPhrase(e,t){try{const n=await this.makeApiRequest("/phrase","POST",{Maddr:t.toString(),Phrase:e});if(!n.ok)throw new Error(`Failed to register phrase. Status: ${n.status}`);return await n.json()}catch(n){throw this.handleApiError(n),n}}async lookupPhrase(e){try{const t=await this.makeApiRequest(`/phrase/${encodeURIComponent(e)}`,"GET");if(!t.ok)throw new Error(`Failed to lookup phrase. Status: ${t.status}`);return await t.json()}catch(t){throw this.handleApiError(t),t}}async makeApiRequest(e,t,n=null){const i=`${this.apiUrl}${e}`,s={method:t,headers:{"Content-type":"application/json; charset=UTF-8"}};return n&&(s.body=JSON.stringify(n)),await fetch(i,s)}handleApiError(e){console.error("API Error:",e)}validatePhrase(e){return!!(e!=null&&e.trim().length>0&&/^\d{1,3}-(?:[a-z]{3,8})-(?:[a-z]{3,8})$/.test(e))}sanitizePhrase(e){return e.trim().toLowerCase()}}class hF{appState;elements;theme="light";onFileSelected=()=>{};onPhraseEntered=()=>{};onReceiveModeRequested=()=>{};constructor(e){this.appState=e,this.elements=this.getUIElements(),this.initTheme(),this.clearPhrase()}showSenderMode(){this.hideElement("initialDropUI"),this.showElement("fileInfoArea")}showSendingInProgress(){this.hideElement("fileInfoArea"),this.showElement("sendInProgress")}showReceiverMode(){this.hideElement("initialReceiveUI"),this.showElement("receiveInProgress")}showHome(){window.location.assign(window.location.origin)}showSendWindow(){this.showElement("goBackButton","flex"),this.hideElement("goSendButton"),this.hideElement("goReceiveButton"),this.showElement("sendWindow"),this.hideElement("receiveWindow")}showReceiveWindow(){this.showElement("goBackButton","flex"),this.hideElement("goSendButton"),this.hideElement("goReceiveButton"),this.showElement("receiveWindow"),this.hideElement("sendWindow")}resetUI(){this.showHome(),this.clearFileDisplay(),this.hideErrorPopup()}initTheme(){this.theme=localStorage.theme||this.getSystemTheme(),document.documentElement.classList.add(this.theme)}toggleTheme(){this.theme==="light"?(this.theme="dark",localStorage.theme="dark",document.documentElement.classList.remove("light"),document.documentElement.classList.add("dark")):(this.theme="light",localStorage.theme="light",document.documentElement.classList.remove("dark"),document.documentElement.classList.add("light"))}getSystemTheme(){return window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?(localStorage.theme="dark","dark"):(localStorage.theme="light","light")}displaySelectedFile(e){this.updateElement("fileNameDisplay",e.name),this.updateElement("fileSizeDisplay",`${(e.size/1024/1024).toFixed(2)} MB`)}showFileProgress(e,t){const{percentage:n,current:i,total:s,rate:o}=e,a=t==="send"?"sendProgressBar":"receiveProgressBar",c=t==="send"?"sendProgressText":"receiveProgressText",l=t==="send"?"sendRate":"receiveRate";this.updateProgressBar(a,n),this.updateElement(c,`${i} MB / ${s} MB`),this.updateElement(l,`${o} Mbps`)}showReceivedFileDetails(e,t){this.updateElement("receivedFileName",e),this.updateElement("receivedFileSize",`${(t/1024/1024).toFixed(2)} MB`)}showTransferComplete(e){const t=e==="send"?"sendInProgress":"receiveInProgress",n=e==="send"?"sendComplete":"receiveComplete";this.hideElement(t),this.showElement(n)}updateProgressBar(e,t){const n=document.getElementById(e);n&&(n.style.width=`${t}%`)}clearFileDisplay(){this.updateElement("fileNameDisplay",""),this.updateElement("fileSizeDisplay","")}showReconnecting(){this.appState.getMode()==="sender"?(this.hideElement("sendInProgress"),this.showElement("reconnectingSend")):this.appState.getMode()==="receiver"&&(this.hideElement("receiveInProgress"),this.showElement("reconnectingReceive"))}hideReconnecting(){this.appState.getMode()==="sender"?(this.hideElement("reconnectingSend"),this.showElement("sendInProgress")):this.appState.getMode()==="receiver"&&(this.hideElement("reconnectingReceive"),this.showElement("receiveInProgress"))}showErrorPopup(e){this.updateElement("errorMessageText",e),this.elements.errorWindow?.classList.remove("hidden")}hideErrorPopup(){this.elements.errorWindow?.classList.add("hidden")}setupEventListeners(){this.setupFileHandlers(),this.setupButtonHandlers(),this.setupErrorHandlers()}setupFileHandlers(){const e=this.elements.dropZone,t=this.elements.fileInput;e?.addEventListener("dragover",this.handleDragOver.bind(this)),e?.addEventListener("drop",this.handleFileDrop.bind(this)),t?.addEventListener("change",this.handleFileSelect.bind(this))}setupButtonHandlers(){this.elements.sun?.addEventListener("click",()=>this.toggleTheme()),this.elements.moon?.addEventListener("click",()=>this.toggleTheme()),this.elements.selectFileButton?.addEventListener("click",()=>this.elements.fileInput?.click()),this.elements.goSendButton?.addEventListener("click",this.showSendWindow.bind(this)),this.elements.goReceiveButton?.addEventListener("click",this.showReceiveWindow.bind(this)),this.elements.goBackButton?.addEventListener("click",this.showHome.bind(this)),this.elements.copyPhraseButton?.addEventListener("click",this.copyPhrase.bind(this)),this.elements.receiveModeButton?.addEventListener("click",()=>{const t=document.getElementById("phraseInput").value.trim();if(!t){this.showErrorPopup("Please enter a valid phrase.");return}this.showReceiverMode(),this.onPhraseEntered(t)})}setupErrorHandlers(){const e=this.elements.errorWindow,t=this.elements.closeErrorButton;e?.addEventListener("click",n=>{n.target===e&&(this.hideErrorPopup(),this.resetUI())}),t?.addEventListener("click",()=>{this.hideErrorPopup(),this.resetUI()})}handleDragOver(e){e.preventDefault()}handleFileDrop(e){e.preventDefault();let t=null;if(e.dataTransfer?.items){const n=[...e.dataTransfer.items].find(i=>i.kind==="file");n&&(t=n.getAsFile())}else e.dataTransfer?.files&&e.dataTransfer.files.length>0&&(t=e.dataTransfer.files[0]);t&&(this.appState.setSelectedFile(t),this.displaySelectedFile(t),this.onFileSelected(t))}handleFileSelect(e){const t=e.target;if(t.files&&t.files[0]){const n=t.files[0];this.appState.setSelectedFile(n),this.displaySelectedFile(n),this.onFileSelected(n)}}showPhrase(e){this.updateElement("generatedPhraseDisplay",e)}copyPhrase(){this.elements.generatedPhraseDisplay?.innerText&&navigator.clipboard.writeText(this.elements.generatedPhraseDisplay.innerText)}clearPhrase(){const e=document.getElementById("phraseInput");e&&(e.value="")}updateElement(e,t){const n=document.getElementById(e);n&&(n.textContent=t)}showElement(e,t="block"){const n=document.getElementById(e);n&&(n.style.display=t)}hideElement(e){const t=document.getElementById(e);t&&(t.style.display="none")}getUIElements(){return{dropZone:document.getElementById("drop_zone"),fileInput:document.getElementById("fileInput"),copyPhraseButton:document.getElementById("copyPhraseButton"),receiveModeButton:document.getElementById("receiveModeButton"),goSendButton:document.getElementById("goSendButton"),goReceiveButton:document.getElementById("goReceiveButton"),goBackButton:document.getElementById("goBackButton"),selectFileButton:document.getElementById("selectFileButton"),errorWindow:document.getElementById("errorWindow"),closeErrorButton:document.getElementById("closeErrorButton"),generatedPhraseDisplay:document.getElementById("generatedPhraseDisplay"),sun:document.getElementById("sun"),moon:document.getElementById("moon")}}}class fF{uiManager;lastUpdateTime;lastBytes;updateInterval;constructor(e){this.uiManager=e,this.lastUpdateTime=0,this.lastBytes=0,this.updateInterval=250}updateProgress(e,t,n,i=!1){const s=Date.now(),o=s-this.lastUpdateTime;if(!i&&o<this.updateInterval)return;const a=o/1e3,c=e-this.lastBytes;let l=0;a>0&&c>0&&(l=c/a*8/(1024*1024));const u=t>0?e/t*100:0,d=(e/(1024*1024)).toFixed(2),h=(t/(1024*1024)).toFixed(2);if(console.log("Receive progress: "+u.toFixed(2)+"% ("+d+" MB / "+h+" MB)"),this.uiManager.showSendingInProgress(),u>=100)this.uiManager.showTransferComplete(n);else{const p={percentage:u,current:d,total:h,rate:l.toFixed(2)};this.uiManager.showFileProgress(p,n)}this.lastUpdateTime=s,this.lastBytes=e}}class pF{uiManager;constructor(e){this.uiManager=e}handleConnectionError(e,t){const n=`Connection error: ${e.message}`;this.logError(e,t),this.uiManager.showErrorPopup(n)}tryAgainError(){this.uiManager.showErrorPopup("The FileFerry got lost at sea, make sure your maps are in order and try again.")}handleTransferError(e,t){const n=`Transfer error: ${e.message}`;this.logError(e,t),this.uiManager.showErrorPopup(n)}handleApiError(e,t){const n=`API error: ${e.message}`;this.logError(e,t),this.uiManager.showErrorPopup(n)}reconnecting(){this.uiManager.showReconnecting()}reconnected(){this.uiManager.hideReconnecting()}logError(e,t){console.error("Error:",e.message,"Context:",t)}isNetworkError(e){return e.message.includes("network")||e.message.includes("connection")||e.code==="NETWORK_ERROR"}isTimeoutError(e){return e.message.includes("timeout")||e.message.includes("timed out")||e.code==="TIMEOUT"}isRecoverableError(e){return this.isNetworkError(e)||this.isTimeoutError(e)}}class gF{config;constructor(){this.config={relay:{address:"/ip4/195.114.14.137/tcp/41338/tls/sni/195-114-14-137.k51qzi5uqu5dlg6rzzu1wamxpip5om9vddzw5dvmw38wp1f4b30yi0q4itxkym.libp2p.direct/ws/p2p/12D3KooWQ3E3PsbrVnnh34dSggrcTqBKqrA2bbMwTH9EHmea7CfP",timeout:3e4},api:{url:"https://exchange.fileferry.xyz",timeout:1e4},transfer:{chunkSize:256*256,protocol:"/fileferry/filetransfer/1.0.0"},stun:{fallback:"stun:l.google.com:19302",timeout:5e3},debug:!0}}getRelayAddress(){return this.config.relay.address}getApiUrl(){return this.config.api.url}getStunServers(){return[this.config.stun.fallback,"turn:relay.fileferry.xyz:3478?transport=udp","turn:relay.fileferry.xyz:3478?transport=tcp"]}getTransferSettings(){return this.config.transfer}getFileTransferProtocol(){return this.config.transfer.protocol}validateConfig(){const e=["relay.address","api.url","transfer.protocol"];for(const t of e)if(!this.getConfigValue(t))throw new Error(`Missing required configuration: ${t}`);return!0}getConfigValue(e,t=null){const n=e.split(".");let i=this.config;for(const s of n){if(i[s]===void 0)return t;i=i[s]}return i}}class mF{config;appState;node;services;managers;constructor(){this.config=new gF,this.appState=new k4,this.node=null,this.services={},this.managers={}}async initialize(){try{this.config.validateConfig(),await this.setupServices(),await this.setupLibp2pNode(),await this.setupManagers(),await this.setupUI(),console.log("FileFerry app initialized successfully")}catch(e){throw console.error("Failed to initialize app:",e),e}}async setupServices(){this.services.stun=new aF,this.services.phrase=new dF(this.config.getApiUrl())}async setupLibp2pNode(){const e=await this.getStunConfiguration();console.log(e);const t={rtcConfiguration:{iceServers:[{urls:["stun:stun.l.google.com:19302",e,"turn:relay.fileferry.xyz:3478?transport=udp","turn:relay.fileferry.xyz:3478?transport=tcp"],username:"ferryCaptain",credential:"i^YV13eTPOHdVzWm#2t5"}]}},n={addresses:{listen:["/p2p-circuit","/webrtc"]},transports:[EB(),nM(t),rM(t),SM({filter:cx})],connectionEncrypters:[SE()],streamMuxers:[rR({maxStreamWindowSize:1024*1024*4})],connectionManager:{maxConnections:50,dialTimeout:3e4},connectionGater:{denyDialMultiaddr:()=>!1},services:{autoNAT:o4(),dcutr:I4(),identify:jB({maxMessageSize:1024*1024*16,timeout:1e4}),identifyPush:HB({concurrency:1}),keychain:_4(),ping:eN()}};this.node=await W8(n),await this.node.start(),console.log(`Node started with Peer ID: ${this.node.peerId.toString()}`)}async setupManagers(){if(!this.node)throw new Error("Libp2p node is not initialized.");this.managers.ui=new hF(this.appState),this.managers.error=new pF(this.managers.ui),this.managers.progress=new fF(this.managers.ui),this.managers.fileTransfer=new oF(this.node,this.appState,this.managers.progress,this.managers.ui),this.managers.connection=new T4(this.node,this.appState,this.managers.error,this.config,this.managers.fileTransfer),this.setupEventListeners(),this.managers.fileTransfer.setupFileTransferProtocol();const e=window.location.pathname;e&&this.actionPathname(e)}async setupUI(){if(!this.managers.ui)throw new Error("UIManager not initialized");this.managers.ui.setupEventListeners(),this.managers.ui.onFileSelected=this.handleFileSelected.bind(this),this.managers.ui.onPhraseEntered=this.handlePhraseEntered.bind(this),this.managers.ui.onReceiveModeRequested=this.handleReceiveModeRequested.bind(this)}setupEventListeners(){!this.node||!this.managers.connection||(this.node.addEventListener("connection:open",this.managers.connection.onConnectionEstablished.bind(this.managers.connection)),this.node.addEventListener("connection:close",this.managers.connection.onConnectionClosed.bind(this.managers.connection)))}async getStunConfiguration(){if(!this.services.stun)return this.config.getStunServers()[0];try{const e=await this.services.stun.getClosestStunServer();return e?`stun:${e}`:this.config.getStunServers()[0]}catch(e){return console.warn("Could not fetch closest STUN server:",e),this.config.getStunServers()[0]}}async handleFileSelected(e){if(!(!this.managers.ui||!this.managers.error))try{this.managers.ui.showSenderMode(),await this.startSenderMode(e)}catch(t){this.managers.error.handleTransferError(t,{operation:"fileSelected",direction:"send"})}}async handlePhraseEntered(e){if(this.managers.error)try{await this.startReceiverMode(e)}catch(t){this.managers.error.handleApiError(t,{operation:"phraseEntered"})}}async handleReceiveModeRequested(){this.managers.ui&&this.managers.ui.showReceiverMode()}async startSenderMode(e){if(!(!this.services.phrase||!this.managers.error))try{this.appState.setSelectedFile(e),this.appState.setMode("sender"),console.log("Starting sender mode...");const t=await this.services.phrase.generatePhrase();console.log(`Generated phrase: ${t}`);const n=document.getElementById("generatedPhraseDisplay");n&&(n.textContent=t);const i=de(this.config.getRelayAddress());i?await this.managers.connection?.dialPeer(i,{signal:AbortSignal.timeout(5e3)}):this.managers.ui?.showErrorPopup("Relay address is not configured.");let s;for(;!s;)s=this.node?.getMultiaddrs().find(o=>Jl.matches(o)),await new Promise(o=>setTimeout(o,1e3));console.log("WebRTC Circuit Address:",s?.toString()),console.log("Registering phrase..."),await this.services.phrase.registerPhrase(t,s),console.log("Sender mode setup complete. Waiting for receiver...")}catch(t){throw console.error("Failed to start sender mode:",t),this.managers.error.handleTransferError(t,{operation:"startSenderMode",direction:"send"}),this.appState.setMode("idle"),t}}async startReceiverMode(e){if(!this.appState||!this.services.phrase||!this.managers.connection||!this.node)return;this.appState.setMode("receiver");const t=await this.services.phrase.lookupPhrase(e);if(!t.maddr)throw new Error("No address found for phrase");const n=de(t.maddr);console.log(`Connecting to peer: ${t.maddr}`);const i=await this.managers.connection.dialPeer(n,{signal:AbortSignal.timeout(6e4)});console.log(`Connected to sender via phrase: ${e}`),this.appState.setActivePeer(i.remotePeer.toString())}actionPathname(e){if(e.startsWith("/send"))this.managers.ui?.showSendWindow();else if(e.startsWith("/receive")){this.managers.ui?.showReceiveWindow();const t=new URLSearchParams(window.location.search),n=this.services.phrase?.sanitizePhrase(t.get("phrase")||"");n&&this.services.phrase?.validatePhrase(n)?(this.startReceiverMode(n),this.managers.ui?.showReceiverMode(),this.managers.ui?.onPhraseEntered(n)):this.managers.ui?.showErrorPopup("Invalid phrase provided.")}}async start(){await this.initialize()}async stop(){this.node&&await this.node.stop(),this.appState.reset(),console.log("FileFerry app stopped")}}const W_=new mF;document.addEventListener("DOMContentLoaded",async()=>{try{await W_.start()}catch(r){console.error("Failed to start FileFerry app:",r)}});window.addEventListener("unhandledrejection",r=>{console.error("Unhandled promise rejection:",r.reason)});window.addEventListener("error",r=>{console.error("Global error:",r.error)});window.fileFerryApp=W_;
