(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const s of i)if(s.type==="childList")for(const o of s.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function t(i){const s={};return i.integrity&&(s.integrity=i.integrity),i.referrerPolicy&&(s.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?s.credentials="include":i.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(i){if(i.ep)return;i.ep=!0;const s=t(i);fetch(i.href,s)}})();const a_=Symbol.for("@libp2p/connection"),ay=Symbol.for("@libp2p/content-routing"),cy=Symbol.for("@libp2p/peer-discovery"),sg=Symbol.for("@libp2p/peer-id");function pv(r){return!!r?.[sg]}const ly=Symbol.for("@libp2p/peer-routing"),og="keep-alive",Eu=Symbol.for("@libp2p/transport");var Ho;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(Ho||(Ho={}));let Ii=class extends Error{static name="AbortError";constructor(e="The operation was aborted"){super(e),this.name="AbortError"}};class c_ extends Error{static name="UnexpectedPeerError";constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}}let l_=class extends Error{static name="InvalidCryptoExchangeError";constructor(e="Invalid crypto exchange"){super(e),this.name="InvalidCryptoExchangeError"}},le=class extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}};class gv extends Error{static name="InvalidPublicKeyError";constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}}class mv extends Error{static name="InvalidPrivateKeyError";constructor(e="Invalid private key"){super(e),this.name="InvalidPrivateKeyError"}}class u_ extends Error{static name="ConnectionClosingError";constructor(e="The connection is closing"){super(e),this.name="ConnectionClosingError"}}class yv extends Error{static name="ConnectionClosedError";constructor(e="The connection is closed"){super(e),this.name="ConnectionClosedError"}}class wv extends Error{static name="ConnectionFailedError";constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}}class vo extends Error{static name="MuxerClosedError";constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}}class d_ extends Error{static name="StreamResetError";constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}}class Qh extends Error{static name="StreamStateError";constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}}let di=class extends Error{static name="NotFoundError";constructor(e="Not found"){super(e),this.name="NotFoundError"}};class bv extends Error{static name="InvalidPeerIdError";constructor(e="Invalid PeerID"){super(e),this.name="InvalidPeerIdError"}}let ag=class extends Error{static name="InvalidMultiaddrError";constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}};class h_ extends Error{static name="InvalidCIDError";constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}}class f_ extends Error{static name="InvalidMultihashError";constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}}class cg extends Error{static name="UnsupportedProtocolError";constructor(e="Unsupported protocol error"){super(e),this.name="UnsupportedProtocolError"}}class Et extends Error{static name="InvalidMessageError";constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}}class p_ extends Error{static name="ProtocolError";constructor(e="Protocol error"){super(e),this.name="ProtocolError"}}let lg=class extends Error{static name="TimeoutError";constructor(e="Timed out"){super(e),this.name="TimeoutError"}};class Wo extends Error{static name="NotStartedError";constructor(e="Not started"){super(e),this.name="NotStartedError"}}class Do extends Error{static name="DialError";constructor(e="Dial error"){super(e),this.name="DialError"}}class Xh extends Error{static name="ListenError";constructor(e="Listen error"){super(e),this.name="ListenError"}}class vv extends Error{static name="LimitedConnectionError";constructor(e="Limited connection"){super(e),this.name="LimitedConnectionError"}}class g_ extends Error{static name="TooManyInboundProtocolStreamsError";constructor(e="Too many inbound protocol streams"){super(e),this.name="TooManyInboundProtocolStreamsError"}}class Sv extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}}class Au extends Error{static name="UnsupportedKeyTypeError";constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}}class $r extends EventTarget{#e=new Map;constructor(){super()}listenerCount(e){const t=this.#e.get(e);return t==null?0:t.length}addEventListener(e,t,n){super.addEventListener(e,t,n);let i=this.#e.get(e);i==null&&(i=[],this.#e.set(e,i)),i.push({callback:t,once:(n!==!0&&n!==!1&&n?.once)??!1})}removeEventListener(e,t,n){super.removeEventListener(e.toString(),t??null,n);let i=this.#e.get(e);i!=null&&(i=i.filter(({callback:s})=>s!==t),this.#e.set(e,i))}dispatchEvent(e){const t=super.dispatchEvent(e);let n=this.#e.get(e.type);return n==null||(n=n.filter(({once:i})=>!i),this.#e.set(e.type,n)),t}safeDispatchEvent(e,t={}){return this.dispatchEvent(new CustomEvent(e,t))}}function ug(r){return r!=null&&typeof r.start=="function"&&typeof r.stop=="function"}async function Ev(...r){const e=[];for(const t of r)ug(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStart!=null&&await t.beforeStart()})),await Promise.all(e.map(async t=>{await t.start()})),await Promise.all(e.map(async t=>{t.afterStart!=null&&await t.afterStart()}))}async function Av(...r){const e=[];for(const t of r)ug(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStop!=null&&await t.beforeStop()})),await Promise.all(e.map(async t=>{await t.stop()})),await Promise.all(e.map(async t=>{t.afterStop!=null&&await t.afterStop()}))}const Zt=Symbol.for("@libp2p/service-capabilities"),As=Symbol.for("@libp2p/service-dependencies");function m_(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function xu(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function y_(r){return new TextEncoder().encode(r)}function w_(r){return new TextDecoder().decode(r)}function b_(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var i=0;i<r.length;i++){var s=r.charAt(i),o=s.charCodeAt(0);if(t[o]!==255)throw new TypeError(s+" is ambiguous");t[o]=i}var a=r.length,c=r.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function d(g){if(g instanceof Uint8Array||(ArrayBuffer.isView(g)?g=new Uint8Array(g.buffer,g.byteOffset,g.byteLength):Array.isArray(g)&&(g=Uint8Array.from(g))),!(g instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(g.length===0)return"";for(var y=0,w=0,x=0,T=g.length;x!==T&&g[x]===0;)x++,y++;for(var v=(T-x)*u+1>>>0,b=new Uint8Array(v);x!==T;){for(var A=g[x],R=0,C=v-1;(A!==0||R<w)&&C!==-1;C--,R++)A+=256*b[C]>>>0,b[C]=A%a>>>0,A=A/a>>>0;if(A!==0)throw new Error("Non-zero carry");w=R,x++}for(var P=v-w;P!==v&&b[P]===0;)P++;for(var D=c.repeat(y);P<v;++P)D+=r.charAt(b[P]);return D}function f(g){if(typeof g!="string")throw new TypeError("Expected String");if(g.length===0)return new Uint8Array;var y=0;if(g[y]!==" "){for(var w=0,x=0;g[y]===c;)w++,y++;for(var T=(g.length-y)*l+1>>>0,v=new Uint8Array(T);g[y];){var b=t[g.charCodeAt(y)];if(b===255)return;for(var A=0,R=T-1;(b!==0||A<x)&&R!==-1;R--,A++)b+=a*v[R]>>>0,v[R]=b%256>>>0,b=b/256>>>0;if(b!==0)throw new Error("Non-zero carry");x=A,y++}if(g[y]!==" "){for(var C=T-x;C!==T&&v[C]===0;)C++;for(var P=new Uint8Array(w+(T-C)),D=w;C!==T;)P[D++]=v[C++];return P}}}function m(g){var y=f(g);if(y)return y;throw new Error(`Non-${e} character`)}return{encode:d,decodeUnsafe:f,decode:m}}var v_=b_,S_=v_;class E_{name;prefix;baseEncode;constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}let A_=class{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,n){this.name=e,this.prefix=t;const i=t.codePointAt(0);if(i===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=i,this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return xv(this,e)}};class x_{decoders;constructor(e){this.decoders=e}or(e){return xv(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n!=null)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function xv(r,e){return new x_({...r.decoders??{[r.prefix]:r},...e.decoders??{[e.prefix]:e}})}class __{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,n,i){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=i,this.encoder=new E_(e,t,n),this.decoder=new A_(e,t,i)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function _u({name:r,prefix:e,encode:t,decode:n}){return new __(r,e,t,n)}function wa({name:r,prefix:e,alphabet:t}){const{encode:n,decode:i}=S_(t,r);return _u({prefix:e,name:r,encode:n,decode:s=>xu(i(s))})}function C_(r,e,t,n){let i=r.length;for(;r[i-1]==="=";)--i;const s=new Uint8Array(i*t/8|0);let o=0,a=0,c=0;for(let l=0;l<i;++l){const u=e[r[l]];if(u===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<t|u,o+=t,o>=8&&(o-=8,s[c++]=255&a>>o)}if(o>=t||(255&a<<8-o)!==0)throw new SyntaxError("Unexpected end of data");return s}function I_(r,e,t){const n=e[e.length-1]==="=",i=(1<<t)-1;let s="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>t;)o-=t,s+=e[i&a>>o];if(o!==0&&(s+=e[i&a<<t-o]),n)for(;(s.length*t&7)!==0;)s+="=";return s}function k_(r){const e={};for(let t=0;t<r.length;++t)e[r[t]]=t;return e}function gt({name:r,prefix:e,bitsPerChar:t,alphabet:n}){const i=k_(n);return _u({prefix:e,name:r,encode(s){return I_(s,n,t)},decode(s){return C_(s,i,t,r)}})}const Je=wa({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),T_=wa({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),P_=Object.freeze(Object.defineProperty({__proto__:null,base58btc:Je,base58flickr:T_},Symbol.toStringTag,{value:"Module"})),Dn=gt({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),R_=gt({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),O_=gt({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),B_=gt({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),N_=gt({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),D_=gt({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),L_=gt({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),M_=gt({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),U_=gt({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),F_=Object.freeze(Object.defineProperty({__proto__:null,base32:Dn,base32hex:N_,base32hexpad:L_,base32hexpadupper:M_,base32hexupper:D_,base32pad:O_,base32padupper:B_,base32upper:R_,base32z:U_},Symbol.toStringTag,{value:"Module"})),jc=wa({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),$_=wa({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),V_=Object.freeze(Object.defineProperty({__proto__:null,base36:jc,base36upper:$_},Symbol.toStringTag,{value:"Module"}));var q_=_v,uy=128,j_=-128,z_=Math.pow(2,31);function _v(r,e,t){e=e||[],t=t||0;for(var n=t;r>=z_;)e[t++]=r&255|uy,r/=128;for(;r&j_;)e[t++]=r&255|uy,r>>>=7;return e[t]=r|0,_v.bytes=t-n+1,e}var H_=Zh,W_=128,dy=127;function Zh(r,n){var t=0,n=n||0,i=0,s=n,o,a=r.length;do{if(s>=a)throw Zh.bytes=0,new RangeError("Could not decode varint");o=r[s++],t+=i<28?(o&dy)<<i:(o&dy)*Math.pow(2,i),i+=7}while(o>=W_);return Zh.bytes=s-n,t}var K_=Math.pow(2,7),G_=Math.pow(2,14),Y_=Math.pow(2,21),Q_=Math.pow(2,28),X_=Math.pow(2,35),Z_=Math.pow(2,42),J_=Math.pow(2,49),eC=Math.pow(2,56),tC=Math.pow(2,63),rC=function(r){return r<K_?1:r<G_?2:r<Y_?3:r<Q_?4:r<X_?5:r<Z_?6:r<J_?7:r<eC?8:r<tC?9:10},nC={encode:q_,decode:H_,encodingLength:rC},rl=nC;function Jh(r,e=0){return[rl.decode(r,e),rl.decode.bytes]}function nl(r,e,t=0){return rl.encode(r,e,t),e}function il(r){return rl.encodingLength(r)}function qn(r,e){const t=e.byteLength,n=il(r),i=n+il(t),s=new Uint8Array(i+t);return nl(r,s,0),nl(t,s,n),s.set(e,i),new dg(r,t,e,s)}function Qn(r){const e=xu(r),[t,n]=Jh(e),[i,s]=Jh(e.subarray(n)),o=e.subarray(n+s);if(o.byteLength!==i)throw new Error("Incorrect length");return new dg(t,i,o,e)}function iC(r,e){if(r===e)return!0;{const t=e;return r.code===t.code&&r.size===t.size&&t.bytes instanceof Uint8Array&&m_(r.bytes,t.bytes)}}class dg{code;size;digest;bytes;constructor(e,t,n,i){this.code=e,this.size=t,this.digest=n,this.bytes=i}}function hy(r,e){const{bytes:t,version:n}=r;switch(n){case 0:return oC(t,ef(r),e??Je.encoder);default:return aC(t,ef(r),e??Dn.encoder)}}const fy=new WeakMap;function ef(r){const e=fy.get(r);if(e==null){const t=new Map;return fy.set(r,t),t}return e}class Le{code;version;multihash;bytes;"/";constructor(e,t,n,i){this.code=t,this.version=e,this.multihash=n,this.bytes=i,this["/"]=i}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==So)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==cC)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return Le.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=qn(e,t);return Le.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return Le.equals(this,e)}static equals(e,t){const n=t;return n!=null&&e.code===n.code&&e.version===n.version&&iC(e.multihash,n.multihash)}toString(e){return hy(this,e)}toJSON(){return{"/":hy(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof Le)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:n,code:i,multihash:s,bytes:o}=t;return new Le(n,i,s,o??py(n,i,s.bytes))}else if(t[lC]===!0){const{version:n,multihash:i,code:s}=t,o=Qn(i);return Le.create(n,s,o)}else return null}static create(e,t,n){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==So)throw new Error(`Version 0 CID must use dag-pb (code: ${So}) block encoding`);return new Le(e,t,n,n.bytes)}case 1:{const i=py(e,t,n.bytes);return new Le(e,t,n,i)}default:throw new Error("Invalid version")}}static createV0(e){return Le.create(0,So,e)}static createV1(e,t){return Le.create(1,e,t)}static decode(e){const[t,n]=Le.decodeFirst(e);if(n.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=Le.inspectBytes(e),n=t.size-t.multihashSize,i=xu(e.subarray(n,n+t.multihashSize));if(i.byteLength!==t.multihashSize)throw new Error("Incorrect length");const s=i.subarray(t.multihashSize-t.digestSize),o=new dg(t.multihashCode,t.digestSize,s,i);return[t.version===0?Le.createV0(o):Le.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[d,f]=Jh(e.subarray(t));return t+=f,d};let i=n(),s=So;if(i===18?(i=0,t=0):s=n(),i!==0&&i!==1)throw new RangeError(`Invalid CID version ${i}`);const o=t,a=n(),c=n(),l=t+c,u=l-o;return{version:i,codec:s,multihashCode:a,digestSize:c,multihashSize:u,size:l}}static parse(e,t){const[n,i]=sC(e,t),s=Le.decode(i);if(s.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return ef(s).set(n,e),s}}function sC(r,e){switch(r[0]){case"Q":{const t=e??Je;return[Je.prefix,t.decode(`${Je.prefix}${r}`)]}case Je.prefix:{const t=e??Je;return[Je.prefix,t.decode(r)]}case Dn.prefix:{const t=e??Dn;return[Dn.prefix,t.decode(r)]}case jc.prefix:{const t=e??jc;return[jc.prefix,t.decode(r)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],e.decode(r)]}}}function oC(r,e,t){const{prefix:n}=t;if(n!==Je.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const i=e.get(n);if(i==null){const s=t.encode(r).slice(1);return e.set(n,s),s}else return i}function aC(r,e,t){const{prefix:n}=t,i=e.get(n);if(i==null){const s=t.encode(r);return e.set(n,s),s}else return i}const So=112,cC=18;function py(r,e,t){const n=il(r),i=n+il(e),s=new Uint8Array(i+t.byteLength);return nl(r,s,0),nl(e,s,n),s.set(t,i),s}const lC=Symbol.for("@ipld/js-cid/CID"),Cv=0,uC="identity",Iv=xu;function dC(r){return qn(Cv,Iv(r))}const ba={code:Cv,name:uC,encode:Iv,digest:dC};function et(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function Pe(r=0){return new Uint8Array(r)}function Vr(r=0){return new Uint8Array(r)}function cn(r,e){e==null&&(e=r.reduce((i,s)=>i+s.length,0));const t=Vr(e);let n=0;for(const i of r)t.set(i,n),n+=i.length;return t}const kv=Symbol.for("@achingbrain/uint8arraylist");function gy(r,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(const n of r){const i=t+n.byteLength;if(e<i)return{buf:n,index:e-t};t=i}throw new RangeError("index is out of bounds")}function sc(r){return!!r?.[kv]}class be{bufs;length;[kv]=!0;constructor(...e){this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const n of e)if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.push(n);else if(sc(n))t+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const n of e.reverse())if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.unshift(n);else if(sc(n))t+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){const t=gy(this.bufs,e);return t.buf[t.index]}set(e,t){const n=gy(this.bufs,e);n.buf[n.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let n=0;n<e.length;n++)this.set(t+n,e[n]);else if(sc(e))for(let n=0;n<e.length;n++)this.set(t+n,e.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){const{bufs:n,length:i}=this._subList(e,t);return cn(n,i)}subarray(e,t){const{bufs:n,length:i}=this._subList(e,t);return n.length===1?n[0]:cn(n,i)}sublist(e,t){const{bufs:n,length:i}=this._subList(e,t),s=new be;return s.length=i,s.bufs=[...n],s}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};const n=[];let i=0;for(let s=0;s<this.bufs.length;s++){const o=this.bufs[s],a=i,c=a+o.byteLength;if(i=c,e>=c)continue;const l=e>=a&&e<c,u=t>a&&t<=c;if(l&&u){if(e===a&&t===c){n.push(o);break}const d=e-a;n.push(o.subarray(d,d+(t-e)));break}if(l){if(e===0){n.push(o);continue}n.push(o.subarray(e-a));continue}if(u){if(t===c){n.push(o);break}n.push(o.subarray(0,t-a));break}n.push(o)}return{bufs:n,length:t-e}}indexOf(e,t=0){if(!sc(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const n=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const i=n.byteLength;if(i===0)throw new TypeError("search must be at least 1 byte long");const s=256,o=new Int32Array(s);for(let d=0;d<s;d++)o[d]=-1;for(let d=0;d<i;d++)o[n[d]]=d;const a=o,c=this.byteLength-n.byteLength,l=n.byteLength-1;let u;for(let d=t;d<=c;d+=u){u=0;for(let f=l;f>=0;f--){const m=this.get(d+f);if(n[f]!==m){u=Math.max(1,f-a[m]);break}}if(u===0)return d}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const n=Vr(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,t),this.write(n,e)}getInt16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,t)}setInt16(e,t,n){const i=Pe(2);new DataView(i.buffer,i.byteOffset,i.byteLength).setInt16(0,t,n),this.write(i,e)}getInt32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,t)}setInt32(e,t,n){const i=Pe(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setInt32(0,t,n),this.write(i,e)}getBigInt64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,t)}setBigInt64(e,t,n){const i=Pe(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setBigInt64(0,t,n),this.write(i,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const n=Vr(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,t),this.write(n,e)}getUint16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,t)}setUint16(e,t,n){const i=Pe(2);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint16(0,t,n),this.write(i,e)}getUint32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,t)}setUint32(e,t,n){const i=Pe(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint32(0,t,n),this.write(i,e)}getBigUint64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,t)}setBigUint64(e,t,n){const i=Pe(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setBigUint64(0,t,n),this.write(i,e)}getFloat32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,t)}setFloat32(e,t,n){const i=Pe(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setFloat32(0,t,n),this.write(i,e)}getFloat64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,t)}setFloat64(e,t,n){const i=Pe(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setFloat64(0,t,n),this.write(i,e)}equals(e){if(e==null||!(e instanceof be)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!et(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const n=new be;return n.bufs=e,t==null&&(t=e.reduce((i,s)=>i+s.byteLength,0)),n.length=t,n}}const hC=wa({prefix:"9",name:"base10",alphabet:"0123456789"}),fC=Object.freeze(Object.defineProperty({__proto__:null,base10:hC},Symbol.toStringTag,{value:"Module"})),pC=gt({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),gC=gt({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),mC=Object.freeze(Object.defineProperty({__proto__:null,base16:pC,base16upper:gC},Symbol.toStringTag,{value:"Module"})),yC=gt({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),wC=Object.freeze(Object.defineProperty({__proto__:null,base2:yC},Symbol.toStringTag,{value:"Module"})),Tv=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),bC=Tv.reduce((r,e,t)=>(r[t]=e,r),[]),vC=Tv.reduce((r,e,t)=>{const n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);return r[n]=t,r},[]);function SC(r){return r.reduce((e,t)=>(e+=bC[t],e),"")}function EC(r){const e=[];for(const t of r){const n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);const i=vC[n];if(i==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(i)}return new Uint8Array(e)}const AC=_u({prefix:"ðŸš€",name:"base256emoji",encode:SC,decode:EC}),xC=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:AC},Symbol.toStringTag,{value:"Module"})),Pv=gt({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),_C=gt({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),va=gt({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),CC=gt({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),IC=Object.freeze(Object.defineProperty({__proto__:null,base64:Pv,base64pad:_C,base64url:va,base64urlpad:CC},Symbol.toStringTag,{value:"Module"})),kC=gt({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),TC=Object.freeze(Object.defineProperty({__proto__:null,base8:kC},Symbol.toStringTag,{value:"Module"})),PC=_u({prefix:"\0",name:"identity",encode:r=>w_(r),decode:r=>y_(r)}),RC=Object.freeze(Object.defineProperty({__proto__:null,identity:PC},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;function OC({name:r,code:e,encode:t}){return new BC(r,e,t)}class BC{name;code;encode;constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?qn(this.code,t):t.then(n=>qn(this.code,n))}else throw Error("Unknown type, must be binary type")}}function NC(r){return async e=>new Uint8Array(await crypto.subtle.digest(r,e))}const eo=OC({name:"sha2-256",code:18,encode:NC("SHA-256")}),sl={...RC,...wC,...TC,...fC,...mC,...F_,...V_,...P_,...IC,...xC};function Rv(r,e,t,n){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:n}}}const my=Rv("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),$d=Rv("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);const e=Vr(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),Ov={utf8:my,"utf-8":my,hex:sl.base16,latin1:$d,ascii:$d,binary:$d,...sl};function oe(r,e="utf8"){const t=Ov[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${r}`)}function ge(r,e="utf8"){const t=Ov[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(r).substring(1)}const DC=parseInt("11111",2),tf=parseInt("10000000",2),LC=parseInt("01111111",2),yy={0:Eo,1:Eo,2:MC,3:$C,4:VC,5:FC,6:UC,16:Eo,22:Eo,48:Eo};function Cu(r,e={offset:0}){const t=r[e.offset]&DC;if(e.offset++,yy[t]!=null)return yy[t](r,e);throw new Error("No decoder for tag "+t)}function Sa(r,e){let t=0;if((r[e.offset]&tf)===tf){const n=r[e.offset]&LC;let i="0x";e.offset++;for(let s=0;s<n;s++,e.offset++)i+=r[e.offset].toString(16).padStart(2,"0");t=parseInt(i,16)}else t=r[e.offset],e.offset++;return t}function Eo(r,e){Sa(r,e);const t=[];for(;!(e.offset>=r.byteLength);){const n=Cu(r,e);if(n===null)break;t.push(n)}return t}function MC(r,e){const t=Sa(r,e),n=e.offset,i=e.offset+t,s=[];for(let o=n;o<i;o++)o===n&&r[o]===0||s.push(r[o]);return e.offset+=t,Uint8Array.from(s)}function UC(r,e){const t=Sa(r,e),n=e.offset+t,i=r[e.offset];e.offset++;let s=0,o=0;i<40?(s=0,o=i):i<80?(s=1,o=i-40):(s=2,o=i-80);let a=`${s}.${o}`,c=[];for(;e.offset<n;){const l=r[e.offset];if(e.offset++,c.push(l&127),l<128){c.reverse();let u=0;for(let d=0;d<c.length;d++)u+=c[d]<<d*7;a+=`.${u}`,c=[]}}return a}function FC(r,e){return e.offset++,null}function $C(r,e){const t=Sa(r,e),n=r[e.offset];e.offset++;const i=r.subarray(e.offset,e.offset+t-1);if(e.offset+=t,n!==0)throw new Error("Unused bits in bit string is unimplemented");return i}function VC(r,e){const t=Sa(r,e),n=r.subarray(e.offset,e.offset+t);return e.offset+=t,n}function qC(r){let e=r.toString(16);e.length%2===1&&(e="0"+e);const t=new be;for(let n=0;n<e.length;n+=2)t.append(Uint8Array.from([parseInt(`${e[n]}${e[n+1]}`,16)]));return t}function Iu(r){if(r.byteLength<128)return Uint8Array.from([r.byteLength]);const e=qC(r.byteLength);return new be(Uint8Array.from([e.byteLength|tf]),e)}function Wt(r){const e=new be,t=128;return(r.subarray()[0]&t)===t&&e.append(Uint8Array.from([0])),e.append(r),new be(Uint8Array.from([2]),Iu(e),e)}function hg(r){const e=Uint8Array.from([0]),t=new be(e,r);return new be(Uint8Array.from([3]),Iu(t),t)}function jC(r){return new be(Uint8Array.from([4]),Iu(r),r)}function rn(r,e=48){const t=new be;for(const n of r)t.append(n);return new be(Uint8Array.from([e]),Iu(t),t)}async function zC(r="P-256"){const e=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:r},!0,["sign","verify"]);return{publicKey:await crypto.subtle.exportKey("jwk",e.publicKey),privateKey:await crypto.subtle.exportKey("jwk",e.privateKey)}}async function HC(r,e,t){const n=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv??"P-256"},!1,["sign"]);t?.signal?.throwIfAborted();const i=await crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},n,e.subarray());return t?.signal?.throwIfAborted(),new Uint8Array(i,0,i.byteLength)}async function WC(r,e,t,n){const i=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv??"P-256"},!1,["verify"]);n?.signal?.throwIfAborted();const s=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},i,e,t.subarray());return n?.signal?.throwIfAborted(),s}const KC=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),GC=Uint8Array.from([6,5,43,129,4,0,34]),YC=Uint8Array.from([6,5,43,129,4,0,35]),QC={ext:!0,kty:"EC",crv:"P-256"},XC={ext:!0,kty:"EC",crv:"P-384"},ZC={ext:!0,kty:"EC",crv:"P-521"},Vd=32,qd=48,jd=66;function Bv(r){const e=Cu(r);return JC(e)}function JC(r){const e=r[1][1][0],t=1;let n,i;if(e.byteLength===Vd*2+1)return n=ge(e.subarray(t,t+Vd),"base64url"),i=ge(e.subarray(t+Vd),"base64url"),new zc({...QC,key_ops:["verify"],x:n,y:i});if(e.byteLength===qd*2+1)return n=ge(e.subarray(t,t+qd),"base64url"),i=ge(e.subarray(t+qd),"base64url"),new zc({...XC,key_ops:["verify"],x:n,y:i});if(e.byteLength===jd*2+1)return n=ge(e.subarray(t,t+jd),"base64url"),i=ge(e.subarray(t+jd),"base64url"),new zc({...ZC,key_ops:["verify"],x:n,y:i});throw new le(`coordinates were wrong length, got ${e.byteLength}, expected 65, 97 or 133`)}function e2(r){return rn([Wt(Uint8Array.from([1])),jC(oe(r.d??"","base64url")),rn([Nv(r.crv)],160),rn([hg(new be(Uint8Array.from([4]),oe(r.x??"","base64url"),oe(r.y??"","base64url")))],161)]).subarray()}function t2(r){return rn([Wt(Uint8Array.from([1])),rn([Nv(r.crv)],160),rn([hg(new be(Uint8Array.from([4]),oe(r.x??"","base64url"),oe(r.y??"","base64url")))],161)]).subarray()}function Nv(r){if(r==="P-256")return KC;if(r==="P-384")return GC;if(r==="P-521")return YC;throw new le(`Invalid curve ${r}`)}async function r2(r="P-256"){const e=await zC(r);return new n2(e.privateKey)}class zc{type="ECDSA";jwk;_raw;constructor(e){this.jwk=e}get raw(){return this._raw==null&&(this._raw=t2(this.jwk)),this._raw}toMultihash(){return ba.digest(nn(this))}toCID(){return Le.createV1(114,this.toMultihash())}toString(){return Je.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:et(this.raw,e.raw)}async verify(e,t,n){return WC(this.jwk,t,e,n)}}class n2{type="ECDSA";jwk;publicKey;_raw;constructor(e){this.jwk=e,this.publicKey=new zc({crv:e.crv,ext:e.ext,key_ops:["verify"],kty:"EC",x:e.x,y:e.y})}get raw(){return this._raw==null&&(this._raw=e2(this.jwk)),this._raw}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:et(this.raw,e.raw)}async sign(e,t){return HC(this.jwk,e,t)}}const Ji=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function i2(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function ol(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function Ea(r,...e){if(!i2(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function fg(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");ol(r.outputLen),ol(r.blockLen)}function al(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function s2(r,e){Ea(r);const t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function ki(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function zd(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function Rr(r,e){return r<<32-e|r>>>e}function o2(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}function Ko(r){return typeof r=="string"&&(r=o2(r)),Ea(r),r}function a2(...r){let e=0;for(let n=0;n<r.length;n++){const i=r[n];Ea(i),e+=i.length}const t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){const s=r[n];t.set(s,i),i+=s.length}return t}class Dv{}function Lv(r){const e=n=>r().update(Ko(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function ku(r=32){if(Ji&&typeof Ji.getRandomValues=="function")return Ji.getRandomValues(new Uint8Array(r));if(Ji&&typeof Ji.randomBytes=="function")return Uint8Array.from(Ji.randomBytes(r));throw new Error("crypto.getRandomValues must be defined")}function c2(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const i=BigInt(32),s=BigInt(4294967295),o=Number(t>>i&s),a=Number(t&s),c=n?4:0,l=n?0:4;r.setUint32(e+c,o,n),r.setUint32(e+l,a,n)}function l2(r,e,t){return r&e^~r&t}function u2(r,e,t){return r&e^r&t^e&t}class Mv extends Dv{constructor(e,t,n,i){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=i,this.buffer=new Uint8Array(e),this.view=zd(this.buffer)}update(e){al(this),e=Ko(e),Ea(e);const{view:t,buffer:n,blockLen:i}=this,s=e.length;for(let o=0;o<s;){const a=Math.min(i-this.pos,s-o);if(a===i){const c=zd(e);for(;i<=s-o;o+=i)this.process(c,o);continue}n.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){al(this),s2(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:i,isLE:s}=this;let{pos:o}=this;t[o++]=128,ki(this.buffer.subarray(o)),this.padOffset>i-o&&(this.process(n,0),o=0);for(let d=o;d<i;d++)t[d]=0;c2(n,i-8,BigInt(this.length*8),s),this.process(n,0);const a=zd(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=c/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<l;d++)a.setUint32(4*d,u[d],s)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:i,finished:s,destroyed:o,pos:a}=this;return e.destroyed=o,e.finished=s,e.length=i,e.pos=a,i%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}}const bn=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),yt=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),oc=BigInt(2**32-1),wy=BigInt(32);function d2(r,e=!1){return e?{h:Number(r&oc),l:Number(r>>wy&oc)}:{h:Number(r>>wy&oc)|0,l:Number(r&oc)|0}}function h2(r,e=!1){const t=r.length;let n=new Uint32Array(t),i=new Uint32Array(t);for(let s=0;s<t;s++){const{h:o,l:a}=d2(r[s],e);[n[s],i[s]]=[o,a]}return[n,i]}const by=(r,e,t)=>r>>>t,vy=(r,e,t)=>r<<32-t|e>>>t,es=(r,e,t)=>r>>>t|e<<32-t,ts=(r,e,t)=>r<<32-t|e>>>t,ac=(r,e,t)=>r<<64-t|e>>>t-32,cc=(r,e,t)=>r>>>t-32|e<<64-t;function Gr(r,e,t,n){const i=(e>>>0)+(n>>>0);return{h:r+t+(i/2**32|0)|0,l:i|0}}const f2=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),p2=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,g2=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),m2=(r,e,t,n,i)=>e+t+n+i+(r/2**32|0)|0,y2=(r,e,t,n,i)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(i>>>0),w2=(r,e,t,n,i,s)=>e+t+n+i+s+(r/2**32|0)|0,b2=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),vn=new Uint32Array(64);class v2 extends Mv{constructor(e=32){super(64,e,8,!1),this.A=bn[0]|0,this.B=bn[1]|0,this.C=bn[2]|0,this.D=bn[3]|0,this.E=bn[4]|0,this.F=bn[5]|0,this.G=bn[6]|0,this.H=bn[7]|0}get(){const{A:e,B:t,C:n,D:i,E:s,F:o,G:a,H:c}=this;return[e,t,n,i,s,o,a,c]}set(e,t,n,i,s,o,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=i|0,this.E=s|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let d=0;d<16;d++,t+=4)vn[d]=e.getUint32(t,!1);for(let d=16;d<64;d++){const f=vn[d-15],m=vn[d-2],g=Rr(f,7)^Rr(f,18)^f>>>3,y=Rr(m,17)^Rr(m,19)^m>>>10;vn[d]=y+vn[d-7]+g+vn[d-16]|0}let{A:n,B:i,C:s,D:o,E:a,F:c,G:l,H:u}=this;for(let d=0;d<64;d++){const f=Rr(a,6)^Rr(a,11)^Rr(a,25),m=u+f+l2(a,c,l)+b2[d]+vn[d]|0,y=(Rr(n,2)^Rr(n,13)^Rr(n,22))+u2(n,i,s)|0;u=l,l=c,c=a,a=o+m|0,o=s,s=i,i=n,n=m+y|0}n=n+this.A|0,i=i+this.B|0,s=s+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(n,i,s,o,a,c,l,u)}roundClean(){ki(vn)}destroy(){this.set(0,0,0,0,0,0,0,0),ki(this.buffer)}}const Uv=h2(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),S2=Uv[0],E2=Uv[1],Sn=new Uint32Array(80),En=new Uint32Array(80);class A2 extends Mv{constructor(e=64){super(128,e,16,!1),this.Ah=yt[0]|0,this.Al=yt[1]|0,this.Bh=yt[2]|0,this.Bl=yt[3]|0,this.Ch=yt[4]|0,this.Cl=yt[5]|0,this.Dh=yt[6]|0,this.Dl=yt[7]|0,this.Eh=yt[8]|0,this.El=yt[9]|0,this.Fh=yt[10]|0,this.Fl=yt[11]|0,this.Gh=yt[12]|0,this.Gl=yt[13]|0,this.Hh=yt[14]|0,this.Hl=yt[15]|0}get(){const{Ah:e,Al:t,Bh:n,Bl:i,Ch:s,Cl:o,Dh:a,Dl:c,Eh:l,El:u,Fh:d,Fl:f,Gh:m,Gl:g,Hh:y,Hl:w}=this;return[e,t,n,i,s,o,a,c,l,u,d,f,m,g,y,w]}set(e,t,n,i,s,o,a,c,l,u,d,f,m,g,y,w){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=i|0,this.Ch=s|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=d|0,this.Fl=f|0,this.Gh=m|0,this.Gl=g|0,this.Hh=y|0,this.Hl=w|0}process(e,t){for(let v=0;v<16;v++,t+=4)Sn[v]=e.getUint32(t),En[v]=e.getUint32(t+=4);for(let v=16;v<80;v++){const b=Sn[v-15]|0,A=En[v-15]|0,R=es(b,A,1)^es(b,A,8)^by(b,A,7),C=ts(b,A,1)^ts(b,A,8)^vy(b,A,7),P=Sn[v-2]|0,D=En[v-2]|0,z=es(P,D,19)^ac(P,D,61)^by(P,D,6),$=ts(P,D,19)^cc(P,D,61)^vy(P,D,6),j=g2(C,$,En[v-7],En[v-16]),q=m2(j,R,z,Sn[v-7],Sn[v-16]);Sn[v]=q|0,En[v]=j|0}let{Ah:n,Al:i,Bh:s,Bl:o,Ch:a,Cl:c,Dh:l,Dl:u,Eh:d,El:f,Fh:m,Fl:g,Gh:y,Gl:w,Hh:x,Hl:T}=this;for(let v=0;v<80;v++){const b=es(d,f,14)^es(d,f,18)^ac(d,f,41),A=ts(d,f,14)^ts(d,f,18)^cc(d,f,41),R=d&m^~d&y,C=f&g^~f&w,P=y2(T,A,C,E2[v],En[v]),D=w2(P,x,b,R,S2[v],Sn[v]),z=P|0,$=es(n,i,28)^ac(n,i,34)^ac(n,i,39),j=ts(n,i,28)^cc(n,i,34)^cc(n,i,39),q=n&s^n&a^s&a,ie=i&o^i&c^o&c;x=y|0,T=w|0,y=m|0,w=g|0,m=d|0,g=f|0,{h:d,l:f}=Gr(l|0,u|0,D|0,z|0),l=a|0,u=c|0,a=s|0,c=o|0,s=n|0,o=i|0;const N=f2(z,j,ie);n=p2(N,D,$,q),i=N|0}({h:n,l:i}=Gr(this.Ah|0,this.Al|0,n|0,i|0)),{h:s,l:o}=Gr(this.Bh|0,this.Bl|0,s|0,o|0),{h:a,l:c}=Gr(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:u}=Gr(this.Dh|0,this.Dl|0,l|0,u|0),{h:d,l:f}=Gr(this.Eh|0,this.El|0,d|0,f|0),{h:m,l:g}=Gr(this.Fh|0,this.Fl|0,m|0,g|0),{h:y,l:w}=Gr(this.Gh|0,this.Gl|0,y|0,w|0),{h:x,l:T}=Gr(this.Hh|0,this.Hl|0,x|0,T|0),this.set(n,i,s,o,a,c,l,u,d,f,m,g,y,w,x,T)}roundClean(){ki(Sn,En)}destroy(){ki(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Fv=Lv(()=>new v2),x2=Lv(()=>new A2);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const pg=BigInt(0),rf=BigInt(1);function Aa(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function gg(r){if(!Aa(r))throw new Error("Uint8Array expected")}function Ln(r,e){if(typeof e!="boolean")throw new Error(r+" boolean expected, got "+e)}function lc(r){const e=r.toString(16);return e.length&1?"0"+e:e}function $v(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?pg:BigInt("0x"+r)}const Vv=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",_2=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function xs(r){if(gg(r),Vv)return r.toHex();let e="";for(let t=0;t<r.length;t++)e+=_2[r[t]];return e}const Yr={_0:48,_9:57,A:65,F:70,a:97,f:102};function Sy(r){if(r>=Yr._0&&r<=Yr._9)return r-Yr._0;if(r>=Yr.A&&r<=Yr.F)return r-(Yr.A-10);if(r>=Yr.a&&r<=Yr.f)return r-(Yr.a-10)}function cl(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(Vv)return Uint8Array.fromHex(r);const e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let i=0,s=0;i<t;i++,s+=2){const o=Sy(r.charCodeAt(s)),a=Sy(r.charCodeAt(s+1));if(o===void 0||a===void 0){const c=r[s]+r[s+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+s)}n[i]=o*16+a}return n}function wi(r){return $v(xs(r))}function bi(r){return gg(r),$v(xs(Uint8Array.from(r).reverse()))}function xa(r,e){return cl(r.toString(16).padStart(e*2,"0"))}function Go(r,e){return xa(r,e).reverse()}function He(r,e,t){let n;if(typeof e=="string")try{n=cl(e)}catch(s){throw new Error(r+" must be hex string or Uint8Array, cause: "+s)}else if(Aa(e))n=Uint8Array.from(e);else throw new Error(r+" must be hex string or Uint8Array");const i=n.length;if(typeof t=="number"&&i!==t)throw new Error(r+" of length "+t+" expected, got "+i);return n}function _s(...r){let e=0;for(let n=0;n<r.length;n++){const i=r[n];gg(i),e+=i.length}const t=new Uint8Array(e);for(let n=0,i=0;n<r.length;n++){const s=r[n];t.set(s,i),i+=s.length}return t}const Hd=r=>typeof r=="bigint"&&pg<=r;function mg(r,e,t){return Hd(r)&&Hd(e)&&Hd(t)&&e<=r&&r<t}function Gt(r,e,t,n){if(!mg(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function C2(r){let e;for(e=0;r>pg;r>>=rf,e+=1);return e}const Tu=r=>(rf<<BigInt(r))-rf,Wd=r=>new Uint8Array(r),Ey=r=>Uint8Array.from(r);function I2(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=Wd(r),i=Wd(r),s=0;const o=()=>{n.fill(1),i.fill(0),s=0},a=(...d)=>t(i,n,...d),c=(d=Wd(0))=>{i=a(Ey([0]),d),n=a(),d.length!==0&&(i=a(Ey([1]),d),n=a())},l=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let d=0;const f=[];for(;d<e;){n=a();const m=n.slice();f.push(m),d+=n.length}return _s(...f)};return(d,f)=>{o(),c(d);let m;for(;!(m=f(l()));)c();return o(),m}}const k2={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||Aa(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function to(r,e,t={}){const n=(i,s,o)=>{const a=k2[s];if(typeof a!="function")throw new Error("invalid validator function");const c=r[i];if(!(o&&c===void 0)&&!a(c,r))throw new Error("param "+String(i)+" is invalid. Expected "+s+", got "+c)};for(const[i,s]of Object.entries(e))n(i,s,!1);for(const[i,s]of Object.entries(t))n(i,s,!0);return r}function ll(r){const e=new WeakMap;return(t,...n)=>{const i=e.get(t);if(i!==void 0)return i;const s=r(t,...n);return e.set(t,s),s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ft=BigInt(0),dt=BigInt(1),hi=BigInt(2),T2=BigInt(3),qv=BigInt(4),jv=BigInt(5),zv=BigInt(8);function Me(r,e){const t=r%e;return t>=Ft?t:e+t}function ze(r,e,t){let n=r;for(;e-- >Ft;)n*=n,n%=t;return n}function nf(r,e){if(r===Ft)throw new Error("invert: expected non-zero number");if(e<=Ft)throw new Error("invert: expected positive modulus, got "+e);let t=Me(r,e),n=e,i=Ft,s=dt;for(;t!==Ft;){const a=n/t,c=n%t,l=i-s*a;n=t,t=c,i=s,s=l}if(n!==dt)throw new Error("invert: does not exist");return Me(i,e)}function Hv(r,e){const t=(r.ORDER+dt)/qv,n=r.pow(e,t);if(!r.eql(r.sqr(n),e))throw new Error("Cannot find square root");return n}function P2(r,e){const t=(r.ORDER-jv)/zv,n=r.mul(e,hi),i=r.pow(n,t),s=r.mul(e,i),o=r.mul(r.mul(s,hi),i),a=r.mul(s,r.sub(o,r.ONE));if(!r.eql(r.sqr(a),e))throw new Error("Cannot find square root");return a}function R2(r){if(r<BigInt(3))throw new Error("sqrt is not defined for small field");let e=r-dt,t=0;for(;e%hi===Ft;)e/=hi,t++;let n=hi;const i=_a(r);for(;Ay(i,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return Hv;let s=i.pow(n,e);const o=(e+dt)/hi;return function(c,l){if(c.is0(l))return l;if(Ay(c,l)!==1)throw new Error("Cannot find square root");let u=t,d=c.mul(c.ONE,s),f=c.pow(l,e),m=c.pow(l,o);for(;!c.eql(f,c.ONE);){if(c.is0(f))return c.ZERO;let g=1,y=c.sqr(f);for(;!c.eql(y,c.ONE);)if(g++,y=c.sqr(y),g===u)throw new Error("Cannot find square root");const w=dt<<BigInt(u-g-1),x=c.pow(d,w);u=g,d=c.sqr(x),f=c.mul(f,d),m=c.mul(m,x)}return m}}function O2(r){return r%qv===T2?Hv:r%zv===jv?P2:R2(r)}const B2=(r,e)=>(Me(r,e)&dt)===dt,N2=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function D2(r){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=N2.reduce((n,i)=>(n[i]="function",n),e);return to(r,t)}function L2(r,e,t){if(t<Ft)throw new Error("invalid exponent, negatives unsupported");if(t===Ft)return r.ONE;if(t===dt)return e;let n=r.ONE,i=e;for(;t>Ft;)t&dt&&(n=r.mul(n,i)),i=r.sqr(i),t>>=dt;return n}function yg(r,e,t=!1){const n=new Array(e.length).fill(t?r.ZERO:void 0),i=e.reduce((o,a,c)=>r.is0(a)?o:(n[c]=o,r.mul(o,a)),r.ONE),s=r.inv(i);return e.reduceRight((o,a,c)=>r.is0(a)?o:(n[c]=r.mul(o,n[c]),r.mul(o,a)),s),n}function Ay(r,e){const t=(r.ORDER-dt)/hi,n=r.pow(e,t),i=r.eql(n,r.ONE),s=r.eql(n,r.ZERO),o=r.eql(n,r.neg(r.ONE));if(!i&&!s&&!o)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function Wv(r,e){e!==void 0&&ol(e);const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function _a(r,e,t=!1,n={}){if(r<=Ft)throw new Error("invalid field: expected ORDER > 0, got "+r);const{nBitLength:i,nByteLength:s}=Wv(r,e);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const a=Object.freeze({ORDER:r,isLE:t,BITS:i,BYTES:s,MASK:Tu(i),ZERO:Ft,ONE:dt,create:c=>Me(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return Ft<=c&&c<r},is0:c=>c===Ft,isOdd:c=>(c&dt)===dt,neg:c=>Me(-c,r),eql:(c,l)=>c===l,sqr:c=>Me(c*c,r),add:(c,l)=>Me(c+l,r),sub:(c,l)=>Me(c-l,r),mul:(c,l)=>Me(c*l,r),pow:(c,l)=>L2(a,c,l),div:(c,l)=>Me(c*nf(l,r),r),sqrN:c=>c*c,addN:(c,l)=>c+l,subN:(c,l)=>c-l,mulN:(c,l)=>c*l,inv:c=>nf(c,r),sqrt:n.sqrt||(c=>(o||(o=O2(r)),o(a,c))),toBytes:c=>t?Go(c,s):xa(c,s),fromBytes:c=>{if(c.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+c.length);return t?bi(c):wi(c)},invertBatch:c=>yg(a,c),cmov:(c,l,u)=>u?l:c});return Object.freeze(a)}function Kv(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function Gv(r){const e=Kv(r);return e+Math.ceil(e/2)}function M2(r,e,t=!1){const n=r.length,i=Kv(e),s=Gv(e);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);const o=t?bi(r):wi(r),a=Me(o,e-dt)+dt;return t?Go(a,i):xa(a,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const xy=BigInt(0),sf=BigInt(1);function Kd(r,e){const t=e.negate();return r?t:e}function Yv(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function Gd(r,e){Yv(r,e);const t=Math.ceil(e/r)+1,n=2**(r-1),i=2**r,s=Tu(r),o=BigInt(r);return{windows:t,windowSize:n,mask:s,maxNumber:i,shiftBy:o}}function _y(r,e,t){const{windowSize:n,mask:i,maxNumber:s,shiftBy:o}=t;let a=Number(r&i),c=r>>o;a>n&&(a-=s,c+=sf);const l=e*n,u=l+Math.abs(a)-1,d=a===0,f=a<0,m=e%2!==0;return{nextN:c,offset:u,isZero:d,isNeg:f,isNegF:m,offsetF:l}}function U2(r,e){if(!Array.isArray(r))throw new Error("array expected");r.forEach((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)})}function F2(r,e){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)})}const Yd=new WeakMap,Qv=new WeakMap;function Qd(r){return Qv.get(r)||1}function Xv(r,e){return{constTimeNegate:Kd,hasPrecomputes(t){return Qd(t)!==1},unsafeLadder(t,n,i=r.ZERO){let s=t;for(;n>xy;)n&sf&&(i=i.add(s)),s=s.double(),n>>=sf;return i},precomputeWindow(t,n){const{windows:i,windowSize:s}=Gd(n,e),o=[];let a=t,c=a;for(let l=0;l<i;l++){c=a,o.push(c);for(let u=1;u<s;u++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(t,n,i){let s=r.ZERO,o=r.BASE;const a=Gd(t,e);for(let c=0;c<a.windows;c++){const{nextN:l,offset:u,isZero:d,isNeg:f,isNegF:m,offsetF:g}=_y(i,c,a);i=l,d?o=o.add(Kd(m,n[g])):s=s.add(Kd(f,n[u]))}return{p:s,f:o}},wNAFUnsafe(t,n,i,s=r.ZERO){const o=Gd(t,e);for(let a=0;a<o.windows&&i!==xy;a++){const{nextN:c,offset:l,isZero:u,isNeg:d}=_y(i,a,o);if(i=c,!u){const f=n[l];s=s.add(d?f.negate():f)}}return s},getPrecomputes(t,n,i){let s=Yd.get(n);return s||(s=this.precomputeWindow(n,t),t!==1&&Yd.set(n,i(s))),s},wNAFCached(t,n,i){const s=Qd(t);return this.wNAF(s,this.getPrecomputes(s,t,i),n)},wNAFCachedUnsafe(t,n,i,s){const o=Qd(t);return o===1?this.unsafeLadder(t,n,s):this.wNAFUnsafe(o,this.getPrecomputes(o,t,i),n,s)},setWindowSize(t,n){Yv(n,e),Qv.set(t,n),Yd.delete(t)}}}function Zv(r,e,t,n){U2(t,r),F2(n,e);const i=t.length,s=n.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");const o=r.ZERO,a=C2(BigInt(i));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const l=Tu(c),u=new Array(Number(l)+1).fill(o),d=Math.floor((e.BITS-1)/c)*c;let f=o;for(let m=d;m>=0;m-=c){u.fill(o);for(let y=0;y<s;y++){const w=n[y],x=Number(w>>BigInt(m)&l);u[x]=u[x].add(t[y])}let g=o;for(let y=u.length-1,w=o;y>0;y--)w=w.add(u[y]),g=g.add(w);if(f=f.add(g),m!==0)for(let y=0;y<c;y++)f=f.double()}return f}function wg(r){return D2(r.Fp),to(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Wv(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Or=BigInt(0),kt=BigInt(1),Cy=BigInt(2),$2=BigInt(8),V2={zip215:!0};function q2(r){const e=wg(r);return to(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function j2(r){const e=q2(r),{Fp:t,n,prehash:i,hash:s,randomBytes:o,nByteLength:a,h:c}=e,l=Cy<<BigInt(a*8)-kt,u=t.create,d=_a(e.n,e.nBitLength);function f(B,E){const k=t.sqr(B),M=t.sqr(E),W=t.add(t.mul(e.a,k),M),F=t.add(t.ONE,t.mul(e.d,t.mul(k,M)));return t.eql(W,F)}if(!f(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const m=e.uvRatio||((B,E)=>{try{return{isValid:!0,value:t.sqrt(B*t.inv(E))}}catch{return{isValid:!1,value:Or}}}),g=e.adjustScalarBytes||(B=>B),y=e.domain||((B,E,k)=>{if(Ln("phflag",k),E.length||k)throw new Error("Contexts/pre-hash are not supported");return B});function w(B,E,k=!1){const M=k?kt:Or;Gt("coordinate "+B,E,M,l)}function x(B){if(!(B instanceof b))throw new Error("ExtendedPoint expected")}const T=ll((B,E)=>{const{ex:k,ey:M,ez:W}=B,F=B.is0();E==null&&(E=F?$2:t.inv(W));const ae=u(k*E),ue=u(M*E),re=u(W*E);if(F)return{x:Or,y:kt};if(re!==kt)throw new Error("invZ was invalid");return{x:ae,y:ue}}),v=ll(B=>{const{a:E,d:k}=e;if(B.is0())throw new Error("bad point: ZERO");const{ex:M,ey:W,ez:F,et:ae}=B,ue=u(M*M),re=u(W*W),fe=u(F*F),Ae=u(fe*fe),ve=u(ue*E),tt=u(fe*u(ve+re)),Fe=u(Ae+u(k*u(ue*re)));if(tt!==Fe)throw new Error("bad point: equation left != right (1)");const Ge=u(M*W),Ye=u(F*ae);if(Ge!==Ye)throw new Error("bad point: equation left != right (2)");return!0});class b{constructor(E,k,M,W){w("x",E),w("y",k),w("z",M,!0),w("t",W),this.ex=E,this.ey=k,this.ez=M,this.et=W,Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(E){if(E instanceof b)throw new Error("extended point not allowed");const{x:k,y:M}=E||{};return w("x",k),w("y",M),new b(k,M,kt,u(k*M))}static normalizeZ(E){const k=yg(t,E.map(M=>M.ez));return E.map((M,W)=>M.toAffine(k[W])).map(b.fromAffine)}static msm(E,k){return Zv(b,d,E,k)}_setWindowSize(E){C.setWindowSize(this,E)}assertValidity(){v(this)}equals(E){x(E);const{ex:k,ey:M,ez:W}=this,{ex:F,ey:ae,ez:ue}=E,re=u(k*ue),fe=u(F*W),Ae=u(M*ue),ve=u(ae*W);return re===fe&&Ae===ve}is0(){return this.equals(b.ZERO)}negate(){return new b(u(-this.ex),this.ey,this.ez,u(-this.et))}double(){const{a:E}=e,{ex:k,ey:M,ez:W}=this,F=u(k*k),ae=u(M*M),ue=u(Cy*u(W*W)),re=u(E*F),fe=k+M,Ae=u(u(fe*fe)-F-ae),ve=re+ae,tt=ve-ue,Fe=re-ae,Ge=u(Ae*tt),Ye=u(ve*Fe),mt=u(Ae*Fe),zt=u(tt*ve);return new b(Ge,Ye,zt,mt)}add(E){x(E);const{a:k,d:M}=e,{ex:W,ey:F,ez:ae,et:ue}=this,{ex:re,ey:fe,ez:Ae,et:ve}=E,tt=u(W*re),Fe=u(F*fe),Ge=u(ue*M*ve),Ye=u(ae*Ae),mt=u((W+F)*(re+fe)-tt-Fe),zt=Ye-Ge,Kr=Ye+Ge,wo=u(Fe-k*tt),tc=u(mt*zt),rc=u(Kr*wo),nc=u(mt*wo),ic=u(zt*Kr);return new b(tc,rc,ic,nc)}subtract(E){return this.add(E.negate())}wNAF(E){return C.wNAFCached(this,E,b.normalizeZ)}multiply(E){const k=E;Gt("scalar",k,kt,n);const{p:M,f:W}=this.wNAF(k);return b.normalizeZ([M,W])[0]}multiplyUnsafe(E,k=b.ZERO){const M=E;return Gt("scalar",M,Or,n),M===Or?R:this.is0()||M===kt?this:C.wNAFCachedUnsafe(this,M,b.normalizeZ,k)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return C.unsafeLadder(this,n).is0()}toAffine(E){return T(this,E)}clearCofactor(){const{h:E}=e;return E===kt?this:this.multiplyUnsafe(E)}static fromHex(E,k=!1){const{d:M,a:W}=e,F=t.BYTES;E=He("pointHex",E,F),Ln("zip215",k);const ae=E.slice(),ue=E[F-1];ae[F-1]=ue&-129;const re=bi(ae),fe=k?l:t.ORDER;Gt("pointHex.y",re,Or,fe);const Ae=u(re*re),ve=u(Ae-kt),tt=u(M*Ae-W);let{isValid:Fe,value:Ge}=m(ve,tt);if(!Fe)throw new Error("Point.fromHex: invalid y coordinate");const Ye=(Ge&kt)===kt,mt=(ue&128)!==0;if(!k&&Ge===Or&&mt)throw new Error("Point.fromHex: x=0 and x_0=1");return mt!==Ye&&(Ge=u(-Ge)),b.fromAffine({x:Ge,y:re})}static fromPrivateKey(E){const{scalar:k}=z(E);return A.multiply(k)}toRawBytes(){const{x:E,y:k}=this.toAffine(),M=Go(k,t.BYTES);return M[M.length-1]|=E&kt?128:0,M}toHex(){return xs(this.toRawBytes())}}b.BASE=new b(e.Gx,e.Gy,kt,u(e.Gx*e.Gy)),b.ZERO=new b(Or,kt,kt,Or);const{BASE:A,ZERO:R}=b,C=Xv(b,a*8);function P(B){return Me(B,n)}function D(B){return P(bi(B))}function z(B){const E=t.BYTES;B=He("private key",B,E);const k=He("hashed private key",s(B),2*E),M=g(k.slice(0,E)),W=k.slice(E,2*E),F=D(M);return{head:M,prefix:W,scalar:F}}function $(B){const{head:E,prefix:k,scalar:M}=z(B),W=A.multiply(M),F=W.toRawBytes();return{head:E,prefix:k,scalar:M,point:W,pointBytes:F}}function j(B){return $(B).pointBytes}function q(B=Uint8Array.of(),...E){const k=_s(...E);return D(s(y(k,He("context",B),!!i)))}function ie(B,E,k={}){B=He("message",B),i&&(B=i(B));const{prefix:M,scalar:W,pointBytes:F}=$(E),ae=q(k.context,M,B),ue=A.multiply(ae).toRawBytes(),re=q(k.context,ue,F,B),fe=P(ae+re*W);Gt("signature.s",fe,Or,n);const Ae=_s(ue,Go(fe,t.BYTES));return He("result",Ae,t.BYTES*2)}const N=V2;function L(B,E,k,M=N){const{context:W,zip215:F}=M,ae=t.BYTES;B=He("signature",B,2*ae),E=He("message",E),k=He("publicKey",k,ae),F!==void 0&&Ln("zip215",F),i&&(E=i(E));const ue=bi(B.slice(ae,2*ae));let re,fe,Ae;try{re=b.fromHex(k,F),fe=b.fromHex(B.slice(0,ae),F),Ae=A.multiplyUnsafe(ue)}catch{return!1}if(!F&&re.isSmallOrder())return!1;const ve=q(W,fe.toRawBytes(),re.toRawBytes(),E);return fe.add(re.multiplyUnsafe(ve)).subtract(Ae).clearCofactor().equals(b.ZERO)}return A._setWindowSize(8),{CURVE:e,getPublicKey:j,sign:ie,verify:L,ExtendedPoint:b,utils:{getExtendedPublicKey:$,randomPrivateKey:()=>o(t.BYTES),precompute(B=8,E=b.BASE){return E._setWindowSize(B),E.multiply(BigInt(3)),E}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ao=BigInt(0),rs=BigInt(1),uc=BigInt(2);function z2(r){return to(r,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...r})}function H2(r){const e=z2(r),{P:t,type:n,adjustScalarBytes:i,powPminus2:s}=e,o=n==="x25519";if(!o&&n!=="x448")throw new Error("invalid type");const a=o?255:448,c=o?32:56,l=BigInt(o?9:5),u=BigInt(o?121665:39081),d=o?uc**BigInt(254):uc**BigInt(447),f=o?BigInt(8)*uc**BigInt(251)-rs:BigInt(4)*uc**BigInt(445)-rs,m=d+f+rs,g=C=>Me(C,t),y=w(l);function w(C){return Go(g(C),c)}function x(C){const P=He("u coordinate",C,c);return o&&(P[31]&=127),g(bi(P))}function T(C){return bi(i(He("scalar",C,c)))}function v(C,P){const D=R(x(P),T(C));if(D===Ao)throw new Error("invalid private or public key received");return w(D)}function b(C){return v(C,y)}function A(C,P,D){const z=g(C*(P-D));return P=g(P-z),D=g(D+z),{x_2:P,x_3:D}}function R(C,P){Gt("u",C,Ao,t),Gt("scalar",P,d,m);const D=P,z=C;let $=rs,j=Ao,q=C,ie=rs,N=Ao;for(let H=BigInt(a-1);H>=Ao;H--){const B=D>>H&rs;N^=B,{x_2:$,x_3:q}=A(N,$,q),{x_2:j,x_3:ie}=A(N,j,ie),N=B;const E=$+j,k=g(E*E),M=$-j,W=g(M*M),F=k-W,ae=q+ie,ue=q-ie,re=g(ue*E),fe=g(ae*M),Ae=re+fe,ve=re-fe;q=g(Ae*Ae),ie=g(z*g(ve*ve)),$=g(k*W),j=g(F*(k+g(u*F)))}({x_2:$,x_3:q}=A(N,$,q)),{x_2:j,x_3:ie}=A(N,j,ie);const L=s(j);return g($*L)}return{scalarMult:v,scalarMultBase:b,getSharedSecret:(C,P)=>v(C,P),getPublicKey:C=>b(C),utils:{randomPrivateKey:()=>e.randomBytes(c)},GuBytes:y.slice()}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Yo=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Iy=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const W2=BigInt(1),ky=BigInt(2),K2=BigInt(3),G2=BigInt(5),Y2=BigInt(8);function Jv(r){const e=BigInt(10),t=BigInt(20),n=BigInt(40),i=BigInt(80),s=Yo,a=r*r%s*r%s,c=ze(a,ky,s)*a%s,l=ze(c,W2,s)*r%s,u=ze(l,G2,s)*l%s,d=ze(u,e,s)*u%s,f=ze(d,t,s)*d%s,m=ze(f,n,s)*f%s,g=ze(m,i,s)*m%s,y=ze(g,i,s)*m%s,w=ze(y,e,s)*u%s;return{pow_p_5_8:ze(w,ky,s)*r%s,b2:a}}function eS(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function Q2(r,e){const t=Yo,n=Me(e*e*e,t),i=Me(n*n*e,t),s=Jv(r*i).pow_p_5_8;let o=Me(r*n*s,t);const a=Me(e*o*o,t),c=o,l=Me(o*Iy,t),u=a===r,d=a===Me(-r,t),f=a===Me(-r*Iy,t);return u&&(o=c),(d||f)&&(o=l),B2(o,t)&&(o=Me(-o,t)),{isValid:u||d,value:o}}const Ty=_a(Yo,void 0,!0),X2={a:Ty.create(BigInt(-1)),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Ty,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Y2,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:x2,randomBytes:ku,adjustScalarBytes:eS,uvRatio:Q2},ul=j2(X2),dc=H2({P:Yo,type:"x25519",powPminus2:r=>{const e=Yo,{pow_p_5_8:t,b2:n}=Jv(r);return Me(ze(t,K2,e)*n,e)},adjustScalarBytes:eS,randomBytes:ku});class Py extends Error{constructor(e="An error occurred while signing a message"){super(e),this.name="SigningError"}}class Ry extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}}class Z2 extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}}const ur={get(r=globalThis){const e=r.crypto;if(e?.subtle==null)throw new Z2("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return e}},tS=32,bg=64,of=32;let ps;const rS=(async()=>{try{return await ur.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function J2(){const r=ul.utils.randomPrivateKey(),e=ul.getPublicKey(r);return{privateKey:oI(r,e),publicKey:e}}async function eI(r,e){let t;r.length===bg?t=r.subarray(0,32):t=r;const n={crv:"Ed25519",kty:"OKP",x:ge(r.subarray(32),"base64url"),d:ge(t,"base64url"),ext:!0,key_ops:["sign"]},i=await ur.get().subtle.importKey("jwk",n,{name:"Ed25519"},!0,["sign"]),s=await ur.get().subtle.sign({name:"Ed25519"},i,e instanceof Uint8Array?e:e.subarray());return new Uint8Array(s,0,s.byteLength)}function tI(r,e){const t=r.subarray(0,of);return ul.sign(e instanceof Uint8Array?e:e.subarray(),t)}async function rI(r,e){return ps==null&&(ps=await rS),ps?eI(r,e):tI(r,e)}async function nI(r,e,t){if(r.buffer instanceof ArrayBuffer){const n=await ur.get().subtle.importKey("raw",r.buffer,{name:"Ed25519"},!1,["verify"]);return await ur.get().subtle.verify({name:"Ed25519"},n,e,t instanceof Uint8Array?t:t.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function iI(r,e,t){return ul.verify(e,t instanceof Uint8Array?t:t.subarray(),r)}async function sI(r,e,t){return ps==null&&(ps=await rS),ps?nI(r,e,t):iI(r,e,t)}function oI(r,e){const t=new Uint8Array(bg);for(let n=0;n<of;n++)t[n]=r[n],t[of+n]=e[n];return t}function Pu(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class nS{type="Ed25519";raw;constructor(e){this.raw=vg(e,tS)}toMultihash(){return ba.digest(nn(this))}toCID(){return Le.createV1(114,this.toMultihash())}toString(){return Je.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:et(this.raw,e.raw)}verify(e,t,n){n?.signal?.throwIfAborted();const i=sI(this.raw,t,e);return Pu(i)?i.then(s=>(n?.signal?.throwIfAborted(),s)):i}}class aI{type="Ed25519";raw;publicKey;constructor(e,t){this.raw=vg(e,bg),this.publicKey=new nS(t)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:et(this.raw,e.raw)}sign(e,t){t?.signal?.throwIfAborted();const n=rI(this.raw,e);return Pu(n)?n.then(i=>(t?.signal?.throwIfAborted(),i)):(t?.signal?.throwIfAborted(),n)}}function iS(r){return r=vg(r,tS),new nS(r)}async function cI(){const{privateKey:r,publicKey:e}=J2();return new aI(r,e)}function vg(r,e){if(r=Uint8Array.from(r??[]),r.length!==e)throw new le(`Key must be a Uint8Array of length ${e}, got ${r.length}`);return r}const lI=Math.pow(2,7),uI=Math.pow(2,14),dI=Math.pow(2,21),Sg=Math.pow(2,28),Eg=Math.pow(2,35),Ag=Math.pow(2,42),xg=Math.pow(2,49),Ie=128,vt=127;function _t(r){if(r<lI)return 1;if(r<uI)return 2;if(r<dI)return 3;if(r<Sg)return 4;if(r<Eg)return 5;if(r<Ag)return 6;if(r<xg)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function dl(r,e,t=0){switch(_t(r)){case 8:e[t++]=r&255|Ie,r/=128;case 7:e[t++]=r&255|Ie,r/=128;case 6:e[t++]=r&255|Ie,r/=128;case 5:e[t++]=r&255|Ie,r/=128;case 4:e[t++]=r&255|Ie,r>>>=7;case 3:e[t++]=r&255|Ie,r>>>=7;case 2:e[t++]=r&255|Ie,r>>>=7;case 1:{e[t++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return e}function hI(r,e,t=0){switch(_t(r)){case 8:e.set(t++,r&255|Ie),r/=128;case 7:e.set(t++,r&255|Ie),r/=128;case 6:e.set(t++,r&255|Ie),r/=128;case 5:e.set(t++,r&255|Ie),r/=128;case 4:e.set(t++,r&255|Ie),r>>>=7;case 3:e.set(t++,r&255|Ie),r>>>=7;case 2:e.set(t++,r&255|Ie),r>>>=7;case 1:{e.set(t++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return e}function sS(r,e){let t=r[e],n=0;if(n+=t&vt,t<Ie||(t=r[e+1],n+=(t&vt)<<7,t<Ie)||(t=r[e+2],n+=(t&vt)<<14,t<Ie)||(t=r[e+3],n+=(t&vt)<<21,t<Ie)||(t=r[e+4],n+=(t&vt)*Sg,t<Ie)||(t=r[e+5],n+=(t&vt)*Eg,t<Ie)||(t=r[e+6],n+=(t&vt)*Ag,t<Ie)||(t=r[e+7],n+=(t&vt)*xg,t<Ie))return n;throw new RangeError("Could not decode varint")}function fI(r,e){let t=r.get(e),n=0;if(n+=t&vt,t<Ie||(t=r.get(e+1),n+=(t&vt)<<7,t<Ie)||(t=r.get(e+2),n+=(t&vt)<<14,t<Ie)||(t=r.get(e+3),n+=(t&vt)<<21,t<Ie)||(t=r.get(e+4),n+=(t&vt)*Sg,t<Ie)||(t=r.get(e+5),n+=(t&vt)*Eg,t<Ie)||(t=r.get(e+6),n+=(t&vt)*Ag,t<Ie)||(t=r.get(e+7),n+=(t&vt)*xg,t<Ie))return n;throw new RangeError("Could not decode varint")}function gs(r,e,t=0){return e==null&&(e=Vr(_t(r))),e instanceof Uint8Array?dl(r,e,t):hI(r,e,t)}function Ru(r,e=0){return r instanceof Uint8Array?sS(r,e):fI(r,e)}const _g=new Float32Array([-0]),kn=new Uint8Array(_g.buffer);function pI(r,e,t){_g[0]=r,e[t]=kn[0],e[t+1]=kn[1],e[t+2]=kn[2],e[t+3]=kn[3]}function gI(r,e){return kn[0]=r[e],kn[1]=r[e+1],kn[2]=r[e+2],kn[3]=r[e+3],_g[0]}const Cg=new Float64Array([-0]),St=new Uint8Array(Cg.buffer);function mI(r,e,t){Cg[0]=r,e[t]=St[0],e[t+1]=St[1],e[t+2]=St[2],e[t+3]=St[3],e[t+4]=St[4],e[t+5]=St[5],e[t+6]=St[6],e[t+7]=St[7]}function yI(r,e){return St[0]=r[e],St[1]=r[e+1],St[2]=r[e+2],St[3]=r[e+3],St[4]=r[e+4],St[5]=r[e+5],St[6]=r[e+6],St[7]=r[e+7],Cg[0]}const wI=BigInt(Number.MAX_SAFE_INTEGER),bI=BigInt(Number.MIN_SAFE_INTEGER);class At{lo;hi;constructor(e,t){this.lo=e|0,this.hi=t|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(t+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(BigInt(t)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?t===0?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:n<128?9:10}static fromBigInt(e){if(e===0n)return vi;if(e<wI&&e>bI)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let n=e>>32n,i=e-(n<<32n);return t&&(n=~n|0n,i=~i|0n,++i>Oy&&(i=0n,++n>Oy&&(n=0n))),new At(Number(i),Number(n))}static fromNumber(e){if(e===0)return vi;const t=e<0;t&&(e=-e);let n=e>>>0,i=(e-n)/4294967296>>>0;return t&&(i=~i>>>0,n=~n>>>0,++n>4294967295&&(n=0,++i>4294967295&&(i=0))),new At(n,i)}static from(e){return typeof e=="number"?At.fromNumber(e):typeof e=="bigint"?At.fromBigInt(e):typeof e=="string"?At.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new At(e.low>>>0,e.high>>>0):vi}}const vi=new At(0,0);vi.toBigInt=function(){return 0n};vi.zzEncode=vi.zzDecode=function(){return this};vi.length=function(){return 1};const Oy=4294967296n;function vI(r){let e=0,t=0;for(let n=0;n<r.length;++n)t=r.charCodeAt(n),t<128?e+=1:t<2048?e+=2:(t&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,e+=4):e+=3;return e}function SI(r,e,t){if(t-e<1)return"";let i;const s=[];let o=0,a;for(;e<t;)a=r[e++],a<128?s[o++]=a:a>191&&a<224?s[o++]=(a&31)<<6|r[e++]&63:a>239&&a<365?(a=((a&7)<<18|(r[e++]&63)<<12|(r[e++]&63)<<6|r[e++]&63)-65536,s[o++]=55296+(a>>10),s[o++]=56320+(a&1023)):s[o++]=(a&15)<<12|(r[e++]&63)<<6|r[e++]&63,o>8191&&((i??(i=[])).push(String.fromCharCode.apply(String,s)),o=0);return i!=null?(o>0&&i.push(String.fromCharCode.apply(String,s.slice(0,o))),i.join("")):String.fromCharCode.apply(String,s.slice(0,o))}function oS(r,e,t){const n=t;let i,s;for(let o=0;o<r.length;++o)i=r.charCodeAt(o),i<128?e[t++]=i:i<2048?(e[t++]=i>>6|192,e[t++]=i&63|128):(i&64512)===55296&&((s=r.charCodeAt(o+1))&64512)===56320?(i=65536+((i&1023)<<10)+(s&1023),++o,e[t++]=i>>18|240,e[t++]=i>>12&63|128,e[t++]=i>>6&63|128,e[t++]=i&63|128):(e[t++]=i>>12|224,e[t++]=i>>6&63|128,e[t++]=i&63|128);return t-n}function yr(r,e){return RangeError(`index out of range: ${r.pos} + ${e??1} > ${r.len}`)}function hc(r,e){return(r[e-4]|r[e-3]<<8|r[e-2]<<16|r[e-1]<<24)>>>0}class EI{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(e){this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,yr(this,10);return e}int32(){return this.uint32()|0}sint32(){const e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw yr(this,4);return hc(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw yr(this,4);return hc(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw yr(this,4);const e=gI(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw yr(this,4);const e=yI(this.buf,this.pos);return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,n=this.pos+e;if(n>this.len)throw yr(this,e);return this.pos+=e,t===n?new Uint8Array(0):this.buf.subarray(t,n)}string(){const e=this.bytes();return SI(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw yr(this,e);this.pos+=e}else do if(this.pos>=this.len)throw yr(this);while((this.buf[this.pos++]&128)!==0);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new At(0,0);let t=0;if(this.len-this.pos>4){for(;t<4;++t)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw yr(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,e}if(this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw yr(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw yr(this,8);const e=hc(this.buf,this.pos+=4),t=hc(this.buf,this.pos+=4);return new At(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=sS(this.buf,this.pos);return this.pos+=_t(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function AI(r){return new EI(r instanceof Uint8Array?r:r.subarray())}function Be(r,e,t){const n=AI(r);return e.decode(n,void 0,t)}function xI(r){let n,i=8192;return function(o){if(o<1||o>4096)return Vr(o);i+o>8192&&(n=Vr(8192),i=0);const a=n.subarray(i,i+=o);return(i&7)!==0&&(i=(i|7)+1),a}}class ko{fn;len;next;val;constructor(e,t,n){this.fn=e,this.len=t,this.next=void 0,this.val=n}}function Xd(){}class _I{head;tail;len;next;constructor(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}}const CI=xI();function II(r){return globalThis.Buffer!=null?Vr(r):CI(r)}class af{len;head;tail;states;constructor(){this.len=0,this.head=new ko(Xd,0,0),this.tail=this.head,this.states=null}_push(e,t,n){return this.tail=this.tail.next=new ko(e,t,n),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new TI((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(fc,10,At.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=At.fromBigInt(e);return this._push(fc,t.length(),t)}uint64Number(e){return this._push(dl,_t(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=At.fromBigInt(e).zzEncode();return this._push(fc,t.length(),t)}sint64Number(e){const t=At.fromNumber(e).zzEncode();return this._push(fc,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(Zd,1,e?1:0)}fixed32(e){return this._push(xo,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=At.fromBigInt(e);return this._push(xo,4,t.lo)._push(xo,4,t.hi)}fixed64Number(e){const t=At.fromNumber(e);return this._push(xo,4,t.lo)._push(xo,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(pI,4,e)}double(e){return this._push(mI,8,e)}bytes(e){const t=e.length>>>0;return t===0?this._push(Zd,1,0):this.uint32(t)._push(PI,t,e)}string(e){const t=vI(e);return t!==0?this.uint32(t)._push(oS,t,e):this._push(Zd,1,0)}fork(){return this.states=new _I(this),this.head=this.tail=new ko(Xd,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new ko(Xd,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=e.next,this.tail=t,this.len+=n),this}finish(){let e=this.head.next;const t=II(this.len);let n=0;for(;e!=null;)e.fn(e.val,t,n),n+=e.len,e=e.next;return t}}function Zd(r,e,t){e[t]=r&255}function kI(r,e,t){for(;r>127;)e[t++]=r&127|128,r>>>=7;e[t]=r}class TI extends ko{next;constructor(e,t){super(kI,e,t),this.next=void 0}}function fc(r,e,t){for(;r.hi!==0;)e[t++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)e[t++]=r.lo&127|128,r.lo=r.lo>>>7;e[t++]=r.lo}function xo(r,e,t){e[t]=r&255,e[t+1]=r>>>8&255,e[t+2]=r>>>16&255,e[t+3]=r>>>24}function PI(r,e,t){e.set(r,t)}globalThis.Buffer!=null&&(af.prototype.bytes=function(r){const e=r.length>>>0;return this.uint32(e),e>0&&this._push(RI,e,r),this},af.prototype.string=function(r){const e=globalThis.Buffer.byteLength(r);return this.uint32(e),e>0&&this._push(OI,e,r),this});function RI(r,e,t){e.set(r,t)}function OI(r,e,t){r.length<40?oS(r,e,t):e.utf8Write!=null?e.utf8Write(r,t):e.set(oe(r),t)}function BI(){return new af}function Ne(r,e){const t=BI();return e.encode(r,t,{lengthDelimited:!1}),t.finish()}var hl;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(hl||(hl={}));function aS(r,e,t,n){return{name:r,type:e,encode:t,decode:n}}function ln(r){function e(i){if(r[i.toString()]==null)throw new Error("Invalid enum value");return r[i]}const t=function(s,o){const a=e(s);o.int32(a)},n=function(s){const o=s.int32();return e(o)};return aS("enum",hl.VARINT,t,n)}function De(r,e){return aS("message",hl.LENGTH_DELIMITED,r,e)}class Cr extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"}class By extends Error{code="ERR_MAX_SIZE";name="MaxSizeError"}var ot;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1",r.ECDSA="ECDSA"})(ot||(ot={}));var cf;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1",r[r.ECDSA=3]="ECDSA"})(cf||(cf={}));(function(r){r.codec=()=>ln(cf)})(ot||(ot={}));var Ti;(function(r){let e;r.codec=()=>(e==null&&(e=De((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),ot.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.Type=ot.codec().decode(t);break}case 2:{s.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ne(t,r.codec()),r.decode=(t,n)=>Be(t,r.codec(),n)})(Ti||(Ti={}));var Ny;(function(r){let e;r.codec=()=>(e==null&&(e=De((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),ot.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.Type=ot.codec().decode(t);break}case 2:{s.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ne(t,r.codec()),r.decode=(t,n)=>Be(t,r.codec(),n)})(Ny||(Ny={}));function Ig(r){if(isNaN(r)||r<=0)throw new le("random bytes length must be a Number bigger than 0");return ku(r)}const Lo=Fv;let cS=class{type="RSA";jwk;_raw;_multihash;constructor(e,t){this.jwk=e,this._multihash=t}get raw(){return this._raw==null&&(this._raw=uS(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return Le.createV1(114,this._multihash)}toString(){return Je.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:et(this.raw,e.raw)}verify(e,t,n){return HI(this.jwk,t,e,n)}},NI=class{type="RSA";jwk;_raw;publicKey;constructor(e,t){this.jwk=e,this.publicKey=t}get raw(){return this._raw==null&&(this._raw=UI(this.jwk)),this._raw}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:et(this.raw,e.raw)}sign(e,t){return zI(this.jwk,e,t)}};const DI=8192,lS=18,LI=1062,MI=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function UI(r){if(r.n==null||r.e==null||r.d==null||r.p==null||r.q==null||r.dp==null||r.dq==null||r.qi==null)throw new le("JWK was missing components");return rn([Wt(Uint8Array.from([0])),Wt(oe(r.n,"base64url")),Wt(oe(r.e,"base64url")),Wt(oe(r.d,"base64url")),Wt(oe(r.p,"base64url")),Wt(oe(r.q,"base64url")),Wt(oe(r.dp,"base64url")),Wt(oe(r.dq,"base64url")),Wt(oe(r.qi,"base64url"))]).subarray()}function FI(r){const e=Cu(r[1],{offset:0});return{kty:"RSA",n:ge(e[0],"base64url"),e:ge(e[1],"base64url")}}function uS(r){if(r.n==null||r.e==null)throw new le("JWK was missing components");return rn([MI,hg(rn([Wt(oe(r.n,"base64url")),Wt(oe(r.e,"base64url"))]))]).subarray()}function $I(r,e){if(r.byteLength>=LI)throw new gv("Key size is too large");const t=Cu(r,{offset:0});return VI(t,r,e)}function VI(r,e,t){const n=FI(r);if(t==null){const i=Lo(Ti.encode({Type:ot.RSA,Data:e}));t=qn(lS,i)}return new cS(n,t)}async function qI(r){if(r>DI)throw new le("Key size is too large");const e=await jI(r),t=Lo(Ti.encode({Type:ot.RSA,Data:uS(e.publicKey)})),n=qn(lS,t);return new NI(e.privateKey,new cS(e.publicKey,n))}async function jI(r,e){const t=await ur.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:r,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),n=await WI(t);return{privateKey:n[0],publicKey:n[1]}}async function zI(r,e,t){const n=await ur.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]);t?.signal?.throwIfAborted();const i=await ur.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},n,e instanceof Uint8Array?e:e.subarray());return t?.signal?.throwIfAborted(),new Uint8Array(i,0,i.byteLength)}async function HI(r,e,t,n){const i=await ur.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);n?.signal?.throwIfAborted();const s=await ur.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},i,e,t instanceof Uint8Array?t:t.subarray());return n?.signal?.throwIfAborted(),s}async function WI(r,e){if(r.privateKey==null||r.publicKey==null)throw new le("Private and public key are required");return await Promise.all([ur.get().subtle.exportKey("jwk",r.privateKey),ur.get().subtle.exportKey("jwk",r.publicKey)])}class dS extends Dv{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,fg(e);const n=Ko(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,s=new Uint8Array(i);s.set(n.length>i?e.create().update(n).digest():n);for(let o=0;o<s.length;o++)s[o]^=54;this.iHash.update(s),this.oHash=e.create();for(let o=0;o<s.length;o++)s[o]^=106;this.oHash.update(s),ki(s)}update(e){return al(this),this.iHash.update(e),this}digestInto(e){al(this),Ea(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:i,destroyed:s,blockLen:o,outputLen:a}=this;return e=e,e.finished=i,e.destroyed=s,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ou=(r,e,t)=>new dS(r,e).update(t).digest();Ou.create=(r,e)=>new dS(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Dy(r){r.lowS!==void 0&&Ln("lowS",r.lowS),r.prehash!==void 0&&Ln("prehash",r.prehash)}function KI(r){const e=wg(r);to(e,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:t,Fp:n,a:i}=e;if(t){if(!n.eql(i,n.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...e})}class GI extends Error{constructor(e=""){super(e)}}const Zr={Err:GI,_tlv:{encode:(r,e)=>{const{Err:t}=Zr;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const n=e.length/2,i=lc(n);if(i.length/2&128)throw new t("tlv.encode: long form length too big");const s=n>127?lc(i.length/2|128):"";return lc(r)+s+i+e},decode(r,e){const{Err:t}=Zr;let n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");const i=e[n++],s=!!(i&128);let o=0;if(!s)o=i;else{const c=i&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const l=e.subarray(n,n+c);if(l.length!==c)throw new t("tlv.decode: length bytes not complete");if(l[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const u of l)o=o<<8|u;if(n+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(n,n+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+o)}}},_int:{encode(r){const{Err:e}=Zr;if(r<Jr)throw new e("integer: negative integers are not allowed");let t=lc(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(r){const{Err:e}=Zr;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return wi(r)}},toSig(r){const{Err:e,_int:t,_tlv:n}=Zr,i=He("signature",r),{v:s,l:o}=n.decode(48,i);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,s),{v:l,l:u}=n.decode(2,c);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(l)}},hexFromSig(r){const{_tlv:e,_int:t}=Zr,n=e.encode(2,t.encode(r.r)),i=e.encode(2,t.encode(r.s)),s=n+i;return e.encode(48,s)}};function Jd(r,e){return xs(xa(r,e))}const Jr=BigInt(0),st=BigInt(1);BigInt(2);const eh=BigInt(3),YI=BigInt(4);function QI(r){const e=KI(r),{Fp:t}=e,n=_a(e.n,e.nBitLength),i=e.toBytes||((v,b,A)=>{const R=b.toAffine();return _s(Uint8Array.from([4]),t.toBytes(R.x),t.toBytes(R.y))}),s=e.fromBytes||(v=>{const b=v.subarray(1),A=t.fromBytes(b.subarray(0,t.BYTES)),R=t.fromBytes(b.subarray(t.BYTES,2*t.BYTES));return{x:A,y:R}});function o(v){const{a:b,b:A}=e,R=t.sqr(v),C=t.mul(R,v);return t.add(t.add(C,t.mul(v,b)),A)}function a(v,b){const A=t.sqr(b),R=o(v);return t.eql(A,R)}if(!a(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const c=t.mul(t.pow(e.a,eh),YI),l=t.mul(t.sqr(e.b),BigInt(27));if(t.is0(t.add(c,l)))throw new Error("bad curve params: a or b");function u(v){return mg(v,st,e.n)}function d(v){const{allowedPrivateKeyLengths:b,nByteLength:A,wrapPrivateKey:R,n:C}=e;if(b&&typeof v!="bigint"){if(Aa(v)&&(v=xs(v)),typeof v!="string"||!b.includes(v.length))throw new Error("invalid private key");v=v.padStart(A*2,"0")}let P;try{P=typeof v=="bigint"?v:wi(He("private key",v,A))}catch{throw new Error("invalid private key, expected hex or "+A+" bytes, got "+typeof v)}return R&&(P=Me(P,C)),Gt("private key",P,st,C),P}function f(v){if(!(v instanceof y))throw new Error("ProjectivePoint expected")}const m=ll((v,b)=>{const{px:A,py:R,pz:C}=v;if(t.eql(C,t.ONE))return{x:A,y:R};const P=v.is0();b==null&&(b=P?t.ONE:t.inv(C));const D=t.mul(A,b),z=t.mul(R,b),$=t.mul(C,b);if(P)return{x:t.ZERO,y:t.ZERO};if(!t.eql($,t.ONE))throw new Error("invZ was invalid");return{x:D,y:z}}),g=ll(v=>{if(v.is0()){if(e.allowInfinityPoint&&!t.is0(v.py))return;throw new Error("bad point: ZERO")}const{x:b,y:A}=v.toAffine();if(!t.isValid(b)||!t.isValid(A))throw new Error("bad point: x or y not FE");if(!a(b,A))throw new Error("bad point: equation left != right");if(!v.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class y{constructor(b,A,R){if(b==null||!t.isValid(b))throw new Error("x required");if(A==null||!t.isValid(A)||t.is0(A))throw new Error("y required");if(R==null||!t.isValid(R))throw new Error("z required");this.px=b,this.py=A,this.pz=R,Object.freeze(this)}static fromAffine(b){const{x:A,y:R}=b||{};if(!b||!t.isValid(A)||!t.isValid(R))throw new Error("invalid affine point");if(b instanceof y)throw new Error("projective point not allowed");const C=P=>t.eql(P,t.ZERO);return C(A)&&C(R)?y.ZERO:new y(A,R,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(b){const A=yg(t,b.map(R=>R.pz));return b.map((R,C)=>R.toAffine(A[C])).map(y.fromAffine)}static fromHex(b){const A=y.fromAffine(s(He("pointHex",b)));return A.assertValidity(),A}static fromPrivateKey(b){return y.BASE.multiply(d(b))}static msm(b,A){return Zv(y,n,b,A)}_setWindowSize(b){T.setWindowSize(this,b)}assertValidity(){g(this)}hasEvenY(){const{y:b}=this.toAffine();if(t.isOdd)return!t.isOdd(b);throw new Error("Field doesn't support isOdd")}equals(b){f(b);const{px:A,py:R,pz:C}=this,{px:P,py:D,pz:z}=b,$=t.eql(t.mul(A,z),t.mul(P,C)),j=t.eql(t.mul(R,z),t.mul(D,C));return $&&j}negate(){return new y(this.px,t.neg(this.py),this.pz)}double(){const{a:b,b:A}=e,R=t.mul(A,eh),{px:C,py:P,pz:D}=this;let z=t.ZERO,$=t.ZERO,j=t.ZERO,q=t.mul(C,C),ie=t.mul(P,P),N=t.mul(D,D),L=t.mul(C,P);return L=t.add(L,L),j=t.mul(C,D),j=t.add(j,j),z=t.mul(b,j),$=t.mul(R,N),$=t.add(z,$),z=t.sub(ie,$),$=t.add(ie,$),$=t.mul(z,$),z=t.mul(L,z),j=t.mul(R,j),N=t.mul(b,N),L=t.sub(q,N),L=t.mul(b,L),L=t.add(L,j),j=t.add(q,q),q=t.add(j,q),q=t.add(q,N),q=t.mul(q,L),$=t.add($,q),N=t.mul(P,D),N=t.add(N,N),q=t.mul(N,L),z=t.sub(z,q),j=t.mul(N,ie),j=t.add(j,j),j=t.add(j,j),new y(z,$,j)}add(b){f(b);const{px:A,py:R,pz:C}=this,{px:P,py:D,pz:z}=b;let $=t.ZERO,j=t.ZERO,q=t.ZERO;const ie=e.a,N=t.mul(e.b,eh);let L=t.mul(A,P),H=t.mul(R,D),B=t.mul(C,z),E=t.add(A,R),k=t.add(P,D);E=t.mul(E,k),k=t.add(L,H),E=t.sub(E,k),k=t.add(A,C);let M=t.add(P,z);return k=t.mul(k,M),M=t.add(L,B),k=t.sub(k,M),M=t.add(R,C),$=t.add(D,z),M=t.mul(M,$),$=t.add(H,B),M=t.sub(M,$),q=t.mul(ie,k),$=t.mul(N,B),q=t.add($,q),$=t.sub(H,q),q=t.add(H,q),j=t.mul($,q),H=t.add(L,L),H=t.add(H,L),B=t.mul(ie,B),k=t.mul(N,k),H=t.add(H,B),B=t.sub(L,B),B=t.mul(ie,B),k=t.add(k,B),L=t.mul(H,k),j=t.add(j,L),L=t.mul(M,k),$=t.mul(E,$),$=t.sub($,L),L=t.mul(E,H),q=t.mul(M,q),q=t.add(q,L),new y($,j,q)}subtract(b){return this.add(b.negate())}is0(){return this.equals(y.ZERO)}wNAF(b){return T.wNAFCached(this,b,y.normalizeZ)}multiplyUnsafe(b){const{endo:A,n:R}=e;Gt("scalar",b,Jr,R);const C=y.ZERO;if(b===Jr)return C;if(this.is0()||b===st)return this;if(!A||T.hasPrecomputes(this))return T.wNAFCachedUnsafe(this,b,y.normalizeZ);let{k1neg:P,k1:D,k2neg:z,k2:$}=A.splitScalar(b),j=C,q=C,ie=this;for(;D>Jr||$>Jr;)D&st&&(j=j.add(ie)),$&st&&(q=q.add(ie)),ie=ie.double(),D>>=st,$>>=st;return P&&(j=j.negate()),z&&(q=q.negate()),q=new y(t.mul(q.px,A.beta),q.py,q.pz),j.add(q)}multiply(b){const{endo:A,n:R}=e;Gt("scalar",b,st,R);let C,P;if(A){const{k1neg:D,k1:z,k2neg:$,k2:j}=A.splitScalar(b);let{p:q,f:ie}=this.wNAF(z),{p:N,f:L}=this.wNAF(j);q=T.constTimeNegate(D,q),N=T.constTimeNegate($,N),N=new y(t.mul(N.px,A.beta),N.py,N.pz),C=q.add(N),P=ie.add(L)}else{const{p:D,f:z}=this.wNAF(b);C=D,P=z}return y.normalizeZ([C,P])[0]}multiplyAndAddUnsafe(b,A,R){const C=y.BASE,P=(z,$)=>$===Jr||$===st||!z.equals(C)?z.multiplyUnsafe($):z.multiply($),D=P(this,A).add(P(b,R));return D.is0()?void 0:D}toAffine(b){return m(this,b)}isTorsionFree(){const{h:b,isTorsionFree:A}=e;if(b===st)return!0;if(A)return A(y,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:b,clearCofactor:A}=e;return b===st?this:A?A(y,this):this.multiplyUnsafe(e.h)}toRawBytes(b=!0){return Ln("isCompressed",b),this.assertValidity(),i(y,this,b)}toHex(b=!0){return Ln("isCompressed",b),xs(this.toRawBytes(b))}}y.BASE=new y(e.Gx,e.Gy,t.ONE),y.ZERO=new y(t.ZERO,t.ONE,t.ZERO);const{endo:w,nBitLength:x}=e,T=Xv(y,w?Math.ceil(x/2):x);return{CURVE:e,ProjectivePoint:y,normPrivateKeyToScalar:d,weierstrassEquation:o,isWithinCurveOrder:u}}function XI(r){const e=wg(r);return to(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function ZI(r){const e=XI(r),{Fp:t,n,nByteLength:i,nBitLength:s}=e,o=t.BYTES+1,a=2*t.BYTES+1;function c(N){return Me(N,n)}function l(N){return nf(N,n)}const{ProjectivePoint:u,normPrivateKeyToScalar:d,weierstrassEquation:f,isWithinCurveOrder:m}=QI({...e,toBytes(N,L,H){const B=L.toAffine(),E=t.toBytes(B.x),k=_s;return Ln("isCompressed",H),H?k(Uint8Array.from([L.hasEvenY()?2:3]),E):k(Uint8Array.from([4]),E,t.toBytes(B.y))},fromBytes(N){const L=N.length,H=N[0],B=N.subarray(1);if(L===o&&(H===2||H===3)){const E=wi(B);if(!mg(E,st,t.ORDER))throw new Error("Point is not on curve");const k=f(E);let M;try{M=t.sqrt(k)}catch(ae){const ue=ae instanceof Error?": "+ae.message:"";throw new Error("Point is not on curve"+ue)}const W=(M&st)===st;return(H&1)===1!==W&&(M=t.neg(M)),{x:E,y:M}}else if(L===a&&H===4){const E=t.fromBytes(B.subarray(0,t.BYTES)),k=t.fromBytes(B.subarray(t.BYTES,2*t.BYTES));return{x:E,y:k}}else{const E=o,k=a;throw new Error("invalid Point, expected length of "+E+", or uncompressed "+k+", got "+L)}}});function g(N){const L=n>>st;return N>L}function y(N){return g(N)?c(-N):N}const w=(N,L,H)=>wi(N.slice(L,H));class x{constructor(L,H,B){Gt("r",L,st,n),Gt("s",H,st,n),this.r=L,this.s=H,B!=null&&(this.recovery=B),Object.freeze(this)}static fromCompact(L){const H=i;return L=He("compactSignature",L,H*2),new x(w(L,0,H),w(L,H,2*H))}static fromDER(L){const{r:H,s:B}=Zr.toSig(He("DER",L));return new x(H,B)}assertValidity(){}addRecoveryBit(L){return new x(this.r,this.s,L)}recoverPublicKey(L){const{r:H,s:B,recovery:E}=this,k=C(He("msgHash",L));if(E==null||![0,1,2,3].includes(E))throw new Error("recovery id invalid");const M=E===2||E===3?H+e.n:H;if(M>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const W=(E&1)===0?"02":"03",F=u.fromHex(W+Jd(M,t.BYTES)),ae=l(M),ue=c(-k*ae),re=c(B*ae),fe=u.BASE.multiplyAndAddUnsafe(F,ue,re);if(!fe)throw new Error("point at infinify");return fe.assertValidity(),fe}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new x(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return cl(this.toDERHex())}toDERHex(){return Zr.hexFromSig(this)}toCompactRawBytes(){return cl(this.toCompactHex())}toCompactHex(){const L=i;return Jd(this.r,L)+Jd(this.s,L)}}const T={isValidPrivateKey(N){try{return d(N),!0}catch{return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{const N=Gv(e.n);return M2(e.randomBytes(N),e.n)},precompute(N=8,L=u.BASE){return L._setWindowSize(N),L.multiply(BigInt(3)),L}};function v(N,L=!0){return u.fromPrivateKey(N).toRawBytes(L)}function b(N){if(typeof N=="bigint")return!1;if(N instanceof u)return!0;const H=He("key",N).length,B=t.BYTES,E=B+1,k=2*B+1;if(!(e.allowedPrivateKeyLengths||i===E))return H===E||H===k}function A(N,L,H=!0){if(b(N)===!0)throw new Error("first arg must be private key");if(b(L)===!1)throw new Error("second arg must be public key");return u.fromHex(L).multiply(d(N)).toRawBytes(H)}const R=e.bits2int||function(N){if(N.length>8192)throw new Error("input is too large");const L=wi(N),H=N.length*8-s;return H>0?L>>BigInt(H):L},C=e.bits2int_modN||function(N){return c(R(N))},P=Tu(s);function D(N){return Gt("num < 2^"+s,N,Jr,P),xa(N,i)}function z(N,L,H=$){if(["recovered","canonical"].some(ve=>ve in H))throw new Error("sign() legacy options not supported");const{hash:B,randomBytes:E}=e;let{lowS:k,prehash:M,extraEntropy:W}=H;k==null&&(k=!0),N=He("msgHash",N),Dy(H),M&&(N=He("prehashed msgHash",B(N)));const F=C(N),ae=d(L),ue=[D(ae),D(F)];if(W!=null&&W!==!1){const ve=W===!0?E(t.BYTES):W;ue.push(He("extraEntropy",ve))}const re=_s(...ue),fe=F;function Ae(ve){const tt=R(ve);if(!m(tt))return;const Fe=l(tt),Ge=u.BASE.multiply(tt).toAffine(),Ye=c(Ge.x);if(Ye===Jr)return;const mt=c(Fe*c(fe+Ye*ae));if(mt===Jr)return;let zt=(Ge.x===Ye?0:2)|Number(Ge.y&st),Kr=mt;return k&&g(mt)&&(Kr=y(mt),zt^=1),new x(Ye,Kr,zt)}return{seed:re,k2sig:Ae}}const $={lowS:e.lowS,prehash:!1},j={lowS:e.lowS,prehash:!1};function q(N,L,H=$){const{seed:B,k2sig:E}=z(N,L,H),k=e;return I2(k.hash.outputLen,k.nByteLength,k.hmac)(B,E)}u.BASE._setWindowSize(8);function ie(N,L,H,B=j){const E=N;L=He("msgHash",L),H=He("publicKey",H);const{lowS:k,prehash:M,format:W}=B;if(Dy(B),"strict"in B)throw new Error("options.strict was renamed to lowS");if(W!==void 0&&W!=="compact"&&W!=="der")throw new Error("format must be compact or der");const F=typeof E=="string"||Aa(E),ae=!F&&!W&&typeof E=="object"&&E!==null&&typeof E.r=="bigint"&&typeof E.s=="bigint";if(!F&&!ae)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let ue,re;try{if(ae&&(ue=new x(E.r,E.s)),F){try{W!=="compact"&&(ue=x.fromDER(E))}catch(zt){if(!(zt instanceof Zr.Err))throw zt}!ue&&W!=="der"&&(ue=x.fromCompact(E))}re=u.fromHex(H)}catch{return!1}if(!ue||k&&ue.hasHighS())return!1;M&&(L=e.hash(L));const{r:fe,s:Ae}=ue,ve=C(L),tt=l(Ae),Fe=c(ve*tt),Ge=c(fe*tt),Ye=u.BASE.multiplyAndAddUnsafe(re,Fe,Ge)?.toAffine();return Ye?c(Ye.x)===fe:!1}return{CURVE:e,getPublicKey:v,getSharedSecret:A,sign:q,verify:ie,ProjectivePoint:u,Signature:x,utils:T}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function JI(r){return{hash:r,hmac:(e,...t)=>Ou(r,e,a2(...t)),randomBytes:ku}}function ek(r,e){const t=n=>ZI({...r,...JI(n)});return{...t(e),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const hS=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Ly=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),tk=BigInt(0),rk=BigInt(1),lf=BigInt(2),My=(r,e)=>(r+e/lf)/e;function nk(r){const e=hS,t=BigInt(3),n=BigInt(6),i=BigInt(11),s=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),l=r*r*r%e,u=l*l*r%e,d=ze(u,t,e)*u%e,f=ze(d,t,e)*u%e,m=ze(f,lf,e)*l%e,g=ze(m,i,e)*m%e,y=ze(g,s,e)*g%e,w=ze(y,a,e)*y%e,x=ze(w,c,e)*w%e,T=ze(x,a,e)*y%e,v=ze(T,t,e)*u%e,b=ze(v,o,e)*g%e,A=ze(b,n,e)*l%e,R=ze(A,lf,e);if(!uf.eql(uf.sqr(R),r))throw new Error("Cannot find square root");return R}const uf=_a(hS,void 0,void 0,{sqrt:nk}),un=ek({a:tk,b:BigInt(7),Fp:uf,n:Ly,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{const e=Ly,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-rk*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=t,o=BigInt("0x100000000000000000000000000000000"),a=My(s*r,e),c=My(-n*r,e);let l=Me(r-a*t-c*i,e),u=Me(-a*n-c*s,e);const d=l>o,f=u>o;if(d&&(l=e-l),f&&(u=e-u),l>o||u>o)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:d,k1:l,k2neg:f,k2:u}}}},Fv);function ik(r,e,t){const n=eo.digest(e instanceof Uint8Array?e:e.subarray());if(Pu(n))return n.then(({digest:i})=>(t?.signal?.throwIfAborted(),un.sign(i,r).toDERRawBytes())).catch(i=>{throw i.name==="AbortError"?i:new Py(String(i))});try{return un.sign(n.digest,r).toDERRawBytes()}catch(i){throw new Py(String(i))}}function sk(r,e,t,n){const i=eo.digest(t instanceof Uint8Array?t:t.subarray());if(Pu(i))return i.then(({digest:s})=>(n?.signal?.throwIfAborted(),un.verify(e,s,r))).catch(s=>{throw s.name==="AbortError"?s:new Ry(String(s))});try{return n?.signal?.throwIfAborted(),un.verify(e,i.digest,r)}catch(s){throw new Ry(String(s))}}class fS{type="secp256k1";raw;_key;constructor(e){this._key=uk(e),this.raw=ck(this._key)}toMultihash(){return ba.digest(nn(this))}toCID(){return Le.createV1(114,this.toMultihash())}toString(){return Je.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:et(this.raw,e.raw)}verify(e,t,n){return sk(this._key,t,e,n)}}class ok{type="secp256k1";raw;publicKey;constructor(e,t){this.raw=lk(e),this.publicKey=new fS(t??dk(e))}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:et(this.raw,e.raw)}sign(e,t){return ik(this.raw,e,t)}}function pS(r){return new fS(r)}async function ak(){const r=hk();return new ok(r)}function ck(r){return un.ProjectivePoint.fromHex(r).toRawBytes(!0)}function lk(r){try{return un.getPublicKey(r,!0),r}catch(e){throw new mv(String(e))}}function uk(r){try{return un.ProjectivePoint.fromHex(r),r}catch(e){throw new gv(String(e))}}function dk(r){try{return un.getPublicKey(r,!0)}catch(e){throw new mv(String(e))}}function hk(){return un.utils.randomPrivateKey()}async function gS(r,e){if(r==="Ed25519")return cI();if(r==="secp256k1")return ak();if(r==="RSA")return qI(pk(e));if(r==="ECDSA")return r2(gk(e));throw new Au}function jn(r,e){const{Type:t,Data:n}=Ti.decode(r),i=n??new Uint8Array;switch(t){case ot.RSA:return $I(i,e);case ot.Ed25519:return iS(i);case ot.secp256k1:return pS(i);case ot.ECDSA:return Bv(i);default:throw new Au}}function fk(r){const{Type:e,Data:t}=Ti.decode(r.digest),n=t??new Uint8Array;switch(e){case ot.Ed25519:return iS(n);case ot.secp256k1:return pS(n);case ot.ECDSA:return Bv(n);default:throw new Au}}function nn(r){return Ti.encode({Type:ot[r.type],Data:r.raw})}function pk(r){return r==null?2048:parseInt(r,10)}function gk(r){if(r==="P-256"||r==null)return"P-256";if(r==="P-384")return"P-384";if(r==="P-521")return"P-521";throw new le("Unsupported curve, should be P-256, P-384 or P-521")}async function mS(r){if(r.type==="RSA")return{privateKey:await crypto.subtle.importKey("jwk",r.jwk,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["sign"]),publicKey:await crypto.subtle.importKey("jwk",r.publicKey.jwk,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["verify"])};if(r.type==="ECDSA")return{privateKey:await crypto.subtle.importKey("jwk",r.jwk,{name:"ECDSA",namedCurve:r.jwk.crv??"P-256"},!0,["sign"]),publicKey:await crypto.subtle.importKey("jwk",r.publicKey.jwk,{name:"ECDSA",namedCurve:r.publicKey.jwk.crv??"P-256"},!0,["verify"])};throw new le("Only RSA and ECDSA keys are supported")}const yS=Symbol.for("nodejs.util.inspect.custom"),mk=114;class kg{type;multihash;publicKey;string;constructor(e){this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[sg]=!0;toString(){return this.string==null&&(this.string=Je.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return Le.createV1(mk,this.multihash)}toJSON(){return this.toString()}equals(e){if(e==null)return!1;if(e instanceof Uint8Array)return et(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(e?.toMultihash()?.bytes!=null)return et(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[yS](){return`PeerId(${this.toString()})`}}class wS extends kg{type="RSA";publicKey;constructor(e){super({...e,type:"RSA"}),this.publicKey=e.publicKey}}class bS extends kg{type="Ed25519";publicKey;constructor(e){super({...e,type:"Ed25519"}),this.publicKey=e.publicKey}}class vS extends kg{type="secp256k1";publicKey;constructor(e){super({...e,type:"secp256k1"}),this.publicKey=e.publicKey}}const yk=2336;class SS{type="url";multihash;publicKey;url;constructor(e){this.url=e.toString(),this.multihash=ba.digest(oe(this.url))}[yS](){return`PeerId(${this.url})`}[sg]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return Le.createV1(yk,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=ge(e)),e.toString()===this.toString())}}const wk=114,Uy=2336;function Ir(r,e){let t;if(r.charAt(0)==="1"||r.charAt(0)==="Q")t=Qn(Je.decode(`z${r}`));else{if(r.startsWith("k51qzi5uqu5")||r.startsWith("kzwfwjn5ji4")||r.startsWith("k2k4r8")||r.startsWith("bafz"))return Ca(Le.parse(r));throw new le('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return ro(t)}function Qo(r){if(r.type==="Ed25519")return new bS({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new vS({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new wS({multihash:r.toCID().multihash,publicKey:r});throw new Au}function bk(r){return Qo(r.publicKey)}function ro(r){if(Sk(r))return new wS({multihash:r});if(vk(r))try{const e=fk(r);if(e.type==="Ed25519")return new bS({multihash:r,publicKey:e});if(e.type==="secp256k1")return new vS({multihash:r,publicKey:e})}catch{const t=ge(r.digest);return new SS(new URL(t))}throw new f_("Supplied PeerID Multihash is invalid")}function Ca(r){if(r?.multihash==null||r.version==null||r.version===1&&r.code!==wk&&r.code!==Uy)throw new h_("Supplied PeerID CID is invalid");if(r.code===Uy){const e=ge(r.multihash.digest);return new SS(new URL(e))}return ro(r.multihash)}function vk(r){return r.code===ba.code}function Sk(r){return r.code===eo.code}const Ek=8,Tg=1024*1024*4;let Ak=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},ES=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},xk=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"},Fy=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};function AS(r){return r[Symbol.asyncIterator]!=null}function xS(r,e){if(r.byteLength>e)throw new ES("Message length too long")}const Bu=r=>{const e=_t(r),t=Vr(e);return gs(r,t),Bu.bytes=e,t};Bu.bytes=0;function fl(r,e){e=e??{};const t=e.lengthEncoder??Bu,n=e?.maxDataLength??Tg;function*i(s){xS(s,n);const o=t(s.byteLength);o instanceof Uint8Array?yield o:yield*o,s instanceof Uint8Array?yield s:yield*s}return AS(r)?async function*(){for await(const s of r)yield*i(s)}():function*(){for(const s of r)yield*i(s)}()}fl.single=(r,e)=>{e=e??{};const t=e.lengthEncoder??Bu,n=e?.maxDataLength??Tg;return xS(r,n),new be(t(r.byteLength),r)};var oi;(function(r){r[r.LENGTH=0]="LENGTH",r[r.DATA=1]="DATA"})(oi||(oi={}));const Pg=r=>{const e=Ru(r);return Pg.bytes=_t(e),e};Pg.bytes=0;function pl(r,e){const t=new be;let n=oi.LENGTH,i=-1;const s=e?.lengthDecoder??Pg,o=e?.maxLengthLength??Ek,a=e?.maxDataLength??Tg;function*c(){for(;t.byteLength>0;){if(n===oi.LENGTH)try{if(i=s(t),i<0)throw new Ak("Invalid message length");if(i>a)throw new ES("Message length too long");const l=s.bytes;t.consume(l),e?.onLength!=null&&e.onLength(i),n=oi.DATA}catch(l){if(l instanceof RangeError){if(t.byteLength>o)throw new xk("Message length length too long");break}throw l}if(n===oi.DATA){if(t.byteLength<i)break;const l=t.sublist(0,i);t.consume(i),e?.onData!=null&&e.onData(l),yield l,n=oi.LENGTH}}}return AS(r)?async function*(){for await(const l of r)t.append(l),yield*c();if(t.byteLength>0)throw new Fy("Unexpected end of input")}():function*(){for(const l of r)t.append(l),yield*c();if(t.byteLength>0)throw new Fy("Unexpected end of input")}()}pl.fromReader=(r,e)=>{let t=1;const n=async function*(){for(;;)try{const{done:s,value:o}=await r.next(t);if(s===!0)return;o!=null&&(yield o)}catch(s){if(s.code==="ERR_UNDER_READ")return{done:!0,value:null};throw s}finally{t=1}}();return pl(n,{...e??{},onLength:s=>{t=s}})};function We(){const r={};return r.promise=new Promise((e,t)=>{r.resolve=e,r.reject=t}),r}let $y=class extends Error{type;code;constructor(e,t,n){super(e??"The operation was aborted"),this.type="aborted",this.name=n??"AbortError",this.code=t??"ABORT_ERR"}};async function sr(r,e,t){if(e==null)return r;if(e.aborted)return r.catch(()=>{}),Promise.reject(new $y(t?.errorMessage,t?.errorCode,t?.errorName));let n;const i=new $y(t?.errorMessage,t?.errorCode,t?.errorName);try{return await Promise.race([r,new Promise((s,o)=>{n=()=>{o(i)},e.addEventListener("abort",n)})])}finally{n!=null&&e.removeEventListener("abort",n)}}class _k{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=We(),this.haveNext=We()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=We(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=We(),await sr(this.readNext.promise,t?.signal,t)}}function _S(){return new _k}class Ck extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"}function gl(r,e){const t=_S();r.sink(t).catch(async o=>{await t.end(o)}),r.sink=async o=>{for await(const a of o)await t.push(a);await t.end()};let n=r.source;r.source[Symbol.iterator]!=null?n=r.source[Symbol.iterator]():r.source[Symbol.asyncIterator]!=null&&(n=r.source[Symbol.asyncIterator]());const i=new be;return{read:async o=>{if(o?.signal?.throwIfAborted(),o?.bytes==null){const{done:c,value:l}=await sr(n.next(),o?.signal);return c===!0?null:l}for(;i.byteLength<o.bytes;){const{value:c,done:l}=await sr(n.next(),o?.signal);if(l===!0)throw new Ck("unexpected end of input");i.append(c)}const a=i.sublist(0,o.bytes);return i.consume(o.bytes),a},write:async(o,a)=>{a?.signal?.throwIfAborted(),o instanceof Uint8Array?await t.push(o,a):await t.push(o.subarray(),a)},unwrap:()=>{if(i.byteLength>0){const o=r.source;r.source=async function*(){e?.yieldBytes===!1?yield i:yield*i,yield*o}()}return r}}}class Ik extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"}class kk extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"}class Tk extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"}function Cs(r,e={}){const t=gl(r,e);e.maxDataLength!=null&&e.maxLengthLength==null&&(e.maxLengthLength=_t(e.maxDataLength));const n=e?.lengthDecoder??Ru,i=e?.lengthEncoder??gs;return{read:async o=>{let a=-1;const c=new be;for(;;){c.append(await t.read({...o,bytes:1}));try{a=n(c)}catch(l){if(l instanceof RangeError)continue;throw l}if(a<0)throw new Ik("Invalid message length");if(e?.maxLengthLength!=null&&c.byteLength>e.maxLengthLength)throw new Tk("message length length too long");if(a>-1)break}if(e?.maxDataLength!=null&&a>e.maxDataLength)throw new kk("message length too long");return t.read({...o,bytes:a})},write:async(o,a)=>{await t.write(new be(i(o.byteLength),o),a)},writeV:async(o,a)=>{const c=new be(...o.flatMap(l=>[i(l.byteLength),l]));await t.write(c,a)},unwrap:()=>t.unwrap()}}function Vy(){const r=We();let e=!1;return{sink:async t=>{if(e)throw new Error("already piped");e=!0,r.resolve(t)},source:async function*(){yield*await r.promise}()}}function Pk(){const r=Vy(),e=Vy();return[{source:r.source,sink:e.sink},{source:e.source,sink:r.sink}]}class qy{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||(e-1&e)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}}class th{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new qy(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return e?.byteLength!=null?e.byteLength:1}push(e){if(e?.value!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new qy(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return e?.value!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}let Rk=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}};function Ia(r={}){return Ok(t=>{const n=t.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function Ok(r,e){e=e??{};let t=e.onEnd,n=new th,i,s,o,a=We();const c=async()=>{try{return n.isEmpty()?o?{done:!0}:await new Promise((w,x)=>{s=T=>{s=null,n.push(T);try{w(r(n))}catch(v){x(v)}return i}}):r(n)}finally{n.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=We()})}},l=w=>s!=null?s(w):(n.push(w),i),u=w=>(n=new th,s!=null?s({error:w}):(n.push({error:w}),i)),d=w=>{if(o)return i;if(e?.objectMode!==!0&&w?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:w})},f=w=>o?i:(o=!0,w!=null?u(w):l({done:!0})),m=()=>(n=new th,f(),{done:!0}),g=w=>(f(w),{done:!0});if(i={[Symbol.asyncIterator](){return this},next:c,return:m,throw:g,push:d,end:f,get readableLength(){return n.size},onEmpty:async w=>{const x=w?.signal;if(x?.throwIfAborted(),n.isEmpty())return;let T,v;x!=null&&(T=new Promise((b,A)=>{v=()=>{A(new Rk)},x.addEventListener("abort",v)}));try{await Promise.race([a.promise,T])}finally{v!=null&&x!=null&&x?.removeEventListener("abort",v)}}},t==null)return i;const y=i;return i={[Symbol.asyncIterator](){return this},next(){return y.next()},throw(w){return y.throw(w),t!=null&&(t(w),t=void 0),{done:!0}},return(){return y.return(),t!=null&&(t(),t=void 0),{done:!0}},push:d,end(w){return y.end(w),t!=null&&(t(w),t=void 0),i},get readableLength(){return y.readableLength},onEmpty:w=>y.onEmpty(w)},i}function Bk(r){return r[Symbol.asyncIterator]!=null}async function Nk(r,e,t){try{await Promise.all(r.map(async n=>{for await(const i of n)await e.push(i,{signal:t}),t.throwIfAborted()})),await e.end(void 0,{signal:t})}catch(n){await e.end(n,{signal:t}).catch(()=>{})}}async function*Dk(r){const e=new AbortController,t=_S();Nk(r,t,e.signal).catch(()=>{});try{yield*t}finally{e.abort()}}function*Lk(r){for(const e of r)yield*e}function ml(...r){const e=[];for(const t of r)Bk(t)||e.push(t);return e.length===r.length?Lk(e):Dk(r)}function Rg(r,...e){if(r==null)throw new Error("Empty pipeline");if(rh(r)){const n=r;r=()=>n.source}else if(IS(r)||CS(r)){const n=r;r=()=>n}const t=[r,...e];if(t.length>1&&rh(t[t.length-1])&&(t[t.length-1]=t[t.length-1].sink),t.length>2)for(let n=1;n<t.length-1;n++)rh(t[n])&&(t[n]=Uk(t[n]));return Mk(...t)}const Mk=(...r)=>{let e;for(;r.length>0;)e=r.shift()(e);return e},CS=r=>r?.[Symbol.asyncIterator]!=null,IS=r=>r?.[Symbol.iterator]!=null,rh=r=>r==null?!1:r.sink!=null&&r.source!=null,Uk=r=>e=>{const t=r.sink(e);if(t?.then!=null){const n=Ia({objectMode:!0});t.then(()=>{n.end()},o=>{n.end(o)});let i;const s=r.source;if(CS(s))i=async function*(){yield*s,n.end()};else if(IS(s))i=function*(){yield*s,n.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return ml(n,i())}return r.source},Xo=65535,jy=Xo-16,ka=!!globalThis.process?.env?.DUMP_SESSION_KEYS;/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function kS(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function df(r){if(typeof r!="boolean")throw new Error(`boolean expected, not ${r}`)}function nh(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function Lt(r,...e){if(!kS(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function zy(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Fk(r,e){Lt(r);const t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function Mn(r){return new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength/4))}function Is(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function $k(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}const Vk=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function qk(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}function hf(r){if(typeof r=="string")r=qk(r);else if(kS(r))r=ff(r);else throw new Error("Uint8Array expected, got "+typeof r);return r}function jk(r,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(r,e)}function zk(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}const Hk=(r,e)=>{function t(n,...i){if(Lt(n),!Vk)throw new Error("Non little-endian hardware is not yet supported");if(r.nonceLength!==void 0){const u=i[0];if(!u)throw new Error("nonce / iv required");r.varSizeNonce?Lt(u):Lt(u,r.nonceLength)}const s=r.tagLength;s&&i[1]!==void 0&&Lt(i[1]);const o=e(n,...i),a=(u,d)=>{if(d!==void 0){if(u!==2)throw new Error("cipher output not supported");Lt(d)}};let c=!1;return{encrypt(u,d){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,Lt(u),a(o.encrypt.length,d),o.encrypt(u,d)},decrypt(u,d){if(Lt(u),s&&u.length<s)throw new Error("invalid ciphertext length: smaller than tagLength="+s);return a(o.decrypt.length,d),o.decrypt(u,d)}}}return Object.assign(t,r),t};function Hy(r,e,t=!0){if(e===void 0)return new Uint8Array(r);if(e.length!==r)throw new Error("invalid output length, expected "+r+", got: "+e.length);if(t&&!Kk(e))throw new Error("invalid output, must be aligned");return e}function Wy(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const i=BigInt(32),s=BigInt(4294967295),o=Number(t>>i&s),a=Number(t&s),c=4,l=0;r.setUint32(e+c,o,n),r.setUint32(e+l,a,n)}function Wk(r,e,t){df(t);const n=new Uint8Array(16),i=$k(n);return Wy(i,0,BigInt(e),t),Wy(i,8,BigInt(r),t),n}function Kk(r){return r.byteOffset%4===0}function ff(r){return Uint8Array.from(r)}const TS=r=>Uint8Array.from(r.split("").map(e=>e.charCodeAt(0))),Gk=TS("expand 16-byte k"),Yk=TS("expand 32-byte k"),Qk=Mn(Gk),Xk=Mn(Yk);function xe(r,e){return r<<e|r>>>32-e}function pf(r){return r.byteOffset%4===0}const pc=64,Zk=16,PS=2**32-1,Ky=new Uint32Array;function Jk(r,e,t,n,i,s,o,a){const c=i.length,l=new Uint8Array(pc),u=Mn(l),d=pf(i)&&pf(s),f=d?Mn(i):Ky,m=d?Mn(s):Ky;for(let g=0;g<c;o++){if(r(e,t,n,u,o,a),o>=PS)throw new Error("arx: counter overflow");const y=Math.min(pc,c-g);if(d&&y===pc){const w=g/4;if(g%4!==0)throw new Error("arx: invalid block position");for(let x=0,T;x<Zk;x++)T=w+x,m[T]=f[T]^u[x];g+=pc;continue}for(let w=0,x;w<y;w++)x=g+w,s[x]=i[x]^l[w];g+=y}}function eT(r,e){const{allowShortKeys:t,extendNonceFn:n,counterLength:i,counterRight:s,rounds:o}=jk({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof r!="function")throw new Error("core must be a function");return nh(i),nh(o),df(s),df(t),(a,c,l,u,d=0)=>{Lt(a),Lt(c),Lt(l);const f=l.length;if(u===void 0&&(u=new Uint8Array(f)),Lt(u),nh(d),d<0||d>=PS)throw new Error("arx: counter overflow");if(u.length<f)throw new Error(`arx: output (${u.length}) is shorter than data (${f})`);const m=[];let g=a.length,y,w;if(g===32)m.push(y=ff(a)),w=Xk;else if(g===16&&t)y=new Uint8Array(32),y.set(a),y.set(a,16),w=Qk,m.push(y);else throw new Error(`arx: invalid 32-byte key, got length=${g}`);pf(c)||m.push(c=ff(c));const x=Mn(y);if(n){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");n(w,x,Mn(c.subarray(0,16)),x),c=c.subarray(16)}const T=16-i;if(T!==c.length)throw new Error(`arx: nonce must be ${T} or 16 bytes`);if(T!==12){const b=new Uint8Array(12);b.set(c,s?0:12-c.length),c=b,m.push(c)}const v=Mn(c);return Jk(r,w,x,v,l,u,d,o),Is(...m),u}}const ct=(r,e)=>r[e++]&255|(r[e++]&255)<<8;class tT{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=hf(e),Lt(e,32);const t=ct(e,0),n=ct(e,2),i=ct(e,4),s=ct(e,6),o=ct(e,8),a=ct(e,10),c=ct(e,12),l=ct(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|n<<3)&8191,this.r[2]=(n>>>10|i<<6)&7939,this.r[3]=(i>>>7|s<<9)&8191,this.r[4]=(s>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|l<<8)&8191,this.r[9]=l>>>5&127;for(let u=0;u<8;u++)this.pad[u]=ct(e,16+2*u)}process(e,t,n=!1){const i=n?0:2048,{h:s,r:o}=this,a=o[0],c=o[1],l=o[2],u=o[3],d=o[4],f=o[5],m=o[6],g=o[7],y=o[8],w=o[9],x=ct(e,t+0),T=ct(e,t+2),v=ct(e,t+4),b=ct(e,t+6),A=ct(e,t+8),R=ct(e,t+10),C=ct(e,t+12),P=ct(e,t+14);let D=s[0]+(x&8191),z=s[1]+((x>>>13|T<<3)&8191),$=s[2]+((T>>>10|v<<6)&8191),j=s[3]+((v>>>7|b<<9)&8191),q=s[4]+((b>>>4|A<<12)&8191),ie=s[5]+(A>>>1&8191),N=s[6]+((A>>>14|R<<2)&8191),L=s[7]+((R>>>11|C<<5)&8191),H=s[8]+((C>>>8|P<<8)&8191),B=s[9]+(P>>>5|i),E=0,k=E+D*a+z*(5*w)+$*(5*y)+j*(5*g)+q*(5*m);E=k>>>13,k&=8191,k+=ie*(5*f)+N*(5*d)+L*(5*u)+H*(5*l)+B*(5*c),E+=k>>>13,k&=8191;let M=E+D*c+z*a+$*(5*w)+j*(5*y)+q*(5*g);E=M>>>13,M&=8191,M+=ie*(5*m)+N*(5*f)+L*(5*d)+H*(5*u)+B*(5*l),E+=M>>>13,M&=8191;let W=E+D*l+z*c+$*a+j*(5*w)+q*(5*y);E=W>>>13,W&=8191,W+=ie*(5*g)+N*(5*m)+L*(5*f)+H*(5*d)+B*(5*u),E+=W>>>13,W&=8191;let F=E+D*u+z*l+$*c+j*a+q*(5*w);E=F>>>13,F&=8191,F+=ie*(5*y)+N*(5*g)+L*(5*m)+H*(5*f)+B*(5*d),E+=F>>>13,F&=8191;let ae=E+D*d+z*u+$*l+j*c+q*a;E=ae>>>13,ae&=8191,ae+=ie*(5*w)+N*(5*y)+L*(5*g)+H*(5*m)+B*(5*f),E+=ae>>>13,ae&=8191;let ue=E+D*f+z*d+$*u+j*l+q*c;E=ue>>>13,ue&=8191,ue+=ie*a+N*(5*w)+L*(5*y)+H*(5*g)+B*(5*m),E+=ue>>>13,ue&=8191;let re=E+D*m+z*f+$*d+j*u+q*l;E=re>>>13,re&=8191,re+=ie*c+N*a+L*(5*w)+H*(5*y)+B*(5*g),E+=re>>>13,re&=8191;let fe=E+D*g+z*m+$*f+j*d+q*u;E=fe>>>13,fe&=8191,fe+=ie*l+N*c+L*a+H*(5*w)+B*(5*y),E+=fe>>>13,fe&=8191;let Ae=E+D*y+z*g+$*m+j*f+q*d;E=Ae>>>13,Ae&=8191,Ae+=ie*u+N*l+L*c+H*a+B*(5*w),E+=Ae>>>13,Ae&=8191;let ve=E+D*w+z*y+$*g+j*m+q*f;E=ve>>>13,ve&=8191,ve+=ie*d+N*u+L*l+H*c+B*a,E+=ve>>>13,ve&=8191,E=(E<<2)+E|0,E=E+k|0,k=E&8191,E=E>>>13,M+=E,s[0]=k,s[1]=M,s[2]=W,s[3]=F,s[4]=ae,s[5]=ue,s[6]=re,s[7]=fe,s[8]=Ae,s[9]=ve}finalize(){const{h:e,pad:t}=this,n=new Uint16Array(10);let i=e[1]>>>13;e[1]&=8191;for(let a=2;a<10;a++)e[a]+=i,i=e[a]>>>13,e[a]&=8191;e[0]+=i*5,i=e[0]>>>13,e[0]&=8191,e[1]+=i,i=e[1]>>>13,e[1]&=8191,e[2]+=i,n[0]=e[0]+5,i=n[0]>>>13,n[0]&=8191;for(let a=1;a<10;a++)n[a]=e[a]+i,i=n[a]>>>13,n[a]&=8191;n[9]-=8192;let s=(i^1)-1;for(let a=0;a<10;a++)n[a]&=s;s=~s;for(let a=0;a<10;a++)e[a]=e[a]&s|n[a];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let o=e[0]+t[0];e[0]=o&65535;for(let a=1;a<8;a++)o=(e[a]+t[a]|0)+(o>>>16)|0,e[a]=o&65535;Is(n)}update(e){zy(this),e=hf(e),Lt(e);const{buffer:t,blockLen:n}=this,i=e.length;for(let s=0;s<i;){const o=Math.min(n-this.pos,i-s);if(o===n){for(;n<=i-s;s+=n)this.process(e,s);continue}t.set(e.subarray(s,s+o),this.pos),this.pos+=o,s+=o,this.pos===n&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){Is(this.h,this.r,this.buffer,this.pad)}digestInto(e){zy(this),Fk(e,this),this.finished=!0;const{buffer:t,h:n}=this;let{pos:i}=this;if(i){for(t[i++]=1;i<16;i++)t[i]=0;this.process(t,0,!0)}this.finalize();let s=0;for(let o=0;o<8;o++)e[s++]=n[o]>>>0,e[s++]=n[o]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}}function rT(r){const e=(n,i)=>r(i).update(hf(n)).digest(),t=r(new Uint8Array(32));return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=n=>r(n),e}const nT=rT(r=>new tT(r));function iT(r,e,t,n,i,s=20){let o=r[0],a=r[1],c=r[2],l=r[3],u=e[0],d=e[1],f=e[2],m=e[3],g=e[4],y=e[5],w=e[6],x=e[7],T=i,v=t[0],b=t[1],A=t[2],R=o,C=a,P=c,D=l,z=u,$=d,j=f,q=m,ie=g,N=y,L=w,H=x,B=T,E=v,k=b,M=A;for(let F=0;F<s;F+=2)R=R+z|0,B=xe(B^R,16),ie=ie+B|0,z=xe(z^ie,12),R=R+z|0,B=xe(B^R,8),ie=ie+B|0,z=xe(z^ie,7),C=C+$|0,E=xe(E^C,16),N=N+E|0,$=xe($^N,12),C=C+$|0,E=xe(E^C,8),N=N+E|0,$=xe($^N,7),P=P+j|0,k=xe(k^P,16),L=L+k|0,j=xe(j^L,12),P=P+j|0,k=xe(k^P,8),L=L+k|0,j=xe(j^L,7),D=D+q|0,M=xe(M^D,16),H=H+M|0,q=xe(q^H,12),D=D+q|0,M=xe(M^D,8),H=H+M|0,q=xe(q^H,7),R=R+$|0,M=xe(M^R,16),L=L+M|0,$=xe($^L,12),R=R+$|0,M=xe(M^R,8),L=L+M|0,$=xe($^L,7),C=C+j|0,B=xe(B^C,16),H=H+B|0,j=xe(j^H,12),C=C+j|0,B=xe(B^C,8),H=H+B|0,j=xe(j^H,7),P=P+q|0,E=xe(E^P,16),ie=ie+E|0,q=xe(q^ie,12),P=P+q|0,E=xe(E^P,8),ie=ie+E|0,q=xe(q^ie,7),D=D+z|0,k=xe(k^D,16),N=N+k|0,z=xe(z^N,12),D=D+z|0,k=xe(k^D,8),N=N+k|0,z=xe(z^N,7);let W=0;n[W++]=o+R|0,n[W++]=a+C|0,n[W++]=c+P|0,n[W++]=l+D|0,n[W++]=u+z|0,n[W++]=d+$|0,n[W++]=f+j|0,n[W++]=m+q|0,n[W++]=g+ie|0,n[W++]=y+N|0,n[W++]=w+L|0,n[W++]=x+H|0,n[W++]=T+B|0,n[W++]=v+E|0,n[W++]=b+k|0,n[W++]=A+M|0}const sT=eT(iT,{counterRight:!1,counterLength:4,allowShortKeys:!1}),oT=new Uint8Array(16),Gy=(r,e)=>{r.update(e);const t=e.length%16;t&&r.update(oT.subarray(t))},aT=new Uint8Array(32);function Yy(r,e,t,n,i){const s=r(e,t,aT),o=nT.create(s);i&&Gy(o,i),Gy(o,n);const a=Wk(n.length,i?i.length:0,!0);o.update(a);const c=o.digest();return Is(s,a),c}const cT=r=>(e,t,n)=>({encrypt(s,o){const a=s.length;o=Hy(a+16,o,!1),o.set(s);const c=o.subarray(0,-16);r(e,t,c,c,1);const l=Yy(r,e,t,c,n);return o.set(l,a),Is(l),o},decrypt(s,o){o=Hy(s.length-16,o,!1);const a=s.subarray(0,-16),c=s.subarray(-16),l=Yy(r,e,t,a,n);if(!zk(c,l))throw new Error("invalid tag");return o.set(s.subarray(0,-16)),r(e,t,o,o,1),Is(l),o}}),Qy=Hk({blockSize:64,nonceLength:12,tagLength:16},cT(sT));function lT(r,e,t){return fg(r),t===void 0&&(t=new Uint8Array(r.outputLen)),Ou(r,Ko(t),Ko(e))}const ih=Uint8Array.from([0]),Xy=Uint8Array.of();function uT(r,e,t,n=32){fg(r),ol(n);const i=r.outputLen;if(n>255*i)throw new Error("Length should be <= 255*HashLen");const s=Math.ceil(n/i);t===void 0&&(t=Xy);const o=new Uint8Array(s*i),a=Ou.create(r,e),c=a._cloneInto(),l=new Uint8Array(a.outputLen);for(let u=0;u<s;u++)ih[0]=u+1,c.update(u===0?Xy:l).update(t).update(ih).digestInto(l),o.set(l,i*u),a._cloneInto(c);return a.destroy(),c.destroy(),ki(l,ih),o.slice(0,n)}const dT={hashSHA256(r){return Lo(r.subarray())},getHKDF(r,e){const t=lT(Lo,e,r),i=uT(Lo,t,void 0,96),s=i.subarray(0,32),o=i.subarray(32,64),a=i.subarray(64,96);return[s,o,a]},generateX25519KeyPair(){const r=dc.utils.randomPrivateKey();return{publicKey:dc.getPublicKey(r),privateKey:r}},generateX25519KeyPairFromSeed(r){return{publicKey:dc.getPublicKey(r),privateKey:r}},generateX25519SharedKey(r,e){return dc.getSharedSecret(r.subarray(),e.subarray())},chaCha20Poly1305Encrypt(r,e,t,n){return Qy(n,e,t).encrypt(r.subarray())},chaCha20Poly1305Decrypt(r,e,t,n,i){return Qy(n,e,t).decrypt(r.subarray(),i)}},hT=dT;function fT(r){return{generateKeypair:r.generateX25519KeyPair,dh:(e,t)=>r.generateX25519SharedKey(e.privateKey,t).subarray(0,32),encrypt:r.chaCha20Poly1305Encrypt,decrypt:r.chaCha20Poly1305Decrypt,hash:r.hashSHA256,hkdf:r.getHKDF}}const yl=r=>{const e=Vr(2);return e[0]=r>>8,e[1]=r,e};yl.bytes=2;const Hc=r=>{if(r.length<2)throw RangeError("Could not decode int16BE");if(r instanceof Uint8Array){let e=0;return e+=r[0]<<8,e+=r[1],e}return r.getUint16(0)};Hc.bytes=2;function pT(r){return{xxHandshakeSuccesses:r.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:r.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:r.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:r.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:r.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}function RS(r,e){!e.enabled||!ka||(r?(e(`LOCAL_STATIC_PUBLIC_KEY ${ge(r.publicKey,"hex")}`),e(`LOCAL_STATIC_PRIVATE_KEY ${ge(r.privateKey,"hex")}`)):e("Missing local static keys."))}function OS(r,e){!e.enabled||!ka||(r?(e(`LOCAL_PUBLIC_EPHEMERAL_KEY ${ge(r.publicKey,"hex")}`),e(`LOCAL_PRIVATE_EPHEMERAL_KEY ${ge(r.privateKey,"hex")}`)):e("Missing local ephemeral keys."))}function gT(r,e){!e.enabled||!ka||e(r?`REMOTE_STATIC_PUBLIC_KEY ${ge(r.subarray(),"hex")}`:"Missing remote static public key.")}function BS(r,e){!e.enabled||!ka||e(r?`REMOTE_EPHEMERAL_PUBLIC_KEY ${ge(r.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function NS(r,e,t){!t.enabled||!ka||(t(`CIPHER_STATE_1 ${r.n.getUint64()} ${r.k&&ge(r.k,"hex")}`),t(`CIPHER_STATE_2 ${e.n.getUint64()} ${e.k&&ge(e.k,"hex")}`))}class Mo extends Error{code;constructor(e="Invalid crypto exchange"){super(e),this.code=Mo.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"}const mT=0,yT=4294967295,wT="Cipherstate has reached maximum n, a new handshake must be performed";class bT{n;bytes;view;constructor(e=mT){this.n=e,this.bytes=Pe(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,e,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>yT)throw new Error(wT)}}const ms=Pe(0);class gc{k;n;crypto;constructor(e,t=void 0,n=0){this.crypto=e,this.k=t,this.n=new bT(n)}hasKey(){return!!this.k}encryptWithAd(e,t){if(!this.hasKey())return t;this.n.assertValue();const n=this.crypto.encrypt(t,this.n.getBytes(),e,this.k);return this.n.increment(),n}decryptWithAd(e,t,n){if(!this.hasKey())return t;this.n.assertValue();const i=this.crypto.decrypt(t,this.n.getBytes(),e,this.k,n);return this.n.increment(),i}}class vT{cs;ck;h;crypto;constructor(e,t){this.crypto=e;const n=oe(t,"utf-8");this.h=ET(e,n),this.ck=this.h,this.cs=new gc(e)}mixKey(e){const[t,n]=this.crypto.hkdf(this.ck,e);this.ck=t,this.cs=new gc(this.crypto,n)}mixHash(e){this.h=this.crypto.hash(new be(this.h,e))}encryptAndHash(e){const t=this.cs.encryptWithAd(this.h,e);return this.mixHash(t),t}decryptAndHash(e){const t=this.cs.decryptWithAd(this.h,e);return this.mixHash(e),t}split(){const[e,t]=this.crypto.hkdf(this.ck,ms);return[new gc(this.crypto,e),new gc(this.crypto,t)]}}class ST{ss;s;e;rs;re;initiator;crypto;constructor(e){const{crypto:t,protocolName:n,prologue:i,initiator:s,s:o,e:a,rs:c,re:l}=e;this.crypto=t,this.ss=new vT(t,n),this.ss.mixHash(i),this.initiator=s,this.s=o,this.e=a,this.rs=c,this.re=l}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const e=this.crypto.generateKeypair();return this.ss.mixHash(e.publicKey),this.e=e,e.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(e,t=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(e.byteLength<t+32)throw new Error("message is not long enough");this.re=e.sublist(t,t+32),this.ss.mixHash(this.re)}readS(e,t=0){if(this.rs)throw new Error("remote static public key is already set");const n=32+(this.ss.cs.hasKey()?16:0);if(e.byteLength<t+n)throw new Error("message is not long enough");const i=e.sublist(t,t+n);return this.rs=this.ss.decryptAndHash(i),n}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class DS extends ST{writeMessageA(e){return new be(this.writeE(),this.ss.encryptAndHash(e))}writeMessageB(e){const t=this.writeE();this.writeEE();const n=this.writeS();return this.writeES(),new be(t,n,this.ss.encryptAndHash(e))}writeMessageC(e){const t=this.writeS();return this.writeSE(),new be(t,this.ss.encryptAndHash(e))}readMessageA(e){try{return this.readE(e),this.ss.decryptAndHash(e.sublist(32))}catch(t){throw new Mo(`handshake stage 0 validation fail: ${t.message}`)}}readMessageB(e){try{this.readE(e),this.readEE();const t=this.readS(e,32);return this.readES(),this.ss.decryptAndHash(e.sublist(32+t))}catch(t){throw new Mo(`handshake stage 1 validation fail: ${t.message}`)}}readMessageC(e){try{const t=this.readS(e);return this.readSE(),this.ss.decryptAndHash(e.sublist(t))}catch(t){throw new Mo(`handshake stage 2 validation fail: ${t.message}`)}}}function ET(r,e){if(e.length<=32){const t=Pe(32);return t.set(e),t}else return r.hash(e)}var wl;(function(r){let e;r.codec=()=>(e==null&&(e=De((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.webtransportCerthashes!=null)for(const s of t.webtransportCerthashes)n.uint32(10),n.bytes(s);if(t.streamMuxers!=null)for(const s of t.streamMuxers)n.uint32(18),n.string(s);i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={webtransportCerthashes:[],streamMuxers:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(i.limits?.webtransportCerthashes!=null&&s.webtransportCerthashes.length===i.limits.webtransportCerthashes)throw new Cr('Decode error - map field "webtransportCerthashes" had too many elements');s.webtransportCerthashes.push(t.bytes());break}case 2:{if(i.limits?.streamMuxers!=null&&s.streamMuxers.length===i.limits.streamMuxers)throw new Cr('Decode error - map field "streamMuxers" had too many elements');s.streamMuxers.push(t.string());break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ne(t,r.codec()),r.decode=(t,n)=>Be(t,r.codec(),n)})(wl||(wl={}));var bl;(function(r){let e;r.codec=()=>(e==null&&(e=De((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.identityKey!=null&&t.identityKey.byteLength>0&&(n.uint32(10),n.bytes(t.identityKey)),t.identitySig!=null&&t.identitySig.byteLength>0&&(n.uint32(18),n.bytes(t.identitySig)),t.extensions!=null&&(n.uint32(34),wl.codec().encode(t.extensions,n)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={identityKey:Pe(0),identitySig:Pe(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.identityKey=t.bytes();break}case 2:{s.identitySig=t.bytes();break}case 4:{s.extensions=wl.codec().decode(t,t.uint32(),{limits:i.limits?.extensions});break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ne(t,r.codec()),r.decode=(t,n)=>Be(t,r.codec(),n)})(bl||(bl={}));async function LS(r,e,t){const n=await r.sign(US(e));return bl.encode({identityKey:nn(r.publicKey),identitySig:n,extensions:t})}async function MS(r,e,t){try{const n=bl.decode(r),i=jn(n.identityKey);if(t?.equals(i)===!1)throw new Error(`Payload identity key ${i} does not match expected remote identity key ${t}`);if(!e)throw new Error("Remote static does not exist");const s=US(e);if(!await i.verify(s,n.identitySig))throw new Error("Invalid payload signature");return n}catch(n){throw new c_(n.message)}}function US(r){const e=oe("noise-libp2p-static-key:");return r instanceof Uint8Array?cn([e,r],e.length+r.length):(r.prepend(e),r)}async function AT(r,e){const{log:t,connection:n,crypto:i,privateKey:s,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=r,u=await LS(s,a.publicKey,l),d=new DS({crypto:i,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});RS(d.s,t),t.trace("Stage 0 - Initiator starting to send first message."),await n.write(d.writeMessageA(ms),e),t.trace("Stage 0 - Initiator finished sending first message."),OS(d.e,t),t.trace("Stage 1 - Initiator waiting to receive first message from responder...");const f=d.readMessageB(await n.read(e));t.trace("Stage 1 - Initiator received the message."),BS(d.re,t),gT(d.rs,t),t.trace("Initiator going to check remote's signature...");const m=await MS(f,d.rs,c);t.trace("All good with the signature!"),t.trace("Stage 2 - Initiator sending third handshake message."),await n.write(d.writeMessageC(u),e),t.trace("Stage 2 - Initiator sent message with signed payload.");const[g,y]=d.ss.split();return NS(g,y,t),{payload:m,encrypt:w=>g.encryptWithAd(ms,w),decrypt:(w,x)=>y.decryptWithAd(ms,w,x)}}async function xT(r,e){const{log:t,connection:n,crypto:i,privateKey:s,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=r,u=await LS(s,a.publicKey,l),d=new DS({crypto:i,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});RS(d.s,t),t.trace("Stage 0 - Responder waiting to receive first message."),d.readMessageA(await n.read(e)),t.trace("Stage 0 - Responder received first message."),BS(d.re,t),t.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await n.write(d.writeMessageB(u),e),t.trace("Stage 1 - Responder sent the second handshake message with signed payload."),OS(d.e,t),t.trace("Stage 2 - Responder waiting for third handshake message...");const f=d.readMessageC(await n.read(e));t.trace("Stage 2 - Responder received the message, finished handshake.");const m=await MS(f,d.rs,c),[g,y]=d.ss.split();return NS(g,y,t),{payload:m,encrypt:w=>y.encryptWithAd(ms,w),decrypt:(w,x)=>g.decryptWithAd(ms,w,x)}}const Zy=16;function _T(r,e){return async function*(t){for await(const n of t)for(let i=0;i<n.length;i+=jy){let s=i+jy;s>n.length&&(s=n.length);let o;n instanceof Uint8Array?o=r.encrypt(n.subarray(i,s)):o=r.encrypt(n.sublist(i,s)),e?.encryptedPackets.increment(),yield new be(yl(o.byteLength),o)}}}function CT(r,e){return async function*(t){for await(const n of t)for(let i=0;i<n.length;i+=Xo){let s=i+Xo;if(s>n.length&&(s=n.length),s-Zy<i)throw new Error("Invalid chunk");const o=n.sublist(i,s),a=n.subarray(i,s-Zy);try{const c=r.decrypt(o,a);e?.decryptedPackets.increment(),yield c}catch(c){throw e?.decryptErrors.increment(),c}}}}class IT{protocol="/noise";crypto;prologue;staticKey;extensions;metrics;components;constructor(e,t={}){const{staticNoiseKey:n,extensions:i,crypto:s,prologueBytes:o}=t,{metrics:a}=e;this.components=e;const c=s??hT;this.crypto=fT(c),this.extensions={webtransportCerthashes:[],...i},this.metrics=a?pT(a):void 0,n?this.staticKey=c.generateX25519KeyPairFromSeed(n):this.staticKey=c.generateX25519KeyPair(),this.prologue=o??Pe(0)}[Symbol.toStringTag]="@chainsafe/libp2p-noise";[Zt]=["@libp2p/connection-encryption","@chainsafe/libp2p-noise"];async secureOutbound(e,t){const n=Cs(e,{lengthEncoder:yl,lengthDecoder:Hc,maxDataLength:Xo}),i=await this.performHandshakeInitiator(n,this.components.privateKey,t?.remotePeer?.publicKey,t),s=await this.createSecureConnection(n,i);e.source=s.source,e.sink=s.sink;const o=jn(i.payload.identityKey);return{conn:e,remoteExtensions:i.payload.extensions,remotePeer:Qo(o),streamMuxer:t?.skipStreamMuxerNegotiation===!0?void 0:this.getStreamMuxer(i.payload.extensions?.streamMuxers)}}getStreamMuxer(e){if(e==null||e.length===0)return;const t=this.components.upgrader.getStreamMuxers();if(t!=null)for(const n of e){const i=t.get(n);if(i!=null)return i}if(e.length)throw new l_("Early muxer negotiation was requested but the initiator and responder had no common muxers")}async secureInbound(e,t){const n=Cs(e,{lengthEncoder:yl,lengthDecoder:Hc,maxDataLength:Xo}),i=await this.performHandshakeResponder(n,this.components.privateKey,t?.remotePeer?.publicKey,t),s=await this.createSecureConnection(n,i);e.source=s.source,e.sink=s.sink;const o=jn(i.payload.identityKey);return{conn:e,remoteExtensions:i.payload.extensions,remotePeer:Qo(o),streamMuxer:t?.skipStreamMuxerNegotiation===!0?void 0:this.getStreamMuxer(i.payload.extensions?.streamMuxers)}}async performHandshakeInitiator(e,t,n,i){let s;const o=i?.skipStreamMuxerNegotiation===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{s=await AT({connection:e,privateKey:t,remoteIdentityKey:n,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:o,webtransportCerthashes:[],...this.extensions}},i),this.metrics?.xxHandshakeSuccesses.increment()}catch(a){throw this.metrics?.xxHandshakeErrors.increment(),a}return s}async performHandshakeResponder(e,t,n,i){let s;const o=i?.skipStreamMuxerNegotiation===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{s=await xT({connection:e,privateKey:t,remoteIdentityKey:n,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:o,webtransportCerthashes:[],...this.extensions}},i),this.metrics?.xxHandshakeSuccesses.increment()}catch(a){throw this.metrics?.xxHandshakeErrors.increment(),a}return s}async createSecureConnection(e,t){const[n,i]=Pk(),s=e.unwrap();return await Rg(n,_T(t,this.metrics),s,o=>pl(o,{lengthDecoder:Hc}),CT(t,this.metrics),n),i}}function FS(r={}){return e=>new IT(e,r)}function $S(r){if(r!=null){if(typeof r[Symbol.iterator]=="function")return r[Symbol.iterator]();if(typeof r[Symbol.asyncIterator]=="function")return r[Symbol.asyncIterator]();if(typeof r.next=="function")return r}throw new Error("argument is not an iterator or iterable")}class cs extends Error{static name="InvalidFrameError";constructor(e="The frame was invalid"){super(e),this.name="InvalidFrameError"}}class VS extends Error{static name="UnrequestedPingError";constructor(e="Unrequested ping error"){super(e),this.name="UnrequestedPingError"}}class qS extends Error{static name="NotMatchingPingError";constructor(e="Unrequested ping error"){super(e),this.name="NotMatchingPingError"}}class kT extends Error{static name="InvalidStateError";constructor(e="Invalid state"){super(e),this.name="InvalidStateError"}}class TT extends Error{static name="StreamAlreadyExistsError";constructor(e="Strean already exists"){super(e),this.name="StreamAlreadyExistsError"}}class PT extends Error{static name="DecodeInvalidVersionError";constructor(e="Decode invalid version"){super(e),this.name="DecodeInvalidVersionError"}}class RT extends Error{static name="BothClientsError";constructor(e="Both clients"){super(e),this.name="BothClientsError"}}class jS extends Error{static name="ReceiveWindowExceededError";constructor(e="Receive window exceeded"){super(e),this.name="ReceiveWindowExceededError"}}const OT=new Set([cs.name,VS.name,qS.name,TT.name,PT.name,RT.name,jS.name]),Og=256*1024,BT=16*1024*1024,NT={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:Og,maxStreamWindowSize:BT,maxMessageSize:64*1024};function DT(r){if(r.keepAliveInterval<=0)throw new le("keep-alive interval must be positive");if(r.maxInboundStreams<0)throw new le("max inbound streams must be larger or equal 0");if(r.maxOutboundStreams<0)throw new le("max outbound streams must be larger or equal 0");if(r.initialStreamWindowSize<Og)throw new le("InitialStreamWindowSize must be larger or equal 256 kB");if(r.maxStreamWindowSize<r.initialStreamWindowSize)throw new le("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(r.maxStreamWindowSize>2**32-1)throw new le("MaxStreamWindowSize must be less than equal MAX_UINT32");if(r.maxMessageSize<1024)throw new le("MaxMessageSize must be greater than a kilobyte")}var nt;(function(r){r[r.Data=0]="Data",r[r.WindowUpdate=1]="WindowUpdate",r[r.Ping=2]="Ping",r[r.GoAway=3]="GoAway"})(nt||(nt={}));var Ke;(function(r){r[r.SYN=1]="SYN",r[r.ACK=2]="ACK",r[r.FIN=4]="FIN",r[r.RST=8]="RST"})(Ke||(Ke={}));Object.values(Ke).filter(r=>typeof r!="string");const LT=0;var Nr;(function(r){r[r.NormalTermination=0]="NormalTermination",r[r.ProtocolError=1]="ProtocolError",r[r.InternalError=2]="InternalError"})(Nr||(Nr={}));const Uo=12,Jy=2**24;function MT(r){if(r[0]!==LT)throw new cs("Invalid frame version");return{type:r[1],flag:(r[2]<<8)+r[3],streamID:r[4]*Jy+(r[5]<<16)+(r[6]<<8)+r[7],length:r[8]*Jy+(r[9]<<16)+(r[10]<<8)+r[11]}}class UT{source;buffer;frameInProgress;constructor(e){this.source=FT(e),this.buffer=new be,this.frameInProgress=!1}async*emitFrames(){for await(const e of this.source)for(this.buffer.append(e);;){const t=this.readHeader();if(t===void 0)break;const{type:n,length:i}=t;n===nt.Data?(this.frameInProgress=!0,yield{header:t,readData:this.readBytes.bind(this,i)}):yield{header:t}}}readHeader(){if(this.frameInProgress)throw new kT("decoding frame already in progress");if(this.buffer.length<Uo)return;const e=MT(this.buffer.subarray(0,Uo));return this.buffer.consume(Uo),e}async readBytes(e){if(this.buffer.length<e){for await(const n of this.source)if(this.buffer.append(n),this.buffer.length>=e)break}const t=this.buffer.sublist(0,e);return this.buffer.consume(e),this.frameInProgress=!1,t}}function FT(r){if(r[Symbol.iterator]!==void 0){const e=r[Symbol.iterator]();return e.return=void 0,{[Symbol.iterator](){return e}}}else if(r[Symbol.asyncIterator]!==void 0){const e=r[Symbol.asyncIterator]();return e.return=void 0,{[Symbol.asyncIterator](){return e}}}else throw new Error("a source must be either an iterable or an async iterable")}function ew(r){const e=new Uint8Array(Uo);return e[1]=r.type,e[2]=r.flag>>>8,e[3]=r.flag,e[4]=r.streamID>>>24,e[5]=r.streamID>>>16,e[6]=r.streamID>>>8,e[7]=r.streamID,e[8]=r.length>>>24,e[9]=r.length>>>16,e[10]=r.length>>>8,e[11]=r.length,e}function $T(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}function VT(r,e){const t=$S(r).return?.();$T(t)&&t.catch(n=>{e.error("could not cause iterator to return",n)})}const qT=5e3;function sh(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class zS{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;sendingData;constructor(e){this.sinkController=new AbortController,this.sinkEnd=We(),this.closed=We(),this.log=e.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=e.id,this.metadata=e.metadata??{},this.direction=e.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=e.sendCloseWriteTimeout??qT,this.onEnd=e.onEnd,this.onCloseRead=e.onCloseRead,this.onCloseWrite=e.onCloseWrite,this.onReset=e.onReset,this.onAbort=e.onAbort,this.source=this.streamSource=Ia({onEnd:t=>{t!=null?this.log.trace("source ended with error",t):this.log.trace("source ended"),this.onSourceEnd(t)}}),this.sink=this.sink.bind(this)}async sink(e){if(this.writeStatus!=="ready")throw new Qh(`writable end state is "${this.writeStatus}" not "ready"`);try{this.writeStatus="writing";const t={signal:this.sinkController.signal};if(this.direction==="outbound"){const i=this.sendNewStream(t);sh(i)&&await i}const n=()=>{VT(e,this.log)};try{this.sinkController.signal.addEventListener("abort",n),this.log.trace("sink reading from source");for await(let i of e){i=i instanceof Uint8Array?new be(i):i;const s=this.sendData(i,t);sh(s)&&(this.sendingData=We(),await s,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",n)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),this.writeStatus==="writing"&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(t){throw this.log.trace("sink ended with error, calling abort with error",t),this.abort(t),t}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(e){this.timeline.closeRead==null&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),this.onCloseRead?.(),this.timeline.closeWrite!=null?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(e){this.timeline.closeWrite==null&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),this.onCloseWrite?.(),this.timeline.closeRead!=null?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(e){this.status==="open"&&(this.log.trace("closing gracefully"),this.status="closing",await sr(Promise.all([this.closeWrite(e),this.closeRead(e),this.closed.promise]),e?.signal),this.status="closed",this.log.trace("closed gracefully"))}async closeRead(e={}){if(this.readStatus==="closing"||this.readStatus==="closed")return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);const t=this.readStatus;this.readStatus="closing",this.status!=="reset"&&this.status!=="aborted"&&this.timeline.closeRead==null&&(this.log.trace("send close read to remote"),await this.sendCloseRead(e)),t==="ready"&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(e={}){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),this.writeStatus==="ready"&&(this.log.trace("sink was never sunk, sink an empty array"),await sr(this.sink([]),e.signal)),this.writeStatus==="writing"&&(this.sendingData!=null&&await sr(this.sendingData.promise,e.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await sr(this.sinkEnd.promise,e.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(e){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;this.log("abort with error",e),this.log("try to send reset to remote");const t=this.sendReset();sh(t)&&t.catch(n=>{this.log.error("error sending reset message",n)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(e),this.onAbort?.(e)}reset(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;const e=new d_("stream reset");this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(e),this.onReset?.()}_closeSinkAndSource(e){this._closeSink(e),this._closeSource(e)}_closeSink(e){this.writeStatus==="writing"&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(e)}_closeSource(e){this.readStatus!=="closing"&&this.readStatus!=="closed"&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(e))}remoteCloseWrite(){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("received remote close write but local source is already closed");return}this.log.trace("remote close write"),this._closeSource()}remoteCloseRead(){if(this.writeStatus==="closing"||this.writeStatus==="closed"){this.log("received remote close read but local sink is already closed");return}this.log.trace("remote close read"),this._closeSink()}destroy(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset"){this.log("received destroy but we are already closed");return}this.log.trace("stream destroyed"),this._closeSinkAndSource()}sourcePush(e){this.streamSource.push(e)}sourceReadableLength(){return this.streamSource.readableLength}}function HS(r){const[e,t]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>e.next(),push:i=>{n.push(i)},next:()=>n.length>0?{done:!1,value:n.shift()}:e.next(),[t](){return this}}}function jT(r){return r[Symbol.asyncIterator]!=null}function tw(r){return r?.then!=null}function WS(r,e){let t=0;if(jT(r))return async function*(){for await(const c of r){const l=e(c,t++);tw(l)&&await l,yield c}}();const n=HS(r),{value:i,done:s}=n.next();if(s===!0)return function*(){}();if(typeof e(i,t++)?.then=="function")return async function*(){yield i;for await(const c of n){const l=e(c,t++);tw(l)&&await l,yield c}}();const a=e;return function*(){yield i;for(const c of n)a(c,t++),yield c}()}var Sr;(function(r){r[r.Init=0]="Init",r[r.SYNSent=1]="SYNSent",r[r.SYNReceived=2]="SYNReceived",r[r.Established=3]="Established",r[r.Finished=4]="Finished"})(Sr||(Sr={}));class zT extends zS{name;state;config;_id;sendWindowCapacity;sendWindowCapacityUpdate;recvWindow;recvWindowCapacity;epochStart;getRTT;sendFrame;constructor(e){super({...e,onEnd:t=>{this.state=Sr.Finished,e.onEnd?.(t)}}),this.config=e.config,this._id=parseInt(e.id,10),this.name=e.name,this.state=e.state,this.sendWindowCapacity=Og,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=e.getRTT,this.sendFrame=e.sendFrame,this.source=WS(this.source,()=>{this.sendWindowUpdate()})}async sendNewStream(){}async sendData(e,t={}){for(e=e.sublist();e.byteLength!==0;){if(this.sendWindowCapacity===0&&(this.log?.trace("wait for send window capacity, status %s",this.status),await this.waitForSendWindowCapacity(t),this.status==="closed"||this.status==="aborted"||this.status==="reset")){this.log?.trace("%s while waiting for send window capacity",this.status);return}const n=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-Uo,e.length),i=this.getSendFlags();this.sendFrame({type:nt.Data,flag:i,streamID:this._id,length:n},e.sublist(0,n)),this.sendWindowCapacity-=n,e.consume(n)}}async sendReset(){this.sendFrame({type:nt.WindowUpdate,flag:Ke.RST,streamID:this._id,length:0})}async sendCloseWrite(){const e=this.getSendFlags()|Ke.FIN;this.sendFrame({type:nt.WindowUpdate,flag:e,streamID:this._id,length:0})}async sendCloseRead(){}async waitForSendWindowCapacity(e={}){if(this.sendWindowCapacity>0)return;let t,n;const i=()=>{this.status==="open"||this.status==="closing"?n(new Ii("Stream aborted")):t()};e.signal?.addEventListener("abort",i);try{await new Promise((s,o)=>{this.sendWindowCapacityUpdate=()=>{s()},n=o,t=s})}finally{e.signal?.removeEventListener("abort",i)}}handleWindowUpdate(e){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(e.flag);const t=this.sendWindowCapacity;this.sendWindowCapacity+=e.length,t===0&&e.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(e,t){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(e.flag),this.recvWindowCapacity<e.length)throw new jS("Receive window exceeded");const n=await t();this.recvWindowCapacity-=e.length,this.sourcePush(n)}processFlags(e){(e&Ke.ACK)===Ke.ACK&&this.state===Sr.SYNSent&&(this.state=Sr.Established),(e&Ke.FIN)===Ke.FIN&&this.remoteCloseWrite(),(e&Ke.RST)===Ke.RST&&this.reset()}getSendFlags(){switch(this.state){case Sr.Init:return this.state=Sr.SYNSent,Ke.SYN;case Sr.SYNReceived:return this.state=Sr.Established,Ke.ACK;default:return 0}}sendWindowUpdate(){const e=this.getSendFlags(),t=Date.now(),n=this.getRTT();if(e===0&&n>-1&&t-this.epochStart<n*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&e===0)return;const i=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=t,this.sendFrame({type:nt.WindowUpdate,flag:e,streamID:this._id,length:i})}}const KS="/yamux/1.0.0",HT=500;class WT{protocol=KS;_components;_init;constructor(e,t={}){this._components=e,this._init=t}[Symbol.toStringTag]="@chainsafe/libp2p-yamux";[Zt]=["@libp2p/stream-multiplexing"];createStreamMuxer(e){return new KT(this._components,{...this._init,...e})}}class KT{protocol=KS;source;sink;config;log;logger;closeController;nextStreamID;_streams;nextPingID;activePing;rtt;client;localGoAway;remoteGoAway;numInboundStreams;numOutboundStreams;onIncomingStream;onStreamEnd;constructor(e,t){this.client=t.direction==="outbound",this.config={...NT,...t},this.logger=e.logger,this.log=this.logger.forComponent("libp2p:yamux"),DT(this.config),this.closeController=new AbortController,this.closeController.signal,this.onIncomingStream=t.onIncomingStream,this.onStreamEnd=t.onStreamEnd,this._streams=new Map,this.source=Ia({onEnd:()=>{this.log?.trace("muxer source ended"),this._streams.forEach(n=>{n.destroy()})}}),this.sink=async n=>{const i=()=>{const a=$S(n);if(a.return!=null){const c=a.return();GT(c)&&c.catch(l=>{this.log?.("could not cause sink source to return",l)})}};let s,o;try{const a=new UT(n);try{this.closeController.signal.addEventListener("abort",i);for await(const c of a.emitFrames())await this.handleFrame(c.header,c.readData)}finally{this.closeController.signal.removeEventListener("abort",i)}s=Nr.NormalTermination}catch(a){OT.has(a.name)?(this.log?.error("protocol error in sink",a),s=Nr.ProtocolError):(this.log?.error("internal error in sink",a),s=Nr.InternalError),o=a}this.log?.trace("muxer sink ended"),o!=null?this.abort(o,s):await this.close({reason:s})},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(n=>this.log?.error("keepalive error: %s",n)),this.ping().catch(n=>this.log?.error("ping error: %s",n))}get streams(){return Array.from(this._streams.values())}newStream(e){if(this.remoteGoAway!==void 0)throw new vo("Muxer closed remotely");if(this.localGoAway!==void 0)throw new vo("Muxer closed locally");const t=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new Sv("max outbound streams exceeded");this.log?.trace("new outgoing stream id=%s",t);const n=this._newStream(t,e,Sr.Init,"outbound");return this._streams.set(t,n),this.numOutboundStreams++,n.sendWindowUpdate(),n}async ping(){if(this.remoteGoAway!==void 0)throw new vo("Muxer closed remotely");if(this.localGoAway!==void 0)throw new vo("Muxer closed locally");if(this.activePing===void 0){let e=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((i,s)=>{const o=()=>{s(new vo("Muxer closed locally"))};this.closeController.signal.addEventListener("abort",o,{once:!0}),e=()=>{this.closeController.signal.removeEventListener("abort",o),i()}}),resolve:e};const t=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}const n=Date.now();this.rtt=n-t}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}async close(e={}){if(this.closeController.signal.aborted)return;const t=e?.reason??Nr.NormalTermination;if(this.log?.trace("muxer close reason=%s",t),e.signal==null){const n=AbortSignal.timeout(HT);e={...e,signal:n}}try{await Promise.all([...this._streams.values()].map(async n=>n.close(e))),this.sendGoAway(t),this._closeMuxer()}catch(n){this.abort(n)}}abort(e,t){if(!this.closeController.signal.aborted){t=t??Nr.InternalError,this.log?.error("muxer abort reason=%s error=%s",t,e);for(const n of this._streams.values())n.abort(e);this.sendGoAway(t),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(e,t,n,i){if(this._streams.get(e)!=null)throw new le("Stream already exists with that id");const s=new zT({id:e.toString(),name:t,state:n,direction:i,sendFrame:this.sendFrame.bind(this),onEnd:()=>{this.closeStream(e),this.onStreamEnd?.(s)},log:this.logger.forComponent(`libp2p:yamux:${i}:${e}`),config:this.config,getRTT:this.getRTT.bind(this)});return s}closeStream(e){this.client===(e%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(e)}async keepAliveLoop(){const e=new Promise((t,n)=>{this.closeController.signal.addEventListener("abort",n,{once:!0})});for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let t;try{await Promise.race([e,new Promise(n=>{t=setTimeout(n,this.config.keepAliveInterval)})]),this.ping().catch(n=>this.log?.error("ping error: %s",n))}catch{clearInterval(t);return}}}async handleFrame(e,t){const{streamID:n,type:i,length:s}=e;if(this.log?.trace("received frame %o",e),n===0)switch(i){case nt.Ping:{this.handlePing(e);return}case nt.GoAway:{this.handleGoAway(s);return}default:throw new cs("Invalid frame type")}else switch(e.type){case nt.Data:case nt.WindowUpdate:{await this.handleStreamMessage(e,t);return}default:throw new cs("Invalid frame type")}}handlePing(e){if(e.flag===Ke.SYN)this.log?.trace("received ping request pingId=%s",e.length),this.sendPing(e.length,Ke.ACK);else if(e.flag===Ke.ACK)this.log?.trace("received ping response pingId=%s",e.length),this.handlePingResponse(e.length);else throw new cs("Invalid frame flag")}handlePingResponse(e){if(this.activePing===void 0)throw new VS("ping not requested");if(this.activePing.id!==e)throw new qS("ping doesn't match our id");this.activePing.resolve()}handleGoAway(e){this.log?.trace("received GoAway reason=%s",Nr[e]??"unknown"),this.remoteGoAway=e;for(const t of this._streams.values())t.reset();this._closeMuxer()}async handleStreamMessage(e,t){const{streamID:n,flag:i,type:s}=e;(i&Ke.SYN)===Ke.SYN&&this.incomingStream(n);const o=this._streams.get(n);if(o===void 0){if(s===nt.Data){if(this.log?.("discarding data for stream id=%s",n),t===void 0)throw new Error("unreachable");await t()}else this.log?.trace("frame for missing stream id=%s",n);return}switch(s){case nt.WindowUpdate:{o.handleWindowUpdate(e);return}case nt.Data:{if(t===void 0)throw new Error("unreachable");await o.handleData(e,t);return}default:throw new Error("unreachable")}}incomingStream(e){if(this.client!==(e%2===0))throw new le("Both endpoints are clients");if(this._streams.has(e))return;if(this.log?.trace("new incoming stream id=%s",e),this.localGoAway!==void 0){this.sendFrame({type:nt.WindowUpdate,flag:Ke.RST,streamID:e,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){this.log?.("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:nt.WindowUpdate,flag:Ke.RST,streamID:e,length:0});return}const t=this._newStream(e,void 0,Sr.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(e,t),this.onIncomingStream?.(t)}sendFrame(e,t){if(this.log?.trace("sending frame %o",e),e.type===nt.Data){if(t===void 0)throw new cs("Invalid frame");this.source.push(new be(ew(e),t))}else this.source.push(ew(e))}sendPing(e,t=Ke.SYN){t===Ke.SYN?this.log?.trace("sending ping request pingId=%s",e):this.log?.trace("sending ping response pingId=%s",e),this.sendFrame({type:nt.Ping,flag:t,streamID:0,length:e})}sendGoAway(e=Nr.NormalTermination){this.log?.("sending GoAway reason=%s",Nr[e]),this.localGoAway=e,this.sendFrame({type:nt.GoAway,flag:0,streamID:0,length:e})}}function GT(r){return r!=null&&typeof r.then=="function"}function YT(r={}){return e=>new WT(e,r)}var vl;(function(r){let e;r.codec=()=>(e==null&&(e=De((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&t.payload.byteLength>0&&(n.uint32(26),n.bytes(t.payload)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={publicKey:Pe(0),payloadType:Pe(0),payload:Pe(0),signature:Pe(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.publicKey=t.bytes();break}case 2:{s.payloadType=t.bytes();break}case 3:{s.payload=t.bytes();break}case 5:{s.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ne(t,r.codec()),r.decode=(t,n)=>Be(t,r.codec(),n)})(vl||(vl={}));class QT extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}}class Ur{static createFromProtobuf=async e=>{const t=vl.decode(e),n=jn(t.publicKey);return new Ur({publicKey:n,payloadType:t.payloadType,payload:t.payload,signature:t.signature})};static seal=async(e,t)=>{if(t==null)throw new Error("Missing private key");const n=e.domain,i=e.codec,s=e.marshal(),o=rw(n,i,s),a=await t.sign(o.subarray());return new Ur({publicKey:t.publicKey,payloadType:i,payload:s,signature:a})};static openAndCertify=async(e,t)=>{const n=await Ur.createFromProtobuf(e);if(!await n.validate(t))throw new QT("Envelope signature is not valid for the given domain");return n};publicKey;payloadType;payload;signature;marshaled;constructor(e){const{publicKey:t,payloadType:n,payload:i,signature:s}=e;this.publicKey=t,this.payloadType=n,this.payload=i,this.signature=s}marshal(){return this.marshaled==null&&(this.marshaled=vl.encode({publicKey:nn(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return e==null?!1:et(this.marshal(),e.marshal())}async validate(e){const t=rw(e,this.payloadType,this.payload);return this.publicKey.verify(t.subarray(),this.signature)}}const rw=(r,e,t)=>{const n=oe(r),i=gs(n.byteLength),s=gs(e.length),o=gs(t.length);return new be(i,n,s,e,o,t)};function XT(r,e){const t=(n,i)=>n.toString().localeCompare(i.toString());return r.length!==e.length?!1:(e.sort(t),r.sort(t).every((n,i)=>e[i].equals(n)))}class or extends Error{static name="InvalidMultiaddrError";name="InvalidMultiaddrError"}class Zo extends Error{static name="ValidationError";name="ValidationError"}class ZT extends Error{static name="InvalidParametersError";name="InvalidParametersError"}class JT extends Error{static name="InvalidProtocolError";name="InvalidProtocolError"}class eP{index=0;input="";new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,n=e();return n===void 0&&(this.index=t),n}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{const t=this.readChar();if(t===e)return t})}readSeparator(e,t,n){return this.readAtomically(()=>{if(!(t>0&&this.readGivenChar(e)===void 0))return n()})}readNumber(e,t,n,i){return this.readAtomically(()=>{let s=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",l=2**(8*i)-1;for(;;){const u=this.readAtomically(()=>{const d=this.readChar();if(d===void 0)return;const f=Number.parseInt(d,e);if(!Number.isNaN(f))return f});if(u===void 0)break;if(s*=e,s+=u,s>l||(o+=1,t!==void 0&&o>t))return}if(o!==0)return!n&&c&&o>1?void 0:s})}readIPv4Addr(){return this.readAtomically(()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const n=this.readSeparator(".",t,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;e[t]=n}return e})}readIPv6Addr(){const e=t=>{for(let n=0;n<t.length/2;n++){const i=n*2;if(n<t.length-3){const o=this.readSeparator(":",n,()=>this.readIPv4Addr());if(o!==void 0)return t[i]=o[0],t[i+1]=o[1],t[i+2]=o[2],t[i+3]=o[3],[i+4,!0]}const s=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(s===void 0)return[i,!1];t[i]=s>>8,t[i+1]=s&255}return[t.length,!1]};return this.readAtomically(()=>{const t=new Uint8Array(16),[n,i]=e(t);if(n===16)return t;if(i||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const s=new Uint8Array(14),o=16-(n+2),[a]=e(s.subarray(0,o));return t.set(s.subarray(0,a),16-a),t})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const GS=45,tP=15,ks=new eP;function YS(r){if(!(r.length>tP))return ks.new(r).parseWith(()=>ks.readIPv4Addr())}function QS(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>GS))return ks.new(r).parseWith(()=>ks.readIPv6Addr())}function gf(r,e=!1){if(r.includes("%")&&(r=r.split("%")[0]),r.length>GS)return;const t=ks.new(r).parseWith(()=>ks.readIPAddr());if(t)return e&&t.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,t[0],t[1],t[2],t[3]]):t}function Pi(r){return!!YS(r)}function Bg(r){return!!QS(r)}const Ts=4,mf=6,yf=273,rP=33,Un=41,Ta=42,nP=43,Ng=53,Dg=54,Nu=55,Lg=56,iP=132,sP=301,oP=302,aP=400,XS=421,cP=444,lP=445,uP=446,dP=447,hP=448,fP=449,pP=454,gP=460,mP=461,yP=465,wP=466,bP=480,vP=481,SP=443,EP=477,AP=478,xP=479,_P=277,CP=275,IP=276,kP=280,TP=281,ZS=290,PP=777;function nw(r){return e=>ge(e,r)}function iw(r){return e=>oe(e,r)}function To(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function ls(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(e)}function RP(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=oe(e[0],"base32"),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=ls(n);return cn([t,i],t.length+i.length)}function OP(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=Dn.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const i=ls(n);return cn([t,i],t.length+i.length)}function sw(r){const e=r.subarray(0,r.length-2),t=r.subarray(r.length-2),n=ge(e,"base32"),i=To(t);return`${n}:${i}`}const JS=function(r){r=r.toString().trim();const e=new Uint8Array(4);return r.split(/\./g).forEach((t,n)=>{const i=parseInt(t,10);if(isNaN(i)||i<0||i>255)throw new or("Invalid byte value in IP address");e[n]=i}),e},BP=function(r){let e=0;r=r.toString().trim();const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const s=Pi(t[n]);let o;s&&(o=JS(t[n]),t[n]=ge(o.subarray(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,ge(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const s=[n,1];for(n=9-t.length;n>0;n--)s.push("0");t.splice.apply(t,s)}const i=new Uint8Array(e+16);for(n=0;n<t.length;n++){t[n]===""&&(t[n]="0");const s=parseInt(t[n],16);if(isNaN(s)||s<0||s>65535)throw new or("Invalid byte value in IP address");i[e++]=s>>8&255,i[e++]=s&255}return i},NP=function(r){if(r.byteLength!==4)throw new or("IPv4 address was incorrect length");const e=[];for(let t=0;t<r.byteLength;t++)e.push(r[t]);return e.join(".")},DP=function(r){if(r.byteLength!==16)throw new or("IPv6 address was incorrect length");const e=[];for(let n=0;n<r.byteLength;n+=2){const i=r[n],s=r[n+1],o=`${i.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const n=new URL(`http://[${t}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new or(`Invalid IPv6 address "${t}"`)}};function LP(r){try{const e=new URL(`http://[${r}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new or(`Invalid IPv6 address "${r}"`)}}const oh=Object.values(sl).map(r=>r.decoder),MP=function(){let r=oh[0].or(oh[1]);return oh.slice(2).forEach(e=>r=r.or(e)),r}();function UP(r){return MP.decode(r)}function FP(r){return e=>r.encoder.encode(e)}function $P(r){if(parseInt(r).toString()!==r)throw new Zo("Value must be an integer")}function VP(r){if(r<0)throw new Zo("Value must be a positive integer, or zero")}function qP(r){return e=>{if(e>r)throw new Zo(`Value must be smaller than or equal to ${r}`)}}function jP(...r){return e=>{for(const t of r)t(e)}}const mc=jP($P,VP,qP(65535)),wt=-1;let zP=class{protocolsByCode=new Map;protocolsByName=new Map;getCodec(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new JT(`Protocol ${e} was unknown`);return t}addCodec(e,t,n){this.protocolsByCode.set(e,t),this.protocolsByName.set(t.name,t),n?.forEach(i=>{this.protocolsByName.set(i,t)})}deleteCodec(e){const t=this.getCodec(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),t.aliases?.forEach(n=>{this.protocolsByName.delete(n)}))}};const Fr=new zP,HP=[{code:Ts,name:"ip4",size:32,valueToBytes:JS,bytesToValue:NP,validate:r=>{if(!Pi(r))throw new Zo(`Invalid IPv4 address "${r}"`)}},{code:mf,name:"tcp",size:16,valueToBytes:ls,bytesToValue:To,validate:mc},{code:yf,name:"udp",size:16,valueToBytes:ls,bytesToValue:To,validate:mc},{code:rP,name:"dccp",size:16,valueToBytes:ls,bytesToValue:To,validate:mc},{code:Un,name:"ip6",size:128,valueToBytes:BP,bytesToValue:DP,stringToValue:LP,validate:r=>{if(!Bg(r))throw new Zo(`Invalid IPv6 address "${r}"`)}},{code:Ta,name:"ip6zone",size:wt},{code:nP,name:"ipcidr",size:8,bytesToValue:nw("base10"),valueToBytes:iw("base10")},{code:Ng,name:"dns",size:wt,resolvable:!0},{code:Dg,name:"dns4",size:wt,resolvable:!0},{code:Nu,name:"dns6",size:wt,resolvable:!0},{code:Lg,name:"dnsaddr",size:wt,resolvable:!0},{code:iP,name:"sctp",size:16,valueToBytes:ls,bytesToValue:To,validate:mc},{code:sP,name:"udt"},{code:oP,name:"utp"},{code:aP,name:"unix",size:wt,path:!0,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:XS,name:"p2p",aliases:["ipfs"],size:wt,bytesToValue:nw("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?iw("base58btc")(r):Le.parse(r).multihash.bytes},{code:cP,name:"onion",size:96,bytesToValue:sw,valueToBytes:RP},{code:lP,name:"onion3",size:296,bytesToValue:sw,valueToBytes:OP},{code:uP,name:"garlic64",size:wt},{code:dP,name:"garlic32",size:wt},{code:hP,name:"tls"},{code:fP,name:"sni",size:wt},{code:pP,name:"noise"},{code:gP,name:"quic"},{code:mP,name:"quic-v1"},{code:yP,name:"webtransport"},{code:wP,name:"certhash",size:wt,bytesToValue:FP(va),valueToBytes:UP},{code:bP,name:"http"},{code:vP,name:"http-path",size:wt,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:SP,name:"https"},{code:EP,name:"ws"},{code:AP,name:"wss"},{code:xP,name:"p2p-websocket-star"},{code:_P,name:"p2p-stardust"},{code:CP,name:"p2p-webrtc-star"},{code:IP,name:"p2p-webrtc-direct"},{code:kP,name:"webrtc-direct"},{code:TP,name:"webrtc"},{code:ZS,name:"p2p-circuit"},{code:PP,name:"memory",size:wt}];HP.forEach(r=>{Fr.addCodec(r.code,r,r.aliases)});function WP(r){const e=[];let t=0;for(;t<r.length;){const n=Ru(r,t),i=Fr.getCodec(n),s=_t(n),o=QP(i,r,t+s);let a=0;o>0&&i.size===wt&&(a=_t(o));const c=s+a+o,l={code:n,name:i.name,bytes:r.subarray(t,t+c)};if(o>0){const u=t+s+a,d=r.subarray(u,u+o);l.value=i.bytesToValue?.(d)??ge(d)}e.push(l),t+=c}return e}function KP(r){let e=0;const t=[];for(const n of r){if(n.bytes==null){const i=Fr.getCodec(n.code),s=_t(n.code);let o,a=0,c=0;n.value!=null&&(o=i.valueToBytes?.(n.value)??oe(n.value),a=o.byteLength,i.size===wt&&(c=_t(a)));const l=new Uint8Array(s+c+a);let u=0;dl(n.code,l,u),u+=s,o!=null&&(i.size===wt&&(dl(a,l,u),u+=c),l.set(o,u)),n.bytes=l}t.push(n.bytes),e+=n.bytes.byteLength}return cn(t,e)}function GP(r){if(r.charAt(0)!=="/")throw new or('String multiaddr must start with "/"');const e=[];let t="protocol",n="",i="";for(let s=1;s<r.length;s++){const o=r.charAt(s);o!=="/"&&(t==="protocol"?i+=r.charAt(s):n+=r.charAt(s));const a=s===r.length-1;if(o==="/"||a){const c=Fr.getCodec(i);if(t==="protocol"){if(c.size==null||c.size===0){e.push({code:c.code,name:c.name}),n="",i="",t="protocol";continue}else if(a)throw new or(`Component ${i} was missing value`);t="value"}else if(t==="value"){const l={code:c.code,name:c.name};if(c.size!=null&&c.size!==0){if(n==="")throw new or(`Component ${i} was missing value`);l.value=c.stringToValue?.(n)??n}e.push(l),n="",i="",t="protocol"}}}if(i!==""&&n!=="")throw new or("Incomplete multiaddr");return e}function YP(r){return`/${r.flatMap(e=>{if(e.value==null)return e.name;const t=Fr.getCodec(e.code);if(t==null)throw new or(`Unknown protocol code ${e.code}`);return[e.name,t.valueToString?.(e.value)??e.value]}).join("/")}`}function QP(r,e,t){return r.size==null||r.size===0?0:r.size>0?r.size/8:Ru(e,t)}const XP=Symbol.for("nodejs.util.inspect.custom"),eE=Symbol.for("@multiformats/multiaddr"),ZP=[Ng,Dg,Nu,Lg];class JP extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}}function eR(r){if(r==null&&(r="/"),Du(r))return r.getComponents();if(r instanceof Uint8Array)return WP(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),GP(r);if(Array.isArray(r))return r;throw new or("Must be a string, Uint8Array, Component[], or another Multiaddr")}class us{[eE]=!0;#e;#r;#t;constructor(e="/",t={}){this.#e=eR(e),t.validate!==!1&&tR(this)}get bytes(){return this.#t==null&&(this.#t=KP(this.#e)),this.#t}toString(){return this.#r==null&&(this.#r=YP(this.#e)),this.#r}toJSON(){return this.toString()}toOptions(){let e,t,n,i,s="";for(const{code:a,name:c,value:l}of this.#e)a===Ta&&(s=`%${l??""}`),ZP.includes(a)&&(t="tcp",i=443,n=`${l??""}${s}`,e=a===Nu?6:4),(a===mf||a===yf)&&(t=c==="tcp"?"tcp":"udp",i=parseInt(l??"")),(a===Ts||a===Un)&&(t="tcp",n=`${l??""}${s}`,e=a===Un?6:4);if(e==null||t==null||n==null||i==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:n,transport:t,port:i}}getComponents(){return[...this.#e]}protos(){return this.#e.map(({code:e,value:t})=>{const n=Fr.getCodec(e);return{code:e,size:n.size??0,name:n.name,resolvable:!!n.resolvable,path:!!n.path}})}protoCodes(){return this.#e.map(({code:e})=>e)}protoNames(){return this.#e.map(({name:e})=>e)}tuples(){return this.#e.map(({code:e,value:t})=>{if(t==null)return[e];const n=Fr.getCodec(e),i=[e];return t!=null&&i.push(n.valueToBytes?.(t)??oe(t)),i})}stringTuples(){return this.#e.map(({code:e,value:t})=>t==null?[e]:[e,t])}encapsulate(e){const t=new us(e);return new us([...this.#e,...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),n=this.toString(),i=n.lastIndexOf(t);if(i<0)throw new ZT(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new us(n.slice(0,i),{validate:!1})}decapsulateCode(e){let t;for(let n=this.#e.length-1;n>-1;n--)if(this.#e[n].code===e){t=n;break}return new us(this.#e.slice(0,t),{validate:!1})}getPeerId(){try{let e=[];this.#e.forEach(({code:n,value:i})=>{n===XS&&e.push([n,i]),n===ZS&&(e=[])});const t=e.pop();if(t?.[1]!=null){const n=t[1];return n[0]==="Q"||n[0]==="1"?ge(Je.decode(`z${n}`),"base58btc"):ge(Le.parse(n).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){for(const e of this.#e)if(Fr.getCodec(e.code).path)return e.value??null;return null}equals(e){return et(this.bytes,e.bytes)}async resolve(e){const t=this.protos().find(s=>s.resolvable);if(t==null)return[this];const n=Mg.get(t.name);if(n==null)throw new JP(`no available resolver for ${t.name}`);return(await n(this,e)).map(s=>he(s))}nodeAddress(){const e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(){return!(this.#e.length!==2||this.#e[0].code!==Ts&&this.#e[0].code!==Un||this.#e[1].code!==mf&&this.#e[1].code!==yf)}[XP](){return`Multiaddr(${this.toString()})`}}function tR(r){r.getComponents().forEach(e=>{const t=Fr.getCodec(e.code);e.value!=null&&t.validate?.(e.value)})}function rR(r,e,t){let n=0;for(const i of r)if(!(n<e)){if(n>t)break;if(i!==255)return!1;n++}return!0}function nR(r,e,t,n){let i=0;for(const s of r)if(!(i<t)){if(i>n)break;if(s!==e[i])return!1;i++}return!0}function iR(r){switch(r.length){case Jo:return r.join(".");case ea:{const e=[];for(let t=0;t<r.length;t++)t%2===0&&e.push(r[t].toString(16).padStart(2,"0")+r[t+1].toString(16).padStart(2,"0"));return e.join(":")}default:throw new Error("Invalid ip length")}}function sR(r){let e=0;for(let[t,n]of r.entries()){if(n===255){e+=8;continue}for(;(n&128)!=0;)e++,n=n<<1;if((n&128)!=0)return-1;for(let i=t+1;i<r.length;i++)if(r[i]!=0)return-1;break}return e}function oR(r){let e="0x";for(const t of r)e+=(t>>4).toString(16)+(t&15).toString(16);return e}const Jo=4,ea=16,aR=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function tE(r,e){e.length===ea&&r.length===Jo&&rR(e,0,11)&&(e=e.slice(12)),e.length===Jo&&r.length===ea&&nR(r,aR,0,11)&&(r=r.slice(12));const t=r.length;if(t!=e.length)throw new Error("Failed to mask ip");const n=new Uint8Array(t);for(let i=0;i<t;i++)n[i]=r[i]&e[i];return n}function cR(r,e){if(typeof e=="string"&&(e=gf(e)),e==null)throw new Error("Invalid ip");if(e.length!==r.network.length)return!1;for(let t=0;t<e.length;t++)if((r.network[t]&r.mask[t])!==(e[t]&r.mask[t]))return!1;return!0}function lR(r){const[e,t]=r.split("/");if(!e||!t)throw new Error("Failed to parse given CIDR: "+r);let n=Jo,i=YS(e);if(i==null&&(n=ea,i=QS(e),i==null))throw new Error("Failed to parse given CIDR: "+r);const s=parseInt(t,10);if(Number.isNaN(s)||String(s).length!==t.length||s<0||s>n*8)throw new Error("Failed to parse given CIDR: "+r);const o=rE(s,8*n);return{network:tE(i,o),mask:o}}function rE(r,e){if(e!==8*Jo&&e!==8*ea)throw new Error("Invalid CIDR mask");if(r<0||r>e)throw new Error("Invalid CIDR mask");const t=e/8,n=new Uint8Array(t);for(let i=0;i<t;i++){if(r>=8){n[i]=255,r-=8;continue}n[i]=255-(255>>r),r=0}return n}class nE{constructor(e,t){if(t==null)({network:this.network,mask:this.mask}=lR(e));else{const n=gf(e);if(n==null)throw new Error("Failed to parse network");t=String(t);const i=parseInt(t,10);if(Number.isNaN(i)||String(i).length!==t.length||i<0||i>n.length*8){const s=gf(t);if(s==null)throw new Error("Failed to parse mask");this.mask=s}else this.mask=rE(i,8*n.length);this.network=tE(n,this.mask)}}contains(e){return cR({network:this.network,mask:this.mask},e)}toString(){const e=sR(this.mask),t=e!==-1?String(e):oR(this.mask);return iR(this.network)+"/"+t}}function uR(r,e){return new nE(r).contains(e)}function dR(r){let e,t;if(r.getComponents().forEach(n=>{(n.name==="ip4"||n.name==="ip6")&&(t=n.value),n.name==="ipcidr"&&(e=n.value)}),e==null||t==null)throw new Error("Invalid multiaddr");return new nE(t,e)}const Mg=new Map;function Du(r){return!!r?.[eE]}function he(r){return new us(r)}function xt(r){const e=Fr.getCodec(r);return{code:e.code,size:e.size??0,name:e.name,resolvable:!!e.resolvable,path:!!e.path}}const hR="libp2p-peer-record",fR=Uint8Array.from([3,1]);var Sl;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=De((i,s,o={})=>{o.lengthDelimited!==!1&&s.fork(),i.multiaddr!=null&&i.multiaddr.byteLength>0&&(s.uint32(10),s.bytes(i.multiaddr)),o.lengthDelimited!==!1&&s.ldelim()},(i,s,o={})=>{const a={multiaddr:Pe(0)},c=s==null?i.len:i.pos+s;for(;i.pos<c;){const l=i.uint32();switch(l>>>3){case 1:{a.multiaddr=i.bytes();break}default:{i.skipType(l&7);break}}}return a})),n),t.encode=i=>Ne(i,t.codec()),t.decode=(i,s)=>Be(i,t.codec(),s)})(r.AddressInfo||(r.AddressInfo={}));let e;r.codec=()=>(e==null&&(e=De((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.peerId!=null&&t.peerId.byteLength>0&&(n.uint32(10),n.bytes(t.peerId)),t.seq!=null&&t.seq!==0n&&(n.uint32(16),n.uint64(t.seq)),t.addresses!=null)for(const s of t.addresses)n.uint32(26),r.AddressInfo.codec().encode(s,n);i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={peerId:Pe(0),seq:0n,addresses:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.peerId=t.bytes();break}case 2:{s.seq=t.uint64();break}case 3:{if(i.limits?.addresses!=null&&s.addresses.length===i.limits.addresses)throw new Cr('Decode error - map field "addresses" had too many elements');s.addresses.push(r.AddressInfo.codec().decode(t,t.uint32(),{limits:i.limits?.addresses$}));break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ne(t,r.codec()),r.decode=(t,n)=>Be(t,r.codec(),n)})(Sl||(Sl={}));class Xt{static createFromProtobuf=e=>{const t=Sl.decode(e),n=ro(Qn(t.peerId)),i=(t.addresses??[]).map(o=>he(o.multiaddr)),s=t.seq;return new Xt({peerId:n,multiaddrs:i,seqNumber:s})};static DOMAIN=hR;static CODEC=fR;peerId;multiaddrs;seqNumber;domain=Xt.DOMAIN;codec=Xt.CODEC;marshaled;constructor(e){const{peerId:t,multiaddrs:n,seqNumber:i}=e;this.peerId=t,this.multiaddrs=n??[],this.seqNumber=i??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=Sl.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(e=>({multiaddr:e.bytes}))})),this.marshaled}equals(e){return!(!(e instanceof Xt)||!this.peerId.equals(e.peerId)||this.seqNumber!==e.seqNumber||!XT(this.multiaddrs,e.multiaddrs))}}function Jt(r,e){const t=Cs(r,e),n={read:async(i,s)=>{const o=await t.read(s);return i.decode(o)},write:async(i,s,o)=>{await t.write(s.encode(i),o)},writeV:async(i,s,o)=>{await t.writeV(i.map(a=>s.encode(a)),o)},pb:i=>({read:async s=>n.read(i,s),write:async(s,o)=>n.write(s,i,o),writeV:async(s,o)=>n.writeV(s,i,o),unwrap:()=>n}),unwrap:()=>t.unwrap()};return n}const pR=290,gR=1,iE=2e3,mR=100,yc=`${og}-circuit-relay`;BigInt(1<<17);const El="/libp2p/circuit/relay/0.2.0/hop",ow="/libp2p/circuit/relay/0.2.0/stop",aw=300,yR=4096,wR=.001;var Ps;(function(r){(function(n){n.RESERVE="RESERVE",n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let e;(function(n){n[n.RESERVE=0]="RESERVE",n[n.CONNECT=1]="CONNECT",n[n.STATUS=2]="STATUS"})(e||(e={})),function(n){n.codec=()=>ln(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=De((n,i,s={})=>{s.lengthDelimited!==!1&&i.fork(),n.type!=null&&(i.uint32(8),r.Type.codec().encode(n.type,i)),n.peer!=null&&(i.uint32(18),Rs.codec().encode(n.peer,i)),n.reservation!=null&&(i.uint32(26),Al.codec().encode(n.reservation,i)),n.limit!=null&&(i.uint32(34),Os.codec().encode(n.limit,i)),n.status!=null&&(i.uint32(40),Pt.codec().encode(n.status,i)),s.lengthDelimited!==!1&&i.ldelim()},(n,i,s={})=>{const o={},a=i==null?n.len:n.pos+i;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=Rs.codec().decode(n,n.uint32(),{limits:s.limits?.peer});break}case 3:{o.reservation=Al.codec().decode(n,n.uint32(),{limits:s.limits?.reservation});break}case 4:{o.limit=Os.codec().decode(n,n.uint32(),{limits:s.limits?.limit});break}case 5:{o.status=Pt.codec().decode(n);break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>Ne(n,r.codec()),r.decode=(n,i)=>Be(n,r.codec(),i)})(Ps||(Ps={}));var Xr;(function(r){(function(n){n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let e;(function(n){n[n.CONNECT=0]="CONNECT",n[n.STATUS=1]="STATUS"})(e||(e={})),function(n){n.codec=()=>ln(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=De((n,i,s={})=>{s.lengthDelimited!==!1&&i.fork(),n.type!=null&&(i.uint32(8),r.Type.codec().encode(n.type,i)),n.peer!=null&&(i.uint32(18),Rs.codec().encode(n.peer,i)),n.limit!=null&&(i.uint32(26),Os.codec().encode(n.limit,i)),n.status!=null&&(i.uint32(32),Pt.codec().encode(n.status,i)),s.lengthDelimited!==!1&&i.ldelim()},(n,i,s={})=>{const o={},a=i==null?n.len:n.pos+i;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=Rs.codec().decode(n,n.uint32(),{limits:s.limits?.peer});break}case 3:{o.limit=Os.codec().decode(n,n.uint32(),{limits:s.limits?.limit});break}case 4:{o.status=Pt.codec().decode(n);break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>Ne(n,r.codec()),r.decode=(n,i)=>Be(n,r.codec(),i)})(Xr||(Xr={}));var Rs;(function(r){let e;r.codec=()=>(e==null&&(e=De((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.id!=null&&t.id.byteLength>0&&(n.uint32(10),n.bytes(t.id)),t.addrs!=null)for(const s of t.addrs)n.uint32(18),n.bytes(s);i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={id:Pe(0),addrs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.id=t.bytes();break}case 2:{if(i.limits?.addrs!=null&&s.addrs.length===i.limits.addrs)throw new Cr('Decode error - map field "addrs" had too many elements');s.addrs.push(t.bytes());break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ne(t,r.codec()),r.decode=(t,n)=>Be(t,r.codec(),n)})(Rs||(Rs={}));var Al;(function(r){let e;r.codec=()=>(e==null&&(e=De((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.expire!=null&&t.expire!==0n&&(n.uint32(8),n.uint64(t.expire)),t.addrs!=null)for(const s of t.addrs)n.uint32(18),n.bytes(s);t.voucher!=null&&(n.uint32(26),_l.codec().encode(t.voucher,n)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={expire:0n,addrs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.expire=t.uint64();break}case 2:{if(i.limits?.addrs!=null&&s.addrs.length===i.limits.addrs)throw new Cr('Decode error - map field "addrs" had too many elements');s.addrs.push(t.bytes());break}case 3:{s.voucher=_l.codec().decode(t,t.uint32(),{limits:i.limits?.voucher});break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ne(t,r.codec()),r.decode=(t,n)=>Be(t,r.codec(),n)})(Al||(Al={}));var Os;(function(r){let e;r.codec=()=>(e==null&&(e=De((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.duration!=null&&(n.uint32(8),n.uint32(t.duration)),t.data!=null&&(n.uint32(16),n.uint64(t.data)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.duration=t.uint32();break}case 2:{s.data=t.uint64();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ne(t,r.codec()),r.decode=(t,n)=>Be(t,r.codec(),n)})(Os||(Os={}));var Pt;(function(r){r.UNUSED="UNUSED",r.OK="OK",r.RESERVATION_REFUSED="RESERVATION_REFUSED",r.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",r.PERMISSION_DENIED="PERMISSION_DENIED",r.CONNECTION_FAILED="CONNECTION_FAILED",r.NO_RESERVATION="NO_RESERVATION",r.MALFORMED_MESSAGE="MALFORMED_MESSAGE",r.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(Pt||(Pt={}));var wf;(function(r){r[r.UNUSED=0]="UNUSED",r[r.OK=100]="OK",r[r.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",r[r.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",r[r.PERMISSION_DENIED=202]="PERMISSION_DENIED",r[r.CONNECTION_FAILED=203]="CONNECTION_FAILED",r[r.NO_RESERVATION=204]="NO_RESERVATION",r[r.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",r[r.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(wf||(wf={}));(function(r){r.codec=()=>ln(wf)})(Pt||(Pt={}));var xl;(function(r){let e;r.codec=()=>(e==null&&(e=De((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.relay!=null&&t.relay.byteLength>0&&(n.uint32(10),n.bytes(t.relay)),t.peer!=null&&t.peer.byteLength>0&&(n.uint32(18),n.bytes(t.peer)),t.expiration!=null&&t.expiration!==0n&&(n.uint32(24),n.uint64(t.expiration)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={relay:Pe(0),peer:Pe(0),expiration:0n},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.relay=t.bytes();break}case 2:{s.peer=t.bytes();break}case 3:{s.expiration=t.uint64();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ne(t,r.codec()),r.decode=(t,n)=>Be(t,r.codec(),n)})(xl||(xl={}));var _l;(function(r){let e;r.codec=()=>(e==null&&(e=De((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&(n.uint32(26),xl.codec().encode(t.payload,n)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={publicKey:Pe(0),payloadType:Pe(0),signature:Pe(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.publicKey=t.bytes();break}case 2:{s.payloadType=t.bytes();break}case 3:{s.payload=xl.codec().decode(t,t.uint32(),{limits:i.limits?.payload});break}case 5:{s.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ne(t,r.codec()),r.decode=(t,n)=>Be(t,r.codec(),n)})(_l||(_l={}));const bR=r=>r.toString().split("/").slice(1),Pa=r=>({match:e=>e.length<1?!1:r(e[0])?e.slice(1):!1,pattern:"fn"}),pe=r=>({match:e=>Pa(t=>t===r).match(e),pattern:r}),no=()=>({match:r=>Pa(e=>typeof e=="string").match(r),pattern:"{string}"}),ta=()=>({match:r=>Pa(e=>!isNaN(parseInt(e))).match(r),pattern:"{number}"}),Oe=()=>({match:r=>{if(r.length<2||r[0]!=="p2p"&&r[0]!=="ipfs")return!1;if(r[1].startsWith("Q")||r[1].startsWith("1"))try{Je.decode(`z${r[1]}`)}catch{return!1}else return!1;return r.slice(2)},pattern:"/p2p/{peerid}"}),Cl=()=>({match:r=>{if(r.length<2||r[0]!=="certhash")return!1;try{va.decode(r[1])}catch{return!1}return r.slice(2)},pattern:"/certhash/{certhash}"}),ke=r=>({match:e=>{const t=r.match(e);return t===!1?e:t},pattern:`optional(${r.pattern})`}),Ot=(...r)=>({match:e=>{let t;for(const n of r){const i=n.match(e);i!==!1&&(t==null||i.length<t.length)&&(t=i)}return t??!1},pattern:`or(${r.map(e=>e.pattern).join(", ")})`}),we=(...r)=>({match:e=>{for(const t of r){const n=t.match(e);if(n===!1)return!1;e=n}return e},pattern:`and(${r.map(e=>e.pattern).join(", ")})`});function Ue(...r){function e(i){let s=bR(i);for(const o of r){const a=o.match(s);if(a===!1)return!1;s=a}return s}function t(i){return e(i)!==!1}function n(i){const s=e(i);return s===!1?!1:s.length===0}return{matchers:r,matches:t,exactMatch:n}}const vR=Oe(),SR=Ue(vR),Lu=we(pe("dns4"),no()),Mu=we(pe("dns6"),no()),Uu=we(pe("dnsaddr"),no()),Ug=we(pe("dns"),no());Ue(Lu,ke(Oe()));Ue(Mu,ke(Oe()));Ue(Uu,ke(Oe()));const ER=Ue(Ot(Ug,Uu,Lu,Mu),ke(Oe())),sE=we(pe("ip4"),Pa(Pi)),oE=we(pe("ip6"),Pa(Bg)),Fg=Ot(sE,oE),sn=Ot(Fg,Ug,Lu,Mu,Uu),AR=Ue(Ot(Fg,we(Ot(Ug,Uu,Lu,Mu),ke(Oe())))),cw=Ue(sE),lw=Ue(oE),xR=Ue(Fg),$g=we(sn,pe("tcp"),ta()),Ra=we(sn,pe("udp"),ta()),Il=Ue(we($g,ke(Oe())));Ue(Ra);const Vg=we(Ra,pe("quic"),ke(Oe())),Fu=we(Ra,pe("quic-v1"),ke(Oe())),_R=Ot(Vg,Fu);Ue(Vg);const CR=Ue(Fu),bf=Ot(sn,$g,Ra,Vg,Fu),aE=Ot(we(bf,pe("ws"),ke(Oe()))),ra=Ue(aE),cE=Ot(we(bf,pe("wss"),ke(Oe())),we(bf,pe("tls"),ke(we(pe("sni"),no())),pe("ws"),ke(Oe()))),kl=Ue(cE),lE=we(Ra,pe("webrtc-direct"),ke(Cl()),ke(Cl()),ke(Oe())),vf=Ue(lE),uE=we(Fu,pe("webtransport"),ke(Cl()),ke(Cl()),ke(Oe())),uw=Ue(uE),Tl=Ot(aE,cE,we($g,ke(Oe())),we(_R,ke(Oe())),we(sn,ke(Oe())),lE,uE,Oe()),dE=Ue(Tl),IR=we(Tl,pe("p2p-circuit"),Oe()),zn=Ue(IR),kR=Ot(we(Tl,pe("p2p-circuit"),pe("webrtc"),ke(Oe())),we(Tl,pe("webrtc"),ke(Oe())),we(pe("webrtc"),ke(Oe()))),Sf=Ue(kR),TR=Ot(we(sn,pe("tcp"),ta(),pe("http"),ke(Oe())),we(sn,pe("http"),ke(Oe())));Ue(TR);const PR=Ot(we(sn,pe("tcp"),Ot(we(pe("443"),pe("http")),we(ta(),pe("https")),we(ta(),pe("tls"),pe("http"))),ke(Oe())),we(sn,pe("tls"),pe("http"),ke(Oe())),we(sn,pe("https"),ke(Oe())));Ue(PR);const RR=Ot(we(pe("memory"),no(),ke(Oe())));Ue(RR);function qr(r){const e=new globalThis.AbortController;function t(){e.abort();for(const s of r)s?.removeEventListener!=null&&s.removeEventListener("abort",t)}for(const s of r){if(s?.aborted===!0){t();break}s?.addEventListener!=null&&s.addEventListener("abort",t)}function n(){for(const s of r)s?.removeEventListener!=null&&s.removeEventListener("abort",t)}const i=e.signal;return i.clear=n,i}class dw extends Error{static name="HadEnoughRelaysError";name="HadEnoughRelaysError"}class OR extends Error{static name="DoubleRelayError";name="DoubleRelayError"}class BR extends Error{static name="RelayQueueFullError";name="RelayQueueFullError"}function hw(r){const e=r*BigInt(1e3),t=new Date().getTime();return Number(e-BigInt(t))}class fw{expires;bytes;constructor(e){e?.duration!=null&&e?.duration!==0&&(this.expires=Date.now()+e.duration*1e3),this.bytes=e?.data,this.bytes===0n&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(e){this.bytes!=null&&(this.bytes-=BigInt(e.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(this.expires==null&&this.bytes==null)return;const e={};if(this.bytes!=null){const t=this;Object.defineProperty(e,"bytes",{get(){return t.bytes}})}if(this.expires!=null){const t=this;Object.defineProperty(e,"seconds",{get(){return Math.round(((t.expires??0)-Date.now())/1e3)}})}return e}}const hE=Ue(we(dE.matchers[0],pe("p2p-circuit"))),fE=Ue(pe("p2p-circuit"));function Fo(r,e){const t={[Symbol.iterator]:()=>t,next:()=>{const n=r.next(),i=n.value;return n.done===!0||i==null?{done:!0,value:void 0}:{done:!1,value:e(i)}}};return t}function ah(r){const e=Qn(Je.decode(`z${r}`));return ro(e)}class $u{map;constructor(e){if(this.map=new Map,e!=null)for(const[t,n]of e.entries())this.map.set(t.toString(),{key:t,value:n})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return Fo(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach((t,n)=>{e(t.value,t.key,this)})}get(e){return this.map.get(e.toString())?.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return Fo(this.map.values(),e=>e.key)}values(){return Fo(this.map.values(),e=>e.value)}get size(){return this.map.size}}class Si{set;constructor(e){if(this.set=new Set,e!=null)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return Fo(this.set.entries(),e=>{const t=ah(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const n=ah(t);e(n,n,this)})}has(e){return this.set.has(e.toString())}values(){return Fo(this.set.values(),e=>ah(e))}intersection(e){const t=new Si;for(const n of e)this.has(n)&&t.add(n);return t}difference(e){const t=new Si;for(const n of this)e.has(n)||t.add(n);return t}union(e){const t=new Si;for(const n of e)t.add(n);for(const n of this)t.add(n);return t}}function NR(){return new Si}const qg={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},pE={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},gE=new globalThis.TextEncoder;function DR(r,e){const t=qg[e];let n=pE[e];for(let i=0;i<r.length;i++)n^=BigInt(r[i]),n=BigInt.asUintN(e,n*t);return n}function LR(r,e,t){if(t.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const n=qg[e];let i=pE[e],s=r;for(;s.length>0;){const o=gE.encodeInto(s,t);s=s.slice(o.read);for(let a=0;a<o.written;a++)i^=BigInt(t[a]),i=BigInt.asUintN(e,i*n)}return i}function MR(r,{size:e=32,utf8Buffer:t}={}){if(!qg[e])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof r=="string"){if(t)return LR(r,e,t);r=gE.encode(r)}return DR(r,e)}const jg={hash:r=>Number(MR(r,{size:32})),hashV:(r,e)=>UR(jg.hash(r,e))};function UR(r){let e=r.toString(16);return e.length%2===1&&(e=`0${e}`),oe(e,"base16")}const mE=64;class fi{fp;h;seed;constructor(e,t,n,i=2){if(i>mE)throw new TypeError("Invalid Fingerprint Size");const s=t.hashV(e,n),o=Pe(i);for(let a=0;a<o.length;a++)o[a]=s[a];o.length===0&&(o[0]=7),this.fp=o,this.h=t,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return e?.fp instanceof Uint8Array?et(this.fp,e.fp):!1}}function Pl(r,e){return Math.floor(Math.random()*(e-r))+r}class wc{contents;constructor(e){this.contents=new Array(e).fill(null)}has(e){if(!(e instanceof fi))throw new TypeError("Invalid Fingerprint");return this.contents.some(t=>e.equals(t))}add(e){if(!(e instanceof fi))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(this.contents[t]==null)return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof fi))throw new TypeError("Invalid Fingerprint");const t=Pl(0,this.contents.length-1),n=this.contents[t];return this.contents[t]=e,n}remove(e){if(!(e instanceof fi))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex(n=>e.equals(n));return t>-1?(this.contents[t]=null,!0):!1}}const FR=500;class pw{bucketSize;filterSize;fingerprintSize;buckets;count;hash;seed;constructor(e){this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??jg,this.seed=e.seed??Pl(0,Math.pow(2,10))}add(e){typeof e=="string"&&(e=oe(e));const t=new fi(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,i=(n^t.hash())%this.filterSize;if(this.buckets[n]==null&&(this.buckets[n]=new wc(this.bucketSize)),this.buckets[i]==null&&(this.buckets[i]=new wc(this.bucketSize)),this.buckets[n].add(t)||this.buckets[i].add(t))return this.count++,!0;const s=[n,i];let o=s[Pl(0,s.length-1)];this.buckets[o]==null&&(this.buckets[o]=new wc(this.bucketSize));for(let a=0;a<FR;a++){const c=this.buckets[o].swap(t);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new wc(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(e){typeof e=="string"&&(e=oe(e));const t=new fi(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,i=this.buckets[n]?.has(t)??!1;if(i)return i;const s=(n^t.hash())%this.filterSize;return this.buckets[s]?.has(t)??!1}remove(e){typeof e=="string"&&(e=oe(e));const t=new fi(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,i=this.buckets[n]?.remove(t)??!1;if(i)return this.count--,i;const s=(n^t.hash())%this.filterSize,o=this.buckets[s]?.remove(t)??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const $R={1:.5,2:.84,4:.95,8:.98};function VR(r=.001){return r>.002?2:r>1e-5?4:8}function qR(r,e=.001){const t=VR(e),n=$R[t],i=Math.round(r/n),s=Math.min(Math.ceil(Math.log2(1/e)+Math.log2(2*t)),mE);return{filterSize:i,bucketSize:t,fingerprintSize:s}}class jR{filterSize;bucketSize;fingerprintSize;scale;filterSeries;hash;seed;constructor(e){this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??jg,this.seed=e.seed??Pl(0,Math.pow(2,10)),this.filterSeries=[new pw({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if(typeof e=="string"&&(e=oe(e)),this.has(e))return!0;let t=this.filterSeries.find(n=>n.reliable);if(t==null){const n=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new pw({filterSize:n,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){typeof e=="string"&&(e=oe(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){typeof e=="string"&&(e=oe(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce((e,t)=>e+t.count,0)}}function Bs(r,e=.001,t){return new jR({...qR(r,e)})}class zR{filter;constructor(e,t){this.filter=Bs(e,t)}has(e){return this.filter.has(e.toMultihash().bytes)}add(e){this.filter.add(e.toMultihash().bytes)}remove(e){this.filter.remove?.(e.toMultihash().bytes)}}function HR(r,e=.001){return new zR(r,e)}function gw(r){const{stream:e,remoteAddr:t,logger:n,onDataRead:i,onDataWrite:s}=r,o=n.forComponent("libp2p:stream:converter");let a=!1,c=!1;const l=e.close.bind(e);e.close=async g=>{await l(g),m(!0)};const u=e.abort.bind(e);e.abort=g=>{u(g),m(!0)};const d=e.sink.bind(e);e.sink=async g=>{try{await d(Rg(g,y=>WS(y,w=>s?.(w))))}catch(y){y.type!=="aborted"&&o.error("%s error in sink",t,y)}finally{c=!0,m()}};const f={log:o,sink:e.sink,source:async function*(){try{for await(const g of e.source)i?.(g),yield g}finally{a=!0,m()}}(),remoteAddr:t,timeline:{open:Date.now(),close:void 0},close:e.close,abort:e.abort};function m(g){g===!0&&(a=!0,c=!0),a&&c&&f.timeline.close==null&&(f.timeline.close=Date.now())}return f}class Re extends Event{type;detail;constructor(e,t){super(e),this.type=e,this.detail=t}}let WR=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.name="AbortError",this.code=t??"ABORT_ERR"}};async function Ei(r,e,t,n){const i=new WR(n?.errorMessage,n?.errorCode);return t?.aborted===!0?Promise.reject(i):new Promise((s,o)=>{function a(){t?.removeEventListener("abort",u),r.removeEventListener(e,c),n?.errorEvent!=null&&r.removeEventListener(n.errorEvent,l)}const c=d=>{try{if(n?.filter?.(d)===!1)return}catch(f){a(),o(f);return}a(),s(d)},l=d=>{a(),o(d.detail)},u=()=>{a(),o(i)};t?.addEventListener("abort",u),r.addEventListener(e,c),n?.errorEvent!=null&&r.addEventListener(n.errorEvent,l)})}function Ef(r,e){let t;const n=function(){const i=function(){t=void 0,r()};clearTimeout(t),t=setTimeout(i,e)};return n.start=()=>{},n.stop=()=>{clearTimeout(t)},n}class KR extends Error{remainingPoints;msBeforeNext;consumedPoints;isFirstInDuration;constructor(e="Rate limit exceeded",t){super(e),this.name="RateLimitError",this.remainingPoints=t.remainingPoints,this.msBeforeNext=t.msBeforeNext,this.consumedPoints=t.consumedPoints,this.isFirstInDuration=t.isFirstInDuration}}class GR extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}class YR{deferred;signal;constructor(e){this.signal=e,this.deferred=We(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new Ii)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}}function QR(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class XR{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=QR(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,n)=>t&&n.signal?.aborted===!0,!0)&&(this.controller.abort(new Ii),this.cleanup())}async join(e={}){const t=new YR(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await sr(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}}class yE extends $r{concurrency;maxSize;queue;pending;sort;constructor(e={}){super(),this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,e.metricName!=null&&e.metrics?.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})}),this.sort=e.sort,this.queue=[],this.emitEmpty=Ef(this.emitEmpty.bind(this),1),this.emitIdle=Ef(this.emitIdle.bind(this),1)}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if(t.status==="queued"){e=t;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new GR;const n=new XR(e,t);return this.enqueue(n),this.safeDispatchEvent("add"),this.tryToStartAnother(),n.join(t).then(i=>(this.safeDispatchEvent("completed",{detail:i}),this.safeDispatchEvent("success",{detail:{job:n,result:i}}),i)).catch(i=>{if(n.status==="queued"){for(let s=0;s<this.queue.length;s++)if(this.queue[s]===n){this.queue.splice(s,1);break}}throw this.safeDispatchEvent("error",{detail:i}),this.safeDispatchEvent("failure",{detail:{job:n,error:i}}),i})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new Ii)}),this.clear()}async onEmpty(e){this.size!==0&&await Ei(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await Ei(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await Ei(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=Ia({objectMode:!0}),n=c=>{c!=null?this.abort():this.clear(),t.end(c)},i=c=>{c.detail!=null&&t.push(c.detail)},s=c=>{n(c.detail)},o=()=>{n()},a=()=>{n(new Ii("Queue aborted"))};this.addEventListener("completed",i),this.addEventListener("error",s),this.addEventListener("idle",o),e?.signal?.addEventListener("abort",a);try{yield*t}finally{this.removeEventListener("completed",i),this.removeEventListener("error",s),this.removeEventListener("idle",o),e?.signal?.removeEventListener("abort",a),n()}}}class Vu extends yE{has(e){return this.find(e)!=null}find(e){return this.queue.find(t=>e.equals(t.options.peerId))}}class ZR extends $r{peerStore;registrar;connectionManager;randomWalk;started;running;topologyId;log;discoveryController;filter;queue;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.started=!1,this.running=!1,this.peerStore=e.peerStore,this.registrar=e.registrar,this.connectionManager=e.connectionManager,this.randomWalk=e.randomWalk,this.filter=t.filter,this.discoveryController=new AbortController,this.discoveryController.signal}isStarted(){return this.started}async start(){this.topologyId=await this.registrar.register(El,{filter:this.filter,onConnect:e=>{this.log.trace("discovered relay %p queue (length: %d, active %d)",e,this.queue?.size,this.queue?.running),this.safeDispatchEvent("relay:discover",{detail:e})}}),this.started=!0}stop(){this.topologyId!=null&&this.registrar.unregister(this.topologyId),this.discoveryController?.abort(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,this.discoveryController.signal,Promise.resolve().then(async()=>{this.log("searching peer store for relays");const e=await this.peerStore.all({filters:[n=>n.protocols.includes(El)],orders:[()=>Math.random()<.5?1:-1,(n,i)=>{const s=mw(n),o=mw(i);return s>o?-1:o>s?1:0}]});for(const n of e)this.log.trace("found relay peer %p in peer store",n.id),this.safeDispatchEvent("relay:discover",{detail:n.id});this.log("found %d relay peers in peer store",e.length);const t=this.queue=new Vu({concurrency:5});this.log("start random walk");for await(const n of this.randomWalk.walk({signal:this.discoveryController.signal})){if(this.log.trace("found random peer %p",n.id),t.has(n.id)){this.log.trace("random peer %p was already in queue",n.id);continue}if(this.connectionManager.getConnections(n.id)?.length>0){this.log.trace("random peer %p was already connected",n.id);continue}if(!await this.connectionManager.isDialable(n.multiaddrs)){this.log.trace("random peer %p was not dialable",n.id,n.multiaddrs.map(i=>i.toString()));continue}t.queued>10&&(this.log.trace("wait for space in queue for %p",n.id),await t.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",n.id,t.size,t.running),t.add(async()=>{const i=qr([this.discoveryController.signal,AbortSignal.timeout(5e3)]);try{await this.connectionManager.openConnection(n.id,{signal:i})}finally{i.clear()}},{peerId:n.id,signal:this.discoveryController.signal}).catch(i=>{this.log.error("error opening connection to random peer %p",n.id,i)})}this.log("stop random walk"),await t.onIdle()}).catch(e=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network",e)}))}stopDiscovery(){this.log("stop discovery"),this.running=!1,this.discoveryController?.abort()}}function mw(r){const e=r.metadata.get("last-dial-success");return e==null?0:new Date(ge(e)).getTime()}class JR extends $r{connectionManager;addressManager;reservationStore;listeningAddrs;log;listenTimeout;reservationId;relay;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.connectionManager=e.connectionManager,this.addressManager=e.addressManager,this.reservationStore=e.reservationStore,this.listeningAddrs=[],this.listenTimeout=t.listenTimeout??iE,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}_onRemoveRelayPeer=e=>{this.log("relay removed %p our relay %p",e.detail.relay,this.relay,this.relay?.equals(e.detail.relay)),this.relay?.equals(e.detail.relay)===!0&&(this.log("relay peer removed %p",e.detail.relay),this.listeningAddrs.forEach(t=>{this.addressManager.removeObservedAddr(t)}),this.listeningAddrs=[],this.safeDispatchEvent("listening"))};_onAddRelayPeer=e=>{const{details:t}=e.detail;t.type!=="configured"&&t.id===this.reservationId&&this.addedRelay(e.detail)};async listen(e){if(fE.exactMatch(e))this.log("searching for circuit relay servers"),this.reservationId=this.reservationStore.reserveRelay();else if(hE.exactMatch(e)){this.log("listen on specific relay server %a",e);const t=AbortSignal.timeout(this.listenTimeout),n=e.decapsulate("/p2p-circuit"),i=await this.connectionManager.openConnection(n,{signal:t});if(!this.reservationStore.hasReservation(i.remotePeer)){this.log("making reservation on peer %p",i.remotePeer);const s=await this.reservationStore.addRelay(i.remotePeer,"configured");this.addedRelay(s)}}else throw new Xh(`Could not listen on p2p-circuit address "${e}"`)}getAddrs(){return[...this.listeningAddrs.values()].flat()}updateAnnounceAddrs(){}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask(()=>{this.safeDispatchEvent("close")})}addedRelay(e){this.log("relay peer added %p",e.relay),this.relay=e.relay,this.listeningAddrs=e.details.reservation.addrs.map(t=>he(t).encapsulate("/p2p-circuit")),this.listeningAddrs.forEach(t=>{this.addressManager.confirmObservedAddr(t,{type:"transport"})}),queueMicrotask(()=>{this.safeDispatchEvent("listening")})}}function eO(r){return new JR(r)}const tO="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";let rO=(r=21)=>{let e="",t=crypto.getRandomValues(new Uint8Array(r|=0));for(;r--;)e+=tO[t[r]&63];return e};const nO=60*1e3*10,iO=60*1e3*5,sO=30*1e3;class oO extends $r{peerId;connectionManager;peerStore;events;reserveQueue;reservations;pendingReservations;maxReservationQueueLength;reservationCompletionTimeout;started;log;relayFilter;constructor(e,t){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.reservations=new $u,this.pendingReservations=[],this.maxReservationQueueLength=t?.maxReservationQueueLength??mR,this.reservationCompletionTimeout=t?.reservationCompletionTimeout??iE,this.started=!1,this.relayFilter=Bs(100),this.reserveQueue=new Vu({concurrency:t?.reservationConcurrency??gR,metricName:"libp2p_relay_reservation_queue",metrics:e.metrics}),this.events.addEventListener("connection:close",n=>{[...this.reservations.values()].find(s=>s.connection===n.detail.id)!=null&&this.#r(n.detail.remotePeer).catch(s=>{this.log("could not remove relay %p - %e",n.detail,s)})})}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>t.tags.has(yc)]});this.log("removing tag from %d old relays",e.length),await Promise.all(e.map(async t=>{await this.peerStore.merge(t.id,{tags:{[yc]:void 0}})})),this.log("redialing %d old relays",e.length),await Promise.all(e.map(async t=>this.addRelay(t.id,"discovered"))),this.#t()}).catch(e=>{this.log.error(e)})}stop(){this.reserveQueue.clear(),this.reservations.forEach(({timeout:e})=>{clearTimeout(e)}),this.reservations.clear(),this.started=!1}reserveRelay(){const e=rO();return this.pendingReservations.push(e),this.#t(),e}async addRelay(e,t){if(this.peerId.equals(e))throw this.log.trace("not trying to use self as relay"),new Xh("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new BR("The reservation queue is full");const n=this.reserveQueue.find(e);if(n!=null)return this.log.trace("potential relay peer %p is already in the reservation queue",e),n.join();if(this.relayFilter.has(e.toMultihash().bytes))throw new Xh("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",e),this.reserveQueue.add(async()=>{const i=Date.now();try{const s=this.reservations.get(e);if(s!=null){const g=this.connectionManager.getConnections(e);let y=!1;if(g.length===0&&this.log("already have relay reservation with %p but we are no longer connected",e),g.map(w=>w.id).includes(s.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",e),y=!0),y&&hw(s.reservation.expire)>nO)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",e),{relay:e,details:s};await this.#r(e)}if(t==="discovered"&&this.pendingReservations.length===0)throw new dw("Not making reservation on discovered relay because we do not need any more relays");const o=AbortSignal.timeout(this.reservationCompletionTimeout);const a=await this.connectionManager.openConnection(e,{signal:o});if(zn.matches(a.remoteAddr))throw new OR("not creating reservation over relayed connection");const c=await this.#e(a,{signal:o}),l=hw(c.expire);this.log("created reservation on relay peer %p, expiry date is %s",e,new Date(Date.now()+l).toString());const u=Math.min(Math.max(l-iO,sO),Math.pow(2,31)-1),d=setTimeout(()=>{this.log("refresh reservation to relay %p",e),this.addRelay(e,t).catch(async g=>{this.log.error("could not refresh reservation to relay %p - %e",e,g),await this.#r(e)}).catch(g=>{this.log.error("could not remove expired reservation to relay %p - %e",e,g)})},u);let f;if(t==="discovered"){const g=this.pendingReservations.pop();if(g==null)throw new dw("Made reservation on relay but did not need any more discovered relays");f={timeout:d,reservation:c,type:t,connection:a.id,id:g}}else f={timeout:d,reservation:c,type:t,connection:a.id};this.reservations.set(e,f),await this.peerStore.merge(e,{tags:{[yc]:{value:1,ttl:l}}}),this.#t();const m={relay:e,details:f};return this.safeDispatchEvent("relay:created-reservation",{detail:m}),m}catch(s){throw t==="discovered"&&s.name==="HadEnoughRelaysError"||this.log.error("could not reserve slot on %p after %dms - %e",e,Date.now()-i,s),(s.name==="DialError"||s.name==="UnsupportedProtocolError")&&this.relayFilter.add(e.toMultihash().bytes),this.#r(e).catch(o=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",e,o)}),s}},{peerId:e})}hasReservation(e){return this.reservations.has(e)}getReservation(e){return this.reservations.get(e)?.reservation}reservationCount(e){return e==null?this.reservations.size:[...this.reservations.values()].reduce((t,n)=>(n.type===e&&t++,t),0)}cancelReservations(){[...this.reservations.values()].forEach(e=>{clearTimeout(e.timeout)}),this.reservations.clear()}async#e(e,t){t.signal?.throwIfAborted(),this.log("requesting reservation from %p",e.remotePeer);const n=await e.newStream(El,t),s=Jt(n).pb(Ps);this.log.trace("send RESERVE to %p",e.remotePeer),await s.write({type:Ps.Type.RESERVE},t);let o;try{this.log.trace("reading response from %p",e.remotePeer),o=await s.read(t)}catch(c){throw n.abort(c),c}finally{n.status!=="closed"&&await n.close(t)}if(this.log.trace("read response %o",o),o.status===Pt.OK&&o.reservation!=null){const c=new Set;c.add(e.remoteAddr.toString());for(const l of o.reservation.addrs){let u=he(l);u.getPeerId()==null&&(u=u.encapsulate(`/p2p/${e.remotePeer}`)),u=he(u.toString().replace(`/p2p/${e.remotePeer}/p2p/${e.remotePeer}`,`/p2p/${e.remotePeer}`)),c.add(u.toString())}return o.reservation.addrs=[...c].map(l=>he(l).bytes),o.reservation}const a=`reservation failed with status ${o.status??"undefined"}`;throw this.log.error(a),new Error(a)}async#r(e){const t=this.reservations.get(e);t!=null&&(this.log("removing relay reservation with %p from local store",e),clearTimeout(t.timeout),this.reservations.delete(e),t.type==="discovered"&&this.pendingReservations.push(t.id),await this.peerStore.merge(e,{tags:{[yc]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:e,details:t}}),this.#t())}#t(){if(this.pendingReservations.length===0){this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),this.safeDispatchEvent("relay:found-enough-relays");return}this.relayFilter=Bs(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")}}const aO=r=>{if(r.peer==null)return!1;try{r.peer.addrs.forEach(he)}catch{return!1}return!0},yw={maxInboundStopStreams:aw,maxOutboundStopStreams:aw};class cO{discovery;registrar;peerStore;connectionManager;transportManager;peerId;upgrader;addressManager;connectionGater;reservationStore;logger;maxInboundStopStreams;maxOutboundStopStreams;started;log;shutdownController;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:circuit-relay:transport"),this.registrar=e.registrar,this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.transportManager=e.transportManager,this.logger=e.logger,this.peerId=e.peerId,this.upgrader=e.upgrader,this.addressManager=e.addressManager,this.connectionGater=e.connectionGater,this.maxInboundStopStreams=t.maxInboundStopStreams??yw.maxInboundStopStreams,this.maxOutboundStopStreams=t.maxOutboundStopStreams??yw.maxOutboundStopStreams,this.shutdownController=new AbortController,this.discovery=new ZR(e,{filter:t.discoveryFilter??HR(yR,wR)}),this.discovery.addEventListener("relay:discover",n=>{this.reservationStore.addRelay(n.detail,"discovered").catch(i=>{i.name!=="HadEnoughRelaysError"&&i.name!=="RelayQueueFullError"&&this.log.error("could not add discovered relay %p",n.detail,i)})}),this.reservationStore=new oO(e,t),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{this.discovery?.startDiscovery()}),this.reservationStore.addEventListener("relay:found-enough-relays",()=>{this.discovery?.stopDiscovery()}),this.started=!1}[Symbol.toStringTag]="@libp2p/circuit-relay-v2-transport";[Zt]=["@libp2p/transport","@libp2p/circuit-relay-v2-transport"];get[As](){return this.discovery!=null?["@libp2p/identify"]:[]}[Eu]=!0;isStarted(){return this.started}async start(){this.shutdownController=new AbortController,this.shutdownController.signal,await this.registrar.handle(ow,e=>{const t=this.upgrader.createInboundAbortSignal(this.shutdownController.signal);this.onStop(e,t).catch(n=>{this.log.error("error while handling STOP protocol",n),e.stream.abort(n)}).finally(()=>{t.clear()})},{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await Ev(this.discovery,this.reservationStore),this.started=!0}async stop(){this.shutdownController.abort(),await Av(this.discovery,this.reservationStore),await this.registrar.unhandle(ow),this.started=!1}async dial(e,t){if(e.protoCodes().filter(m=>m===pR).length!==1){const m="Invalid circuit relay address";throw this.log.error(m,e),new Do(m)}const n=e.toString().split("/p2p-circuit"),i=he(n[0]),s=he(n[n.length-1]),o=i.getPeerId(),a=s.getPeerId();if(o==null||a==null){const m=`ircuit relay dial to ${e.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${m}`),new Do(`C${m}`)}const c=Ir(o),l=Ir(a);let d=this.connectionManager.getConnections(c)[0];d==null?(await this.peerStore.merge(c,{multiaddrs:[i]}),t.onProgress?.(new Re("circuit-relay:open-connection")),d=await this.connectionManager.openConnection(c,t)):t.onProgress?.(new Re("circuit-relay:reuse-connection"));let f;try{t.onProgress?.(new Re("circuit-relay:open-hop-stream")),f=await d.newStream(El,t);const m=Jt(f),g=m.pb(Ps);t.onProgress?.(new Re("circuit-relay:write-connect-message")),await g.write({type:Ps.Type.CONNECT,peer:{id:l.toMultihash().bytes,addrs:[he(s).bytes]}},t),t.onProgress?.(new Re("circuit-relay:read-connect-response"));const y=await g.read(t);if(y.status!==Pt.OK)throw new Et(`failed to connect via relay with status ${y?.status?.toString()??"undefined"}`);const w=new fw(y.limit),x=gw({stream:m.unwrap(),remoteAddr:e,localAddr:i.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),logger:this.logger,onDataRead:w.onData,onDataWrite:w.onData});return this.log("new outbound relayed connection %a",x.remoteAddr),await this.upgrader.upgradeOutbound(x,{...t,limits:w.getLimits()})}catch(m){throw this.log.error("circuit relay dial to destination %p via relay %p failed",l,c,m),f?.abort(m),m}}createListener(e){return eO({peerId:this.peerId,connectionManager:this.connectionManager,addressManager:this.addressManager,reservationStore:this.reservationStore,logger:this.logger})}listenFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>hE.exactMatch(t)||fE.exactMatch(t))}dialFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>zn.exactMatch(t))}async onStop({connection:e,stream:t},n){if(!this.reservationStore.hasReservation(e.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.transportManager.listen([e.remoteAddr.encapsulate("/p2p-circuit")])}catch(u){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on",u)}const i=Jt(t).pb(Xr),s=await i.read({signal:n});if(this.log("new circuit relay v2 stop stream from %p with type %s",e.remotePeer,s.type),s?.type===void 0){this.log.error("type was missing from circuit v2 stop protocol request from %s",e.remotePeer),await i.write({type:Xr.Type.STATUS,status:Pt.MALFORMED_MESSAGE},{signal:n}),await t.close();return}if(s.type!==Xr.Type.CONNECT){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await i.write({type:Xr.Type.STATUS,status:Pt.UNEXPECTED_MESSAGE},{signal:n}),await t.close();return}if(!aO(s)){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await i.write({type:Xr.Type.STATUS,status:Pt.MALFORMED_MESSAGE},{signal:n}),await t.close({signal:n});return}const o=ro(Qn(s.peer.id));if(await this.connectionGater.denyInboundRelayedConnection?.(e.remotePeer,o)===!0){this.log.error("connection gater denied inbound relayed connection from %p",e.remotePeer),await i.write({type:Xr.Type.STATUS,status:Pt.PERMISSION_DENIED},{signal:n}),await t.close({signal:n});return}this.log.trace("sending success response to %p",e.remotePeer),await i.write({type:Xr.Type.STATUS,status:Pt.OK},{signal:n});const a=new fw(s.limit),c=e.remoteAddr.encapsulate(`/p2p-circuit/p2p/${o.toString()}`);this.addressManager.getAddresses()[0];const l=gw({stream:i.unwrap().unwrap(),remoteAddr:c,logger:this.logger,onDataRead:a.onData,onDataWrite:a.onData});this.log("new inbound relayed connection %a",l.remoteAddr),await this.upgrader.upgradeInbound(l,{limits:a.getLimits(),signal:n}),this.log("%s connection %a upgraded","inbound",l.remoteAddr)}}function lO(r={}){return e=>new cO(e,r)}function uO(r){return r[Symbol.asyncIterator]!=null}function Af(r){if(uO(r))return(async()=>{for await(const e of r);})();for(const e of r);}const bc=globalThis.CustomEvent??Event;async function*wE(r,e={}){let t=e.concurrency??1/0;t<1&&(t=1/0);const n=e.ordered??!1,i=new EventTarget,s=[];let o=We(),a=We(),c=!1,l,u=!1;i.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const g of r){if(s.length===t&&(o=We(),await o.promise),u)break;const y={done:!1};s.push(y),g().then(w=>{y.done=!0,y.ok=!0,y.value=w,i.dispatchEvent(new bc("task-complete"))},w=>{y.done=!0,y.err=w,i.dispatchEvent(new bc("task-complete"))})}c=!0,i.dispatchEvent(new bc("task-complete"))}catch(g){l=g,i.dispatchEvent(new bc("task-complete"))}});function d(){return n?s[0]?.done:!!s.find(g=>g.done)}function*f(){for(;s.length>0&&s[0].done;){const g=s[0];if(s.shift(),g.ok)yield g.value;else throw u=!0,o.resolve(),g.err;o.resolve()}}function*m(){for(;d();)for(let g=0;g<s.length;g++)if(s[g].done){const y=s[g];if(s.splice(g,1),g--,y.ok)yield y.value;else throw u=!0,o.resolve(),y.err;o.resolve()}}for(;;){if(d()||(a=We(),await a.promise),l!=null||(n?yield*f():yield*m(),l!=null))throw l;if(c&&s.length===0)break}}const dO="0.1.0",hO="id",fO="id/push",pO="1.0.0",gO="1.0.0",mO=1024*8,yO=32;var Ns;(function(r){let e;r.codec=()=>(e==null&&(e=De((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.protocolVersion!=null&&(n.uint32(42),n.string(t.protocolVersion)),t.agentVersion!=null&&(n.uint32(50),n.string(t.agentVersion)),t.publicKey!=null&&(n.uint32(10),n.bytes(t.publicKey)),t.listenAddrs!=null)for(const s of t.listenAddrs)n.uint32(18),n.bytes(s);if(t.observedAddr!=null&&(n.uint32(34),n.bytes(t.observedAddr)),t.protocols!=null)for(const s of t.protocols)n.uint32(26),n.string(s);t.signedPeerRecord!=null&&(n.uint32(66),n.bytes(t.signedPeerRecord)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={listenAddrs:[],protocols:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 5:{s.protocolVersion=t.string();break}case 6:{s.agentVersion=t.string();break}case 1:{s.publicKey=t.bytes();break}case 2:{if(i.limits?.listenAddrs!=null&&s.listenAddrs.length===i.limits.listenAddrs)throw new Cr('Decode error - map field "listenAddrs" had too many elements');s.listenAddrs.push(t.bytes());break}case 4:{s.observedAddr=t.bytes();break}case 3:{if(i.limits?.protocols!=null&&s.protocols.length===i.limits.protocols)throw new Cr('Decode error - map field "protocols" had too many elements');s.protocols.push(t.string());break}case 8:{s.signedPeerRecord=t.bytes();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ne(t,r.codec()),r.decode=(t,n)=>Be(t,r.codec(),n)})(Ns||(Ns={}));const nr={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:mO,runOnConnectionOpen:!0,runOnSelfUpdate:!0,runOnLimitedConnection:!0,concurrency:yO};function wO(r){if(r!=null&&r.length>0)try{return he(r)}catch{}}function bO(r,e){return e??r.userAgent}async function bE(r,e,t,n,i){if(t("received identify from %p",n.remotePeer),i==null)throw new Et("message was null or undefined");const s={};if(i.listenAddrs.length>0&&(s.addresses=i.listenAddrs.map(c=>({isCertified:!1,multiaddr:he(c)}))),i.protocols.length>0&&(s.protocols=i.protocols),i.publicKey!=null){const c=jn(i.publicKey);if(!Qo(c).equals(n.remotePeer))throw new Et("public key did not match remote PeerId");s.publicKey=c}let o;if(i.signedPeerRecord!=null){t.trace("received signedPeerRecord from %p",n.remotePeer);let c=i.signedPeerRecord;const l=await Ur.openAndCertify(c,Xt.DOMAIN);let u=Xt.createFromProtobuf(l.payload);const d=Ca(l.publicKey.toCID());if(!u.peerId.equals(d))throw new Et("signing key does not match PeerId in the PeerRecord");if(!n.remotePeer.equals(u.peerId))throw new Et("signing key does not match remote PeerId");let f;try{f=await r.get(u.peerId)}catch(m){if(m.name!=="NotFoundError")throw m}if(f!=null&&(s.metadata=f.metadata,f.peerRecordEnvelope!=null)){const m=await Ur.createFromProtobuf(f.peerRecordEnvelope),g=Xt.createFromProtobuf(m.payload);g.seqNumber>=u.seqNumber&&(t("sequence number was lower or equal to existing sequence number - stored: %d received: %d",g.seqNumber,u.seqNumber),u=g,c=f.peerRecordEnvelope)}s.peerRecordEnvelope=c,s.addresses=u.multiaddrs.map(m=>({isCertified:!0,multiaddr:m})),o={seq:u.seqNumber,addresses:u.multiaddrs}}else t("%p did not send a signed peer record",n.remotePeer);if(t.trace("patching %p with",n.remotePeer,s),await r.patch(n.remotePeer,s),i.agentVersion!=null||i.protocolVersion!=null){const c={};i.agentVersion!=null&&(c.AgentVersion=oe(i.agentVersion)),i.protocolVersion!=null&&(c.ProtocolVersion=oe(i.protocolVersion)),t.trace("merging %p metadata",n.remotePeer,c),await r.merge(n.remotePeer,{metadata:c})}const a={peerId:n.remotePeer,protocolVersion:i.protocolVersion,agentVersion:i.agentVersion,publicKey:i.publicKey,listenAddrs:i.listenAddrs.map(c=>he(c)),observedAddr:i.observedAddr==null?void 0:he(i.observedAddr),protocols:i.protocols,signedPeerRecord:o,connection:n};return e.safeDispatchEvent("peer:identify",{detail:a}),a}class vE{host;protocol;started;timeout;peerId;privateKey;peerStore;registrar;addressManager;maxInboundStreams;maxOutboundStreams;maxMessageSize;maxObservedAddresses;events;runOnLimitedConnection;log;constructor(e,t){this.protocol=t.protocol,this.started=!1,this.peerId=e.peerId,this.privateKey=e.privateKey,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.events=e.events,this.log=t.log,this.timeout=t.timeout??nr.timeout,this.maxInboundStreams=t.maxInboundStreams??nr.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??nr.maxOutboundStreams,this.maxMessageSize=t.maxMessageSize??nr.maxMessageSize,this.maxObservedAddresses=t.maxObservedAddresses??nr.maxObservedAddresses,this.runOnLimitedConnection=t.runOnLimitedConnection??nr.runOnLimitedConnection,this.host={protocolVersion:`${t.protocolPrefix??nr.protocolPrefix}/${dO}`,agentVersion:bO(e.nodeInfo,t.agentVersion)}}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:oe(this.host.agentVersion),ProtocolVersion:oe(this.host.protocolVersion)}}),await this.registrar.handle(this.protocol,e=>{this.handleProtocol(e).catch(t=>{this.log.error(t)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.registrar.unhandle(this.protocol),this.started=!1}}class vO extends vE{connectionManager;concurrency;constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??nr.protocolPrefix}/${fO}/${gO}`,log:e.logger.forComponent("libp2p:identify-push")}),this.connectionManager=e.connectionManager,this.concurrency=t.concurrency??nr.concurrency,(t.runOnSelfUpdate??nr.runOnSelfUpdate)&&e.events.addEventListener("self:peer:update",n=>{this.push().catch(i=>{this.log.error(i)})})}[Zt]=["@libp2p/identify-push"];async push(){if(!this.isStarted())return;const e=this.addressManager.getAddresses().map(u=>u.decapsulateCode(xt("p2p").code)),t=new Xt({peerId:this.peerId,multiaddrs:e}),n=await Ur.seal(t,this.privateKey),i=this.registrar.getProtocols(),s=await this.peerStore.get(this.peerId),o=ge(s.metadata.get("AgentVersion")??oe(this.host.agentVersion)),a=ge(s.metadata.get("ProtocolVersion")??oe(this.host.protocolVersion)),c=this;async function*l(){for(const u of c.connectionManager.getConnections())(await c.peerStore.get(u.remotePeer)).protocols.includes(c.protocol)&&(yield async()=>{let f;const m=AbortSignal.timeout(c.timeout);try{f=await u.newStream(c.protocol,{signal:m,runOnLimitedConnection:c.runOnLimitedConnection}),await Jt(f,{maxDataLength:c.maxMessageSize}).pb(Ns).write({listenAddrs:e.map(y=>y.bytes),signedPeerRecord:n.marshal(),protocols:i,agentVersion:o,protocolVersion:a},{signal:m}),await f.close({signal:m})}catch(g){c.log.error("could not push identify update to peer",g),f?.abort(g)}})}await Af(wE(l(),{concurrency:this.concurrency}))}async handleProtocol(e){const{connection:t,stream:n}=e;try{if(this.peerId.equals(t.remotePeer))throw new Error("received push from ourselves?");const i={signal:AbortSignal.timeout(this.timeout)},o=await Jt(n,{maxDataLength:this.maxMessageSize}).pb(Ns).read(i);await n.close(i),await bE(this.peerStore,this.events,this.log,t,o)}catch(i){this.log.error("received invalid message",i),n.abort(i);return}this.log.trace("handled push from %p",t.remotePeer)}}function SE(r){try{for(const{code:e,value:t}of r.getComponents())if(t!=null&&e===Un)return uR("2000::/3",t)}catch{}return!1}var ww=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Oa(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var ns={},bw;function SO(){return bw||(bw=1,function(){var r,e,t,n,i,s,o,a;a=function(c){var l,u,d,f;return l=(c&255<<24)>>>24,u=(c&255<<16)>>>16,d=(c&65280)>>>8,f=c&255,[l,u,d,f].join(".")},o=function(c){var l,u,d,f,m,g;for(l=[],d=f=0;f<=3&&c.length!==0;d=++f){if(d>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}g=e(c),m=g[0],u=g[1],c=c.substring(u),l.push(m)}if(c.length!==0)throw new Error("Invalid IP");switch(l.length){case 1:if(l[0]>4294967295)throw new Error("Invalid IP");return l[0]>>>0;case 2:if(l[0]>255||l[1]>16777215)throw new Error("Invalid IP");return(l[0]<<24|l[1])>>>0;case 3:if(l[0]>255||l[1]>255||l[2]>65535)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2])>>>0;case 4:if(l[0]>255||l[1]>255||l[2]>255||l[3]>255)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2]<<8|l[3])>>>0;default:throw new Error("Invalid IP")}},t=function(c){return c.charCodeAt(0)},n=t("0"),s=t("a"),i=t("A"),e=function(c){var l,u,d,f,m;for(f=0,l=10,u="9",d=0,c.length>1&&c[d]==="0"&&(c[d+1]==="x"||c[d+1]==="X"?(d+=2,l=16):"0"<=c[d+1]&&c[d+1]<="9"&&(d++,l=8,u="7")),m=d;d<c.length;){if("0"<=c[d]&&c[d]<=u)f=f*l+(t(c[d])-n)>>>0;else if(l===16)if("a"<=c[d]&&c[d]<="f")f=f*l+(10+t(c[d])-s)>>>0;else if("A"<=c[d]&&c[d]<="F")f=f*l+(10+t(c[d])-i)>>>0;else break;else break;if(f>4294967295)throw new Error("too large");d++}if(d===m)throw new Error("empty octet");return[f,d]},r=function(){function c(l,u){var d,f,m;if(typeof l!="string")throw new Error("Missing `net' parameter");if(u||(m=l.split("/",2),l=m[0],u=m[1]),u||(u=32),typeof u=="string"&&u.indexOf(".")>-1){try{this.maskLong=o(u)}catch{throw new Error("Invalid mask: "+u)}for(d=f=32;f>=0;d=--f)if(this.maskLong===4294967295<<32-d>>>0){this.bitmask=d;break}}else if(u||u===0)this.bitmask=parseInt(u,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(l)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+l)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+u);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(l){return typeof l=="string"&&(l.indexOf("/")>0||l.split(".").length!==4)&&(l=new c(l)),l instanceof c?this.contains(l.base)&&this.contains(l.broadcast||l.last):(o(l)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(l){return l==null&&(l=1),new c(a(this.netLong+this.size*l),this.mask)},c.prototype.forEach=function(l){var u,d,f;for(f=o(this.first),d=o(this.last),u=0;f<=d;)l(a(f),f,u),u++,f++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),ns.ip2long=o,ns.long2ip=a,ns.Netmask=r}.call(ns)),ns}var EO=SO();const AO=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],xO=AO.map(r=>new EO.Netmask(r));function zg(r){for(const e of xO)if(e.contains(r))return!0;return!1}function _O(r){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(r)}function CO(r){const e=r.split(":");if(e.length<2)return!1;const t=e[e.length-1].padStart(4,"0"),n=e[e.length-2].padStart(4,"0"),i=`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(t.substring(0,2),16)}.${parseInt(t.substring(2),16)}`;return zg(i)}function IO(r){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)}function kO(r){const e=r.split(":"),t=e[e.length-1];return zg(t)}function TO(r){return/^::$/.test(r)||/^::1$/.test(r)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(r)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(r)||/^ff([0-9a-fA-F]{2,2}):/i.test(r)}function Ba(r){if(Pi(r))return zg(r);if(_O(r))return CO(r);if(IO(r))return kO(r);if(Bg(r))return TO(r)}function EE(r){try{for(const{code:e}of r.getComponents())if(e!==Ta)return e===Ts||e===Un}catch{}return!1}function Ri(r){try{if(!EE(r))return!1;const[[,e]]=r.stringTuples();return e==null?!1:Ba(e)??!1}catch{}return!0}const PO=41;class RO extends vE{constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??nr.protocolPrefix}/${hO}/${pO}`,log:e.logger.forComponent("libp2p:identify")}),(t.runOnConnectionOpen??nr.runOnConnectionOpen)&&e.events.addEventListener("connection:open",n=>{const i=n.detail;this.identify(i).catch(s=>{s.name!==cg.name&&this.log.error("error during identify trigged by connection:open",s)})})}[Zt]=["@libp2p/identify"];async _identify(e,t={}){let n;if(t.signal==null){const i=AbortSignal.timeout(this.timeout);t={...t,signal:i}}try{n=await e.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const s=await Jt(n,{maxDataLength:this.maxMessageSize}).pb(Ns).read(t);return await n.close(t),s}catch(i){throw n?.abort(i),i}}async identify(e,t={}){const n=await this._identify(e,t),{publicKey:i,protocols:s,observedAddr:o}=n;if(i==null)throw new Et("public key was missing from identify message");const a=jn(i),c=Ca(a.toCID());if(!e.remotePeer.equals(c))throw new Et("identified peer does not match the expected peer");if(this.peerId.equals(c))throw new Et("identified peer is our own peer id?");return this.maybeAddObservedAddress(o),this.log("identify completed for peer %p and protocols %o",c,s),bE(this.peerStore,this.events,this.log,e,n)}maybeAddObservedAddress(e){const t=wO(e);if(t==null)return;if(this.log.trace("our observed address was %a",t),Ri(t)){this.log.trace("our observed address was private");return}if(t.stringTuples()[0][0]===PO&&!SE(t)){this.log.trace("our observed address was IPv6 but not a global unicast address");return}Il.exactMatch(t)||(this.log.trace("storing the observed address"),this.addressManager.addObservedAddr(t))}async handleProtocol(e){const{connection:t,stream:n}=e,i=AbortSignal.timeout(this.timeout);try{const s=await this.peerStore.get(this.peerId),o=this.addressManager.getAddresses().map(u=>u.decapsulateCode(xt("p2p").code));let a=s.peerRecordEnvelope;if(o.length>0&&a==null){const u=new Xt({peerId:this.peerId,multiaddrs:o});a=(await Ur.seal(u,this.privateKey)).marshal().subarray()}let c=t.remoteAddr.bytes;AR.matches(t.remoteAddr)||(c=void 0),await Jt(n).pb(Ns).write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:nn(this.privateKey.publicKey),listenAddrs:o.map(u=>u.bytes),signedPeerRecord:a,observedAddr:c,protocols:s.protocols},{signal:i}),await n.close({signal:i})}catch(s){this.log.error("could not respond to identify request",s),n.abort(s)}}}function OO(r={}){return e=>new RO(e,r)}function BO(r={}){return e=>new vO(e,r)}const ch=32,NO="1.0.0",DO="ping",LO="ipfs",MO=1e4,UO=2,FO=1;class $O{protocol;components;started;timeout;maxInboundStreams;maxOutboundStreams;runOnLimitedConnection;log;constructor(e,t={}){this.components=e,this.log=e.logger.forComponent("libp2p:ping"),this.started=!1,this.protocol=`/${t.protocolPrefix??LO}/${DO}/${NO}`,this.timeout=t.timeout??MO,this.maxInboundStreams=t.maxInboundStreams??UO,this.maxOutboundStreams=t.maxOutboundStreams??FO,this.runOnLimitedConnection=t.runOnLimitedConnection??!0,this.handleMessage=this.handleMessage.bind(this)}[Symbol.toStringTag]="@libp2p/ping";[Zt]=["@libp2p/ping"];async start(){await this.components.registrar.handle(this.protocol,this.handleMessage,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(e){this.log("incoming ping from %p",e.connection.remotePeer);const{stream:t}=e,n=Date.now(),i=gl(t);let s=!1;Promise.resolve().then(async()=>{for(;;){const o=AbortSignal.timeout(this.timeout);o.addEventListener("abort",()=>{t?.abort(new lg("ping timeout"))});const a=await i.read({bytes:ch,signal:o});await i.write(a,{signal:o}),s=!0}}).catch(o=>{s&&o.name==="UnexpectedEOFError"&&t.readStatus!=="ready"||(this.log.error("incoming ping from %p failed with error - %e",e.connection.remotePeer,o),t?.abort(o))}).finally(()=>{const o=Date.now()-n;this.log("incoming ping from %p complete in %dms",e.connection.remotePeer,o);const a=AbortSignal.timeout(this.timeout);t.close({signal:a}).catch(c=>{this.log.error("error closing ping stream from %p - %e",e.connection.remotePeer,c),t?.abort(c)})})}async ping(e,t={}){this.log("pinging %p",e);const n=Date.now(),i=Ig(ch),s=await this.components.connectionManager.openConnection(e,t);let o;if(t.signal==null){const a=AbortSignal.timeout(this.timeout);t={...t,signal:a}}try{o=await s.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const a=gl(o),[,c]=await Promise.all([a.write(i,t),a.read({...t,bytes:ch})]),l=Date.now()-n;if(!et(i,c.subarray()))throw new p_(`Received wrong ping ack after ${l}ms`);return this.log("ping %p complete in %dms",s.remotePeer,l),l}catch(a){throw this.log.error("error while pinging %p",s.remotePeer,a),o?.abort(a),a}finally{o!=null&&await o.close(t)}}}function VO(r={}){return e=>new $O(e,r)}var Dt;(function(r){(function(n){n.FIN="FIN",n.STOP_SENDING="STOP_SENDING",n.RESET="RESET",n.FIN_ACK="FIN_ACK"})(r.Flag||(r.Flag={}));let e;(function(n){n[n.FIN=0]="FIN",n[n.STOP_SENDING=1]="STOP_SENDING",n[n.RESET=2]="RESET",n[n.FIN_ACK=3]="FIN_ACK"})(e||(e={})),function(n){n.codec=()=>ln(e)}(r.Flag||(r.Flag={}));let t;r.codec=()=>(t==null&&(t=De((n,i,s={})=>{s.lengthDelimited!==!1&&i.fork(),n.flag!=null&&(i.uint32(8),r.Flag.codec().encode(n.flag,i)),n.message!=null&&(i.uint32(18),i.bytes(n.message)),s.lengthDelimited!==!1&&i.ldelim()},(n,i,s={})=>{const o={},a=i==null?n.len:n.pos+i;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.flag=r.Flag.codec().decode(n);break}case 2:{o.message=n.bytes();break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>Ne(n,r.codec()),r.decode=(n,i)=>Be(n,r.codec(),i)})(Dt||(Dt={}));const qO=["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478","stun:stun.cloudflare.com:3478","stun:stun.services.mozilla.com:3478"],vw=Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"),jO="libp2p+webrtc+v1/",zO=466,HO=2*1024*1024,WO=30*1e3,qu=16*1024;function KO(r=qu){const e=_t(r-_t(r)),t=1+_t(Object.keys(Dt.Flag).length-1),n=1,i=r-e-t-n,s=_t(i);return e+t+n+s}const GO=KO(),YO=5e3,QO=5e3,XO=3e4,AE="/webrtc",xf="/webrtc-signaling/0.0.1",ZO="/libp2p/webrtc-direct/certificate",JO="webrtc-direct-certificate-private-key",eB=12096e5,Sw=864e5;var Ew=function(r,e,t){if(t||arguments.length===2)for(var n=0,i=e.length,s;n<i;n++)(s||!(n in e))&&(s||(s=Array.prototype.slice.call(e,0,n)),s[n]=e[n]);return r.concat(s||Array.prototype.slice.call(e))},tB=function(){function r(e,t,n){this.name=e,this.version=t,this.os=n,this.type="browser"}return r}(),rB=function(){function r(e){this.version=e,this.type="node",this.name="node",this.os=process.platform}return r}(),nB=function(){function r(e,t,n,i){this.name=e,this.version=t,this.os=n,this.bot=i,this.type="bot-device"}return r}(),iB=function(){function r(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return r}(),sB=function(){function r(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return r}(),oB=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,aB=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,Aw=3,cB=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",oB]],xw=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function lB(r){return typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new sB:typeof navigator<"u"?dB(navigator.userAgent):fB()}function uB(r){return r!==""&&cB.reduce(function(e,t){var n=t[0],i=t[1];if(e)return e;var s=i.exec(r);return!!s&&[n,s]},!1)}function dB(r){var e=uB(r);if(!e)return null;var t=e[0],n=e[1];if(t==="searchbot")return new iB;var i=n[1]&&n[1].split(".").join("_").split("_").slice(0,3);i?i.length<Aw&&(i=Ew(Ew([],i,!0),pB(Aw-i.length),!0)):i=[];var s=i.join("."),o=hB(r),a=aB.exec(r);return a&&a[1]?new nB(t,s,o,a[1]):new tB(t,s,o)}function hB(r){for(var e=0,t=xw.length;e<t;e++){var n=xw[e],i=n[0],s=n[1],o=s.exec(r);if(o)return i}return null}function fB(){var r=typeof process<"u"&&process.version;return r?new rB(process.version.slice(1)):null}function pB(r){for(var e=[],t=0;t<r;t++)e.push("0");return e}class xE extends Error{constructor(e){super(e),this.name="TimeoutError"}}let gB=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}};const _w=r=>globalThis.DOMException===void 0?new gB(r):new DOMException(r),Cw=r=>{const e=r.reason===void 0?_w("This operation was aborted."):r.reason;return e instanceof Error?e:_w(e)};function Hg(r,e){const{milliseconds:t,fallback:n,message:i,customTimers:s={setTimeout,clearTimeout}}=e;let o,a;const l=new Promise((u,d)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(e.signal){const{signal:m}=e;m.aborted&&d(Cw(m)),a=()=>{d(Cw(m))},m.addEventListener("abort",a,{once:!0})}if(t===Number.POSITIVE_INFINITY){r.then(u,d);return}const f=new xE;o=s.setTimeout.call(void 0,()=>{if(n){try{u(n())}catch(m){d(m)}return}typeof r.cancel=="function"&&r.cancel(),i===!1?u():i instanceof Error?d(i):(f.message=i??`Promise timed out after ${t} milliseconds`,d(f))},t),(async()=>{try{u(await r)}catch(m){d(m)}})()}).finally(()=>{l.clear(),a&&e.signal&&e.signal.removeEventListener("abort",a)});return l.clear=()=>{s.clearTimeout.call(void 0,o),o=void 0},l}const Iw=lB(),Wg=Iw!=null&&Iw.name==="firefox",_E=async function*(){},CE=async r=>{};function mB(r,e,t=XO,n){r.readyState==="open"&&Promise.resolve().then(async()=>{if(r.bufferedAmount>0){n.log("%s drain channel with %d buffered bytes",e,r.bufferedAmount);const i=We();let s=!1;r.bufferedAmountLowThreshold=0;const o=()=>{s||(n.log("%s drain channel closed before drain",e),i.resolve())};r.addEventListener("close",o,{once:!0}),r.addEventListener("bufferedamountlow",()=>{s=!0,r.removeEventListener("close",o),i.resolve()}),await Hg(i.promise,{milliseconds:t})}}).then(async()=>{r.readyState==="open"&&r.close()}).catch(i=>{n.log.error("error closing outbound stream",i)})}async function kw(r){return r=r??{},typeof r=="function"&&(r=await r()),r.iceServers=r.iceServers??qO.map(e=>({urls:[e]})),r}const yB=(r=32)=>jO+[...Array(r)].map(()=>vw.at(Math.floor(Math.random()*vw.length))).join("");class _f{log;peerConnection;remoteAddr;timeline;metrics;source=_E();sink=CE;constructor(e,t){this.log=e.logger.forComponent("libp2p:webrtc:maconn"),this.remoteAddr=t.remoteAddr,this.timeline=t.timeline,this.peerConnection=t.peerConnection;const n=this.peerConnection,i=n.connectionState;this.peerConnection.onconnectionstatechange=()=>{this.log.trace("peer connection state change",n.connectionState,"initial state",i),(n.connectionState==="disconnected"||n.connectionState==="failed"||n.connectionState==="closed")&&(this.timeline.close=Date.now())}}async close(e){this.log.trace("closing connection"),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({close:!0})}abort(e){this.log.error("closing connection due to error",e),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({abort:!0})}}class wB extends zS{channel;incomingData;maxBufferedAmount;bufferedAmountLowEventTimeout;maxMessageSize;receiveFinAck;finAckTimeout;openTimeout;closeController;constructor(e){const t=e.onEnd;switch(e.onEnd=i=>{this.log.trace('readable and writeable ends closed with status "%s"',this.status),Promise.resolve(async()=>{if(!(this.timeline.abort!=null||this.timeline.reset!==null))try{await Hg(this.receiveFinAck.promise,{milliseconds:this.finAckTimeout})}catch(s){this.log.error("error receiving FIN_ACK",s)}}).then(()=>{this.incomingData.end(),t?.(i)}).catch(s=>{this.log.error("error ending stream",s)}).finally(()=>{this.channel.close()})},super(e),this.channel=e.channel,this.channel.binaryType="arraybuffer",this.incomingData=Ia(),this.bufferedAmountLowEventTimeout=e.bufferedAmountLowEventTimeout??WO,this.maxBufferedAmount=e.maxBufferedAmount??HO,this.maxMessageSize=(e.maxMessageSize??qu)-GO,this.receiveFinAck=We(),this.finAckTimeout=e.closeTimeout??YO,this.openTimeout=e.openTimeout??QO,this.closeController=new AbortController,this.channel.readyState){case"open":this.timeline.open=new Date().getTime();break;case"closed":case"closing":(this.timeline.close===void 0||this.timeline.close===0)&&(this.timeline.close=Date.now());break;case"connecting":break;default:throw this.log.error("unknown datachannel state %s",this.channel.readyState),new Qh("Unknown datachannel state")}this.channel.onopen=i=>{this.timeline.open=new Date().getTime()},this.channel.onclose=i=>{this.log.trace("received onclose event"),this.closeController.abort(),this.receiveFinAck.resolve(),this.close().catch(s=>{this.log.error("error closing stream after channel closed",s)})},this.channel.onerror=i=>{this.log.trace("received onerror event"),this.closeController.abort();const s=i.error;this.abort(s)},this.channel.onmessage=async i=>{const{data:s}=i;s===null||s.byteLength===0||this.incomingData.push(new Uint8Array(s,0,s.byteLength))};const n=this;Promise.resolve().then(async()=>{for await(const i of pl(this.incomingData)){const s=n.processIncomingProtobuf(i);s!=null&&n.sourcePush(new be(s))}}).catch(i=>{this.log.error("error processing incoming data channel messages",i)})}sendNewStream(){}async _sendMessage(e,t=!0){if(this.channel.readyState==="closed"||this.channel.readyState==="closing")throw new Qh(`Invalid datachannel state - ${this.channel.readyState}`);if(this.channel.readyState!=="open"){const n=AbortSignal.timeout(this.openTimeout),i=qr([this.closeController.signal,n]);try{this.log('channel state is "%s" and not "open", waiting for "open" event before sending data',this.channel.readyState),await Ei(this.channel,"open",i)}finally{i.clear()}this.log('channel state is now "%s", sending data',this.channel.readyState)}if(t&&this.channel.bufferedAmount>this.maxBufferedAmount){const n=AbortSignal.timeout(this.bufferedAmountLowEventTimeout),i=qr([this.closeController.signal,n]);try{this.log('channel buffer is %d, wait for "bufferedamountlow" event',this.channel.bufferedAmount),await Ei(this.channel,"bufferedamountlow",i)}catch(s){throw n.aborted?new lg(`Timed out waiting for DataChannel buffer to clear after ${this.bufferedAmountLowEventTimeout}ms`):s}finally{i.clear()}}try{this.log.trace('sending message, channel state "%s"',this.channel.readyState),this.channel.send(e.subarray())}catch(n){this.log.error("error while sending message",n)}}async sendData(e){const t=e.byteLength;for(e=e.sublist();e.byteLength>0;){const n=Math.min(e.byteLength,this.maxMessageSize),i=e.subarray(0,n),s=Dt.encode({message:i}),o=fl.single(s);this.log.trace("sending %d/%d bytes on channel",i.byteLength,t),await this._sendMessage(o),e.consume(n)}this.log.trace('finished sending data, channel state "%s"',this.channel.readyState)}async sendReset(){try{await this._sendFlag(Dt.Flag.RESET)}catch(e){this.log.error("failed to send reset - %e",e)}finally{this.channel.close()}}async sendCloseWrite(e){if(this.channel.readyState!=="open"){this.receiveFinAck.resolve();return}if(await this._sendFlag(Dt.Flag.FIN)){this.log.trace("awaiting FIN_ACK");try{await sr(this.receiveFinAck.promise,e?.signal,{errorMessage:"sending close-write was aborted before FIN_ACK was received",errorName:"FinAckNotReceivedError"})}catch(n){this.log.error("failed to await FIN_ACK",n)}}else this.log.trace("sending FIN failed, not awaiting FIN_ACK");this.receiveFinAck.resolve()}async sendCloseRead(){this.channel.readyState==="open"&&await this._sendFlag(Dt.Flag.STOP_SENDING)}processIncomingProtobuf(e){const t=Dt.decode(e);if(t.flag!==void 0&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',t.flag,this.writeStatus,this.readStatus),t.flag===Dt.Flag.FIN&&(this.remoteCloseWrite(),this.log.trace("sending FIN_ACK"),this._sendFlag(Dt.Flag.FIN_ACK).catch(n=>{this.log.error("error sending FIN_ACK immediately",n)})),t.flag===Dt.Flag.RESET&&this.reset(),t.flag===Dt.Flag.STOP_SENDING&&this.remoteCloseRead(),t.flag===Dt.Flag.FIN_ACK&&(this.log.trace("received FIN_ACK"),this.receiveFinAck.resolve())),this.readStatus==="ready")return t.message}async _sendFlag(e){if(this.channel.readyState!=="open")return this.log.trace('not sending flag %s because channel is "%s" and not "open"',e.toString(),this.channel.readyState),!1;this.log.trace("sending flag %s",e.toString());const t=Dt.encode({flag:e}),n=fl.single(t);try{return await this._sendMessage(n,!1),!0}catch(i){this.log.error("could not send flag %s - %e",e.toString(),i)}return!1}}function Rl(r){const{channel:e,direction:t,handshake:n}=r;return new wB({id:`${e.id}`,log:r.logger.forComponent(`libp2p:webrtc:stream:${n===!0?"handshake":t}:${e.id}`),...r})}class Kg{protocol;peerConnection;bufferedStreams=[];metrics;dataChannelOptions;components;log;constructor(e,t){this.components=e,this.peerConnection=t.peerConnection,this.metrics=t.metrics,this.protocol=t.protocol??AE,this.dataChannelOptions=t.dataChannelOptions??{},this.log=e.logger.forComponent("libp2p:webrtc:muxerfactory"),this.peerConnection.ondatachannel=({channel:n})=>{if(this.log.trace('incoming early datachannel with channel id %d and label "%s"',n.id),n.label==="init"){this.log.trace("closing early init channel"),n.close();return}const i={},s=Rl({channel:n,direction:"inbound",onEnd:o=>{i.onEnd(o)},logger:e.logger,...this.dataChannelOptions});i.stream=s,i.channel=n,i.onEnd=()=>{this.bufferedStreams=this.bufferedStreams.filter(o=>o.stream.id!==s.id)},this.bufferedStreams.push(i)}}createStreamMuxer(e){return new bB(this.components,{...e,peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,streams:this.bufferedStreams,protocol:this.protocol})}}class bB{init;streams;protocol;log;peerConnection;dataChannelOptions;metrics;logger;constructor(e,t){this.init=t,this.log=e.logger.forComponent("libp2p:webrtc:muxer"),this.logger=e.logger,this.streams=t.streams.map(n=>n.stream),this.peerConnection=t.peerConnection,this.protocol=t.protocol??AE,this.metrics=t.metrics,this.dataChannelOptions=t.dataChannelOptions??{},this.peerConnection.ondatachannel=({channel:n})=>{if(this.log.trace("incoming datachannel with channel id %d",n.id),n.label==="init"){this.log.trace("closing init channel"),n.close();return}const i=n.id,s=Rl({channel:n,direction:"inbound",onEnd:()=>{this.#e(s,n),this.log("incoming channel %s ended",i)},logger:this.logger,...this.dataChannelOptions});this.streams.push(s),this.metrics?.increment({incoming_stream:!0}),t?.onIncomingStream?.(s)},this.init.streams.length>0&&queueMicrotask(()=>{this.init.streams.forEach(n=>{n.onEnd=()=>{this.log("incoming early channel %s ended with state %s",n.channel.id,n.channel.readyState),this.#e(n.stream,n.channel)},this.metrics?.increment({incoming_stream:!0}),this.init?.onIncomingStream?.(n.stream)})})}#e(e,t){this.log.trace("stream %s %s %s onEnd",e.direction,e.id,e.protocol),mB(t,`${e.direction} ${e.id} ${e.protocol}`,this.dataChannelOptions.drainTimeout,{log:this.log}),this.streams=this.streams.filter(n=>n.id!==e.id),this.metrics?.increment({stream_end:!0}),this.init?.onStreamEnd?.(e)}async close(e){try{await Promise.all(this.streams.map(async t=>t.close(e)))}catch(t){this.abort(t)}}abort(e){for(const t of this.streams)t.abort(e)}source=_E();sink=CE;newStream(){const e=this.peerConnection.createDataChannel(""),t=e.id;this.log.trace("opened outgoing datachannel with channel id %s",t);const n=Rl({channel:e,direction:"outbound",onEnd:()=>{this.#e(n,e),this.log("outgoing channel %s ended",t)},logger:this.logger,...this.dataChannelOptions});return this.streams.push(n),this.metrics?.increment({outgoing_stream:!0}),n}}const IE=globalThis.RTCPeerConnection,kE=globalThis.RTCSessionDescription,vB=globalThis.RTCIceCandidate;class Na extends Error{constructor(e){super(`WebRTC transport error: ${e}`),this.name="WebRTCTransportError"}}class Tn extends Na{constructor(e="SDP handshake failed"){super(e),this.name="SDPHandshakeFailedError"}}class SB extends Na{constructor(e,t){super(`Invalid fingerprint "${e}" within ${t}`),this.name="WebRTC/InvalidFingerprintError"}}class EB extends Na{constructor(e){super(`A method (${e}) was called though it has been intentionally left unimplemented.`),this.name="WebRTC/UnimplementedError"}}class AB extends Na{constructor(e){super(`unsupported hash algorithm code: ${e} please see the codes at https://github.com/multiformats/multicodec/blob/master/table.csv `),this.name="WebRTC/UnsupportedHashAlgorithmError"}}var Ar;(function(r){(function(n){n.SDP_OFFER="SDP_OFFER",n.SDP_ANSWER="SDP_ANSWER",n.ICE_CANDIDATE="ICE_CANDIDATE"})(r.Type||(r.Type={}));let e;(function(n){n[n.SDP_OFFER=0]="SDP_OFFER",n[n.SDP_ANSWER=1]="SDP_ANSWER",n[n.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(e||(e={})),function(n){n.codec=()=>ln(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=De((n,i,s={})=>{s.lengthDelimited!==!1&&i.fork(),n.type!=null&&(i.uint32(8),r.Type.codec().encode(n.type,i)),n.data!=null&&(i.uint32(18),i.string(n.data)),s.lengthDelimited!==!1&&i.ldelim()},(n,i,s={})=>{const o={},a=i==null?n.len:n.pos+i;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.data=n.string();break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>Ne(n,r.codec()),r.decode=(n,i)=>Be(n,r.codec(),i)})(Ar||(Ar={}));const TE=async(r,e,t)=>{try{const n=We();for(xB(r,n);;){const i=await Promise.race([n.promise,e.read({signal:t.signal}).catch(()=>{})]);if(i==null){t.signal?.throwIfAborted();break}if(i.type!==Ar.Type.ICE_CANDIDATE)throw new Et("ICE candidate message expected");const s=JSON.parse(i.data??"null");if(s===""||s===null){t.onProgress?.(new Re("webrtc:end-of-ice-candidates")),t.log.trace("end-of-candidates received");continue}const o=new vB(s);t.log.trace("%s received new ICE candidate %o",t.direction,s);try{t.onProgress?.(new Re("webrtc:add-ice-candidate",o.candidate)),await r.addIceCandidate(o)}catch(a){t.log.error("%s bad candidate received",t.direction,s,a)}}}catch(n){if(t.log.error("%s error parsing ICE candidate",t.direction,n),t.signal?.aborted===!0&&Gg(r)!=="connected")throw n}};function Gg(r){return Wg?r.iceConnectionState:r.connectionState}function xB(r,e){r[Wg?"oniceconnectionstatechange":"onconnectionstatechange"]=t=>{switch(Gg(r)){case"connected":e.resolve();break;case"failed":case"disconnected":case"closed":e.reject(new wv("RTCPeerConnection was closed"));break}}}async function _B({rtcConfiguration:r,dataChannel:e,signal:t,metrics:n,multiaddr:i,connectionManager:s,transportManager:o,log:a,logger:c,onProgress:l}){const{baseAddr:u}=kB(i);n?.dialerEvents.increment({open:!0}),a.trace("dialing base address: %a",u);const d=u.getPeerId();if(d==null)throw new le("Relay peer was missing");const f=s.getConnections(Ir(d));let m,g=!1;f.length===0?(l?.(new Re("webrtc:dial-relay")),m=await o.dial(u,{signal:t,onProgress:l}),g=!0):(l?.(new Re("webrtc:reuse-relay-connection")),m=f[0]);try{l?.(new Re("webrtc:open-signaling-stream"));const y=await m.newStream(xf,{signal:t,runOnLimitedConnection:!0}),w=Jt(y).pb(Ar),x=new IE(r),T=new Kg({logger:c},{peerConnection:x,dataChannelOptions:e});try{const v=x.createDataChannel("init");x.onicecandidate=({candidate:C})=>{const P=JSON.stringify(C?.toJSON()??null);a.trace("initiator sending ICE candidate %o",C),w.write({type:Ar.Type.ICE_CANDIDATE,data:P},{signal:t}).catch(D=>{a.error("error sending ICE candidate",D)})},x.onicecandidateerror=C=>{a.error("initiator ICE candidate error",C)};const b=await x.createOffer().catch(C=>{throw a.error("could not execute createOffer",C),new Tn("Failed to set createOffer")});a.trace("initiator send SDP offer %s",b.sdp),l?.(new Re("webrtc:send-sdp-offer")),await w.write({type:Ar.Type.SDP_OFFER,data:b.sdp},{signal:t}),await x.setLocalDescription(b).catch(C=>{throw a.error("could not execute setLocalDescription",C),new Tn("Failed to set localDescription")}),l?.(new Re("webrtc:read-sdp-answer")),a.trace("initiator read SDP answer");const A=await w.read({signal:t});if(A.type!==Ar.Type.SDP_ANSWER)throw new Tn("Remote should send an SDP answer");a.trace("initiator received SDP answer %s",A.data);const R=new kE({type:"answer",sdp:A.data});return await x.setRemoteDescription(R).catch(C=>{throw a.error("could not execute setRemoteDescription",C),new Tn("Failed to set remoteDescription")}),a.trace("initiator read candidates until connected"),l?.(new Re("webrtc:read-ice-candidates")),await TE(x,w,{direction:"initiator",signal:t,log:a,onProgress:l}),a.trace("initiator connected, closing init channel"),v.close(),l?.(new Re("webrtc:close-signaling-stream")),a.trace("closing signaling channel"),await y.close({signal:t}),a.trace("initiator connected to remote address %s",i),{remoteAddress:i,peerConnection:x,muxerFactory:T}}catch(v){throw a.error("outgoing signaling error",v),x.close(),y.abort(v),v}finally{x.onicecandidate=null,x.onicecandidateerror=null}}finally{if(g)try{await m.close({signal:t})}catch(y){m.abort(y)}}}const Tw=Ue(dE.matchers[0],pe("p2p-circuit"));class Yg extends $r{transportManager;shutdownController;events;constructor(e,t){super(),this.transportManager=e.transportManager,this.events=e.events,this.shutdownController=t.shutdownController,this.onTransportListening=this.onTransportListening.bind(this)}async listen(){this.events.addEventListener("transport:listening",this.onTransportListening)}onTransportListening(e){e.detail.getAddrs().filter(n=>Tw.exactMatch(n)).map(n=>n.encapsulate("/webrtc")).length>0&&this.safeDispatchEvent("listening")}getAddrs(){return this.transportManager.getListeners().filter(e=>!(e instanceof Yg)).map(e=>e.getAddrs().filter(t=>Tw.exactMatch(t)).map(t=>t.encapsulate("/webrtc"))).flat()}updateAnnounceAddrs(){}async close(){this.events.removeEventListener("transport:listening",this.onTransportListening),this.shutdownController.abort(),queueMicrotask(()=>{this.safeDispatchEvent("close")})}}async function CB({peerConnection:r,stream:e,signal:t,connection:n,log:i}){i.trace("new inbound signaling stream");const s=Jt(e).pb(Ar);try{r.onicecandidate=({candidate:u})=>{const d=JSON.stringify(u?.toJSON()??null);i.trace("recipient sending ICE candidate %s",d),s.write({type:Ar.Type.ICE_CANDIDATE,data:d},{signal:t}).catch(f=>{i.error("error sending ICE candidate",f)})},i.trace("recipient read SDP offer");const a=await s.read({signal:t});if(a.type!==Ar.Type.SDP_OFFER)throw new Tn(`expected message type SDP_OFFER, received: ${a.type??"undefined"} `);i.trace("recipient received SDP offer %s",a.data);const c=new kE({type:"offer",sdp:a.data});await r.setRemoteDescription(c).catch(u=>{throw i.error("could not execute setRemoteDescription",u),new Tn("Failed to set remoteDescription")});const l=await r.createAnswer().catch(u=>{throw i.error("could not execute createAnswer",u),new Tn("Failed to create answer")});i.trace("recipient send SDP answer %s",l.sdp),await s.write({type:Ar.Type.SDP_ANSWER,data:l.sdp},{signal:t}),await r.setLocalDescription(l).catch(u=>{throw i.error("could not execute setLocalDescription",u),new Tn("Failed to set localDescription")}),i.trace("recipient read candidates until connected"),await TE(r,s,{direction:"recipient",signal:t,log:i})}catch(a){if(Gg(r)!=="connected")throw i.error("error while handling signaling stream from peer %a",n.remoteAddr,a),r.close(),a;i("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",n.remoteAddr,a)}const o=he(`/webrtc/p2p/${n.remoteAddr.getPeerId()}`);return i.trace("recipient connected to remote address %s",o),{remoteAddress:o}}class IB{components;init;log;_started=!1;metrics;shutdownController;constructor(e,t={}){this.components=e,this.init=t,this.log=e.logger.forComponent("libp2p:webrtc"),this.shutdownController=new AbortController,this.shutdownController.signal,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}[Eu]=!0;[Symbol.toStringTag]="@libp2p/webrtc";[Zt]=["@libp2p/transport"];[As]=["@libp2p/identify","@libp2p/circuit-relay-v2-transport"];isStarted(){return this._started}async start(){await this.components.registrar.handle(xf,e=>{const t=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);this._onProtocol(e,t).catch(n=>{this.log.error("failed to handle incoming connect from %p",e.connection.remotePeer,n)}).finally(()=>{t.clear()})},{runOnLimitedConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(xf),this._started=!1}createListener(e){return new Yg(this.components,{shutdownController:this.shutdownController})}listenFilter(e){return e.filter(Sf.exactMatch)}dialFilter(e){return this.listenFilter(e)}async dial(e,t){this.log.trace("dialing address: %a",e);const{remoteAddress:n,peerConnection:i,muxerFactory:s}=await _B({rtcConfiguration:await kw(this.init.rtcConfiguration),dataChannel:this.init.dataChannel,multiaddr:e,dataChannelOptions:this.init.dataChannel,signal:t.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager,log:this.log,logger:this.components.logger,onProgress:t.onProgress}),o=new _f(this.components,{peerConnection:i,timeline:{open:Date.now()},remoteAddr:n,metrics:this.metrics?.dialerEvents}),a=await t.upgrader.upgradeOutbound(o,{skipProtection:!0,skipEncryption:!0,muxerFactory:s,onProgress:t.onProgress,signal:t.signal});return this._closeOnShutdown(i,o),a}async _onProtocol({connection:e,stream:t},n){const i=new IE(await kw(this.init.rtcConfiguration)),s=new Kg(this.components,{peerConnection:i,dataChannelOptions:this.init.dataChannel});try{const{remoteAddress:o}=await CB({peerConnection:i,connection:e,stream:t,signal:n,log:this.log});await t.close({signal:n});const a=new _f(this.components,{peerConnection:i,timeline:{open:new Date().getTime()},remoteAddr:o,metrics:this.metrics?.listenerEvents});await this.components.upgrader.upgradeInbound(a,{skipEncryption:!0,skipProtection:!0,muxerFactory:s,signal:n}),this._closeOnShutdown(i,a)}catch(o){throw this.log.error("incoming signaling error",o),i.close(),t.abort(o),o}}_closeOnShutdown(e,t){const n=()=>{t.close().catch(i=>{this.log.error("could not close WebRTCMultiaddrConnection",i)})};this.shutdownController.signal.addEventListener("abort",n),e.addEventListener("close",()=>{this.shutdownController.signal.removeEventListener("abort",n)})}}function kB(r){const e=r.toString().split("/webrtc/");if(e.length!==2)throw new le("webrtc protocol was not present in multiaddr");if(!e[0].includes("/p2p-circuit"))throw new le("p2p-circuit protocol was not present in multiaddr");let t=he(e[0]);const i=he("/"+e[1]).getPeerId();if(i==null)throw new le("destination peer id was missing");const s=t.protos().pop();if(s===void 0)throw new le("invalid multiaddr");return s.name!=="p2p"&&(t=t.encapsulate(`/p2p/${i}`)),{baseAddr:t,peerId:Ir(i)}}var Pw={};/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */var Rw;function TB(){if(Rw)return Pw;Rw=1;var r;return function(e){(function(t){var n=typeof globalThis=="object"?globalThis:typeof ww=="object"?ww:typeof self=="object"?self:typeof this=="object"?this:c(),i=s(e);typeof n.Reflect<"u"&&(i=s(n.Reflect,i)),t(i,n),typeof n.Reflect>"u"&&(n.Reflect=e);function s(l,u){return function(d,f){Object.defineProperty(l,d,{configurable:!0,writable:!0,value:f}),u&&u(d,f)}}function o(){try{return Function("return this;")()}catch{}}function a(){try{return(0,eval)("(function() { return this; })()")}catch{}}function c(){return o()||a()}})(function(t,n){var i=Object.prototype.hasOwnProperty,s=typeof Symbol=="function",o=s&&typeof Symbol.toPrimitive<"u"?Symbol.toPrimitive:"@@toPrimitive",a=s&&typeof Symbol.iterator<"u"?Symbol.iterator:"@@iterator",c=typeof Object.create=="function",l={__proto__:[]}instanceof Array,u=!c&&!l,d={create:c?function(){return Fd(Object.create(null))}:l?function(){return Fd({__proto__:null})}:function(){return Fd({})},has:u?function(_,I){return i.call(_,I)}:function(_,I){return I in _},get:u?function(_,I){return i.call(_,I)?_[I]:void 0}:function(_,I){return _[I]}},f=Object.getPrototypeOf(Function),m=typeof Map=="function"&&typeof Map.prototype.entries=="function"?Map:r_(),g=typeof Set=="function"&&typeof Set.prototype.entries=="function"?Set:n_(),y=typeof WeakMap=="function"?WeakMap:i_(),w=s?Symbol.for("@reflect-metadata:registry"):void 0,x=Jx(),T=e_(x);function v(_,I,O,K){if(F(O)){if(!Ge(_))throw new TypeError;if(!mt(I))throw new TypeError;return q(_,I)}else{if(!Ge(_))throw new TypeError;if(!re(I))throw new TypeError;if(!re(K)&&!F(K)&&!ae(K))throw new TypeError;return ae(K)&&(K=void 0),O=Fe(O),ie(_,I,O,K)}}t("decorate",v);function b(_,I){function O(K,ce){if(!re(K))throw new TypeError;if(!F(ce)&&!zt(ce))throw new TypeError;E(_,I,K,ce)}return O}t("metadata",b);function A(_,I,O,K){if(!re(O))throw new TypeError;return F(K)||(K=Fe(K)),E(_,I,O,K)}t("defineMetadata",A);function R(_,I,O){if(!re(I))throw new TypeError;return F(O)||(O=Fe(O)),N(_,I,O)}t("hasMetadata",R);function C(_,I,O){if(!re(I))throw new TypeError;return F(O)||(O=Fe(O)),L(_,I,O)}t("hasOwnMetadata",C);function P(_,I,O){if(!re(I))throw new TypeError;return F(O)||(O=Fe(O)),H(_,I,O)}t("getMetadata",P);function D(_,I,O){if(!re(I))throw new TypeError;return F(O)||(O=Fe(O)),B(_,I,O)}t("getOwnMetadata",D);function z(_,I){if(!re(_))throw new TypeError;return F(I)||(I=Fe(I)),k(_,I)}t("getMetadataKeys",z);function $(_,I){if(!re(_))throw new TypeError;return F(I)||(I=Fe(I)),M(_,I)}t("getOwnMetadataKeys",$);function j(_,I,O){if(!re(I))throw new TypeError;if(F(O)||(O=Fe(O)),!re(I))throw new TypeError;F(O)||(O=Fe(O));var K=bo(I,O,!1);return F(K)?!1:K.OrdinaryDeleteMetadata(_,I,O)}t("deleteMetadata",j);function q(_,I){for(var O=_.length-1;O>=0;--O){var K=_[O],ce=K(I);if(!F(ce)&&!ae(ce)){if(!mt(ce))throw new TypeError;I=ce}}return I}function ie(_,I,O,K){for(var ce=_.length-1;ce>=0;--ce){var Qe=_[ce],rt=Qe(I,O,K);if(!F(rt)&&!ae(rt)){if(!re(rt))throw new TypeError;K=rt}}return K}function N(_,I,O){var K=L(_,I,O);if(K)return!0;var ce=Ud(I);return ae(ce)?!1:N(_,ce,O)}function L(_,I,O){var K=bo(I,O,!1);return F(K)?!1:ve(K.OrdinaryHasOwnMetadata(_,I,O))}function H(_,I,O){var K=L(_,I,O);if(K)return B(_,I,O);var ce=Ud(I);if(!ae(ce))return H(_,ce,O)}function B(_,I,O){var K=bo(I,O,!1);if(!F(K))return K.OrdinaryGetOwnMetadata(_,I,O)}function E(_,I,O,K){var ce=bo(O,K,!0);ce.OrdinaryDefineOwnMetadata(_,I,O,K)}function k(_,I){var O=M(_,I),K=Ud(_);if(K===null)return O;var ce=k(K,I);if(ce.length<=0)return O;if(O.length<=0)return ce;for(var Qe=new g,rt=[],me=0,Q=O;me<Q.length;me++){var J=Q[me],te=Qe.has(J);te||(Qe.add(J),rt.push(J))}for(var ne=0,ye=ce;ne<ye.length;ne++){var J=ye[ne],te=Qe.has(J);te||(Qe.add(J),rt.push(J))}return rt}function M(_,I){var O=bo(_,I,!1);return O?O.OrdinaryOwnMetadataKeys(_,I):[]}function W(_){if(_===null)return 1;switch(typeof _){case"undefined":return 0;case"boolean":return 2;case"string":return 3;case"symbol":return 4;case"number":return 5;case"object":return _===null?1:6;default:return 6}}function F(_){return _===void 0}function ae(_){return _===null}function ue(_){return typeof _=="symbol"}function re(_){return typeof _=="object"?_!==null:typeof _=="function"}function fe(_,I){switch(W(_)){case 0:return _;case 1:return _;case 2:return _;case 3:return _;case 4:return _;case 5:return _}var O="string",K=wo(_,o);if(K!==void 0){var ce=K.call(_,O);if(re(ce))throw new TypeError;return ce}return Ae(_)}function Ae(_,I){var O,K,ce;{var Qe=_.toString;if(Ye(Qe)){var K=Qe.call(_);if(!re(K))return K}var O=_.valueOf;if(Ye(O)){var K=O.call(_);if(!re(K))return K}}throw new TypeError}function ve(_){return!!_}function tt(_){return""+_}function Fe(_){var I=fe(_);return ue(I)?I:tt(I)}function Ge(_){return Array.isArray?Array.isArray(_):_ instanceof Object?_ instanceof Array:Object.prototype.toString.call(_)==="[object Array]"}function Ye(_){return typeof _=="function"}function mt(_){return typeof _=="function"}function zt(_){switch(W(_)){case 3:return!0;case 4:return!0;default:return!1}}function Kr(_,I){return _===I||_!==_&&I!==I}function wo(_,I){var O=_[I];if(O!=null){if(!Ye(O))throw new TypeError;return O}}function tc(_){var I=wo(_,a);if(!Ye(I))throw new TypeError;var O=I.call(_);if(!re(O))throw new TypeError;return O}function rc(_){return _.value}function nc(_){var I=_.next();return I.done?!1:I}function ic(_){var I=_.return;I&&I.call(_)}function Ud(_){var I=Object.getPrototypeOf(_);if(typeof _!="function"||_===f||I!==f)return I;var O=_.prototype,K=O&&Object.getPrototypeOf(O);if(K==null||K===Object.prototype)return I;var ce=K.constructor;return typeof ce!="function"||ce===_?I:ce}function Zx(){var _;!F(w)&&typeof n.Reflect<"u"&&!(w in n.Reflect)&&typeof n.Reflect.defineMetadata=="function"&&(_=t_(n.Reflect));var I,O,K,ce=new y,Qe={registerProvider:rt,getProvider:Q,setProvider:te};return Qe;function rt(ne){if(!Object.isExtensible(Qe))throw new Error("Cannot add provider to a frozen registry.");switch(!0){case _===ne:break;case F(I):I=ne;break;case I===ne:break;case F(O):O=ne;break;case O===ne:break;default:K===void 0&&(K=new g),K.add(ne);break}}function me(ne,ye){if(!F(I)){if(I.isProviderFor(ne,ye))return I;if(!F(O)){if(O.isProviderFor(ne,ye))return I;if(!F(K))for(var $e=tc(K);;){var Xe=nc($e);if(!Xe)return;var mr=rc(Xe);if(mr.isProviderFor(ne,ye))return ic($e),mr}}}if(!F(_)&&_.isProviderFor(ne,ye))return _}function Q(ne,ye){var $e=ce.get(ne),Xe;return F($e)||(Xe=$e.get(ye)),F(Xe)&&(Xe=me(ne,ye),F(Xe)||(F($e)&&($e=new m,ce.set(ne,$e)),$e.set(ye,Xe))),Xe}function J(ne){if(F(ne))throw new TypeError;return I===ne||O===ne||!F(K)&&K.has(ne)}function te(ne,ye,$e){if(!J($e))throw new Error("Metadata provider not registered.");var Xe=Q(ne,ye);if(Xe!==$e){if(!F(Xe))return!1;var mr=ce.get(ne);F(mr)&&(mr=new m,ce.set(ne,mr)),mr.set(ye,$e)}return!0}}function Jx(){var _;return!F(w)&&re(n.Reflect)&&Object.isExtensible(n.Reflect)&&(_=n.Reflect[w]),F(_)&&(_=Zx()),!F(w)&&re(n.Reflect)&&Object.isExtensible(n.Reflect)&&Object.defineProperty(n.Reflect,w,{enumerable:!1,configurable:!1,writable:!1,value:_}),_}function e_(_){var I=new y,O={isProviderFor:function(J,te){var ne=I.get(J);return F(ne)?!1:ne.has(te)},OrdinaryDefineOwnMetadata:rt,OrdinaryHasOwnMetadata:ce,OrdinaryGetOwnMetadata:Qe,OrdinaryOwnMetadataKeys:me,OrdinaryDeleteMetadata:Q};return x.registerProvider(O),O;function K(J,te,ne){var ye=I.get(J),$e=!1;if(F(ye)){if(!ne)return;ye=new m,I.set(J,ye),$e=!0}var Xe=ye.get(te);if(F(Xe)){if(!ne)return;if(Xe=new m,ye.set(te,Xe),!_.setProvider(J,te,O))throw ye.delete(te),$e&&I.delete(J),new Error("Wrong provider for target.")}return Xe}function ce(J,te,ne){var ye=K(te,ne,!1);return F(ye)?!1:ve(ye.has(J))}function Qe(J,te,ne){var ye=K(te,ne,!1);if(!F(ye))return ye.get(J)}function rt(J,te,ne,ye){var $e=K(ne,ye,!0);$e.set(J,te)}function me(J,te){var ne=[],ye=K(J,te,!1);if(F(ye))return ne;for(var $e=ye.keys(),Xe=tc($e),mr=0;;){var oy=nc(Xe);if(!oy)return ne.length=mr,ne;var s_=rc(oy);try{ne[mr]=s_}catch(o_){try{ic(Xe)}finally{throw o_}}mr++}}function Q(J,te,ne){var ye=K(te,ne,!1);if(F(ye)||!ye.delete(J))return!1;if(ye.size===0){var $e=I.get(te);F($e)||($e.delete(ne),$e.size===0&&I.delete($e))}return!0}}function t_(_){var I=_.defineMetadata,O=_.hasOwnMetadata,K=_.getOwnMetadata,ce=_.getOwnMetadataKeys,Qe=_.deleteMetadata,rt=new y,me={isProviderFor:function(Q,J){var te=rt.get(Q);return!F(te)&&te.has(J)?!0:ce(Q,J).length?(F(te)&&(te=new g,rt.set(Q,te)),te.add(J),!0):!1},OrdinaryDefineOwnMetadata:I,OrdinaryHasOwnMetadata:O,OrdinaryGetOwnMetadata:K,OrdinaryOwnMetadataKeys:ce,OrdinaryDeleteMetadata:Qe};return me}function bo(_,I,O){var K=x.getProvider(_,I);if(!F(K))return K;if(O){if(x.setProvider(_,I,T))return T;throw new Error("Illegal state.")}}function r_(){var _={},I=[],O=function(){function me(Q,J,te){this._index=0,this._keys=Q,this._values=J,this._selector=te}return me.prototype["@@iterator"]=function(){return this},me.prototype[a]=function(){return this},me.prototype.next=function(){var Q=this._index;if(Q>=0&&Q<this._keys.length){var J=this._selector(this._keys[Q],this._values[Q]);return Q+1>=this._keys.length?(this._index=-1,this._keys=I,this._values=I):this._index++,{value:J,done:!1}}return{value:void 0,done:!0}},me.prototype.throw=function(Q){throw this._index>=0&&(this._index=-1,this._keys=I,this._values=I),Q},me.prototype.return=function(Q){return this._index>=0&&(this._index=-1,this._keys=I,this._values=I),{value:Q,done:!0}},me}(),K=function(){function me(){this._keys=[],this._values=[],this._cacheKey=_,this._cacheIndex=-2}return Object.defineProperty(me.prototype,"size",{get:function(){return this._keys.length},enumerable:!0,configurable:!0}),me.prototype.has=function(Q){return this._find(Q,!1)>=0},me.prototype.get=function(Q){var J=this._find(Q,!1);return J>=0?this._values[J]:void 0},me.prototype.set=function(Q,J){var te=this._find(Q,!0);return this._values[te]=J,this},me.prototype.delete=function(Q){var J=this._find(Q,!1);if(J>=0){for(var te=this._keys.length,ne=J+1;ne<te;ne++)this._keys[ne-1]=this._keys[ne],this._values[ne-1]=this._values[ne];return this._keys.length--,this._values.length--,Kr(Q,this._cacheKey)&&(this._cacheKey=_,this._cacheIndex=-2),!0}return!1},me.prototype.clear=function(){this._keys.length=0,this._values.length=0,this._cacheKey=_,this._cacheIndex=-2},me.prototype.keys=function(){return new O(this._keys,this._values,ce)},me.prototype.values=function(){return new O(this._keys,this._values,Qe)},me.prototype.entries=function(){return new O(this._keys,this._values,rt)},me.prototype["@@iterator"]=function(){return this.entries()},me.prototype[a]=function(){return this.entries()},me.prototype._find=function(Q,J){if(!Kr(this._cacheKey,Q)){this._cacheIndex=-1;for(var te=0;te<this._keys.length;te++)if(Kr(this._keys[te],Q)){this._cacheIndex=te;break}}return this._cacheIndex<0&&J&&(this._cacheIndex=this._keys.length,this._keys.push(Q),this._values.push(void 0)),this._cacheIndex},me}();return K;function ce(me,Q){return me}function Qe(me,Q){return Q}function rt(me,Q){return[me,Q]}}function n_(){var _=function(){function I(){this._map=new m}return Object.defineProperty(I.prototype,"size",{get:function(){return this._map.size},enumerable:!0,configurable:!0}),I.prototype.has=function(O){return this._map.has(O)},I.prototype.add=function(O){return this._map.set(O,O),this},I.prototype.delete=function(O){return this._map.delete(O)},I.prototype.clear=function(){this._map.clear()},I.prototype.keys=function(){return this._map.keys()},I.prototype.values=function(){return this._map.keys()},I.prototype.entries=function(){return this._map.entries()},I.prototype["@@iterator"]=function(){return this.keys()},I.prototype[a]=function(){return this.keys()},I}();return _}function i_(){var _=16,I=d.create(),O=K();return function(){function Q(){this._key=K()}return Q.prototype.has=function(J){var te=ce(J,!1);return te!==void 0?d.has(te,this._key):!1},Q.prototype.get=function(J){var te=ce(J,!1);return te!==void 0?d.get(te,this._key):void 0},Q.prototype.set=function(J,te){var ne=ce(J,!0);return ne[this._key]=te,this},Q.prototype.delete=function(J){var te=ce(J,!1);return te!==void 0?delete te[this._key]:!1},Q.prototype.clear=function(){this._key=K()},Q}();function K(){var Q;do Q="@@WeakMap@@"+me();while(d.has(I,Q));return I[Q]=!0,Q}function ce(Q,J){if(!i.call(Q,O)){if(!J)return;Object.defineProperty(Q,O,{value:d.create()})}return Q[O]}function Qe(Q,J){for(var te=0;te<J;++te)Q[te]=Math.random()*255|0;return Q}function rt(Q){if(typeof Uint8Array=="function"){var J=new Uint8Array(Q);return typeof crypto<"u"?crypto.getRandomValues(J):typeof msCrypto<"u"?msCrypto.getRandomValues(J):Qe(J,Q),J}return Qe(new Array(Q),Q)}function me(){var Q=rt(_);Q[6]=Q[6]&79|64,Q[8]=Q[8]&191|128;for(var J="",te=0;te<_;++te){var ne=Q[te];(te===4||te===6||te===8)&&(J+="-"),ne<16&&(J+="0"),J+=ne.toString(16).toLowerCase()}return J}}function Fd(_){return _.__=void 0,delete _.__,_}})}(r||(r={})),Pw}TB();/*!
 * MIT License
 * 
 * Copyright (c) 2017-2024 Peculiar Ventures, LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */const PB="[object ArrayBuffer]";class Y{static isArrayBuffer(e){return Object.prototype.toString.call(e)===PB}static toArrayBuffer(e){return this.isArrayBuffer(e)?e:e.byteLength===e.buffer.byteLength||e.byteOffset===0&&e.byteLength===e.buffer.byteLength?e.buffer:this.toUint8Array(e.buffer).slice(e.byteOffset,e.byteOffset+e.byteLength).buffer}static toUint8Array(e){return this.toView(e,Uint8Array)}static toView(e,t){if(e.constructor===t)return e;if(this.isArrayBuffer(e))return new t(e);if(this.isArrayBufferView(e))return new t(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(e){return this.isArrayBufferView(e)||this.isArrayBuffer(e)}static isArrayBufferView(e){return ArrayBuffer.isView(e)||e&&this.isArrayBuffer(e.buffer)}static isEqual(e,t){const n=Y.toUint8Array(e),i=Y.toUint8Array(t);if(n.length!==i.byteLength)return!1;for(let s=0;s<n.length;s++)if(n[s]!==i[s])return!1;return!0}static concat(...e){let t;Array.isArray(e[0])&&!(e[1]instanceof Function)||Array.isArray(e[0])&&e[1]instanceof Function?t=e[0]:e[e.length-1]instanceof Function?t=e.slice(0,e.length-1):t=e;let n=0;for(const o of t)n+=o.byteLength;const i=new Uint8Array(n);let s=0;for(const o of t){const a=this.toUint8Array(o);i.set(a,s),s+=a.length}return e[e.length-1]instanceof Function?this.toView(i,e[e.length-1]):i.buffer}}const lh="string",RB=/^[0-9a-f\s]+$/i,OB=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,BB=/^[a-zA-Z0-9-_]+$/;class Ow{static fromString(e){const t=unescape(encodeURIComponent(e)),n=new Uint8Array(t.length);for(let i=0;i<t.length;i++)n[i]=t.charCodeAt(i);return n.buffer}static toString(e){const t=Y.toUint8Array(e);let n="";for(let s=0;s<t.length;s++)n+=String.fromCharCode(t[s]);return decodeURIComponent(escape(n))}}class Br{static toString(e,t=!1){const n=Y.toArrayBuffer(e),i=new DataView(n);let s="";for(let o=0;o<n.byteLength;o+=2){const a=i.getUint16(o,t);s+=String.fromCharCode(a)}return s}static fromString(e,t=!1){const n=new ArrayBuffer(e.length*2),i=new DataView(n);for(let s=0;s<e.length;s++)i.setUint16(s*2,e.charCodeAt(s),t);return n}}class ee{static isHex(e){return typeof e===lh&&RB.test(e)}static isBase64(e){return typeof e===lh&&OB.test(e)}static isBase64Url(e){return typeof e===lh&&BB.test(e)}static ToString(e,t="utf8"){const n=Y.toUint8Array(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(n);case"binary":return this.ToBinary(n);case"hex":return this.ToHex(n);case"base64":return this.ToBase64(n);case"base64url":return this.ToBase64Url(n);case"utf16le":return Br.toString(n,!0);case"utf16":case"utf16be":return Br.toString(n);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){if(!e)return new ArrayBuffer(0);switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);case"utf16le":return Br.fromString(e,!0);case"utf16":case"utf16be":return Br.fromString(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(e){const t=Y.toUint8Array(e);if(typeof btoa<"u"){const n=this.ToString(t,"binary");return btoa(n)}else return Buffer.from(t).toString("base64")}static FromBase64(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!ee.isBase64(t))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(t)):new Uint8Array(Buffer.from(t,"base64")).buffer}static FromBase64Url(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!ee.isBase64Url(t))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e,t=ee.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.FromBinary(e);case"utf8":return Ow.fromString(e);case"utf16":case"utf16be":return Br.fromString(e);case"utf16le":case"usc2":return Br.fromString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToUtf8String(e,t=ee.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.ToBinary(e);case"utf8":return Ow.toString(e);case"utf16":case"utf16be":return Br.toString(e);case"utf16le":case"usc2":return Br.toString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromBinary(e){const t=e.length,n=new Uint8Array(t);for(let i=0;i<t;i++)n[i]=e.charCodeAt(i);return n.buffer}static ToBinary(e){const t=Y.toUint8Array(e);let n="";for(let i=0;i<t.length;i++)n+=String.fromCharCode(t[i]);return n}static ToHex(e){const t=Y.toUint8Array(e);let n="";const i=t.length;for(let s=0;s<i;s++){const o=t[s];o<16&&(n+="0"),n+=o.toString(16)}return n}static FromHex(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!ee.isHex(t))throw new TypeError("Argument 'hexString' is not HEX encoded");t.length%2&&(t=`0${t}`);const n=new Uint8Array(t.length/2);for(let i=0;i<t.length;i=i+2){const s=t.slice(i,i+2);n[i/2]=parseInt(s,16)}return n.buffer}static ToUtf16String(e,t=!1){return Br.toString(e,t)}static FromUtf16String(e,t=!1){return Br.fromString(e,t)}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let n=0;n<t;n++)e+="=";return e}static formatString(e){return e?.replace(/[\n\r\t ]/g,"")||""}}ee.DEFAULT_UTF8_ENCODING="utf8";function NB(...r){const e=r.map(i=>i.byteLength).reduce((i,s)=>i+s),t=new Uint8Array(e);let n=0;return r.map(i=>new Uint8Array(i)).forEach(i=>{for(const s of i)t[n++]=s}),t.buffer}function PE(r,e){if(!(r&&e)||r.byteLength!==e.byteLength)return!1;const t=new Uint8Array(r),n=new Uint8Array(e);for(let i=0;i<r.byteLength;i++)if(t[i]!==n[i])return!1;return!0}/*!
 Copyright (c) Peculiar Ventures, LLC
*/function Ds(r,e){let t=0;if(r.length===1)return r[0];for(let n=r.length-1;n>=0;n--)t+=r[r.length-1-n]*Math.pow(2,e*n);return t}function Oi(r,e,t=-1){const n=t;let i=r,s=0,o=Math.pow(2,e);for(let a=1;a<8;a++){if(r<o){let c;if(n<0)c=new ArrayBuffer(a),s=a;else{if(n<a)return new ArrayBuffer(0);c=new ArrayBuffer(n),s=n}const l=new Uint8Array(c);for(let u=a-1;u>=0;u--){const d=Math.pow(2,u*e);l[s-u-1]=Math.floor(i/d),i-=l[s-u-1]*d}return c}o*=Math.pow(2,e)}return new ArrayBuffer(0)}function Cf(...r){let e=0,t=0;for(const s of r)e+=s.length;const n=new ArrayBuffer(e),i=new Uint8Array(n);for(const s of r)i.set(s,t),t+=s.length;return i}function RE(){const r=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const a=r[0]===255&&r[1]&128,c=r[0]===0&&(r[1]&128)===0;(a||c)&&this.warnings.push("Needlessly long format")}const e=new ArrayBuffer(this.valueHex.byteLength),t=new Uint8Array(e);for(let a=0;a<this.valueHex.byteLength;a++)t[a]=0;t[0]=r[0]&128;const n=Ds(t,8),i=new ArrayBuffer(this.valueHex.byteLength),s=new Uint8Array(i);for(let a=0;a<this.valueHex.byteLength;a++)s[a]=r[a];return s[0]&=127,Ds(s,8)-n}function DB(r){const e=r<0?r*-1:r;let t=128;for(let n=1;n<8;n++){if(e<=t){if(r<0){const o=t-e,a=Oi(o,8,n),c=new Uint8Array(a);return c[0]|=128,a}let i=Oi(e,8,n),s=new Uint8Array(i);if(s[0]&128){const o=i.slice(0),a=new Uint8Array(o);i=new ArrayBuffer(i.byteLength+1),s=new Uint8Array(i);for(let c=0;c<o.byteLength;c++)s[c+1]=a[c];s[0]=0}return i}t*=Math.pow(2,8)}return new ArrayBuffer(0)}function LB(r,e){if(r.byteLength!==e.byteLength)return!1;const t=new Uint8Array(r),n=new Uint8Array(e);for(let i=0;i<t.length;i++)if(t[i]!==n[i])return!1;return!0}function Kt(r,e){const t=r.toString(10);if(e<t.length)return"";const n=e-t.length,i=new Array(n);for(let o=0;o<n;o++)i[o]="0";return i.join("").concat(t)}/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */function Ol(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function Qg(r){let e=0,t=0;for(let i=0;i<r.length;i++){const s=r[i];e+=s.byteLength}const n=new Uint8Array(e);for(let i=0;i<r.length;i++){const s=r[i];n.set(new Uint8Array(s),t),t+=s.byteLength}return n.buffer}function mn(r,e,t,n){return e instanceof Uint8Array?e.byteLength?t<0?(r.error="Wrong parameter: inputOffset less than zero",!1):n<0?(r.error="Wrong parameter: inputLength less than zero",!1):e.byteLength-t-n<0?(r.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(r.error="Wrong parameter: inputBuffer has zero length",!1):(r.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}class ju{constructor(){this.items=[]}write(e){this.items.push(e)}final(){return Qg(this.items)}}const _o=[new Uint8Array([1])],Bw="0123456789",uh="name",Nw="valueHexView",MB="isHexOnly",UB="idBlock",FB="tagClass",$B="tagNumber",VB="isConstructed",qB="fromBER",jB="toBER",zB="local",Mt="",Tr=new ArrayBuffer(0),zu=new Uint8Array(0),na="EndOfContent",OE="OCTET STRING",BE="BIT STRING";function zr(r){var e;return e=class extends r{get valueHex(){return this.valueHexView.slice().buffer}set valueHex(n){this.valueHexView=new Uint8Array(n)}constructor(...n){var i;super(...n);const s=n[0]||{};this.isHexOnly=(i=s.isHexOnly)!==null&&i!==void 0?i:!1,this.valueHexView=s.valueHex?Y.toUint8Array(s.valueHex):zu}fromBER(n,i,s){const o=n instanceof ArrayBuffer?new Uint8Array(n):n;if(!mn(this,o,i,s))return-1;const a=i+s;return this.valueHexView=o.subarray(i,a),this.valueHexView.length?(this.blockLength=s,a):(this.warnings.push("Zero buffer length"),i)}toBER(n=!1){return this.isHexOnly?n?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",Tr)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:ee.ToHex(this.valueHexView)}}},e.NAME="hexBlock",e}class Yi{static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(e){this.valueBeforeDecodeView=new Uint8Array(e)}constructor({blockLength:e=0,error:t=Mt,warnings:n=[],valueBeforeDecode:i=zu}={}){this.blockLength=e,this.error=t,this.warnings=n,this.valueBeforeDecodeView=Y.toUint8Array(i)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:ee.ToHex(this.valueBeforeDecodeView)}}}Yi.NAME="baseBlock";class Bt extends Yi{fromBER(e,t,n){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(e,t){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}}Bt.NAME="valueBlock";class NE extends zr(Yi){constructor({idBlock:e={}}={}){var t,n,i,s;super(),e?(this.isHexOnly=(t=e.isHexOnly)!==null&&t!==void 0?t:!1,this.valueHexView=e.valueHex?Y.toUint8Array(e.valueHex):zu,this.tagClass=(n=e.tagClass)!==null&&n!==void 0?n:-1,this.tagNumber=(i=e.tagNumber)!==null&&i!==void 0?i:-1,this.isConstructed=(s=e.isConstructed)!==null&&s!==void 0?s:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(e=!1){let t=0;switch(this.tagClass){case 1:t|=0;break;case 2:t|=64;break;case 3:t|=128;break;case 4:t|=192;break;default:return this.error="Unknown tag class",Tr}if(this.isConstructed&&(t|=32),this.tagNumber<31&&!this.isHexOnly){const i=new Uint8Array(1);if(!e){let s=this.tagNumber;s&=31,t|=s,i[0]=t}return i.buffer}if(!this.isHexOnly){const i=Oi(this.tagNumber,7),s=new Uint8Array(i),o=i.byteLength,a=new Uint8Array(o+1);if(a[0]=t|31,!e){for(let c=0;c<o-1;c++)a[c+1]=s[c]|128;a[o]=s[o-1]}return a.buffer}const n=new Uint8Array(this.valueHexView.byteLength+1);if(n[0]=t|31,!e){const i=this.valueHexView;for(let s=0;s<i.length-1;s++)n[s+1]=i[s]|128;n[this.valueHexView.byteLength]=i[i.length-1]}return n.buffer}fromBER(e,t,n){const i=Y.toUint8Array(e);if(!mn(this,i,t,n))return-1;const s=i.subarray(t,t+n);if(s.length===0)return this.error="Zero buffer length",-1;switch(s[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(s[0]&32)===32,this.isHexOnly=!1;const a=s[0]&31;if(a!==31)this.tagNumber=a,this.blockLength=1;else{let c=1,l=this.valueHexView=new Uint8Array(255),u=255;for(;s[c]&128;){if(l[c-1]=s[c]&127,c++,c>=s.length)return this.error="End of input reached before message was fully decoded",-1;if(c===u){u+=255;const f=new Uint8Array(u);for(let m=0;m<l.length;m++)f[m]=l[m];l=this.valueHexView=new Uint8Array(u)}}this.blockLength=c+1,l[c-1]=s[c]&127;const d=new Uint8Array(c);for(let f=0;f<c;f++)d[f]=l[f];l=this.valueHexView=new Uint8Array(c),l.set(d),this.blockLength<=9?this.tagNumber=Ds(l,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}}NE.NAME="identificationBlock";class DE extends Yi{constructor({lenBlock:e={}}={}){var t,n,i;super(),this.isIndefiniteForm=(t=e.isIndefiniteForm)!==null&&t!==void 0?t:!1,this.longFormUsed=(n=e.longFormUsed)!==null&&n!==void 0?n:!1,this.length=(i=e.length)!==null&&i!==void 0?i:0}fromBER(e,t,n){const i=Y.toUint8Array(e);if(!mn(this,i,t,n))return-1;const s=i.subarray(t,t+n);if(s.length===0)return this.error="Zero buffer length",-1;if(s[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=s[0]===128,this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(s[0]&128),this.longFormUsed===!1)return this.length=s[0],this.blockLength=1,t+this.blockLength;const o=s[0]&127;if(o>8)return this.error="Too big integer",-1;if(o+1>s.length)return this.error="End of input reached before message was fully decoded",-1;const a=t+1,c=i.subarray(a,a+o);return c[o-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=Ds(c,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=o+1,t+this.blockLength}toBER(e=!1){let t,n;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),e===!1&&(n=new Uint8Array(t),n[0]=128),t;if(this.longFormUsed){const i=Oi(this.length,8);if(i.byteLength>127)return this.error="Too big length",Tr;if(t=new ArrayBuffer(i.byteLength+1),e)return t;const s=new Uint8Array(i);n=new Uint8Array(t),n[0]=i.byteLength|128;for(let o=0;o<i.byteLength;o++)n[o+1]=s[o];return t}return t=new ArrayBuffer(1),e===!1&&(n=new Uint8Array(t),n[0]=this.length),t}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}}DE.NAME="lengthBlock";const Z={};class ht extends Yi{constructor({name:e=Mt,optional:t=!1,primitiveSchema:n,...i}={},s){super(i),this.name=e,this.optional=t,n&&(this.primitiveSchema=n),this.idBlock=new NE(i),this.lenBlock=new DE(i),this.valueBlock=s?new s(i):new Bt(i)}fromBER(e,t,n){const i=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return i===-1?(this.error=this.valueBlock.error,i):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),i)}toBER(e,t){const n=t||new ju;t||LE(this);const i=this.idBlock.toBER(e);if(n.write(i),this.lenBlock.isIndefiniteForm)n.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(e,n),n.write(new ArrayBuffer(2));else{const s=this.valueBlock.toBER(e);this.lenBlock.length=s.byteLength;const o=this.lenBlock.toBER(e);n.write(o),n.write(s)}return t?Tr:n.final()}toJSON(){const e={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}toString(e="ascii"){return e==="ascii"?this.onAsciiEncoding():ee.ToHex(this.toBER())}onAsciiEncoding(){const e=this.constructor.NAME,t=ee.ToHex(this.valueBlock.valueBeforeDecodeView);return`${e} : ${t}`}isEqual(e){if(this===e)return!0;if(!(e instanceof this.constructor))return!1;const t=this.toBER(),n=e.toBER();return LB(t,n)}}ht.NAME="BaseBlock";function LE(r){var e;if(r instanceof Z.Constructed)for(const t of r.valueBlock.value)LE(t)&&(r.lenBlock.isIndefiniteForm=!0);return!!(!((e=r.lenBlock)===null||e===void 0)&&e.isIndefiniteForm)}class Xg extends ht{getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}constructor({value:e=Mt,...t}={},n){super(t,n),e&&this.fromString(e)}fromBER(e,t,n){const i=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return i===-1?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),i)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}}Xg.NAME="BaseStringBlock";class ME extends zr(Bt){constructor({isHexOnly:e=!0,...t}={}){super(t),this.isHexOnly=e}}ME.NAME="PrimitiveValueBlock";var UE;class Da extends ht{constructor(e={}){super(e,ME),this.idBlock.isConstructed=!1}}UE=Da;Z.Primitive=UE;Da.NAME="PRIMITIVE";function HB(r,e){if(r instanceof e)return r;const t=new e;return t.idBlock=r.idBlock,t.lenBlock=r.lenBlock,t.warnings=r.warnings,t.valueBeforeDecodeView=r.valueBeforeDecodeView,t}function io(r,e=0,t=r.length){const n=e;let i=new ht({},Bt);const s=new Yi;if(!mn(s,r,e,t))return i.error=s.error,{offset:-1,result:i};if(!r.subarray(e,e+t).length)return i.error="Zero buffer length",{offset:-1,result:i};let a=i.idBlock.fromBER(r,e,t);if(i.idBlock.warnings.length&&i.warnings.concat(i.idBlock.warnings),a===-1)return i.error=i.idBlock.error,{offset:-1,result:i};if(e=a,t-=i.idBlock.blockLength,a=i.lenBlock.fromBER(r,e,t),i.lenBlock.warnings.length&&i.warnings.concat(i.lenBlock.warnings),a===-1)return i.error=i.lenBlock.error,{offset:-1,result:i};if(e=a,t-=i.lenBlock.blockLength,!i.idBlock.isConstructed&&i.lenBlock.isIndefiniteForm)return i.error="Indefinite length form used for primitive encoding form",{offset:-1,result:i};let c=ht;switch(i.idBlock.tagClass){case 1:if(i.idBlock.tagNumber>=37&&i.idBlock.isHexOnly===!1)return i.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:i};switch(i.idBlock.tagNumber){case 0:if(i.idBlock.isConstructed&&i.lenBlock.length>0)return i.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:i};c=Z.EndOfContent;break;case 1:c=Z.Boolean;break;case 2:c=Z.Integer;break;case 3:c=Z.BitString;break;case 4:c=Z.OctetString;break;case 5:c=Z.Null;break;case 6:c=Z.ObjectIdentifier;break;case 10:c=Z.Enumerated;break;case 12:c=Z.Utf8String;break;case 13:c=Z.RelativeObjectIdentifier;break;case 14:c=Z.TIME;break;case 15:return i.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:i};case 16:c=Z.Sequence;break;case 17:c=Z.Set;break;case 18:c=Z.NumericString;break;case 19:c=Z.PrintableString;break;case 20:c=Z.TeletexString;break;case 21:c=Z.VideotexString;break;case 22:c=Z.IA5String;break;case 23:c=Z.UTCTime;break;case 24:c=Z.GeneralizedTime;break;case 25:c=Z.GraphicString;break;case 26:c=Z.VisibleString;break;case 27:c=Z.GeneralString;break;case 28:c=Z.UniversalString;break;case 29:c=Z.CharacterString;break;case 30:c=Z.BmpString;break;case 31:c=Z.DATE;break;case 32:c=Z.TimeOfDay;break;case 33:c=Z.DateTime;break;case 34:c=Z.Duration;break;default:{const l=i.idBlock.isConstructed?new Z.Constructed:new Z.Primitive;l.idBlock=i.idBlock,l.lenBlock=i.lenBlock,l.warnings=i.warnings,i=l}}break;case 2:case 3:case 4:default:c=i.idBlock.isConstructed?Z.Constructed:Z.Primitive}return i=HB(i,c),a=i.fromBER(r,e,i.lenBlock.isIndefiniteForm?t:i.lenBlock.length),i.valueBeforeDecodeView=r.subarray(n,n+i.blockLength),{offset:a,result:i}}function ys(r){if(!r.byteLength){const e=new ht({},Bt);return e.error="Input buffer has zero length",{offset:-1,result:e}}return io(Y.toUint8Array(r).slice(),0,r.byteLength)}function WB(r,e){return r?1:e}class Fn extends Bt{constructor({value:e=[],isIndefiniteForm:t=!1,...n}={}){super(n),this.value=e,this.isIndefiniteForm=t}fromBER(e,t,n){const i=Y.toUint8Array(e);if(!mn(this,i,t,n))return-1;if(this.valueBeforeDecodeView=i.subarray(t,t+n),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),t;let s=t;for(;WB(this.isIndefiniteForm,n)>0;){const o=io(i,s,n);if(o.offset===-1)return this.error=o.result.error,this.warnings.concat(o.result.warnings),-1;if(s=o.offset,this.blockLength+=o.result.blockLength,n-=o.result.blockLength,this.value.push(o.result),this.isIndefiniteForm&&o.result.constructor.NAME===na)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===na?this.value.pop():this.warnings.push("No EndOfContent block encoded")),s}toBER(e,t){const n=t||new ju;for(let i=0;i<this.value.length;i++)this.value[i].toBER(e,n);return t?Tr:n.final()}toJSON(){const e={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(const t of this.value)e.value.push(t.toJSON());return e}}Fn.NAME="ConstructedValueBlock";var FE;class $t extends ht{constructor(e={}){super(e,Fn),this.idBlock.isConstructed=!0}fromBER(e,t,n){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const i=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?n:this.lenBlock.length);return i===-1?(this.error=this.valueBlock.error,i):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),i)}onAsciiEncoding(){const e=[];for(const n of this.valueBlock.value)e.push(n.toString("ascii").split(`
`).map(i=>`  ${i}`).join(`
`));const t=this.idBlock.tagClass===3?`[${this.idBlock.tagNumber}]`:this.constructor.NAME;return e.length?`${t} :
${e.join(`
`)}`:`${t} :`}}FE=$t;Z.Constructed=FE;$t.NAME="CONSTRUCTED";class $E extends Bt{fromBER(e,t,n){return t}toBER(e){return Tr}}$E.override="EndOfContentValueBlock";var VE;class Zg extends ht{constructor(e={}){super(e,$E),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}}VE=Zg;Z.EndOfContent=VE;Zg.NAME=na;var qE;class Bi extends ht{constructor(e={}){super(e,Bt),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}fromBER(e,t,n){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=n,t+n>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+n}toBER(e,t){const n=new ArrayBuffer(2);if(!e){const i=new Uint8Array(n);i[0]=5,i[1]=0}return t&&t.write(n),n}onAsciiEncoding(){return`${this.constructor.NAME}`}}qE=Bi;Z.Null=qE;Bi.NAME="NULL";class jE extends zr(Bt){get value(){for(const e of this.valueHexView)if(e>0)return!0;return!1}set value(e){this.valueHexView[0]=e?255:0}constructor({value:e,...t}={}){super(t),t.valueHex?this.valueHexView=Y.toUint8Array(t.valueHex):this.valueHexView=new Uint8Array(1),e&&(this.value=e)}fromBER(e,t,n){const i=Y.toUint8Array(e);return mn(this,i,t,n)?(this.valueHexView=i.subarray(t,t+n),n>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,RE.call(this),this.blockLength=n,t+n):-1}toBER(){return this.valueHexView.slice()}toJSON(){return{...super.toJSON(),value:this.value}}}jE.NAME="BooleanValueBlock";var zE;let Hu=class extends ht{getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}constructor(e={}){super(e,jE),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.getValue}`}};zE=Hu;Z.Boolean=zE;Hu.NAME="BOOLEAN";class HE extends zr(Fn){constructor({isConstructed:e=!1,...t}={}){super(t),this.isConstructed=e}fromBER(e,t,n){let i=0;if(this.isConstructed){if(this.isHexOnly=!1,i=Fn.prototype.fromBER.call(this,e,t,n),i===-1)return i;for(let s=0;s<this.value.length;s++){const o=this.value[s].constructor.NAME;if(o===na){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(o!==OE)return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,i=super.fromBER(e,t,n),this.blockLength=n;return i}toBER(e,t){return this.isConstructed?Fn.prototype.toBER.call(this,e,t):e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),isConstructed:this.isConstructed}}}HE.NAME="OctetStringValueBlock";var Jg;let Ai=class extends ht{constructor({idBlock:e={},lenBlock:t={},...n}={}){var i,s;(i=n.isConstructed)!==null&&i!==void 0||(n.isConstructed=!!(!((s=n.value)===null||s===void 0)&&s.length)),super({idBlock:{isConstructed:n.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!n.isIndefiniteForm},...n},HE),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,n){if(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,n===0)return this.idBlock.error.length===0&&(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length===0&&(this.blockLength+=this.lenBlock.blockLength),t;if(!this.valueBlock.isConstructed){const s=(e instanceof ArrayBuffer?new Uint8Array(e):e).subarray(t,t+n);try{if(s.byteLength){const o=io(s,0,s.byteLength);o.offset!==-1&&o.offset===n&&(this.valueBlock.value=[o.result])}}catch{}}return super.fromBER(e,t,n)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return $t.prototype.onAsciiEncoding.call(this);const e=this.constructor.NAME,t=ee.ToHex(this.valueBlock.valueHexView);return`${e} : ${t}`}getValue(){if(!this.idBlock.isConstructed)return this.valueBlock.valueHexView.slice().buffer;const e=[];for(const t of this.valueBlock.value)t instanceof Jg&&e.push(t.valueBlock.valueHexView);return Y.concat(e)}};Jg=Ai;Z.OctetString=Jg;Ai.NAME=OE;class WE extends zr(Fn){constructor({unusedBits:e=0,isConstructed:t=!1,...n}={}){super(n),this.unusedBits=e,this.isConstructed=t,this.blockLength=this.valueHexView.byteLength}fromBER(e,t,n){if(!n)return t;let i=-1;if(this.isConstructed){if(i=Fn.prototype.fromBER.call(this,e,t,n),i===-1)return i;for(const a of this.value){const c=a.constructor.NAME;if(c===na){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(c!==BE)return this.error="BIT STRING may consists of BIT STRINGs only",-1;const l=a.valueBlock;if(this.unusedBits>0&&l.unusedBits>0)return this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only',-1;this.unusedBits=l.unusedBits}return i}const s=Y.toUint8Array(e);if(!mn(this,s,t,n))return-1;const o=s.subarray(t,t+n);if(this.unusedBits=o[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;if(!this.unusedBits){const a=o.subarray(1);try{if(a.byteLength){const c=io(a,0,a.byteLength);c.offset!==-1&&c.offset===n-1&&(this.value=[c.result])}}catch{}}return this.valueHexView=o.subarray(1),this.blockLength=o.length,t+n}toBER(e,t){if(this.isConstructed)return Fn.prototype.toBER.call(this,e,t);if(e)return new ArrayBuffer(this.valueHexView.byteLength+1);if(!this.valueHexView.byteLength)return Tr;const n=new Uint8Array(this.valueHexView.length+1);return n[0]=this.unusedBits,n.set(this.valueHexView,1),n.buffer}toJSON(){return{...super.toJSON(),unusedBits:this.unusedBits,isConstructed:this.isConstructed}}}WE.NAME="BitStringValueBlock";var KE;let xi=class extends ht{constructor({idBlock:e={},lenBlock:t={},...n}={}){var i,s;(i=n.isConstructed)!==null&&i!==void 0||(n.isConstructed=!!(!((s=n.value)===null||s===void 0)&&s.length)),super({idBlock:{isConstructed:n.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!n.isIndefiniteForm},...n},WE),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}fromBER(e,t,n){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,n)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return $t.prototype.onAsciiEncoding.call(this);{const e=[],t=this.valueBlock.valueHexView;for(const o of t)e.push(o.toString(2).padStart(8,"0"));const n=e.join(""),i=this.constructor.NAME,s=n.substring(0,n.length-this.valueBlock.unusedBits);return`${i} : ${s}`}}};KE=xi;Z.BitString=KE;xi.NAME=BE;var GE;function KB(r,e){const t=new Uint8Array([0]),n=new Uint8Array(r),i=new Uint8Array(e);let s=n.slice(0);const o=s.length-1,a=i.slice(0),c=a.length-1;let l=0;const u=c<o?o:c;let d=0;for(let f=u;f>=0;f--,d++){switch(!0){case d<a.length:l=s[o-d]+a[c-d]+t[0];break;default:l=s[o-d]+t[0]}switch(t[0]=l/10,!0){case d>=s.length:s=Cf(new Uint8Array([l%10]),s);break;default:s[o-d]=l%10}}return t[0]>0&&(s=Cf(t,s)),s}function Dw(r){if(r>=_o.length)for(let e=_o.length;e<=r;e++){const t=new Uint8Array([0]);let n=_o[e-1].slice(0);for(let i=n.length-1;i>=0;i--){const s=new Uint8Array([(n[i]<<1)+t[0]]);t[0]=s[0]/10,n[i]=s[0]%10}t[0]>0&&(n=Cf(t,n)),_o.push(n)}return _o[r]}function GB(r,e){let t=0;const n=new Uint8Array(r),i=new Uint8Array(e),s=n.slice(0),o=s.length-1,a=i.slice(0),c=a.length-1;let l,u=0;for(let d=c;d>=0;d--,u++)switch(l=s[o-u]-a[c-u]-t,!0){case l<0:t=1,s[o-u]=l+10;break;default:t=0,s[o-u]=l}if(t>0)for(let d=o-c+1;d>=0;d--,u++)if(l=s[o-u]-t,l<0)t=1,s[o-u]=l+10;else{t=0,s[o-u]=l;break}return s.slice()}class em extends zr(Bt){setValueHex(){this.valueHexView.length>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,this.valueHexView.length>0&&(this._valueDec=RE.call(this)))}constructor({value:e,...t}={}){super(t),this._valueDec=0,t.valueHex&&this.setValueHex(),e!==void 0&&(this.valueDec=e)}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this.valueHexView=new Uint8Array(DB(e))}get valueDec(){return this._valueDec}fromDER(e,t,n,i=0){const s=this.fromBER(e,t,n);if(s===-1)return s;const o=this.valueHexView;return o[0]===0&&(o[1]&128)!==0?this.valueHexView=o.subarray(1):i!==0&&o.length<i&&(i-o.length>1&&(i=o.length+1),this.valueHexView=o.subarray(i-o.length)),s}toDER(e=!1){const t=this.valueHexView;switch(!0){case(t[0]&128)!==0:{const n=new Uint8Array(this.valueHexView.length+1);n[0]=0,n.set(t,1),this.valueHexView=n}break;case(t[0]===0&&(t[1]&128)===0):this.valueHexView=this.valueHexView.subarray(1);break}return this.toBER(e)}fromBER(e,t,n){const i=super.fromBER(e,t,n);return i===-1||this.setValueHex(),i}toBER(e){return e?new ArrayBuffer(this.valueHexView.length):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}toString(){const e=this.valueHexView.length*8-1;let t=new Uint8Array(this.valueHexView.length*8/3),n=0,i;const s=this.valueHexView;let o="",a=!1;for(let c=s.byteLength-1;c>=0;c--){i=s[c];for(let l=0;l<8;l++){if((i&1)===1)switch(n){case e:t=GB(Dw(n),t),o="-";break;default:t=KB(t,Dw(n))}n++,i>>=1}}for(let c=0;c<t.length;c++)t[c]&&(a=!0),a&&(o+=Bw.charAt(t[c]));return a===!1&&(o+=Bw.charAt(0)),o}}GE=em;em.NAME="IntegerValueBlock";Object.defineProperty(GE.prototype,"valueHex",{set:function(r){this.valueHexView=new Uint8Array(r),this.setValueHex()},get:function(){return this.valueHexView.slice().buffer}});var $o;class so extends ht{constructor(e={}){super(e,em),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}toBigInt(){return Ol(),BigInt(this.valueBlock.toString())}static fromBigInt(e){Ol();const t=BigInt(e),n=new ju,i=t.toString(16).replace(/^-/,""),s=new Uint8Array(ee.FromHex(i));if(t<0){const a=new Uint8Array(s.length+(s[0]&128?1:0));a[0]|=128;const l=BigInt(`0x${ee.ToHex(a)}`)+t,u=Y.toUint8Array(ee.FromHex(l.toString(16)));u[0]|=128,n.write(u)}else s[0]&128&&n.write(new Uint8Array([0])),n.write(s);return new $o({valueHex:n.final()})}convertToDER(){const e=new $o({valueHex:this.valueBlock.valueHexView});return e.valueBlock.toDER(),e}convertFromDER(){return new $o({valueHex:this.valueBlock.valueHexView[0]===0?this.valueBlock.valueHexView.subarray(1):this.valueBlock.valueHexView})}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()}`}}$o=so;Z.Integer=$o;so.NAME="INTEGER";var YE;class Wu extends so{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}}YE=Wu;Z.Enumerated=YE;Wu.NAME="ENUMERATED";class If extends zr(Bt){constructor({valueDec:e=-1,isFirstSid:t=!1,...n}={}){super(n),this.valueDec=e,this.isFirstSid=t}fromBER(e,t,n){if(!n)return t;const i=Y.toUint8Array(e);if(!mn(this,i,t,n))return-1;const s=i.subarray(t,t+n);this.valueHexView=new Uint8Array(n);for(let a=0;a<n&&(this.valueHexView[a]=s[a]&127,this.blockLength++,(s[a]&128)!==0);a++);const o=new Uint8Array(this.blockLength);for(let a=0;a<this.blockLength;a++)o[a]=this.valueHexView[a];return this.valueHexView=o,(s[this.blockLength-1]&128)!==0?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=Ds(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}set valueBigInt(e){Ol();let t=BigInt(e).toString(2);for(;t.length%7;)t="0"+t;const n=new Uint8Array(t.length/7);for(let i=0;i<n.length;i++)n[i]=parseInt(t.slice(i*7,i*7+7),2)+(i+1<n.length?128:0);this.fromBER(n.buffer,0,n.length)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const i=this.valueHexView,s=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)s[o]=i[o]|128;return s[this.blockLength-1]=i[this.blockLength-1],s.buffer}const t=Oi(this.valueDec,7);if(t.byteLength===0)return this.error="Error during encoding SID value",Tr;const n=new Uint8Array(t.byteLength);if(!e){const i=new Uint8Array(t),s=t.byteLength-1;for(let o=0;o<s;o++)n[o]=i[o]|128;n[s]=i[s]}return n}toString(){let e="";if(this.isHexOnly)e=ee.ToHex(this.valueHexView);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec,isFirstSid:this.isFirstSid}}}If.NAME="sidBlock";class QE extends Bt{constructor({value:e=Mt,...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,n){let i=t;for(;n>0;){const s=new If;if(i=s.fromBER(e,i,n),i===-1)return this.blockLength=0,this.error=s.error,i;this.value.length===0&&(s.isFirstSid=!0),this.blockLength+=s.blockLength,n-=s.blockLength,this.value.push(s)}return i}toBER(e){const t=[];for(let n=0;n<this.value.length;n++){const i=this.value[n].toBER(e);if(i.byteLength===0)return this.error=this.value[n].error,Tr;t.push(i)}return Qg(t)}fromString(e){this.value=[];let t=0,n=0,i="",s=!1;do if(n=e.indexOf(".",t),n===-1?i=e.substring(t):i=e.substring(t,n),t=n+1,s){const o=this.value[0];let a=0;switch(o.valueDec){case 0:break;case 1:a=40;break;case 2:a=80;break;default:this.value=[];return}const c=parseInt(i,10);if(isNaN(c))return;o.valueDec=c+a,s=!1}else{const o=new If;if(i>Number.MAX_SAFE_INTEGER){Ol();const a=BigInt(i);o.valueBigInt=a}else if(o.valueDec=parseInt(i,10),isNaN(o.valueDec))return;this.value.length||(o.isFirstSid=!0,s=!0),this.value.push(o)}while(n!==-1)}toString(){let e="",t=!1;for(let n=0;n<this.value.length;n++){t=this.value[n].isHexOnly;let i=this.value[n].toString();n!==0&&(e=`${e}.`),t?(i=`{${i}}`,this.value[n].isFirstSid?e=`2.{${i} - 80}`:e+=i):e+=i}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}QE.NAME="ObjectIdentifierValueBlock";var XE;class Ku extends ht{getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}constructor(e={}){super(e,QE),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}XE=Ku;Z.ObjectIdentifier=XE;Ku.NAME="OBJECT IDENTIFIER";class kf extends zr(Yi){constructor({valueDec:e=0,...t}={}){super(t),this.valueDec=e}fromBER(e,t,n){if(n===0)return t;const i=Y.toUint8Array(e);if(!mn(this,i,t,n))return-1;const s=i.subarray(t,t+n);this.valueHexView=new Uint8Array(n);for(let a=0;a<n&&(this.valueHexView[a]=s[a]&127,this.blockLength++,(s[a]&128)!==0);a++);const o=new Uint8Array(this.blockLength);for(let a=0;a<this.blockLength;a++)o[a]=this.valueHexView[a];return this.valueHexView=o,(s[this.blockLength-1]&128)!==0?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=Ds(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const i=this.valueHexView,s=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)s[o]=i[o]|128;return s[this.blockLength-1]=i[this.blockLength-1],s.buffer}const t=Oi(this.valueDec,7);if(t.byteLength===0)return this.error="Error during encoding SID value",Tr;const n=new Uint8Array(t.byteLength);if(!e){const i=new Uint8Array(t),s=t.byteLength-1;for(let o=0;o<s;o++)n[o]=i[o]|128;n[s]=i[s]}return n.buffer}toString(){let e="";return this.isHexOnly?e=ee.ToHex(this.valueHexView):e=this.valueDec.toString(),e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}}kf.NAME="relativeSidBlock";class ZE extends Bt{constructor({value:e=Mt,...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,n){let i=t;for(;n>0;){const s=new kf;if(i=s.fromBER(e,i,n),i===-1)return this.blockLength=0,this.error=s.error,i;this.blockLength+=s.blockLength,n-=s.blockLength,this.value.push(s)}return i}toBER(e,t){const n=[];for(let i=0;i<this.value.length;i++){const s=this.value[i].toBER(e);if(s.byteLength===0)return this.error=this.value[i].error,Tr;n.push(s)}return Qg(n)}fromString(e){this.value=[];let t=0,n=0,i="";do{n=e.indexOf(".",t),n===-1?i=e.substring(t):i=e.substring(t,n),t=n+1;const s=new kf;if(s.valueDec=parseInt(i,10),isNaN(s.valueDec))return!0;this.value.push(s)}while(n!==-1);return!0}toString(){let e="",t=!1;for(let n=0;n<this.value.length;n++){t=this.value[n].isHexOnly;let i=this.value[n].toString();n!==0&&(e=`${e}.`),t&&(i=`{${i}}`),e+=i}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}ZE.NAME="RelativeObjectIdentifierValueBlock";var JE;class tm extends ht{getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}constructor(e={}){super(e,ZE),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}JE=tm;Z.RelativeObjectIdentifier=JE;tm.NAME="RelativeObjectIdentifier";var e1;class on extends $t{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}}e1=on;Z.Sequence=e1;on.NAME="SEQUENCE";var t1;let an=class extends $t{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}};t1=an;Z.Set=t1;an.NAME="SET";class r1 extends zr(Bt){constructor({...e}={}){super(e),this.isHexOnly=!0,this.value=Mt}toJSON(){return{...super.toJSON(),value:this.value}}}r1.NAME="StringValueBlock";class n1 extends r1{}n1.NAME="SimpleStringValueBlock";class er extends Xg{constructor({...e}={}){super(e,n1)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,Y.toUint8Array(e))}fromString(e){const t=e.length,n=this.valueBlock.valueHexView=new Uint8Array(t);for(let i=0;i<t;i++)n[i]=e.charCodeAt(i);this.valueBlock.value=e}}er.NAME="SIMPLE STRING";class i1 extends er{fromBuffer(e){this.valueBlock.valueHexView=Y.toUint8Array(e);try{this.valueBlock.value=ee.ToUtf8String(e)}catch(t){this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`),this.valueBlock.value=ee.ToBinary(e)}}fromString(e){this.valueBlock.valueHexView=new Uint8Array(ee.FromUtf8String(e)),this.valueBlock.value=e}}i1.NAME="Utf8StringValueBlock";var s1;class yn extends i1{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}}s1=yn;Z.Utf8String=s1;yn.NAME="UTF8String";class o1 extends er{fromBuffer(e){this.valueBlock.value=ee.ToUtf16String(e),this.valueBlock.valueHexView=Y.toUint8Array(e)}fromString(e){this.valueBlock.value=e,this.valueBlock.valueHexView=new Uint8Array(ee.FromUtf16String(e))}}o1.NAME="BmpStringValueBlock";var a1;class Gu extends o1{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}}a1=Gu;Z.BmpString=a1;Gu.NAME="BMPString";class c1 extends er{fromBuffer(e){const t=ArrayBuffer.isView(e)?e.slice().buffer:e.slice(0),n=new Uint8Array(t);for(let i=0;i<n.length;i+=4)n[i]=n[i+3],n[i+1]=n[i+2],n[i+2]=0,n[i+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length,n=this.valueBlock.valueHexView=new Uint8Array(t*4);for(let i=0;i<t;i++){const s=Oi(e.charCodeAt(i),8),o=new Uint8Array(s);if(o.length>4)continue;const a=4-o.length;for(let c=o.length-1;c>=0;c--)n[i*4+c+a]=o[c]}this.valueBlock.value=e}}c1.NAME="UniversalStringValueBlock";var l1;class Yu extends c1{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}}l1=Yu;Z.UniversalString=l1;Yu.NAME="UniversalString";var u1;class Qu extends er{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}}u1=Qu;Z.NumericString=u1;Qu.NAME="NumericString";var d1;class Xu extends er{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}}d1=Xu;Z.PrintableString=d1;Xu.NAME="PrintableString";var h1;class Zu extends er{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}}h1=Zu;Z.TeletexString=h1;Zu.NAME="TeletexString";var f1;class Ju extends er{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}}f1=Ju;Z.VideotexString=f1;Ju.NAME="VideotexString";var p1;class ed extends er{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}}p1=ed;Z.IA5String=p1;ed.NAME="IA5String";var g1;class td extends er{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}}g1=td;Z.GraphicString=g1;td.NAME="GraphicString";var m1;class La extends er{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}}m1=La;Z.VisibleString=m1;La.NAME="VisibleString";var y1;class rd extends er{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}}y1=rd;Z.GeneralString=y1;rd.NAME="GeneralString";var w1;class nd extends er{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}}w1=nd;Z.CharacterString=w1;nd.NAME="CharacterString";var b1;class Ma extends La{constructor({value:e,valueDate:t,...n}={}){if(super(n),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,e){this.fromString(e),this.valueBlock.valueHexView=new Uint8Array(e.length);for(let i=0;i<e.length;i++)this.valueBlock.valueHexView[i]=e.charCodeAt(i)}t&&(this.fromDate(t),this.valueBlock.valueHexView=new Uint8Array(this.toBuffer())),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,Y.toUint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),n=new Uint8Array(t);for(let i=0;i<e.length;i++)n[i]=e.charCodeAt(i);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const n=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig.exec(e);if(n===null){this.error="Wrong input string for conversion";return}const i=parseInt(n[1],10);i>=50?this.year=1900+i:this.year=2e3+i,this.month=parseInt(n[2],10),this.day=parseInt(n[3],10),this.hour=parseInt(n[4],10),this.minute=parseInt(n[5],10),this.second=parseInt(n[6],10)}toString(e="iso"){if(e==="iso"){const t=new Array(7);return t[0]=Kt(this.year<2e3?this.year-1900:this.year-2e3,2),t[1]=Kt(this.month,2),t[2]=Kt(this.day,2),t[3]=Kt(this.hour,2),t[4]=Kt(this.minute,2),t[5]=Kt(this.second,2),t[6]="Z",t.join("")}return super.toString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.toDate().toISOString()}`}toJSON(){return{...super.toJSON(),year:this.year,month:this.month,day:this.day,hour:this.hour,minute:this.minute,second:this.second}}}b1=Ma;Z.UTCTime=b1;Ma.NAME="UTCTime";var v1;class id extends Ma{constructor(e={}){var t;super(e),(t=this.millisecond)!==null&&t!==void 0||(this.millisecond=0),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromDate(e){super.fromDate(e),this.millisecond=e.getUTCMilliseconds()}toDate(){const e=Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond);return new Date(e)}fromString(e){let t=!1,n="",i="",s=0,o,a=0,c=0;if(e[e.length-1]==="Z")n=e.substring(0,e.length-1),t=!0;else{const d=new Number(e[e.length-1]);if(isNaN(d.valueOf()))throw new Error("Wrong input string for conversion");n=e}if(t){if(n.indexOf("+")!==-1)throw new Error("Wrong input string for conversion");if(n.indexOf("-")!==-1)throw new Error("Wrong input string for conversion")}else{let d=1,f=n.indexOf("+"),m="";if(f===-1&&(f=n.indexOf("-"),d=-1),f!==-1){if(m=n.substring(f+1),n=n.substring(0,f),m.length!==2&&m.length!==4)throw new Error("Wrong input string for conversion");let g=parseInt(m.substring(0,2),10);if(isNaN(g.valueOf()))throw new Error("Wrong input string for conversion");if(a=d*g,m.length===4){if(g=parseInt(m.substring(2,4),10),isNaN(g.valueOf()))throw new Error("Wrong input string for conversion");c=d*g}}}let l=n.indexOf(".");if(l===-1&&(l=n.indexOf(",")),l!==-1){const d=new Number(`0${n.substring(l)}`);if(isNaN(d.valueOf()))throw new Error("Wrong input string for conversion");s=d.valueOf(),i=n.substring(0,l)}else i=n;switch(!0){case i.length===8:if(o=/(\d{4})(\d{2})(\d{2})/ig,l!==-1)throw new Error("Wrong input string for conversion");break;case i.length===10:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})/ig,l!==-1){let d=60*s;this.minute=Math.floor(d),d=60*(d-this.minute),this.second=Math.floor(d),d=1e3*(d-this.second),this.millisecond=Math.floor(d)}break;case i.length===12:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig,l!==-1){let d=60*s;this.second=Math.floor(d),d=1e3*(d-this.second),this.millisecond=Math.floor(d)}break;case i.length===14:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig,l!==-1){const d=1e3*s;this.millisecond=Math.floor(d)}break;default:throw new Error("Wrong input string for conversion")}const u=o.exec(i);if(u===null)throw new Error("Wrong input string for conversion");for(let d=1;d<u.length;d++)switch(d){case 1:this.year=parseInt(u[d],10);break;case 2:this.month=parseInt(u[d],10);break;case 3:this.day=parseInt(u[d],10);break;case 4:this.hour=parseInt(u[d],10)+a;break;case 5:this.minute=parseInt(u[d],10)+c;break;case 6:this.second=parseInt(u[d],10);break;default:throw new Error("Wrong input string for conversion")}if(t===!1){const d=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=d.getUTCFullYear(),this.month=d.getUTCMonth(),this.day=d.getUTCDay(),this.hour=d.getUTCHours(),this.minute=d.getUTCMinutes(),this.second=d.getUTCSeconds(),this.millisecond=d.getUTCMilliseconds()}}toString(e="iso"){if(e==="iso"){const t=[];return t.push(Kt(this.year,4)),t.push(Kt(this.month,2)),t.push(Kt(this.day,2)),t.push(Kt(this.hour,2)),t.push(Kt(this.minute,2)),t.push(Kt(this.second,2)),this.millisecond!==0&&(t.push("."),t.push(Kt(this.millisecond,3))),t.push("Z"),t.join("")}return super.toString(e)}toJSON(){return{...super.toJSON(),millisecond:this.millisecond}}}v1=id;Z.GeneralizedTime=v1;id.NAME="GeneralizedTime";var S1;class rm extends yn{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}}S1=rm;Z.DATE=S1;rm.NAME="DATE";var E1;class nm extends yn{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}}E1=nm;Z.TimeOfDay=E1;nm.NAME="TimeOfDay";var A1;class im extends yn{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}}A1=im;Z.DateTime=A1;im.NAME="DateTime";var x1;class sm extends yn{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}}x1=sm;Z.Duration=x1;sm.NAME="Duration";var _1;class om extends yn{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}}_1=om;Z.TIME=_1;om.NAME="TIME";class Ni{constructor({name:e=Mt,optional:t=!1}={}){this.name=e,this.optional=t}}class am extends Ni{constructor({value:e=[],...t}={}){super(t),this.value=e}}class Bl extends Ni{constructor({value:e=new Ni,local:t=!1,...n}={}){super(n),this.value=e,this.local=t}}class YB{get data(){return this.dataView.slice().buffer}set data(e){this.dataView=Y.toUint8Array(e)}constructor({data:e=zu}={}){this.dataView=Y.toUint8Array(e)}fromBER(e,t,n){const i=t+n;return this.dataView=Y.toUint8Array(e).subarray(t,i),i}toBER(e){return this.dataView.slice().buffer}}function pi(r,e,t){if(t instanceof am){for(const s of t.value)if(pi(r,e,s).verified)return{verified:!0,result:r};{const s={verified:!1,result:{error:"Wrong values for Choice type"}};return t.hasOwnProperty(uh)&&(s.name=t.name),s}}if(t instanceof Ni)return t.hasOwnProperty(uh)&&(r[t.name]=e),{verified:!0,result:r};if(!(r instanceof Object))return{verified:!1,result:{error:"Wrong root object"}};if(!(e instanceof Object))return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(!(t instanceof Object))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(!(UB in t))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(!(qB in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(!(jB in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const n=t.idBlock.toBER(!1);if(n.byteLength===0)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(t.idBlock.fromBER(n,0,n.byteLength)===-1)return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(t.idBlock.hasOwnProperty(FB)===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.tagClass!==e.idBlock.tagClass)return{verified:!1,result:r};if(t.idBlock.hasOwnProperty($B)===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.tagNumber!==e.idBlock.tagNumber)return{verified:!1,result:r};if(t.idBlock.hasOwnProperty(VB)===!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.isConstructed!==e.idBlock.isConstructed)return{verified:!1,result:r};if(!(MB in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(t.idBlock.isHexOnly!==e.idBlock.isHexOnly)return{verified:!1,result:r};if(t.idBlock.isHexOnly){if(!(Nw in t.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const s=t.idBlock.valueHexView,o=e.idBlock.valueHexView;if(s.length!==o.length)return{verified:!1,result:r};for(let a=0;a<s.length;a++)if(s[a]!==o[1])return{verified:!1,result:r}}if(t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Mt),t.name&&(r[t.name]=e)),t instanceof Z.Constructed){let s=0,o={verified:!1,result:{error:"Unknown error"}},a=t.valueBlock.value.length;if(a>0&&t.valueBlock.value[0]instanceof Bl&&(a=e.valueBlock.value.length),a===0)return{verified:!0,result:r};if(e.valueBlock.value.length===0&&t.valueBlock.value.length!==0){let c=!0;for(let l=0;l<t.valueBlock.value.length;l++)c=c&&(t.valueBlock.value[l].optional||!1);return c?{verified:!0,result:r}:(t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Mt),t.name&&delete r[t.name]),r.error="Inconsistent object length",{verified:!1,result:r})}for(let c=0;c<a;c++)if(c-s>=e.valueBlock.value.length){if(t.valueBlock.value[c].optional===!1){const l={verified:!1,result:r};return r.error="Inconsistent length between ASN.1 data and schema",t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Mt),t.name&&(delete r[t.name],l.name=t.name)),l}}else if(t.valueBlock.value[0]instanceof Bl){if(o=pi(r,e.valueBlock.value[c],t.valueBlock.value[0].value),o.verified===!1)if(t.valueBlock.value[0].optional)s++;else return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Mt),t.name&&delete r[t.name]),o;if(uh in t.valueBlock.value[0]&&t.valueBlock.value[0].name.length>0){let l={};zB in t.valueBlock.value[0]&&t.valueBlock.value[0].local?l=e:l=r,typeof l[t.valueBlock.value[0].name]>"u"&&(l[t.valueBlock.value[0].name]=[]),l[t.valueBlock.value[0].name].push(e.valueBlock.value[c])}}else if(o=pi(r,e.valueBlock.value[c-s],t.valueBlock.value[c]),o.verified===!1)if(t.valueBlock.value[c].optional)s++;else return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Mt),t.name&&delete r[t.name]),o;if(o.verified===!1){const c={verified:!1,result:r};return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Mt),t.name&&(delete r[t.name],c.name=t.name)),c}return{verified:!0,result:r}}if(t.primitiveSchema&&Nw in e.valueBlock){const s=io(e.valueBlock.valueHexView);if(s.offset===-1){const o={verified:!1,result:s.result};return t.name&&(t.name=t.name.replace(/^\s+|\s+$/g,Mt),t.name&&(delete r[t.name],o.name=t.name)),o}return pi(r,s.result,t.primitiveSchema)}return{verified:!0,result:r}}function QB(r,e){if(!(e instanceof Object))return{verified:!1,result:{error:"Wrong ASN.1 schema type"}};const t=io(Y.toUint8Array(r));return t.offset===-1?{verified:!1,result:t.result}:pi(t.result,t.result,e)}const C1=Object.freeze(Object.defineProperty({__proto__:null,Any:Ni,BaseBlock:ht,BaseStringBlock:Xg,BitString:xi,BmpString:Gu,Boolean:Hu,CharacterString:nd,Choice:am,Constructed:$t,DATE:rm,DateTime:im,Duration:sm,EndOfContent:Zg,Enumerated:Wu,GeneralString:rd,GeneralizedTime:id,GraphicString:td,HexBlock:zr,IA5String:ed,Integer:so,Null:Bi,NumericString:Qu,ObjectIdentifier:Ku,OctetString:Ai,Primitive:Da,PrintableString:Xu,RawData:YB,RelativeObjectIdentifier:tm,Repeated:Bl,Sequence:on,Set:an,TIME:om,TeletexString:Zu,TimeOfDay:nm,UTCTime:Ma,UniversalString:Yu,Utf8String:yn,ValueBlock:Bt,VideotexString:Ju,ViewWriter:ju,VisibleString:La,compareSchema:pi,fromBER:ys,verifySchema:QB},Symbol.toStringTag,{value:"Module"}));var U;(function(r){r[r.Sequence=0]="Sequence",r[r.Set=1]="Set",r[r.Choice=2]="Choice"})(U||(U={}));var S;(function(r){r[r.Any=1]="Any",r[r.Boolean=2]="Boolean",r[r.OctetString=3]="OctetString",r[r.BitString=4]="BitString",r[r.Integer=5]="Integer",r[r.Enumerated=6]="Enumerated",r[r.ObjectIdentifier=7]="ObjectIdentifier",r[r.Utf8String=8]="Utf8String",r[r.BmpString=9]="BmpString",r[r.UniversalString=10]="UniversalString",r[r.NumericString=11]="NumericString",r[r.PrintableString=12]="PrintableString",r[r.TeletexString=13]="TeletexString",r[r.VideotexString=14]="VideotexString",r[r.IA5String=15]="IA5String",r[r.GraphicString=16]="GraphicString",r[r.VisibleString=17]="VisibleString",r[r.GeneralString=18]="GeneralString",r[r.CharacterString=19]="CharacterString",r[r.UTCTime=20]="UTCTime",r[r.GeneralizedTime=21]="GeneralizedTime",r[r.DATE=22]="DATE",r[r.TimeOfDay=23]="TimeOfDay",r[r.DateTime=24]="DateTime",r[r.Duration=25]="Duration",r[r.TIME=26]="TIME",r[r.Null=27]="Null"})(S||(S={}));class sd{constructor(e,t=0){if(this.unusedBits=0,this.value=new ArrayBuffer(0),e)if(typeof e=="number")this.fromNumber(e);else if(Y.isBufferSource(e))this.unusedBits=t,this.value=Y.toArrayBuffer(e);else throw TypeError("Unsupported type of 'params' argument for BitString")}fromASN(e){if(!(e instanceof xi))throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString");return this.unusedBits=e.valueBlock.unusedBits,this.value=e.valueBlock.valueHex,this}toASN(){return new xi({unusedBits:this.unusedBits,valueHex:this.value})}toSchema(e){return new xi({name:e})}toNumber(){let e="";const t=new Uint8Array(this.value);for(const n of t)e+=n.toString(2).padStart(8,"0");return e=e.split("").reverse().join(""),this.unusedBits&&(e=e.slice(this.unusedBits).padStart(this.unusedBits,"0")),parseInt(e,2)}fromNumber(e){let t=e.toString(2);const n=t.length+7>>3;this.unusedBits=(n<<3)-t.length;const i=new Uint8Array(n);t=t.padStart(n<<3,"0").split("").reverse().join("");let s=0;for(;s<n;)i[s]=parseInt(t.slice(s<<3,(s<<3)+8),2),s++;this.value=i.buffer}}class Ee{get byteLength(){return this.buffer.byteLength}get byteOffset(){return 0}constructor(e){typeof e=="number"?this.buffer=new ArrayBuffer(e):Y.isBufferSource(e)?this.buffer=Y.toArrayBuffer(e):Array.isArray(e)?this.buffer=new Uint8Array(e):this.buffer=new ArrayBuffer(0)}fromASN(e){if(!(e instanceof Ai))throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");return this.buffer=e.valueBlock.valueHex,this}toASN(){return new Ai({valueHex:this.buffer})}toSchema(e){return new Ai({name:e})}}const XB={fromASN:r=>r instanceof Bi?null:r.valueBeforeDecodeView,toASN:r=>{if(r===null)return new Bi;const e=ys(r);if(e.result.error)throw new Error(e.result.error);return e.result}},ZB={fromASN:r=>r.valueBlock.valueHexView.byteLength>=4?r.valueBlock.toString():r.valueBlock.valueDec,toASN:r=>new so({value:+r})},JB={fromASN:r=>r.valueBlock.valueDec,toASN:r=>new Wu({value:r})},Ve={fromASN:r=>r.valueBlock.valueHexView,toASN:r=>new so({valueHex:r})},eN={fromASN:r=>r.valueBlock.valueHexView,toASN:r=>new xi({valueHex:r})},tN={fromASN:r=>r.valueBlock.toString(),toASN:r=>new Ku({value:r})},rN={fromASN:r=>r.valueBlock.value,toASN:r=>new Hu({value:r})},Nl={fromASN:r=>r.valueBlock.valueHexView,toASN:r=>new Ai({valueHex:r})},nN={fromASN:r=>new Ee(r.getValue()),toASN:r=>r.toASN()};function hr(r){return{fromASN:e=>e.valueBlock.value,toASN:e=>new r({value:e})}}const I1=hr(yn),iN=hr(Gu),sN=hr(Yu),oN=hr(Qu),aN=hr(Xu),cN=hr(Zu),lN=hr(Ju),uN=hr(ed),dN=hr(td),hN=hr(La),fN=hr(rd),pN=hr(nd),gN={fromASN:r=>r.toDate(),toASN:r=>new Ma({valueDate:r})},mN={fromASN:r=>r.toDate(),toASN:r=>new id({valueDate:r})},yN={fromASN:()=>null,toASN:()=>new Bi};function cm(r){switch(r){case S.Any:return XB;case S.BitString:return eN;case S.BmpString:return iN;case S.Boolean:return rN;case S.CharacterString:return pN;case S.Enumerated:return JB;case S.GeneralString:return fN;case S.GeneralizedTime:return mN;case S.GraphicString:return dN;case S.IA5String:return uN;case S.Integer:return ZB;case S.Null:return yN;case S.NumericString:return oN;case S.ObjectIdentifier:return tN;case S.OctetString:return Nl;case S.PrintableString:return aN;case S.TeletexString:return cN;case S.UTCTime:return gN;case S.UniversalString:return sN;case S.Utf8String:return I1;case S.VideotexString:return lN;case S.VisibleString:return hN;default:return null}}function en(r){return typeof r=="function"&&r.prototype?r.prototype.toASN&&r.prototype.fromASN?!0:en(r.prototype):!!(r&&typeof r=="object"&&"toASN"in r&&"fromASN"in r)}function k1(r){var e;if(r){const t=Object.getPrototypeOf(r);return((e=t?.prototype)===null||e===void 0?void 0:e.constructor)===Array?!0:k1(t)}return!1}function wN(r,e){if(!(r&&e)||r.byteLength!==e.byteLength)return!1;const t=new Uint8Array(r),n=new Uint8Array(e);for(let i=0;i<r.byteLength;i++)if(t[i]!==n[i])return!1;return!0}class bN{constructor(){this.items=new WeakMap}has(e){return this.items.has(e)}get(e,t=!1){const n=this.items.get(e);if(!n)throw new Error(`Cannot get schema for '${e.prototype.constructor.name}' target`);if(t&&!n.schema)throw new Error(`Schema '${e.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);return n}cache(e){const t=this.get(e);t.schema||(t.schema=this.create(e,!0))}createDefault(e){const t={type:U.Sequence,items:{}},n=this.findParentSchema(e);return n&&(Object.assign(t,n),t.items=Object.assign({},t.items,n.items)),t}create(e,t){const n=this.items.get(e)||this.createDefault(e),i=[];for(const s in n.items){const o=n.items[s],a=t?s:"";let c;if(typeof o.type=="number"){const u=S[o.type],d=C1[u];if(!d)throw new Error(`Cannot get ASN1 class by name '${u}'`);c=new d({name:a})}else en(o.type)?c=new o.type().toSchema(a):o.optional?this.get(o.type).type===U.Choice?c=new Ni({name:a}):(c=this.create(o.type,!1),c.name=a):c=new Ni({name:a});const l=!!o.optional||o.defaultValue!==void 0;if(o.repeated){c.name="";const u=o.repeated==="set"?an:on;c=new u({name:"",value:[new Bl({name:a,value:c})]})}if(o.context!==null&&o.context!==void 0)if(o.implicit)if(typeof o.type=="number"||en(o.type)){const u=o.repeated?$t:Da;i.push(new u({name:a,optional:l,idBlock:{tagClass:3,tagNumber:o.context}}))}else{this.cache(o.type);const u=!!o.repeated;let d=u?c:this.get(o.type,!0).schema;d="valueBlock"in d?d.valueBlock.value:d.value,i.push(new $t({name:u?"":a,optional:l,idBlock:{tagClass:3,tagNumber:o.context},value:d}))}else i.push(new $t({optional:l,idBlock:{tagClass:3,tagNumber:o.context},value:[c]}));else c.optional=l,i.push(c)}switch(n.type){case U.Sequence:return new on({value:i,name:""});case U.Set:return new an({value:i,name:""});case U.Choice:return new am({value:i,name:""});default:throw new Error("Unsupported ASN1 type in use")}}set(e,t){return this.items.set(e,t),this}findParentSchema(e){const t=Object.getPrototypeOf(e);return t?this.items.get(t)||this.findParentSchema(t):null}}const ar=new bN,V=r=>e=>{let t;ar.has(e)?t=ar.get(e):(t=ar.createDefault(e),ar.set(e,t)),Object.assign(t,r)},p=r=>(e,t)=>{let n;ar.has(e.constructor)?n=ar.get(e.constructor):(n=ar.createDefault(e.constructor),ar.set(e.constructor,n));const i=Object.assign({},r);if(typeof i.type=="number"&&!i.converter){const s=cm(r.type);if(!s)throw new Error(`Cannot get default converter for property '${t}' of ${e.constructor.name}`);i.converter=s}n.items[t]=i};class Lw extends Error{constructor(){super(...arguments),this.schemas=[]}}class vN{static parse(e,t){const n=ys(e);if(n.result.error)throw new Error(n.result.error);return this.fromASN(n.result,t)}static fromASN(e,t){var n;try{if(en(t))return new t().fromASN(e);const i=ar.get(t);ar.cache(t);let s=i.schema;if(e.constructor===$t&&i.type!==U.Choice){s=new $t({idBlock:{tagClass:3,tagNumber:e.idBlock.tagNumber},value:i.schema.valueBlock.value});for(const c in i.items)delete e[c]}const o=pi({},e,s);if(!o.verified)throw new Lw(`Data does not match to ${t.name} ASN1 schema. ${o.result.error}`);const a=new t;if(k1(t)){if(!("value"in e.valueBlock&&Array.isArray(e.valueBlock.value)))throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");const c=i.itemType;if(typeof c=="number"){const l=cm(c);if(!l)throw new Error(`Cannot get default converter for array item of ${t.name} ASN1 schema`);return t.from(e.valueBlock.value,u=>l.fromASN(u))}else return t.from(e.valueBlock.value,l=>this.fromASN(l,c))}for(const c in i.items){const l=o.result[c];if(!l)continue;const u=i.items[c],d=u.type;if(typeof d=="number"||en(d)){const f=(n=u.converter)!==null&&n!==void 0?n:en(d)?new d:null;if(!f)throw new Error("Converter is empty");if(u.repeated)if(u.implicit){const m=u.repeated==="sequence"?on:an,g=new m;g.valueBlock=l.valueBlock;const y=ys(g.toBER(!1));if(y.offset===-1)throw new Error(`Cannot parse the child item. ${y.result.error}`);if(!("value"in y.result.valueBlock&&Array.isArray(y.result.valueBlock.value)))throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");const w=y.result.valueBlock.value;a[c]=Array.from(w,x=>f.fromASN(x))}else a[c]=Array.from(l,m=>f.fromASN(m));else{let m=l;if(u.implicit){let g;if(en(d))g=new d().toSchema("");else{const y=S[d],w=C1[y];if(!w)throw new Error(`Cannot get '${y}' class from asn1js module`);g=new w}g.valueBlock=m.valueBlock,m=ys(g.toBER(!1)).result}a[c]=f.fromASN(m)}}else if(u.repeated){if(!Array.isArray(l))throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");a[c]=Array.from(l,f=>this.fromASN(f,d))}else a[c]=this.fromASN(l,d)}return a}catch(i){throw i instanceof Lw&&i.schemas.push(t.name),i}}}class lm{static serialize(e){return e instanceof ht?e.toBER(!1):this.toASN(e).toBER(!1)}static toASN(e){if(e&&typeof e=="object"&&en(e))return e.toASN();if(!(e&&typeof e=="object"))throw new TypeError("Parameter 1 should be type of Object.");const t=e.constructor,n=ar.get(t);ar.cache(t);let i=[];if(n.itemType){if(!Array.isArray(e))throw new TypeError("Parameter 1 should be type of Array.");if(typeof n.itemType=="number"){const o=cm(n.itemType);if(!o)throw new Error(`Cannot get default converter for array item of ${t.name} ASN1 schema`);i=e.map(a=>o.toASN(a))}else i=e.map(o=>this.toAsnItem({type:n.itemType},"[]",t,o))}else for(const o in n.items){const a=n.items[o],c=e[o];if(c===void 0||a.defaultValue===c||typeof a.defaultValue=="object"&&typeof c=="object"&&wN(this.serialize(a.defaultValue),this.serialize(c)))continue;const l=lm.toAsnItem(a,o,t,c);if(typeof a.context=="number")if(a.implicit)if(!a.repeated&&(typeof a.type=="number"||en(a.type))){const u={};u.valueHex=l instanceof Bi?l.valueBeforeDecodeView:l.valueBlock.toBER(),i.push(new Da({optional:a.optional,idBlock:{tagClass:3,tagNumber:a.context},...u}))}else i.push(new $t({optional:a.optional,idBlock:{tagClass:3,tagNumber:a.context},value:l.valueBlock.value}));else i.push(new $t({optional:a.optional,idBlock:{tagClass:3,tagNumber:a.context},value:[l]}));else a.repeated?i=i.concat(l):i.push(l)}let s;switch(n.type){case U.Sequence:s=new on({value:i});break;case U.Set:s=new an({value:i});break;case U.Choice:if(!i[0])throw new Error(`Schema '${t.name}' has wrong data. Choice cannot be empty.`);s=i[0];break}return s}static toAsnItem(e,t,n,i){let s;if(typeof e.type=="number"){const o=e.converter;if(!o)throw new Error(`Property '${t}' doesn't have converter for type ${S[e.type]} in schema '${n.name}'`);if(e.repeated){if(!Array.isArray(i))throw new TypeError("Parameter 'objProp' should be type of Array.");const a=Array.from(i,l=>o.toASN(l)),c=e.repeated==="sequence"?on:an;s=new c({value:a})}else s=o.toASN(i)}else if(e.repeated){if(!Array.isArray(i))throw new TypeError("Parameter 'objProp' should be type of Array.");const o=Array.from(i,c=>this.toASN(c)),a=e.repeated==="sequence"?on:an;s=new a({value:o})}else s=this.toASN(i);return s}}class Te extends Array{constructor(e=[]){if(typeof e=="number")super(e);else{super();for(const t of e)this.push(t)}}}class G{static serialize(e){return lm.serialize(e)}static parse(e,t){return vN.parse(e,t)}static toString(e){const t=Y.isBufferSource(e)?Y.toArrayBuffer(e):G.serialize(e),n=ys(t);if(n.offset===-1)throw new Error(`Cannot decode ASN.1 data. ${n.result.error}`);return n.result.toString()}}function h(r,e,t,n){var i=arguments.length,s=i<3?e:n===null?n=Object.getOwnPropertyDescriptor(e,t):n,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")s=Reflect.decorate(r,e,t,n);else for(var a=r.length-1;a>=0;a--)(o=r[a])&&(s=(i<3?o(s):i>3?o(e,t,s):o(e,t))||s);return i>3&&s&&Object.defineProperty(e,t,s),s}class Mw{static isIPv4(e){return/^(\d{1,3}\.){3}\d{1,3}$/.test(e)}static parseIPv4(e){const t=e.split(".");if(t.length!==4)throw new Error("Invalid IPv4 address");return t.map(n=>{const i=parseInt(n,10);if(isNaN(i)||i<0||i>255)throw new Error("Invalid IPv4 address part");return i})}static parseIPv6(e){const n=this.expandIPv6(e).split(":");if(n.length!==8)throw new Error("Invalid IPv6 address");return n.reduce((i,s)=>{const o=parseInt(s,16);if(isNaN(o)||o<0||o>65535)throw new Error("Invalid IPv6 address part");return i.push(o>>8&255),i.push(o&255),i},[])}static expandIPv6(e){if(!e.includes("::"))return e;const t=e.split("::");if(t.length>2)throw new Error("Invalid IPv6 address");const n=t[0]?t[0].split(":"):[],i=t[1]?t[1].split(":"):[],s=8-(n.length+i.length);if(s<0)throw new Error("Invalid IPv6 address");return[...n,...Array(s).fill("0"),...i].join(":")}static formatIPv6(e){const t=[];for(let n=0;n<16;n+=2)t.push((e[n]<<8|e[n+1]).toString(16));return this.compressIPv6(t.join(":"))}static compressIPv6(e){const t=e.split(":");let n=-1,i=0,s=-1,o=0;for(let a=0;a<t.length;a++)t[a]==="0"?(s===-1&&(s=a),o++):(o>i&&(n=s,i=o),s=-1,o=0);if(o>i&&(n=s,i=o),i>1){const a=t.slice(0,n).join(":"),c=t.slice(n+i).join(":");return`${a}::${c}`}return e}static parseCIDR(e){const[t,n]=e.split("/"),i=parseInt(n,10);if(this.isIPv4(t)){if(i<0||i>32)throw new Error("Invalid IPv4 prefix length");return[this.parseIPv4(t),i]}else{if(i<0||i>128)throw new Error("Invalid IPv6 prefix length");return[this.parseIPv6(t),i]}}static decodeIP(e){if(e.length===64&&parseInt(e,16)===0)return"::/0";if(e.length!==16)return e;const t=parseInt(e.slice(8),16).toString(2).split("").reduce((i,s)=>i+ +s,0);let n=e.slice(0,8).replace(/(.{2})/g,i=>`${parseInt(i,16)}.`);return n=n.slice(0,-1),`${n}/${t}`}static toString(e){const t=new Uint8Array(e);if(t.length===4)return Array.from(t).join(".");if(t.length===16)return this.formatIPv6(t);if(t.length===8||t.length===32){const n=t.length/2,i=t.slice(0,n),s=t.slice(n);if(t.every(c=>c===0))return t.length===8?"0.0.0.0/0":"::/0";const a=s.reduce((c,l)=>c+(l.toString(2).match(/1/g)||[]).length,0);return t.length===8?`${Array.from(i).join(".")}/${a}`:`${this.formatIPv6(i)}/${a}`}return this.decodeIP(ee.ToHex(e))}static fromString(e){if(e.includes("/")){const[n,i]=this.parseCIDR(e),s=new Uint8Array(n.length);let o=i;for(let c=0;c<s.length;c++)o>=8?(s[c]=255,o-=8):o>0&&(s[c]=255<<8-o,o=0);const a=new Uint8Array(n.length*2);return a.set(n,0),a.set(s,n.length),a.buffer}const t=this.isIPv4(e)?this.parseIPv4(e):this.parseIPv6(e);return new Uint8Array(t).buffer}}var Tf,Pf,Rf;let ft=class{constructor(e={}){Object.assign(this,e)}toString(){return this.bmpString||this.printableString||this.teletexString||this.universalString||this.utf8String||""}};h([p({type:S.TeletexString})],ft.prototype,"teletexString",void 0);h([p({type:S.PrintableString})],ft.prototype,"printableString",void 0);h([p({type:S.UniversalString})],ft.prototype,"universalString",void 0);h([p({type:S.Utf8String})],ft.prototype,"utf8String",void 0);h([p({type:S.BmpString})],ft.prototype,"bmpString",void 0);ft=h([V({type:U.Choice})],ft);let Ls=class extends ft{constructor(e={}){super(e),Object.assign(this,e)}toString(){return this.ia5String||(this.anyValue?ee.ToHex(this.anyValue):super.toString())}};h([p({type:S.IA5String})],Ls.prototype,"ia5String",void 0);h([p({type:S.Any})],Ls.prototype,"anyValue",void 0);Ls=h([V({type:U.Choice})],Ls);class od{constructor(e={}){this.type="",this.value=new Ls,Object.assign(this,e)}}h([p({type:S.ObjectIdentifier})],od.prototype,"type",void 0);h([p({type:Ls})],od.prototype,"value",void 0);let Ms=Tf=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,Tf.prototype)}};Ms=Tf=h([V({type:U.Set,itemType:od})],Ms);let Of=Pf=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,Pf.prototype)}};Of=Pf=h([V({type:U.Sequence,itemType:Ms})],Of);let Ze=Rf=class extends Of{constructor(e){super(e),Object.setPrototypeOf(this,Rf.prototype)}};Ze=Rf=h([V({type:U.Sequence})],Ze);const SN={fromASN:r=>Mw.toString(Nl.fromASN(r)),toASN:r=>Nl.toASN(Mw.fromString(r))};class ia{constructor(e={}){this.typeId="",this.value=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:S.ObjectIdentifier})],ia.prototype,"typeId",void 0);h([p({type:S.Any,context:0})],ia.prototype,"value",void 0);class um{constructor(e={}){this.partyName=new ft,Object.assign(this,e)}}h([p({type:ft,optional:!0,context:0,implicit:!0})],um.prototype,"nameAssigner",void 0);h([p({type:ft,context:1,implicit:!0})],um.prototype,"partyName",void 0);let de=class{constructor(e={}){Object.assign(this,e)}};h([p({type:ia,context:0,implicit:!0})],de.prototype,"otherName",void 0);h([p({type:S.IA5String,context:1,implicit:!0})],de.prototype,"rfc822Name",void 0);h([p({type:S.IA5String,context:2,implicit:!0})],de.prototype,"dNSName",void 0);h([p({type:S.Any,context:3,implicit:!0})],de.prototype,"x400Address",void 0);h([p({type:Ze,context:4,implicit:!1})],de.prototype,"directoryName",void 0);h([p({type:um,context:5})],de.prototype,"ediPartyName",void 0);h([p({type:S.IA5String,context:6,implicit:!0})],de.prototype,"uniformResourceIdentifier",void 0);h([p({type:S.OctetString,context:7,implicit:!0,converter:SN})],de.prototype,"iPAddress",void 0);h([p({type:S.ObjectIdentifier,context:8,implicit:!0})],de.prototype,"registeredID",void 0);de=h([V({type:U.Choice})],de);const dm="1.3.6.1.5.5.7",EN=`${dm}.1`,oo=`${dm}.3`,ad=`${dm}.48`,Uw=`${ad}.1`,Fw=`${ad}.2`,$w=`${ad}.3`,Vw=`${ad}.5`,Xn="2.5.29";var Bf;const Nf=`${EN}.1`;class Ua{constructor(e={}){this.accessMethod="",this.accessLocation=new de,Object.assign(this,e)}}h([p({type:S.ObjectIdentifier})],Ua.prototype,"accessMethod",void 0);h([p({type:de})],Ua.prototype,"accessLocation",void 0);let ds=Bf=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,Bf.prototype)}};ds=Bf=h([V({type:U.Sequence,itemType:Ua})],ds);const Df=`${Xn}.35`;class hm extends Ee{}class gi{constructor(e={}){e&&Object.assign(this,e)}}h([p({type:hm,context:0,optional:!0,implicit:!0})],gi.prototype,"keyIdentifier",void 0);h([p({type:de,context:1,optional:!0,implicit:!0,repeated:"sequence"})],gi.prototype,"authorityCertIssuer",void 0);h([p({type:S.Integer,context:2,optional:!0,implicit:!0,converter:Ve})],gi.prototype,"authorityCertSerialNumber",void 0);const T1=`${Xn}.19`;class Dl{constructor(e={}){this.cA=!1,Object.assign(this,e)}}h([p({type:S.Boolean,defaultValue:!1})],Dl.prototype,"cA",void 0);h([p({type:S.Integer,optional:!0})],Dl.prototype,"pathLenConstraint",void 0);var Lf;let Rt=Lf=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,Lf.prototype)}};Rt=Lf=h([V({type:U.Sequence,itemType:de})],Rt);var Mf;let qw=Mf=class extends Rt{constructor(e){super(e),Object.setPrototypeOf(this,Mf.prototype)}};qw=Mf=h([V({type:U.Sequence})],qw);var Uf;const P1=`${Xn}.32`;let dn=class{constructor(e={}){Object.assign(this,e)}toString(){return this.ia5String||this.visibleString||this.bmpString||this.utf8String||""}};h([p({type:S.IA5String})],dn.prototype,"ia5String",void 0);h([p({type:S.VisibleString})],dn.prototype,"visibleString",void 0);h([p({type:S.BmpString})],dn.prototype,"bmpString",void 0);h([p({type:S.Utf8String})],dn.prototype,"utf8String",void 0);dn=h([V({type:U.Choice})],dn);class fm{constructor(e={}){this.organization=new dn,this.noticeNumbers=[],Object.assign(this,e)}}h([p({type:dn})],fm.prototype,"organization",void 0);h([p({type:S.Integer,repeated:"sequence"})],fm.prototype,"noticeNumbers",void 0);class pm{constructor(e={}){Object.assign(this,e)}}h([p({type:fm,optional:!0})],pm.prototype,"noticeRef",void 0);h([p({type:dn,optional:!0})],pm.prototype,"explicitText",void 0);let Ll=class{constructor(e={}){Object.assign(this,e)}};h([p({type:S.IA5String})],Ll.prototype,"cPSuri",void 0);h([p({type:pm})],Ll.prototype,"userNotice",void 0);Ll=h([V({type:U.Choice})],Ll);class gm{constructor(e={}){this.policyQualifierId="",this.qualifier=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:S.ObjectIdentifier})],gm.prototype,"policyQualifierId",void 0);h([p({type:S.Any})],gm.prototype,"qualifier",void 0);class cd{constructor(e={}){this.policyIdentifier="",Object.assign(this,e)}}h([p({type:S.ObjectIdentifier})],cd.prototype,"policyIdentifier",void 0);h([p({type:gm,repeated:"sequence",optional:!0})],cd.prototype,"policyQualifiers",void 0);let Ml=Uf=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,Uf.prototype)}};Ml=Uf=h([V({type:U.Sequence,itemType:cd})],Ml);let Ul=class{constructor(e=0){this.value=e}};h([p({type:S.Integer})],Ul.prototype,"value",void 0);Ul=h([V({type:U.Choice})],Ul);let jw=class extends Ul{};jw=h([V({type:U.Choice})],jw);var Ff;const $f=`${Xn}.31`;var br;(function(r){r[r.unused=1]="unused",r[r.keyCompromise=2]="keyCompromise",r[r.cACompromise=4]="cACompromise",r[r.affiliationChanged=8]="affiliationChanged",r[r.superseded=16]="superseded",r[r.cessationOfOperation=32]="cessationOfOperation",r[r.certificateHold=64]="certificateHold",r[r.privilegeWithdrawn=128]="privilegeWithdrawn",r[r.aACompromise=256]="aACompromise"})(br||(br={}));class R1 extends sd{toJSON(){const e=[],t=this.toNumber();return t&br.aACompromise&&e.push("aACompromise"),t&br.affiliationChanged&&e.push("affiliationChanged"),t&br.cACompromise&&e.push("cACompromise"),t&br.certificateHold&&e.push("certificateHold"),t&br.cessationOfOperation&&e.push("cessationOfOperation"),t&br.keyCompromise&&e.push("keyCompromise"),t&br.privilegeWithdrawn&&e.push("privilegeWithdrawn"),t&br.superseded&&e.push("superseded"),t&br.unused&&e.push("unused"),e}toString(){return`[${this.toJSON().join(", ")}]`}}let Di=class{constructor(e={}){Object.assign(this,e)}};h([p({type:de,context:0,repeated:"sequence",implicit:!0})],Di.prototype,"fullName",void 0);h([p({type:Ms,context:1,implicit:!0})],Di.prototype,"nameRelativeToCRLIssuer",void 0);Di=h([V({type:U.Choice})],Di);class ao{constructor(e={}){Object.assign(this,e)}}h([p({type:Di,context:0,optional:!0})],ao.prototype,"distributionPoint",void 0);h([p({type:R1,context:1,optional:!0,implicit:!0})],ao.prototype,"reasons",void 0);h([p({type:de,context:2,optional:!0,repeated:"sequence",implicit:!0})],ao.prototype,"cRLIssuer",void 0);let ws=Ff=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,Ff.prototype)}};ws=Ff=h([V({type:U.Sequence,itemType:ao})],ws);var Vf;let zw=Vf=class extends ws{constructor(e){super(e),Object.setPrototypeOf(this,Vf.prototype)}};zw=Vf=h([V({type:U.Sequence,itemType:ao})],zw);class Ct{constructor(e={}){this.onlyContainsUserCerts=Ct.ONLY,this.onlyContainsCACerts=Ct.ONLY,this.indirectCRL=Ct.ONLY,this.onlyContainsAttributeCerts=Ct.ONLY,Object.assign(this,e)}}Ct.ONLY=!1;h([p({type:Di,context:0,optional:!0})],Ct.prototype,"distributionPoint",void 0);h([p({type:S.Boolean,context:1,defaultValue:Ct.ONLY,implicit:!0})],Ct.prototype,"onlyContainsUserCerts",void 0);h([p({type:S.Boolean,context:2,defaultValue:Ct.ONLY,implicit:!0})],Ct.prototype,"onlyContainsCACerts",void 0);h([p({type:R1,context:3,optional:!0,implicit:!0})],Ct.prototype,"onlySomeReasons",void 0);h([p({type:S.Boolean,context:4,defaultValue:Ct.ONLY,implicit:!0})],Ct.prototype,"indirectCRL",void 0);h([p({type:S.Boolean,context:5,defaultValue:Ct.ONLY,implicit:!0})],Ct.prototype,"onlyContainsAttributeCerts",void 0);var Vo;(function(r){r[r.unspecified=0]="unspecified",r[r.keyCompromise=1]="keyCompromise",r[r.cACompromise=2]="cACompromise",r[r.affiliationChanged=3]="affiliationChanged",r[r.superseded=4]="superseded",r[r.cessationOfOperation=5]="cessationOfOperation",r[r.certificateHold=6]="certificateHold",r[r.removeFromCRL=8]="removeFromCRL",r[r.privilegeWithdrawn=9]="privilegeWithdrawn",r[r.aACompromise=10]="aACompromise"})(Vo||(Vo={}));let qf=class{constructor(e=Vo.unspecified){this.reason=Vo.unspecified,this.reason=e}toJSON(){return Vo[this.reason]}toString(){return this.toJSON()}};h([p({type:S.Enumerated})],qf.prototype,"reason",void 0);qf=h([V({type:U.Choice})],qf);var jf;const O1=`${Xn}.37`;let Fl=jf=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,jf.prototype)}};Fl=jf=h([V({type:U.Sequence,itemType:S.ObjectIdentifier})],Fl);const AN=`${oo}.1`,xN=`${oo}.2`,_N=`${oo}.3`,CN=`${oo}.4`,IN=`${oo}.8`,kN=`${oo}.9`;let zf=class{constructor(e=new ArrayBuffer(0)){this.value=e}};h([p({type:S.Integer,converter:Ve})],zf.prototype,"value",void 0);zf=h([V({type:U.Choice})],zf);let Hf=class{constructor(e){this.value=new Date,e&&(this.value=e)}};h([p({type:S.GeneralizedTime})],Hf.prototype,"value",void 0);Hf=h([V({type:U.Choice})],Hf);var Wf;let Hw=Wf=class extends Rt{constructor(e){super(e),Object.setPrototypeOf(this,Wf.prototype)}};Hw=Wf=h([V({type:U.Sequence})],Hw);const B1=`${Xn}.15`;var vr;(function(r){r[r.digitalSignature=1]="digitalSignature",r[r.nonRepudiation=2]="nonRepudiation",r[r.keyEncipherment=4]="keyEncipherment",r[r.dataEncipherment=8]="dataEncipherment",r[r.keyAgreement=16]="keyAgreement",r[r.keyCertSign=32]="keyCertSign",r[r.cRLSign=64]="cRLSign",r[r.encipherOnly=128]="encipherOnly",r[r.decipherOnly=256]="decipherOnly"})(vr||(vr={}));class dh extends sd{toJSON(){const e=this.toNumber(),t=[];return e&vr.cRLSign&&t.push("crlSign"),e&vr.dataEncipherment&&t.push("dataEncipherment"),e&vr.decipherOnly&&t.push("decipherOnly"),e&vr.digitalSignature&&t.push("digitalSignature"),e&vr.encipherOnly&&t.push("encipherOnly"),e&vr.keyAgreement&&t.push("keyAgreement"),e&vr.keyCertSign&&t.push("keyCertSign"),e&vr.keyEncipherment&&t.push("keyEncipherment"),e&vr.nonRepudiation&&t.push("nonRepudiation"),t}toString(){return`[${this.toJSON().join(", ")}]`}}var Kf;class ld{constructor(e={}){this.base=new de,this.minimum=0,Object.assign(this,e)}}h([p({type:de})],ld.prototype,"base",void 0);h([p({type:S.Integer,context:0,defaultValue:0,implicit:!0})],ld.prototype,"minimum",void 0);h([p({type:S.Integer,context:1,optional:!0,implicit:!0})],ld.prototype,"maximum",void 0);let $l=Kf=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,Kf.prototype)}};$l=Kf=h([V({type:U.Sequence,itemType:ld})],$l);class N1{constructor(e={}){Object.assign(this,e)}}h([p({type:$l,context:0,optional:!0,implicit:!0})],N1.prototype,"permittedSubtrees",void 0);h([p({type:$l,context:1,optional:!0,implicit:!0})],N1.prototype,"excludedSubtrees",void 0);class D1{constructor(e={}){Object.assign(this,e)}}h([p({type:S.Integer,context:0,implicit:!0,optional:!0,converter:Ve})],D1.prototype,"requireExplicitPolicy",void 0);h([p({type:S.Integer,context:1,implicit:!0,optional:!0,converter:Ve})],D1.prototype,"inhibitPolicyMapping",void 0);var Gf;class mm{constructor(e={}){this.issuerDomainPolicy="",this.subjectDomainPolicy="",Object.assign(this,e)}}h([p({type:S.ObjectIdentifier})],mm.prototype,"issuerDomainPolicy",void 0);h([p({type:S.ObjectIdentifier})],mm.prototype,"subjectDomainPolicy",void 0);let Ww=Gf=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,Gf.prototype)}};Ww=Gf=h([V({type:U.Sequence,itemType:mm})],Ww);var Yf;const L1=`${Xn}.17`;let Qf=Yf=class extends Rt{constructor(e){super(e),Object.setPrototypeOf(this,Yf.prototype)}};Qf=Yf=h([V({type:U.Sequence})],Qf);let hn=class{constructor(e={}){this.type="",this.values=[],Object.assign(this,e)}};h([p({type:S.ObjectIdentifier})],hn.prototype,"type",void 0);h([p({type:S.Any,repeated:"set"})],hn.prototype,"values",void 0);var Xf;let Kw=Xf=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,Xf.prototype)}};Kw=Xf=h([V({type:U.Sequence,itemType:hn})],Kw);const M1=`${Xn}.14`;class $n extends hm{}class U1{constructor(e={}){Object.assign(this,e)}}h([p({type:S.GeneralizedTime,context:0,implicit:!0,optional:!0})],U1.prototype,"notBefore",void 0);h([p({type:S.GeneralizedTime,context:1,implicit:!0,optional:!0})],U1.prototype,"notAfter",void 0);var qo;(function(r){r[r.keyUpdateAllowed=1]="keyUpdateAllowed",r[r.newExtensions=2]="newExtensions",r[r.pKIXCertificate=4]="pKIXCertificate"})(qo||(qo={}));class F1 extends sd{toJSON(){const e=[],t=this.toNumber();return t&qo.pKIXCertificate&&e.push("pKIXCertificate"),t&qo.newExtensions&&e.push("newExtensions"),t&qo.keyUpdateAllowed&&e.push("keyUpdateAllowed"),e}toString(){return`[${this.toJSON().join(", ")}]`}}class $1{constructor(e={}){this.entrustVers="",this.entrustInfoFlags=new F1,Object.assign(this,e)}}h([p({type:S.GeneralString})],$1.prototype,"entrustVers",void 0);h([p({type:F1})],$1.prototype,"entrustInfoFlags",void 0);var Zf;let Gw=Zf=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,Zf.prototype)}};Gw=Zf=h([V({type:U.Sequence,itemType:Ua})],Gw);class X{constructor(e={}){this.algorithm="",Object.assign(this,e)}isEqual(e){return e instanceof X&&e.algorithm==this.algorithm&&(e.parameters&&this.parameters&&PE(e.parameters,this.parameters)||e.parameters===this.parameters)}}h([p({type:S.ObjectIdentifier})],X.prototype,"algorithm",void 0);h([p({type:S.Any,optional:!0})],X.prototype,"parameters",void 0);class xr{constructor(e={}){this.algorithm=new X,this.subjectPublicKey=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:X})],xr.prototype,"algorithm",void 0);h([p({type:S.BitString})],xr.prototype,"subjectPublicKey",void 0);let ut=class{constructor(e){if(e)if(typeof e=="string"||typeof e=="number"||e instanceof Date){const t=new Date(e);t.getUTCFullYear()>2049?this.generalTime=t:this.utcTime=t}else Object.assign(this,e)}getTime(){const e=this.utcTime||this.generalTime;if(!e)throw new Error("Cannot get time from CHOICE object");return e}};h([p({type:S.UTCTime})],ut.prototype,"utcTime",void 0);h([p({type:S.GeneralizedTime})],ut.prototype,"generalTime",void 0);ut=h([V({type:U.Choice})],ut);class Fa{constructor(e){this.notBefore=new ut(new Date),this.notAfter=new ut(new Date),e&&(this.notBefore=new ut(e.notBefore),this.notAfter=new ut(e.notAfter))}}h([p({type:ut})],Fa.prototype,"notBefore",void 0);h([p({type:ut})],Fa.prototype,"notAfter",void 0);var Jf;let dr=class V1{constructor(e={}){this.extnID="",this.critical=V1.CRITICAL,this.extnValue=new Ee,Object.assign(this,e)}};dr.CRITICAL=!1;h([p({type:S.ObjectIdentifier})],dr.prototype,"extnID",void 0);h([p({type:S.Boolean,defaultValue:dr.CRITICAL})],dr.prototype,"critical",void 0);h([p({type:Ee})],dr.prototype,"extnValue",void 0);let Hn=Jf=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,Jf.prototype)}};Hn=Jf=h([V({type:U.Sequence,itemType:dr})],Hn);var Li;(function(r){r[r.v1=0]="v1",r[r.v2=1]="v2",r[r.v3=2]="v3"})(Li||(Li={}));class tr{constructor(e={}){this.version=Li.v1,this.serialNumber=new ArrayBuffer(0),this.signature=new X,this.issuer=new Ze,this.validity=new Fa,this.subject=new Ze,this.subjectPublicKeyInfo=new xr,Object.assign(this,e)}}h([p({type:S.Integer,context:0,defaultValue:Li.v1})],tr.prototype,"version",void 0);h([p({type:S.Integer,converter:Ve})],tr.prototype,"serialNumber",void 0);h([p({type:X})],tr.prototype,"signature",void 0);h([p({type:Ze})],tr.prototype,"issuer",void 0);h([p({type:Fa})],tr.prototype,"validity",void 0);h([p({type:Ze})],tr.prototype,"subject",void 0);h([p({type:xr})],tr.prototype,"subjectPublicKeyInfo",void 0);h([p({type:S.BitString,context:1,implicit:!0,optional:!0})],tr.prototype,"issuerUniqueID",void 0);h([p({type:S.BitString,context:2,implicit:!0,optional:!0})],tr.prototype,"subjectUniqueID",void 0);h([p({type:Hn,context:3,optional:!0})],tr.prototype,"extensions",void 0);class Mi{constructor(e={}){this.tbsCertificate=new tr,this.signatureAlgorithm=new X,this.signatureValue=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:tr})],Mi.prototype,"tbsCertificate",void 0);h([p({type:X})],Mi.prototype,"signatureAlgorithm",void 0);h([p({type:S.BitString})],Mi.prototype,"signatureValue",void 0);class ud{constructor(e={}){this.userCertificate=new ArrayBuffer(0),this.revocationDate=new ut,Object.assign(this,e)}}h([p({type:S.Integer,converter:Ve})],ud.prototype,"userCertificate",void 0);h([p({type:ut})],ud.prototype,"revocationDate",void 0);h([p({type:dr,optional:!0,repeated:"sequence"})],ud.prototype,"crlEntryExtensions",void 0);class wn{constructor(e={}){this.signature=new X,this.issuer=new Ze,this.thisUpdate=new ut,Object.assign(this,e)}}h([p({type:S.Integer,optional:!0})],wn.prototype,"version",void 0);h([p({type:X})],wn.prototype,"signature",void 0);h([p({type:Ze})],wn.prototype,"issuer",void 0);h([p({type:ut})],wn.prototype,"thisUpdate",void 0);h([p({type:ut,optional:!0})],wn.prototype,"nextUpdate",void 0);h([p({type:ud,repeated:"sequence",optional:!0})],wn.prototype,"revokedCertificates",void 0);h([p({type:dr,optional:!0,context:0,repeated:"sequence"})],wn.prototype,"crlExtensions",void 0);class ym{constructor(e={}){this.tbsCertList=new wn,this.signatureAlgorithm=new X,this.signature=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:wn})],ym.prototype,"tbsCertList",void 0);h([p({type:X})],ym.prototype,"signatureAlgorithm",void 0);h([p({type:S.BitString})],ym.prototype,"signature",void 0);class co{constructor(e={}){this.issuer=new Ze,this.serialNumber=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:Ze})],co.prototype,"issuer",void 0);h([p({type:S.Integer,converter:Ve})],co.prototype,"serialNumber",void 0);let Us=class{constructor(e={}){Object.assign(this,e)}};h([p({type:$n,context:0,implicit:!0})],Us.prototype,"subjectKeyIdentifier",void 0);h([p({type:co})],Us.prototype,"issuerAndSerialNumber",void 0);Us=h([V({type:U.Choice})],Us);var fn;(function(r){r[r.v0=0]="v0",r[r.v1=1]="v1",r[r.v2=2]="v2",r[r.v3=3]="v3",r[r.v4=4]="v4",r[r.v5=5]="v5"})(fn||(fn={}));let sa=class extends X{};sa=h([V({type:U.Sequence})],sa);let Vl=class extends X{};Vl=h([V({type:U.Sequence})],Vl);let jr=class extends X{};jr=h([V({type:U.Sequence})],jr);let ql=class extends X{};ql=h([V({type:U.Sequence})],ql);let Yw=class extends X{};Yw=h([V({type:U.Sequence})],Yw);let ep=class extends X{};ep=h([V({type:U.Sequence})],ep);let lo=class{constructor(e={}){this.attrType="",this.attrValues=[],Object.assign(this,e)}};h([p({type:S.ObjectIdentifier})],lo.prototype,"attrType",void 0);h([p({type:S.Any,repeated:"set"})],lo.prototype,"attrValues",void 0);var tp;class Hr{constructor(e={}){this.version=fn.v0,this.sid=new Us,this.digestAlgorithm=new sa,this.signatureAlgorithm=new Vl,this.signature=new Ee,Object.assign(this,e)}}h([p({type:S.Integer})],Hr.prototype,"version",void 0);h([p({type:Us})],Hr.prototype,"sid",void 0);h([p({type:sa})],Hr.prototype,"digestAlgorithm",void 0);h([p({type:lo,repeated:"set",context:0,implicit:!0,optional:!0})],Hr.prototype,"signedAttrs",void 0);h([p({type:Vl})],Hr.prototype,"signatureAlgorithm",void 0);h([p({type:Ee})],Hr.prototype,"signature",void 0);h([p({type:lo,repeated:"set",context:1,implicit:!0,optional:!0})],Hr.prototype,"unsignedAttrs",void 0);let jl=tp=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,tp.prototype)}};jl=tp=h([V({type:U.Set,itemType:Hr})],jl);let Qw=class extends ut{};Qw=h([V({type:U.Choice})],Qw);let Xw=class extends Hr{};Xw=h([V({type:U.Sequence})],Xw);class wm{constructor(e={}){this.acIssuer=new de,this.acSerial=0,this.attrs=[],Object.assign(this,e)}}h([p({type:de})],wm.prototype,"acIssuer",void 0);h([p({type:S.Integer})],wm.prototype,"acSerial",void 0);h([p({type:hn,repeated:"sequence"})],wm.prototype,"attrs",void 0);var rp;let zl=rp=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,rp.prototype)}};zl=rp=h([V({type:U.Sequence,itemType:S.ObjectIdentifier})],zl);class dd{constructor(e={}){this.permitUnSpecified=!0,Object.assign(this,e)}}h([p({type:S.Integer,optional:!0})],dd.prototype,"pathLenConstraint",void 0);h([p({type:zl,implicit:!0,context:0,optional:!0})],dd.prototype,"permittedAttrs",void 0);h([p({type:zl,implicit:!0,context:1,optional:!0})],dd.prototype,"excludedAttrs",void 0);h([p({type:S.Boolean,defaultValue:!0})],dd.prototype,"permitUnSpecified",void 0);class Qi{constructor(e={}){this.issuer=new Rt,this.serial=new ArrayBuffer(0),this.issuerUID=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:Rt})],Qi.prototype,"issuer",void 0);h([p({type:S.Integer,converter:Ve})],Qi.prototype,"serial",void 0);h([p({type:S.BitString,optional:!0})],Qi.prototype,"issuerUID",void 0);var np;(function(r){r[r.publicKey=0]="publicKey",r[r.publicKeyCert=1]="publicKeyCert",r[r.otherObjectTypes=2]="otherObjectTypes"})(np||(np={}));class Xi{constructor(e={}){this.digestedObjectType=np.publicKey,this.digestAlgorithm=new X,this.objectDigest=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:S.Enumerated})],Xi.prototype,"digestedObjectType",void 0);h([p({type:S.ObjectIdentifier,optional:!0})],Xi.prototype,"otherObjectTypeID",void 0);h([p({type:X})],Xi.prototype,"digestAlgorithm",void 0);h([p({type:S.BitString})],Xi.prototype,"objectDigest",void 0);class hd{constructor(e={}){Object.assign(this,e)}}h([p({type:Rt,optional:!0})],hd.prototype,"issuerName",void 0);h([p({type:Qi,context:0,implicit:!0,optional:!0})],hd.prototype,"baseCertificateID",void 0);h([p({type:Xi,context:1,implicit:!0,optional:!0})],hd.prototype,"objectDigestInfo",void 0);let Fs=class{constructor(e={}){Object.assign(this,e)}};h([p({type:de,repeated:"sequence"})],Fs.prototype,"v1Form",void 0);h([p({type:hd,context:0,implicit:!0})],Fs.prototype,"v2Form",void 0);Fs=h([V({type:U.Choice})],Fs);class fd{constructor(e={}){this.notBeforeTime=new Date,this.notAfterTime=new Date,Object.assign(this,e)}}h([p({type:S.GeneralizedTime})],fd.prototype,"notBeforeTime",void 0);h([p({type:S.GeneralizedTime})],fd.prototype,"notAfterTime",void 0);class $a{constructor(e={}){Object.assign(this,e)}}h([p({type:Qi,implicit:!0,context:0,optional:!0})],$a.prototype,"baseCertificateID",void 0);h([p({type:Rt,implicit:!0,context:1,optional:!0})],$a.prototype,"entityName",void 0);h([p({type:Xi,implicit:!0,context:2,optional:!0})],$a.prototype,"objectDigestInfo",void 0);var ip;(function(r){r[r.v2=1]="v2"})(ip||(ip={}));class Pr{constructor(e={}){this.version=ip.v2,this.holder=new $a,this.issuer=new Fs,this.signature=new X,this.serialNumber=new ArrayBuffer(0),this.attrCertValidityPeriod=new fd,this.attributes=[],Object.assign(this,e)}}h([p({type:S.Integer})],Pr.prototype,"version",void 0);h([p({type:$a})],Pr.prototype,"holder",void 0);h([p({type:Fs})],Pr.prototype,"issuer",void 0);h([p({type:X})],Pr.prototype,"signature",void 0);h([p({type:S.Integer,converter:Ve})],Pr.prototype,"serialNumber",void 0);h([p({type:fd})],Pr.prototype,"attrCertValidityPeriod",void 0);h([p({type:hn,repeated:"sequence"})],Pr.prototype,"attributes",void 0);h([p({type:S.BitString,optional:!0})],Pr.prototype,"issuerUniqueID",void 0);h([p({type:Hn,optional:!0})],Pr.prototype,"extensions",void 0);class pd{constructor(e={}){this.acinfo=new Pr,this.signatureAlgorithm=new X,this.signatureValue=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:Pr})],pd.prototype,"acinfo",void 0);h([p({type:X})],pd.prototype,"signatureAlgorithm",void 0);h([p({type:S.BitString})],pd.prototype,"signatureValue",void 0);var Hl;(function(r){r[r.unmarked=1]="unmarked",r[r.unclassified=2]="unclassified",r[r.restricted=4]="restricted",r[r.confidential=8]="confidential",r[r.secret=16]="secret",r[r.topSecret=32]="topSecret"})(Hl||(Hl={}));class sp extends sd{}class bm{constructor(e={}){this.type="",this.value=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:S.ObjectIdentifier,implicit:!0,context:0})],bm.prototype,"type",void 0);h([p({type:S.Any,implicit:!0,context:1})],bm.prototype,"value",void 0);class vm{constructor(e={}){this.policyId="",this.classList=new sp(Hl.unclassified),Object.assign(this,e)}}h([p({type:S.ObjectIdentifier})],vm.prototype,"policyId",void 0);h([p({type:sp,defaultValue:new sp(Hl.unclassified)})],vm.prototype,"classList",void 0);h([p({type:bm,repeated:"set"})],vm.prototype,"securityCategories",void 0);class gd{constructor(e={}){Object.assign(this,e)}}h([p({type:Ee})],gd.prototype,"cotets",void 0);h([p({type:S.ObjectIdentifier})],gd.prototype,"oid",void 0);h([p({type:S.Utf8String})],gd.prototype,"string",void 0);class q1{constructor(e={}){this.values=[],Object.assign(this,e)}}h([p({type:Rt,implicit:!0,context:0,optional:!0})],q1.prototype,"policyAuthority",void 0);h([p({type:gd,repeated:"sequence"})],q1.prototype,"values",void 0);var op;class md{constructor(e={}){this.targetCertificate=new Qi,Object.assign(this,e)}}h([p({type:Qi})],md.prototype,"targetCertificate",void 0);h([p({type:de,optional:!0})],md.prototype,"targetName",void 0);h([p({type:Xi,optional:!0})],md.prototype,"certDigestInfo",void 0);let $s=class{constructor(e={}){Object.assign(this,e)}};h([p({type:de,context:0,implicit:!0})],$s.prototype,"targetName",void 0);h([p({type:de,context:1,implicit:!0})],$s.prototype,"targetGroup",void 0);h([p({type:md,context:2,implicit:!0})],$s.prototype,"targetCert",void 0);$s=h([V({type:U.Choice})],$s);let ap=op=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,op.prototype)}};ap=op=h([V({type:U.Sequence,itemType:$s})],ap);var cp;let Zw=cp=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,cp.prototype)}};Zw=cp=h([V({type:U.Sequence,itemType:ap})],Zw);class j1{constructor(e={}){Object.assign(this,e)}}h([p({type:Rt,implicit:!0,context:0,optional:!0})],j1.prototype,"roleAuthority",void 0);h([p({type:de,implicit:!0,context:1})],j1.prototype,"roleName",void 0);class Sm{constructor(e={}){this.service=new de,this.ident=new de,Object.assign(this,e)}}h([p({type:de})],Sm.prototype,"service",void 0);h([p({type:de})],Sm.prototype,"ident",void 0);h([p({type:Ee,optional:!0})],Sm.prototype,"authInfo",void 0);var lp;class Em{constructor(e={}){this.otherCertFormat="",this.otherCert=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:S.ObjectIdentifier})],Em.prototype,"otherCertFormat",void 0);h([p({type:S.Any})],Em.prototype,"otherCert",void 0);let Vs=class{constructor(e={}){Object.assign(this,e)}};h([p({type:Mi})],Vs.prototype,"certificate",void 0);h([p({type:pd,context:2,implicit:!0})],Vs.prototype,"v2AttrCert",void 0);h([p({type:Em,context:3,implicit:!0})],Vs.prototype,"other",void 0);Vs=h([V({type:U.Choice})],Vs);let Wl=lp=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,lp.prototype)}};Wl=lp=h([V({type:U.Set,itemType:Vs})],Wl);class uo{constructor(e={}){this.contentType="",this.content=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:S.ObjectIdentifier})],uo.prototype,"contentType",void 0);h([p({type:S.Any,context:0})],uo.prototype,"content",void 0);let oa=class{constructor(e={}){Object.assign(this,e)}};h([p({type:Ee})],oa.prototype,"single",void 0);h([p({type:S.Any})],oa.prototype,"any",void 0);oa=h([V({type:U.Choice})],oa);class yd{constructor(e={}){this.eContentType="",Object.assign(this,e)}}h([p({type:S.ObjectIdentifier})],yd.prototype,"eContentType",void 0);h([p({type:oa,context:0,optional:!0})],yd.prototype,"eContent",void 0);let aa=class{constructor(e={}){Object.assign(this,e)}};h([p({type:Ee,context:0,implicit:!0,optional:!0})],aa.prototype,"value",void 0);h([p({type:Ee,converter:nN,context:0,implicit:!0,optional:!0,repeated:"sequence"})],aa.prototype,"constructedValue",void 0);aa=h([V({type:U.Choice})],aa);class Va{constructor(e={}){this.contentType="",this.contentEncryptionAlgorithm=new ql,Object.assign(this,e)}}h([p({type:S.ObjectIdentifier})],Va.prototype,"contentType",void 0);h([p({type:ql})],Va.prototype,"contentEncryptionAlgorithm",void 0);h([p({type:aa,optional:!0})],Va.prototype,"encryptedContent",void 0);class wd{constructor(e={}){this.keyAttrId="",Object.assign(this,e)}}h([p({type:S.ObjectIdentifier})],wd.prototype,"keyAttrId",void 0);h([p({type:S.Any,optional:!0})],wd.prototype,"keyAttr",void 0);var up;class bd{constructor(e={}){this.subjectKeyIdentifier=new $n,Object.assign(this,e)}}h([p({type:$n})],bd.prototype,"subjectKeyIdentifier",void 0);h([p({type:S.GeneralizedTime,optional:!0})],bd.prototype,"date",void 0);h([p({type:wd,optional:!0})],bd.prototype,"other",void 0);let qs=class{constructor(e={}){Object.assign(this,e)}};h([p({type:bd,context:0,implicit:!0,optional:!0})],qs.prototype,"rKeyId",void 0);h([p({type:co,optional:!0})],qs.prototype,"issuerAndSerialNumber",void 0);qs=h([V({type:U.Choice})],qs);class Am{constructor(e={}){this.rid=new qs,this.encryptedKey=new Ee,Object.assign(this,e)}}h([p({type:qs})],Am.prototype,"rid",void 0);h([p({type:Ee})],Am.prototype,"encryptedKey",void 0);let Kl=up=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,up.prototype)}};Kl=up=h([V({type:U.Sequence,itemType:Am})],Kl);class xm{constructor(e={}){this.algorithm=new X,this.publicKey=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:X})],xm.prototype,"algorithm",void 0);h([p({type:S.BitString})],xm.prototype,"publicKey",void 0);let Ui=class{constructor(e={}){Object.assign(this,e)}};h([p({type:$n,context:0,implicit:!0,optional:!0})],Ui.prototype,"subjectKeyIdentifier",void 0);h([p({type:xm,context:1,implicit:!0,optional:!0})],Ui.prototype,"originatorKey",void 0);h([p({type:co,optional:!0})],Ui.prototype,"issuerAndSerialNumber",void 0);Ui=h([V({type:U.Choice})],Ui);class ho{constructor(e={}){this.version=fn.v3,this.originator=new Ui,this.keyEncryptionAlgorithm=new jr,this.recipientEncryptedKeys=new Kl,Object.assign(this,e)}}h([p({type:S.Integer})],ho.prototype,"version",void 0);h([p({type:Ui,context:0})],ho.prototype,"originator",void 0);h([p({type:Ee,context:1,optional:!0})],ho.prototype,"ukm",void 0);h([p({type:jr})],ho.prototype,"keyEncryptionAlgorithm",void 0);h([p({type:Kl})],ho.prototype,"recipientEncryptedKeys",void 0);let js=class{constructor(e={}){Object.assign(this,e)}};h([p({type:$n,context:0,implicit:!0})],js.prototype,"subjectKeyIdentifier",void 0);h([p({type:co})],js.prototype,"issuerAndSerialNumber",void 0);js=h([V({type:U.Choice})],js);class qa{constructor(e={}){this.version=fn.v0,this.rid=new js,this.keyEncryptionAlgorithm=new jr,this.encryptedKey=new Ee,Object.assign(this,e)}}h([p({type:S.Integer})],qa.prototype,"version",void 0);h([p({type:js})],qa.prototype,"rid",void 0);h([p({type:jr})],qa.prototype,"keyEncryptionAlgorithm",void 0);h([p({type:Ee})],qa.prototype,"encryptedKey",void 0);class ja{constructor(e={}){this.keyIdentifier=new Ee,Object.assign(this,e)}}h([p({type:Ee})],ja.prototype,"keyIdentifier",void 0);h([p({type:S.GeneralizedTime,optional:!0})],ja.prototype,"date",void 0);h([p({type:wd,optional:!0})],ja.prototype,"other",void 0);class za{constructor(e={}){this.version=fn.v4,this.kekid=new ja,this.keyEncryptionAlgorithm=new jr,this.encryptedKey=new Ee,Object.assign(this,e)}}h([p({type:S.Integer})],za.prototype,"version",void 0);h([p({type:ja})],za.prototype,"kekid",void 0);h([p({type:jr})],za.prototype,"keyEncryptionAlgorithm",void 0);h([p({type:Ee})],za.prototype,"encryptedKey",void 0);class Ha{constructor(e={}){this.version=fn.v0,this.keyEncryptionAlgorithm=new jr,this.encryptedKey=new Ee,Object.assign(this,e)}}h([p({type:S.Integer})],Ha.prototype,"version",void 0);h([p({type:ep,context:0,optional:!0})],Ha.prototype,"keyDerivationAlgorithm",void 0);h([p({type:jr})],Ha.prototype,"keyEncryptionAlgorithm",void 0);h([p({type:Ee})],Ha.prototype,"encryptedKey",void 0);class _m{constructor(e={}){this.oriType="",this.oriValue=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:S.ObjectIdentifier})],_m.prototype,"oriType",void 0);h([p({type:S.Any})],_m.prototype,"oriValue",void 0);let Wn=class{constructor(e={}){Object.assign(this,e)}};h([p({type:qa,optional:!0})],Wn.prototype,"ktri",void 0);h([p({type:ho,context:1,implicit:!0,optional:!0})],Wn.prototype,"kari",void 0);h([p({type:za,context:2,implicit:!0,optional:!0})],Wn.prototype,"kekri",void 0);h([p({type:Ha,context:3,implicit:!0,optional:!0})],Wn.prototype,"pwri",void 0);h([p({type:_m,context:4,implicit:!0,optional:!0})],Wn.prototype,"ori",void 0);Wn=h([V({type:U.Choice})],Wn);var dp;let Gl=dp=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,dp.prototype)}};Gl=dp=h([V({type:U.Set,itemType:Wn})],Gl);var hp;class vd{constructor(e={}){this.otherRevInfoFormat="",this.otherRevInfo=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:S.ObjectIdentifier})],vd.prototype,"otherRevInfoFormat",void 0);h([p({type:S.Any})],vd.prototype,"otherRevInfo",void 0);let Yl=class{constructor(e={}){this.other=new vd,Object.assign(this,e)}};h([p({type:vd,context:1,implicit:!0})],Yl.prototype,"other",void 0);Yl=h([V({type:U.Choice})],Yl);let Ql=hp=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,hp.prototype)}};Ql=hp=h([V({type:U.Set,itemType:Yl})],Ql);class Cm{constructor(e={}){Object.assign(this,e)}}h([p({type:Wl,context:0,implicit:!0,optional:!0})],Cm.prototype,"certs",void 0);h([p({type:Ql,context:1,implicit:!0,optional:!0})],Cm.prototype,"crls",void 0);var fp;let pp=fp=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,fp.prototype)}};pp=fp=h([V({type:U.Set,itemType:lo})],pp);class Wa{constructor(e={}){this.version=fn.v0,this.recipientInfos=new Gl,this.encryptedContentInfo=new Va,Object.assign(this,e)}}h([p({type:S.Integer})],Wa.prototype,"version",void 0);h([p({type:Cm,context:0,implicit:!0,optional:!0})],Wa.prototype,"originatorInfo",void 0);h([p({type:Gl})],Wa.prototype,"recipientInfos",void 0);h([p({type:Va})],Wa.prototype,"encryptedContentInfo",void 0);h([p({type:pp,context:1,implicit:!0,optional:!0})],Wa.prototype,"unprotectedAttrs",void 0);const TN="1.2.840.113549.1.7.2";var gp;let Xl=gp=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,gp.prototype)}};Xl=gp=h([V({type:U.Set,itemType:sa})],Xl);class fo{constructor(e={}){this.version=fn.v0,this.digestAlgorithms=new Xl,this.encapContentInfo=new yd,this.signerInfos=new jl,Object.assign(this,e)}}h([p({type:S.Integer})],fo.prototype,"version",void 0);h([p({type:Xl})],fo.prototype,"digestAlgorithms",void 0);h([p({type:yd})],fo.prototype,"encapContentInfo",void 0);h([p({type:Wl,context:0,implicit:!0,optional:!0})],fo.prototype,"certificates",void 0);h([p({type:Ql,context:1,implicit:!0,optional:!0})],fo.prototype,"crls",void 0);h([p({type:jl})],fo.prototype,"signerInfos",void 0);const ca="1.2.840.10045.2.1",Im="1.2.840.10045.4.1",z1="1.2.840.10045.4.3.1",km="1.2.840.10045.4.3.2",Tm="1.2.840.10045.4.3.3",Pm="1.2.840.10045.4.3.4",Jw="1.2.840.10045.3.1.7",eb="1.3.132.0.34",tb="1.3.132.0.35";function Ka(r){return new X({algorithm:r})}const PN=Ka(Im);Ka(z1);const RN=Ka(km),ON=Ka(Tm),BN=Ka(Pm);let la=class{constructor(e={}){Object.assign(this,e)}};h([p({type:S.ObjectIdentifier})],la.prototype,"fieldType",void 0);h([p({type:S.Any})],la.prototype,"parameters",void 0);la=h([V({type:U.Sequence})],la);class NN extends Ee{}let zs=class{constructor(e={}){Object.assign(this,e)}};h([p({type:S.OctetString})],zs.prototype,"a",void 0);h([p({type:S.OctetString})],zs.prototype,"b",void 0);h([p({type:S.BitString,optional:!0})],zs.prototype,"seed",void 0);zs=h([V({type:U.Sequence})],zs);var mp;(function(r){r[r.ecpVer1=1]="ecpVer1"})(mp||(mp={}));let pn=class{constructor(e={}){this.version=mp.ecpVer1,Object.assign(this,e)}};h([p({type:S.Integer})],pn.prototype,"version",void 0);h([p({type:la})],pn.prototype,"fieldID",void 0);h([p({type:zs})],pn.prototype,"curve",void 0);h([p({type:NN})],pn.prototype,"base",void 0);h([p({type:S.Integer,converter:Ve})],pn.prototype,"order",void 0);h([p({type:S.Integer,optional:!0})],pn.prototype,"cofactor",void 0);pn=h([V({type:U.Sequence})],pn);let Kn=class{constructor(e={}){Object.assign(this,e)}};h([p({type:S.ObjectIdentifier})],Kn.prototype,"namedCurve",void 0);h([p({type:S.Null})],Kn.prototype,"implicitCurve",void 0);h([p({type:pn})],Kn.prototype,"specifiedCurve",void 0);Kn=h([V({type:U.Choice})],Kn);class Sd{constructor(e={}){this.version=1,this.privateKey=new Ee,Object.assign(this,e)}}h([p({type:S.Integer})],Sd.prototype,"version",void 0);h([p({type:Ee})],Sd.prototype,"privateKey",void 0);h([p({type:Kn,context:0,optional:!0})],Sd.prototype,"parameters",void 0);h([p({type:S.BitString,context:1,optional:!0})],Sd.prototype,"publicKey",void 0);class Zl{constructor(e={}){this.r=new ArrayBuffer(0),this.s=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:S.Integer,converter:Ve})],Zl.prototype,"r",void 0);h([p({type:S.Integer,converter:Ve})],Zl.prototype,"s",void 0);const qt="1.2.840.113549.1.1",Fi=`${qt}.1`,DN=`${qt}.7`,LN=`${qt}.9`,jo=`${qt}.10`,MN=`${qt}.2`,UN=`${qt}.4`,Jl=`${qt}.5`,FN=`${qt}.14`,yp=`${qt}.11`,eu=`${qt}.12`,tu=`${qt}.13`,H1=`${qt}.15`,W1=`${qt}.16`,ru="1.3.14.3.2.26",K1="2.16.840.1.101.3.4.2.4",nu="2.16.840.1.101.3.4.2.1",iu="2.16.840.1.101.3.4.2.2",su="2.16.840.1.101.3.4.2.3",$N="2.16.840.1.101.3.4.2.5",VN="2.16.840.1.101.3.4.2.6",qN="1.2.840.113549.2.2",jN="1.2.840.113549.2.5",Ed=`${qt}.8`;function it(r){return new X({algorithm:r,parameters:null})}it(qN);it(jN);const $i=it(ru);it(K1);it(nu);it(iu);it(su);it($N);it(VN);const G1=new X({algorithm:Ed,parameters:G.serialize($i)}),Y1=new X({algorithm:LN,parameters:G.serialize(Nl.toASN(new Uint8Array([218,57,163,238,94,107,75,13,50,85,191,239,149,96,24,144,175,216,7,9]).buffer))});it(Fi);it(MN);it(UN);it(Jl);it(H1);it(W1);it(eu);it(tu);it(H1);it(W1);class Ad{constructor(e={}){this.hashAlgorithm=new X($i),this.maskGenAlgorithm=new X({algorithm:Ed,parameters:G.serialize($i)}),this.pSourceAlgorithm=new X(Y1),Object.assign(this,e)}}h([p({type:X,context:0,defaultValue:$i})],Ad.prototype,"hashAlgorithm",void 0);h([p({type:X,context:1,defaultValue:G1})],Ad.prototype,"maskGenAlgorithm",void 0);h([p({type:X,context:2,defaultValue:Y1})],Ad.prototype,"pSourceAlgorithm",void 0);new X({algorithm:DN,parameters:G.serialize(new Ad)});class Vi{constructor(e={}){this.hashAlgorithm=new X($i),this.maskGenAlgorithm=new X({algorithm:Ed,parameters:G.serialize($i)}),this.saltLength=20,this.trailerField=1,Object.assign(this,e)}}h([p({type:X,context:0,defaultValue:$i})],Vi.prototype,"hashAlgorithm",void 0);h([p({type:X,context:1,defaultValue:G1})],Vi.prototype,"maskGenAlgorithm",void 0);h([p({type:S.Integer,context:2,defaultValue:20})],Vi.prototype,"saltLength",void 0);h([p({type:S.Integer,context:3,defaultValue:1})],Vi.prototype,"trailerField",void 0);new X({algorithm:jo,parameters:G.serialize(new Vi)});class xd{constructor(e={}){this.digestAlgorithm=new X,this.digest=new Ee,Object.assign(this,e)}}h([p({type:X})],xd.prototype,"digestAlgorithm",void 0);h([p({type:Ee})],xd.prototype,"digest",void 0);var wp;class _d{constructor(e={}){this.prime=new ArrayBuffer(0),this.exponent=new ArrayBuffer(0),this.coefficient=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:S.Integer,converter:Ve})],_d.prototype,"prime",void 0);h([p({type:S.Integer,converter:Ve})],_d.prototype,"exponent",void 0);h([p({type:S.Integer,converter:Ve})],_d.prototype,"coefficient",void 0);let bp=wp=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,wp.prototype)}};bp=wp=h([V({type:U.Sequence,itemType:_d})],bp);class Wr{constructor(e={}){this.version=0,this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0),this.privateExponent=new ArrayBuffer(0),this.prime1=new ArrayBuffer(0),this.prime2=new ArrayBuffer(0),this.exponent1=new ArrayBuffer(0),this.exponent2=new ArrayBuffer(0),this.coefficient=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:S.Integer})],Wr.prototype,"version",void 0);h([p({type:S.Integer,converter:Ve})],Wr.prototype,"modulus",void 0);h([p({type:S.Integer,converter:Ve})],Wr.prototype,"publicExponent",void 0);h([p({type:S.Integer,converter:Ve})],Wr.prototype,"privateExponent",void 0);h([p({type:S.Integer,converter:Ve})],Wr.prototype,"prime1",void 0);h([p({type:S.Integer,converter:Ve})],Wr.prototype,"prime2",void 0);h([p({type:S.Integer,converter:Ve})],Wr.prototype,"exponent1",void 0);h([p({type:S.Integer,converter:Ve})],Wr.prototype,"exponent2",void 0);h([p({type:S.Integer,converter:Ve})],Wr.prototype,"coefficient",void 0);h([p({type:bp,optional:!0})],Wr.prototype,"otherPrimeInfos",void 0);class Rm{constructor(e={}){this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:S.Integer,converter:Ve})],Rm.prototype,"modulus",void 0);h([p({type:S.Integer,converter:Ve})],Rm.prototype,"publicExponent",void 0);var vp;(function(r){r[r.Transient=0]="Transient",r[r.Singleton=1]="Singleton",r[r.ResolutionScoped=2]="ResolutionScoped",r[r.ContainerScoped=3]="ContainerScoped"})(vp||(vp={}));const Nt=vp;/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var Sp=function(r,e){return Sp=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,n){t.__proto__=n}||function(t,n){for(var i in n)n.hasOwnProperty(i)&&(t[i]=n[i])},Sp(r,e)};function Om(r,e){Sp(r,e);function t(){this.constructor=r}r.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}function zN(r,e,t,n){function i(s){return s instanceof t?s:new t(function(o){o(s)})}return new(t||(t=Promise))(function(s,o){function a(u){try{l(n.next(u))}catch(d){o(d)}}function c(u){try{l(n.throw(u))}catch(d){o(d)}}function l(u){u.done?s(u.value):i(u.value).then(a,c)}l((n=n.apply(r,[])).next())})}function HN(r,e){var t={label:0,sent:function(){if(s[0]&1)throw s[1];return s[1]},trys:[],ops:[]},n,i,s,o;return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(l){return function(u){return c([l,u])}}function c(l){if(n)throw new TypeError("Generator is already executing.");for(;t;)try{if(n=1,i&&(s=l[0]&2?i.return:l[0]?i.throw||((s=i.return)&&s.call(i),0):i.next)&&!(s=s.call(i,l[1])).done)return s;switch(i=0,s&&(l=[l[0]&2,s.value]),l[0]){case 0:case 1:s=l;break;case 4:return t.label++,{value:l[1],done:!1};case 5:t.label++,i=l[1],l=[0];continue;case 7:l=t.ops.pop(),t.trys.pop();continue;default:if(s=t.trys,!(s=s.length>0&&s[s.length-1])&&(l[0]===6||l[0]===2)){t=0;continue}if(l[0]===3&&(!s||l[1]>s[0]&&l[1]<s[3])){t.label=l[1];break}if(l[0]===6&&t.label<s[1]){t.label=s[1],s=l;break}if(s&&t.label<s[2]){t.label=s[2],t.ops.push(l);break}s[2]&&t.ops.pop(),t.trys.pop();continue}l=e.call(r,t)}catch(u){l=[6,u],i=0}finally{n=s=0}if(l[0]&5)throw l[1];return{value:l[0]?l[1]:void 0,done:!0}}}function vc(r){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&r[e],n=0;if(t)return t.call(r);if(r&&typeof r.length=="number")return{next:function(){return r&&n>=r.length&&(r=void 0),{value:r&&r[n++],done:!r}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")}function ou(r,e){var t=typeof Symbol=="function"&&r[Symbol.iterator];if(!t)return r;var n=t.call(r),i,s=[],o;try{for(;(e===void 0||e-- >0)&&!(i=n.next()).done;)s.push(i.value)}catch(a){o={error:a}}finally{try{i&&!i.done&&(t=n.return)&&t.call(n)}finally{if(o)throw o.error}}return s}function ai(){for(var r=[],e=0;e<arguments.length;e++)r=r.concat(ou(arguments[e]));return r}var WN="injectionTokens";function KN(r){var e=Reflect.getMetadata("design:paramtypes",r)||[],t=Reflect.getOwnMetadata(WN,r)||{};return Object.keys(t).forEach(function(n){e[+n]=t[n]}),e}function Q1(r){return!!r.useClass}function Ep(r){return!!r.useFactory}var X1=function(){function r(e){this.wrap=e,this.reflectMethods=["get","getPrototypeOf","setPrototypeOf","getOwnPropertyDescriptor","defineProperty","has","set","deleteProperty","apply","construct","ownKeys"]}return r.prototype.createProxy=function(e){var t=this,n={},i=!1,s,o=function(){return i||(s=e(t.wrap()),i=!0),s};return new Proxy(n,this.createHandler(o))},r.prototype.createHandler=function(e){var t={},n=function(i){t[i]=function(){for(var s=[],o=0;o<arguments.length;o++)s[o]=arguments[o];s[0]=e();var a=Reflect[i];return a.apply(void 0,ai(s))}};return this.reflectMethods.forEach(n),t},r}();function is(r){return typeof r=="string"||typeof r=="symbol"}function GN(r){return typeof r=="object"&&"token"in r&&"multiple"in r}function rb(r){return typeof r=="object"&&"token"in r&&"transform"in r}function YN(r){return typeof r=="function"||r instanceof X1}function Wc(r){return!!r.useToken}function Kc(r){return r.useValue!=null}function QN(r){return Q1(r)||Kc(r)||Wc(r)||Ep(r)}var Bm=function(){function r(){this._registryMap=new Map}return r.prototype.entries=function(){return this._registryMap.entries()},r.prototype.getAll=function(e){return this.ensure(e),this._registryMap.get(e)},r.prototype.get=function(e){this.ensure(e);var t=this._registryMap.get(e);return t[t.length-1]||null},r.prototype.set=function(e,t){this.ensure(e),this._registryMap.get(e).push(t)},r.prototype.setAll=function(e,t){this._registryMap.set(e,t)},r.prototype.has=function(e){return this.ensure(e),this._registryMap.get(e).length>0},r.prototype.clear=function(){this._registryMap.clear()},r.prototype.ensure=function(e){this._registryMap.has(e)||this._registryMap.set(e,[])},r}(),XN=function(r){Om(e,r);function e(){return r!==null&&r.apply(this,arguments)||this}return e}(Bm),Sc=function(){function r(){this.scopedResolutions=new Map}return r}();function ZN(r,e){if(r===null)return"at position #"+e;var t=r.split(",")[e].trim();return'"'+t+'" at position #'+e}function JN(r,e,t){return t===void 0&&(t="    "),ai([r],e.message.split(`
`).map(function(n){return t+n})).join(`
`)}function eD(r,e,t){var n=ou(r.toString().match(/constructor\(([\w, ]+)\)/)||[],2),i=n[1],s=i===void 0?null:i,o=ZN(s,e);return JN("Cannot inject the dependency "+o+' of "'+r.name+'" constructor. Reason:',t)}function tD(r){if(typeof r.dispose!="function")return!1;var e=r.dispose;return!(e.length>0)}var rD=function(r){Om(e,r);function e(){return r!==null&&r.apply(this,arguments)||this}return e}(Bm),nD=function(r){Om(e,r);function e(){return r!==null&&r.apply(this,arguments)||this}return e}(Bm),iD=function(){function r(){this.preResolution=new rD,this.postResolution=new nD}return r}(),Z1=new Map,sD=function(){function r(e){this.parent=e,this._registry=new XN,this.interceptors=new iD,this.disposed=!1,this.disposables=new Set}return r.prototype.register=function(e,t,n){n===void 0&&(n={lifecycle:Nt.Transient}),this.ensureNotDisposed();var i;if(QN(t)?i=t:i={useClass:t},Wc(i))for(var s=[e],o=i;o!=null;){var a=o.useToken;if(s.includes(a))throw new Error("Token registration cycle detected! "+ai(s,[a]).join(" -> "));s.push(a);var c=this._registry.get(a);c&&Wc(c.provider)?o=c.provider:o=null}if((n.lifecycle===Nt.Singleton||n.lifecycle==Nt.ContainerScoped||n.lifecycle==Nt.ResolutionScoped)&&(Kc(i)||Ep(i)))throw new Error('Cannot use lifecycle "'+Nt[n.lifecycle]+'" with ValueProviders or FactoryProviders');return this._registry.set(e,{provider:i,options:n}),this},r.prototype.registerType=function(e,t){return this.ensureNotDisposed(),is(t)?this.register(e,{useToken:t}):this.register(e,{useClass:t})},r.prototype.registerInstance=function(e,t){return this.ensureNotDisposed(),this.register(e,{useValue:t})},r.prototype.registerSingleton=function(e,t){if(this.ensureNotDisposed(),is(e)){if(is(t))return this.register(e,{useToken:t},{lifecycle:Nt.Singleton});if(t)return this.register(e,{useClass:t},{lifecycle:Nt.Singleton});throw new Error('Cannot register a type name as a singleton without a "to" token')}var n=e;return t&&!is(t)&&(n=t),this.register(e,{useClass:n},{lifecycle:Nt.Singleton})},r.prototype.resolve=function(e,t,n){t===void 0&&(t=new Sc),n===void 0&&(n=!1),this.ensureNotDisposed();var i=this.getRegistration(e);if(!i&&is(e)){if(n)return;throw new Error('Attempted to resolve unregistered dependency token: "'+e.toString()+'"')}if(this.executePreResolutionInterceptor(e,"Single"),i){var s=this.resolveRegistration(i,t);return this.executePostResolutionInterceptor(e,s,"Single"),s}if(YN(e)){var s=this.construct(e,t);return this.executePostResolutionInterceptor(e,s,"Single"),s}throw new Error("Attempted to construct an undefined constructor. Could mean a circular dependency problem. Try using `delay` function.")},r.prototype.executePreResolutionInterceptor=function(e,t){var n,i;if(this.interceptors.preResolution.has(e)){var s=[];try{for(var o=vc(this.interceptors.preResolution.getAll(e)),a=o.next();!a.done;a=o.next()){var c=a.value;c.options.frequency!="Once"&&s.push(c),c.callback(e,t)}}catch(l){n={error:l}}finally{try{a&&!a.done&&(i=o.return)&&i.call(o)}finally{if(n)throw n.error}}this.interceptors.preResolution.setAll(e,s)}},r.prototype.executePostResolutionInterceptor=function(e,t,n){var i,s;if(this.interceptors.postResolution.has(e)){var o=[];try{for(var a=vc(this.interceptors.postResolution.getAll(e)),c=a.next();!c.done;c=a.next()){var l=c.value;l.options.frequency!="Once"&&o.push(l),l.callback(e,t,n)}}catch(u){i={error:u}}finally{try{c&&!c.done&&(s=a.return)&&s.call(a)}finally{if(i)throw i.error}}this.interceptors.postResolution.setAll(e,o)}},r.prototype.resolveRegistration=function(e,t){if(this.ensureNotDisposed(),e.options.lifecycle===Nt.ResolutionScoped&&t.scopedResolutions.has(e))return t.scopedResolutions.get(e);var n=e.options.lifecycle===Nt.Singleton,i=e.options.lifecycle===Nt.ContainerScoped,s=n||i,o;return Kc(e.provider)?o=e.provider.useValue:Wc(e.provider)?o=s?e.instance||(e.instance=this.resolve(e.provider.useToken,t)):this.resolve(e.provider.useToken,t):Q1(e.provider)?o=s?e.instance||(e.instance=this.construct(e.provider.useClass,t)):this.construct(e.provider.useClass,t):Ep(e.provider)?o=e.provider.useFactory(this):o=this.construct(e.provider,t),e.options.lifecycle===Nt.ResolutionScoped&&t.scopedResolutions.set(e,o),o},r.prototype.resolveAll=function(e,t,n){var i=this;t===void 0&&(t=new Sc),n===void 0&&(n=!1),this.ensureNotDisposed();var s=this.getAllRegistrations(e);if(!s&&is(e)){if(n)return[];throw new Error('Attempted to resolve unregistered dependency token: "'+e.toString()+'"')}if(this.executePreResolutionInterceptor(e,"All"),s){var o=s.map(function(c){return i.resolveRegistration(c,t)});return this.executePostResolutionInterceptor(e,o,"All"),o}var a=[this.construct(e,t)];return this.executePostResolutionInterceptor(e,a,"All"),a},r.prototype.isRegistered=function(e,t){return t===void 0&&(t=!1),this.ensureNotDisposed(),this._registry.has(e)||t&&(this.parent||!1)&&this.parent.isRegistered(e,!0)},r.prototype.reset=function(){this.ensureNotDisposed(),this._registry.clear(),this.interceptors.preResolution.clear(),this.interceptors.postResolution.clear()},r.prototype.clearInstances=function(){var e,t;this.ensureNotDisposed();try{for(var n=vc(this._registry.entries()),i=n.next();!i.done;i=n.next()){var s=ou(i.value,2),o=s[0],a=s[1];this._registry.setAll(o,a.filter(function(c){return!Kc(c.provider)}).map(function(c){return c.instance=void 0,c}))}}catch(c){e={error:c}}finally{try{i&&!i.done&&(t=n.return)&&t.call(n)}finally{if(e)throw e.error}}},r.prototype.createChildContainer=function(){var e,t;this.ensureNotDisposed();var n=new r(this);try{for(var i=vc(this._registry.entries()),s=i.next();!s.done;s=i.next()){var o=ou(s.value,2),a=o[0],c=o[1];c.some(function(l){var u=l.options;return u.lifecycle===Nt.ContainerScoped})&&n._registry.setAll(a,c.map(function(l){return l.options.lifecycle===Nt.ContainerScoped?{provider:l.provider,options:l.options}:l}))}}catch(l){e={error:l}}finally{try{s&&!s.done&&(t=i.return)&&t.call(i)}finally{if(e)throw e.error}}return n},r.prototype.beforeResolution=function(e,t,n){n===void 0&&(n={frequency:"Always"}),this.interceptors.preResolution.set(e,{callback:t,options:n})},r.prototype.afterResolution=function(e,t,n){n===void 0&&(n={frequency:"Always"}),this.interceptors.postResolution.set(e,{callback:t,options:n})},r.prototype.dispose=function(){return zN(this,void 0,void 0,function(){var e;return HN(this,function(t){switch(t.label){case 0:return this.disposed=!0,e=[],this.disposables.forEach(function(n){var i=n.dispose();i&&e.push(i)}),[4,Promise.all(e)];case 1:return t.sent(),[2]}})})},r.prototype.getRegistration=function(e){return this.isRegistered(e)?this._registry.get(e):this.parent?this.parent.getRegistration(e):null},r.prototype.getAllRegistrations=function(e){return this.isRegistered(e)?this._registry.getAll(e):this.parent?this.parent.getAllRegistrations(e):null},r.prototype.construct=function(e,t){var n=this;if(e instanceof X1)return e.createProxy(function(s){return n.resolve(s,t)});var i=function(){var s=Z1.get(e);if(!s||s.length===0){if(e.length===0)return new e;throw new Error('TypeInfo not known for "'+e.name+'"')}var o=s.map(n.resolveParams(t,e));return new(e.bind.apply(e,ai([void 0],o)))}();return tD(i)&&this.disposables.add(i),i},r.prototype.resolveParams=function(e,t){var n=this;return function(i,s){var o,a,c;try{return GN(i)?rb(i)?i.multiple?(o=n.resolve(i.transform)).transform.apply(o,ai([n.resolveAll(i.token,new Sc,i.isOptional)],i.transformArgs)):(a=n.resolve(i.transform)).transform.apply(a,ai([n.resolve(i.token,e,i.isOptional)],i.transformArgs)):i.multiple?n.resolveAll(i.token,new Sc,i.isOptional):n.resolve(i.token,e,i.isOptional):rb(i)?(c=n.resolve(i.transform,e)).transform.apply(c,ai([n.resolve(i.token,e)],i.transformArgs)):n.resolve(i,e)}catch(l){throw new Error(eD(t,s,l))}}},r.prototype.ensureNotDisposed=function(){if(this.disposed)throw new Error("This container has been disposed, you cannot interact with a disposed container")},r}(),pt=new sD;function Cd(r){return function(e){Z1.set(e,KN(e))}}if(typeof Reflect>"u"||!Reflect.getMetadata)throw new Error(`tsyringe requires a reflect polyfill. Please add 'import "reflect-metadata"' to the top of your entry point.`);var Ap;class Id{constructor(e={}){this.attrId="",this.attrValues=[],Object.assign(e)}}h([p({type:S.ObjectIdentifier})],Id.prototype,"attrId",void 0);h([p({type:S.Any,repeated:"set"})],Id.prototype,"attrValues",void 0);let nb=Ap=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,Ap.prototype)}};nb=Ap=h([V({type:U.Sequence,itemType:Id})],nb);var xp;let ib=xp=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,xp.prototype)}};ib=xp=h([V({type:U.Sequence,itemType:uo})],ib);class J1{constructor(e={}){this.certId="",this.certValue=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:S.ObjectIdentifier})],J1.prototype,"certId",void 0);h([p({type:S.Any,context:0})],J1.prototype,"certValue",void 0);class eA{constructor(e={}){this.crlId="",this.crltValue=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:S.ObjectIdentifier})],eA.prototype,"crlId",void 0);h([p({type:S.Any,context:0})],eA.prototype,"crltValue",void 0);class tA extends Ee{}let kd=class{constructor(e={}){this.encryptionAlgorithm=new X,this.encryptedData=new tA,Object.assign(this,e)}};h([p({type:X})],kd.prototype,"encryptionAlgorithm",void 0);h([p({type:tA})],kd.prototype,"encryptedData",void 0);var _p,Cp;(function(r){r[r.v1=0]="v1"})(Cp||(Cp={}));class rA extends Ee{}let Ip=_p=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,_p.prototype)}};Ip=_p=h([V({type:U.Sequence,itemType:hn})],Ip);class Ga{constructor(e={}){this.version=Cp.v1,this.privateKeyAlgorithm=new X,this.privateKey=new rA,Object.assign(this,e)}}h([p({type:S.Integer})],Ga.prototype,"version",void 0);h([p({type:X})],Ga.prototype,"privateKeyAlgorithm",void 0);h([p({type:rA})],Ga.prototype,"privateKey",void 0);h([p({type:Ip,implicit:!0,context:0,optional:!0})],Ga.prototype,"attributes",void 0);let sb=class extends Ga{};sb=h([V({type:U.Sequence})],sb);let ob=class extends kd{};ob=h([V({type:U.Sequence})],ob);class nA{constructor(e={}){this.secretTypeId="",this.secretValue=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:S.ObjectIdentifier})],nA.prototype,"secretTypeId",void 0);h([p({type:S.Any,context:0})],nA.prototype,"secretValue",void 0);class Ya{constructor(e={}){this.mac=new xd,this.macSalt=new Ee,this.iterations=1,Object.assign(this,e)}}h([p({type:xd})],Ya.prototype,"mac",void 0);h([p({type:Ee})],Ya.prototype,"macSalt",void 0);h([p({type:S.Integer,defaultValue:1})],Ya.prototype,"iterations",void 0);class Td{constructor(e={}){this.version=3,this.authSafe=new uo,this.macData=new Ya,Object.assign(this,e)}}h([p({type:S.Integer})],Td.prototype,"version",void 0);h([p({type:uo})],Td.prototype,"authSafe",void 0);h([p({type:Ya,optional:!0})],Td.prototype,"macData",void 0);var kp;class Pd{constructor(e={}){this.bagId="",this.bagValue=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:S.ObjectIdentifier})],Pd.prototype,"bagId",void 0);h([p({type:S.Any,context:0})],Pd.prototype,"bagValue",void 0);h([p({type:Id,repeated:"set",optional:!0})],Pd.prototype,"bagAttributes",void 0);let ab=kp=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,kp.prototype)}};ab=kp=h([V({type:U.Sequence,itemType:Pd})],ab);var Tp,Pp,Rp;const iA="1.2.840.113549.1.9",sA=`${iA}.7`,Nm=`${iA}.14`;let au=class extends ft{constructor(e={}){super(e)}toString(){return this.ia5String||super.toString()}};h([p({type:S.IA5String})],au.prototype,"ia5String",void 0);au=h([V({type:U.Choice})],au);let cb=class extends uo{};cb=h([V({type:U.Sequence})],cb);let lb=class extends Td{};lb=h([V({type:U.Sequence})],lb);let ub=class extends kd{};ub=h([V({type:U.Sequence})],ub);let Op=class{constructor(e=""){this.value=e}toString(){return this.value}};h([p({type:S.IA5String})],Op.prototype,"value",void 0);Op=h([V({type:U.Choice})],Op);let db=class extends au{};db=h([V({type:U.Choice})],db);let hb=class extends ft{};hb=h([V({type:U.Choice})],hb);let Bp=class{constructor(e=new Date){this.value=e}};h([p({type:S.GeneralizedTime})],Bp.prototype,"value",void 0);Bp=h([V({type:U.Choice})],Bp);let fb=class extends ft{};fb=h([V({type:U.Choice})],fb);let Np=class{constructor(e="M"){this.value=e}toString(){return this.value}};h([p({type:S.PrintableString})],Np.prototype,"value",void 0);Np=h([V({type:U.Choice})],Np);let cu=class{constructor(e=""){this.value=e}toString(){return this.value}};h([p({type:S.PrintableString})],cu.prototype,"value",void 0);cu=h([V({type:U.Choice})],cu);let pb=class extends cu{};pb=h([V({type:U.Choice})],pb);let gb=class extends ft{};gb=h([V({type:U.Choice})],gb);let Dp=class{constructor(e=""){this.value=e}toString(){return this.value}};h([p({type:S.ObjectIdentifier})],Dp.prototype,"value",void 0);Dp=h([V({type:U.Choice})],Dp);let mb=class extends ut{};mb=h([V({type:U.Choice})],mb);let Lp=class{constructor(e=0){this.value=e}toString(){return this.value.toString()}};h([p({type:S.Integer})],Lp.prototype,"value",void 0);Lp=h([V({type:U.Choice})],Lp);let yb=class extends Hr{};yb=h([V({type:U.Sequence})],yb);let lu=class extends ft{};lu=h([V({type:U.Choice})],lu);let wb=Tp=class extends Hn{constructor(e){super(e),Object.setPrototypeOf(this,Tp.prototype)}};wb=Tp=h([V({type:U.Sequence})],wb);let bb=Pp=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,Pp.prototype)}};bb=Pp=h([V({type:U.Set,itemType:lo})],bb);let Mp=class{constructor(e=""){this.value=e}toString(){return this.value}};h([p({type:S.BmpString})],Mp.prototype,"value",void 0);Mp=h([V({type:U.Choice})],Mp);let Up=class extends X{};Up=h([V({type:U.Sequence})],Up);let vb=Rp=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,Rp.prototype)}};vb=Rp=h([V({type:U.Sequence,itemType:Up})],vb);var Fp;let uu=Fp=class extends Te{constructor(e){super(e),Object.setPrototypeOf(this,Fp.prototype)}};uu=Fp=h([V({type:U.Sequence,itemType:hn})],uu);class po{constructor(e={}){this.version=0,this.subject=new Ze,this.subjectPKInfo=new xr,this.attributes=new uu,Object.assign(this,e)}}h([p({type:S.Integer})],po.prototype,"version",void 0);h([p({type:Ze})],po.prototype,"subject",void 0);h([p({type:xr})],po.prototype,"subjectPKInfo",void 0);h([p({type:uu,implicit:!0,context:0})],po.prototype,"attributes",void 0);class ua{constructor(e={}){this.certificationRequestInfo=new po,this.signatureAlgorithm=new X,this.signature=new ArrayBuffer(0),Object.assign(this,e)}}h([p({type:po})],ua.prototype,"certificationRequestInfo",void 0);h([p({type:X})],ua.prototype,"signatureAlgorithm",void 0);h([p({type:S.BitString})],ua.prototype,"signature",void 0);/*!
 * MIT License
 * 
 * Copyright (c) Peculiar Ventures. All rights reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */const Qa="crypto.algorithm";class oD{getAlgorithms(){return pt.resolveAll(Qa)}toAsnAlgorithm(e){({...e});for(const t of this.getAlgorithms()){const n=t.toAsnAlgorithm(e);if(n)return n}if(/^[0-9.]+$/.test(e.name)){const t=new X({algorithm:e.name});if("parameters"in e){const n=e;t.parameters=n.parameters}return t}throw new Error("Cannot convert WebCrypto algorithm to ASN.1 algorithm")}toWebAlgorithm(e){for(const n of this.getAlgorithms()){const i=n.toWebAlgorithm(e);if(i)return i}return{name:e.algorithm,parameters:e.parameters}}}const qi="crypto.algorithmProvider";pt.registerSingleton(qi,oD);var Gc;const jt="1.3.36.3.3.2.8.1.1",Sb=`${jt}.1`,Eb=`${jt}.2`,Ab=`${jt}.3`,xb=`${jt}.4`,_b=`${jt}.5`,Cb=`${jt}.6`,Ib=`${jt}.7`,kb=`${jt}.8`,Tb=`${jt}.9`,Pb=`${jt}.10`,Rb=`${jt}.11`,Ob=`${jt}.12`,Bb=`${jt}.13`,Nb=`${jt}.14`,Db="brainpoolP160r1",Lb="brainpoolP160t1",Mb="brainpoolP192r1",Ub="brainpoolP192t1",Fb="brainpoolP224r1",$b="brainpoolP224t1",Vb="brainpoolP256r1",qb="brainpoolP256t1",jb="brainpoolP320r1",zb="brainpoolP320t1",Hb="brainpoolP384r1",Wb="brainpoolP384t1",Kb="brainpoolP512r1",Gb="brainpoolP512t1",je="ECDSA";let da=Gc=class{toAsnAlgorithm(e){switch(e.name.toLowerCase()){case je.toLowerCase():if("hash"in e)switch((typeof e.hash=="string"?e.hash:e.hash.name).toLowerCase()){case"sha-1":return PN;case"sha-256":return RN;case"sha-384":return ON;case"sha-512":return BN}else if("namedCurve"in e){let t="";switch(e.namedCurve){case"P-256":t=Jw;break;case"K-256":t=Gc.SECP256K1;break;case"P-384":t=eb;break;case"P-521":t=tb;break;case Db:t=Sb;break;case Lb:t=Eb;break;case Mb:t=Ab;break;case Ub:t=xb;break;case Fb:t=_b;break;case $b:t=Cb;break;case Vb:t=Ib;break;case qb:t=kb;break;case jb:t=Tb;break;case zb:t=Pb;break;case Hb:t=Rb;break;case Wb:t=Ob;break;case Kb:t=Bb;break;case Gb:t=Nb;break}if(t)return new X({algorithm:ca,parameters:G.serialize(new Kn({namedCurve:t}))})}}return null}toWebAlgorithm(e){switch(e.algorithm){case Im:return{name:je,hash:{name:"SHA-1"}};case km:return{name:je,hash:{name:"SHA-256"}};case Tm:return{name:je,hash:{name:"SHA-384"}};case Pm:return{name:je,hash:{name:"SHA-512"}};case ca:{if(!e.parameters)throw new TypeError("Cannot get required parameters from EC algorithm");switch(G.parse(e.parameters,Kn).namedCurve){case Jw:return{name:je,namedCurve:"P-256"};case Gc.SECP256K1:return{name:je,namedCurve:"K-256"};case eb:return{name:je,namedCurve:"P-384"};case tb:return{name:je,namedCurve:"P-521"};case Sb:return{name:je,namedCurve:Db};case Eb:return{name:je,namedCurve:Lb};case Ab:return{name:je,namedCurve:Mb};case xb:return{name:je,namedCurve:Ub};case _b:return{name:je,namedCurve:Fb};case Cb:return{name:je,namedCurve:$b};case Ib:return{name:je,namedCurve:Vb};case kb:return{name:je,namedCurve:qb};case Tb:return{name:je,namedCurve:jb};case Pb:return{name:je,namedCurve:zb};case Rb:return{name:je,namedCurve:Hb};case Ob:return{name:je,namedCurve:Wb};case Bb:return{name:je,namedCurve:Kb};case Nb:return{name:je,namedCurve:Gb}}}}return null}};da.SECP256K1="1.3.132.0.10";da=Gc=h([Cd()],da);pt.registerSingleton(Qa,da);const oA=Symbol("name"),aA=Symbol("value");class _e{constructor(e,t={},n=""){this[oA]=e,this[aA]=n;for(const i in t)this[i]=t[i]}}_e.NAME=oA;_e.VALUE=aA;class aD{static toTextObject(e){const t=new _e("Algorithm Identifier",{},Zn.toString(e.algorithm));if(e.parameters)switch(e.algorithm){case ca:{const n=new da().toWebAlgorithm(e);n&&"namedCurve"in n?t["Named Curve"]=n.namedCurve:t.Parameters=e.parameters;break}default:t.Parameters=e.parameters}return t}}class Zn{static toString(e){const t=this.items[e];return t||e}}Zn.items={[ru]:"sha1",[K1]:"sha224",[nu]:"sha256",[iu]:"sha384",[su]:"sha512",[Fi]:"rsaEncryption",[Jl]:"sha1WithRSAEncryption",[FN]:"sha224WithRSAEncryption",[yp]:"sha256WithRSAEncryption",[eu]:"sha384WithRSAEncryption",[tu]:"sha512WithRSAEncryption",[ca]:"ecPublicKey",[Im]:"ecdsaWithSHA1",[z1]:"ecdsaWithSHA224",[km]:"ecdsaWithSHA256",[Tm]:"ecdsaWithSHA384",[Pm]:"ecdsaWithSHA512",[AN]:"TLS WWW server authentication",[xN]:"TLS WWW client authentication",[_N]:"Code Signing",[CN]:"E-mail Protection",[IN]:"Time Stamping",[kN]:"OCSP Signing",[TN]:"Signed Data"};class ji{static serialize(e){return this.serializeObj(e).join(`
`)}static pad(e=0){return"".padStart(2*e," ")}static serializeObj(e,t=0){const n=[];let i=this.pad(t++),s="";const o=e[_e.VALUE];o&&(s=` ${o}`),n.push(`${i}${e[_e.NAME]}:${s}`),i=this.pad(t);for(const a in e){if(typeof a=="symbol")continue;const c=e[a],l=a?`${a}: `:"";if(typeof c=="string"||typeof c=="number"||typeof c=="boolean")n.push(`${i}${l}${c}`);else if(c instanceof Date)n.push(`${i}${l}${c.toUTCString()}`);else if(Array.isArray(c))for(const u of c)u[_e.NAME]=a,n.push(...this.serializeObj(u,t));else if(c instanceof _e)c[_e.NAME]=a,n.push(...this.serializeObj(c,t));else if(Y.isBufferSource(c))a?(n.push(`${i}${l}`),n.push(...this.serializeBufferSource(c,t+1))):n.push(...this.serializeBufferSource(c,t));else if("toTextObject"in c){const u=c.toTextObject();u[_e.NAME]=a,n.push(...this.serializeObj(u,t))}else throw new TypeError("Cannot serialize data in text format. Unsupported type.")}return n}static serializeBufferSource(e,t=0){const n=this.pad(t),i=Y.toUint8Array(e),s=[];for(let o=0;o<i.length;){const a=[];for(let c=0;c<16&&o<i.length;c++){c===8&&a.push("");const l=i[o++].toString(16).padStart(2,"0");a.push(l)}s.push(`${n}${a.join(" ")}`)}return s}static serializeAlgorithm(e){return this.algorithmSerializer.toTextObject(e)}}ji.oidSerializer=Zn;ji.algorithmSerializer=aD;class Jn{constructor(...e){if(e.length===1){const t=e[0];this.rawData=G.serialize(t),this.onInit(t)}else{const t=G.parse(e[0],e[1]);this.rawData=Y.toArrayBuffer(e[0]),this.onInit(t)}}equal(e){return e instanceof Jn?PE(e.rawData,this.rawData):!1}toString(e="text"){switch(e){case"asn":return G.toString(this.rawData);case"text":return ji.serialize(this.toTextObject());case"hex":return ee.ToHex(this.rawData);case"base64":return ee.ToBase64(this.rawData);case"base64url":return ee.ToBase64Url(this.rawData);default:throw TypeError("Argument 'format' is unsupported value")}}getTextName(){return this.constructor.NAME}toTextObject(){const e=this.toTextObjectEmpty();return e[""]=this.rawData,e}toTextObjectEmpty(e){return new _e(this.getTextName(),{},e)}}Jn.NAME="ASN";class fr extends Jn{constructor(...e){let t;Y.isBufferSource(e[0])?t=Y.toArrayBuffer(e[0]):t=G.serialize(new dr({extnID:e[0],critical:e[1],extnValue:new Ee(Y.toArrayBuffer(e[2]))})),super(t,dr)}onInit(e){this.type=e.extnID,this.critical=e.critical,this.value=e.extnValue.buffer}toTextObject(){const e=this.toTextObjectWithoutValue();return e[""]=this.value,e}toTextObjectWithoutValue(){const e=this.toTextObjectEmpty(this.critical?"critical":void 0);return e[_e.NAME]===fr.NAME&&(e[_e.NAME]=Zn.toString(this.type)),e}}var cA;class Pn{static isCryptoKeyPair(e){return e&&e.privateKey&&e.publicKey}static isCryptoKey(e){return e&&e.usages&&e.type&&e.algorithm&&e.extractable!==void 0}constructor(){this.items=new Map,this[cA]="CryptoProvider",typeof self<"u"&&typeof crypto<"u"?this.set(Pn.DEFAULT,crypto):typeof global<"u"&&global.crypto&&global.crypto.subtle&&this.set(Pn.DEFAULT,global.crypto)}clear(){this.items.clear()}delete(e){return this.items.delete(e)}forEach(e,t){return this.items.forEach(e,t)}has(e){return this.items.has(e)}get size(){return this.items.size}entries(){return this.items.entries()}keys(){return this.items.keys()}values(){return this.items.values()}[Symbol.iterator](){return this.items[Symbol.iterator]()}get(e=Pn.DEFAULT){const t=this.items.get(e.toLowerCase());if(!t)throw new Error(`Cannot get Crypto by name '${e}'`);return t}set(e,t){if(typeof e=="string"){if(!t)throw new TypeError("Argument 'value' is required");this.items.set(e.toLowerCase(),t)}else this.items.set(Pn.DEFAULT,e);return this}}cA=Symbol.toStringTag;Pn.DEFAULT="default";const lt=new Pn,cD=/^[0-2](?:\.[1-9][0-9]*)+$/;function lD(r){return new RegExp(cD).test(r)}class lA{constructor(e={}){this.items={};for(const t in e)this.register(t,e[t])}get(e){return this.items[e]||null}findId(e){return lD(e)?e:this.get(e)}register(e,t){this.items[e]=t,this.items[t]=e}}const Vt=new lA;Vt.register("CN","2.5.4.3");Vt.register("L","2.5.4.7");Vt.register("ST","2.5.4.8");Vt.register("O","2.5.4.10");Vt.register("OU","2.5.4.11");Vt.register("C","2.5.4.6");Vt.register("DC","0.9.2342.19200300.100.1.25");Vt.register("E","1.2.840.113549.1.9.1");Vt.register("G","2.5.4.42");Vt.register("I","2.5.4.43");Vt.register("SN","2.5.4.4");Vt.register("T","2.5.4.12");function uD(r,e){return`\\${ee.ToHex(ee.FromUtf8String(e)).toUpperCase()}`}function dD(r){return r.replace(/([,+"\\<>;])/g,"\\$1").replace(/^([ #])/,"\\$1").replace(/([ ]$)/,"\\$1").replace(/([\r\n\t])/,uD)}class cr{static isASCII(e){for(let t=0;t<e.length;t++)if(e.charCodeAt(t)>255)return!1;return!0}static isPrintableString(e){return/^[A-Za-z0-9 '()+,-./:=?]*$/g.test(e)}constructor(e,t={}){this.extraNames=new lA,this.asn=new Ze;for(const n in t)if(Object.prototype.hasOwnProperty.call(t,n)){const i=t[n];this.extraNames.register(n,i)}typeof e=="string"?this.asn=this.fromString(e):e instanceof Ze?this.asn=e:Y.isBufferSource(e)?this.asn=G.parse(e,Ze):this.asn=this.fromJSON(e)}getField(e){const t=this.extraNames.findId(e)||Vt.findId(e),n=[];for(const i of this.asn)for(const s of i)s.type===t&&n.push(s.value.toString());return n}getName(e){return this.extraNames.get(e)||Vt.get(e)}toString(){return this.asn.map(e=>e.map(t=>{const n=this.getName(t.type)||t.type,i=t.value.anyValue?`#${ee.ToHex(t.value.anyValue)}`:dD(t.value.toString());return`${n}=${i}`}).join("+")).join(", ")}toJSON(){var e;const t=[];for(const n of this.asn){const i={};for(const s of n){const o=this.getName(s.type)||s.type;(e=i[o])!==null&&e!==void 0||(i[o]=[]),i[o].push(s.value.anyValue?`#${ee.ToHex(s.value.anyValue)}`:s.value.toString())}t.push(i)}return t}fromString(e){const t=new Ze,n=/(\d\.[\d.]*\d|[A-Za-z]+)=((?:"")|(?:".*?[^\\]")|(?:[^,+].*?(?:[^\\][,+]))|(?:))([,+])?/g;let i=null,s=",";for(;i=n.exec(`${e},`);){let[,o,a]=i;const c=a[a.length-1];(c===","||c==="+")&&(a=a.slice(0,a.length-1),i[3]=c);const l=i[3];o=this.getTypeOid(o);const u=this.createAttribute(o,a);s==="+"?t[t.length-1].push(u):t.push(new Ms([u])),s=l}return t}fromJSON(e){const t=new Ze;for(const n of e){const i=new Ms;for(const s in n){const o=this.getTypeOid(s),a=n[s];for(const c of a){const l=this.createAttribute(o,c);i.push(l)}}t.push(i)}return t}getTypeOid(e){if(/[\d.]+/.test(e)||(e=this.getName(e)||""),!e)throw new Error(`Cannot get OID for name type '${e}'`);return e}createAttribute(e,t){const n=new od({type:e});if(typeof t=="object")for(const i in t)switch(i){case"ia5String":n.value.ia5String=t[i];break;case"utf8String":n.value.utf8String=t[i];break;case"universalString":n.value.universalString=t[i];break;case"bmpString":n.value.bmpString=t[i];break;case"printableString":n.value.printableString=t[i];break}else if(t[0]==="#")n.value.anyValue=ee.FromHex(t.slice(1));else{const i=this.processStringValue(t);e===this.getName("E")||e===this.getName("DC")?n.value.ia5String=i:cr.isPrintableString(i)?n.value.printableString=i:n.value.utf8String=i}return n}processStringValue(e){const t=/"(.*?[^\\])?"/.exec(e);return t&&(e=t[1]),e.replace(/\\0a/ig,`
`).replace(/\\0d/ig,"\r").replace(/\\0g/ig,"	").replace(/\\(.)/g,"$1")}toArrayBuffer(){return G.serialize(this.asn)}async getThumbprint(...e){var t;let n,i="SHA-1";return e.length>=1&&!(!((t=e[0])===null||t===void 0)&&t.subtle)?(i=e[0]||i,n=e[1]||lt.get()):n=e[0]||lt.get(),await n.subtle.digest(i,this.toArrayBuffer())}}const uA="Cannot initialize GeneralName from ASN.1 data.",Yb=`${uA} Unsupported string format in use.`,hD=`${uA} Value doesn't match to GUID regular expression.`,Qb=/^([0-9a-f]{8})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{12})$/i,Xb="1.3.6.1.4.1.311.25.1",Zb="1.3.6.1.4.1.311.20.2.3",hh="dns",fh="dn",ph="email",gh="ip",mh="url",yh="guid",wh="upn",Ec="id";class Rn extends Jn{constructor(...e){let t;if(e.length===2)switch(e[0]){case fh:{const n=new cr(e[1]).toArrayBuffer(),i=G.parse(n,Ze);t=new de({directoryName:i});break}case hh:t=new de({dNSName:e[1]});break;case ph:t=new de({rfc822Name:e[1]});break;case yh:{const n=new RegExp(Qb,"i").exec(e[1]);if(!n)throw new Error("Cannot parse GUID value. Value doesn't match to regular expression");const i=n.slice(1).map((s,o)=>o<3?ee.ToHex(new Uint8Array(ee.FromHex(s)).reverse()):s).join("");t=new de({otherName:new ia({typeId:Xb,value:G.serialize(new Ee(ee.FromHex(i)))})});break}case gh:t=new de({iPAddress:e[1]});break;case Ec:t=new de({registeredID:e[1]});break;case wh:{t=new de({otherName:new ia({typeId:Zb,value:G.serialize(I1.toASN(e[1]))})});break}case mh:t=new de({uniformResourceIdentifier:e[1]});break;default:throw new Error("Cannot create GeneralName. Unsupported type of the name")}else Y.isBufferSource(e[0])?t=G.parse(e[0],de):t=e[0];super(t)}onInit(e){if(e.dNSName!=null)this.type=hh,this.value=e.dNSName;else if(e.rfc822Name!=null)this.type=ph,this.value=e.rfc822Name;else if(e.iPAddress!=null)this.type=gh,this.value=e.iPAddress;else if(e.uniformResourceIdentifier!=null)this.type=mh,this.value=e.uniformResourceIdentifier;else if(e.registeredID!=null)this.type=Ec,this.value=e.registeredID;else if(e.directoryName!=null)this.type=fh,this.value=new cr(e.directoryName).toString();else if(e.otherName!=null)if(e.otherName.typeId===Xb){this.type=yh;const t=G.parse(e.otherName.value,Ee),n=new RegExp(Qb,"i").exec(ee.ToHex(t));if(!n)throw new Error(hD);this.value=n.slice(1).map((i,s)=>s<3?ee.ToHex(new Uint8Array(ee.FromHex(i)).reverse()):i).join("-")}else if(e.otherName.typeId===Zb)this.type=wh,this.value=G.parse(e.otherName.value,ft).toString();else throw new Error(Yb);else throw new Error(Yb)}toJSON(){return{type:this.type,value:this.value}}toTextObject(){let e;switch(this.type){case fh:case hh:case yh:case gh:case Ec:case wh:case mh:e=this.type.toUpperCase();break;case ph:e="Email";break;default:throw new Error("Unsupported GeneralName type")}let t=this.value;return this.type===Ec&&(t=Zn.toString(t)),new _e(e,void 0,t)}}class ha extends Jn{constructor(e){let t;if(e instanceof Rt)t=e;else if(Array.isArray(e)){const n=[];for(const i of e)if(i instanceof de)n.push(i);else{const s=G.parse(new Rn(i.type,i.value).rawData,de);n.push(s)}t=new Rt(n)}else if(Y.isBufferSource(e))t=G.parse(e,Rt);else throw new Error("Cannot initialize GeneralNames. Incorrect incoming arguments");super(t)}onInit(e){const t=[];for(const n of e){let i=null;try{i=new Rn(n)}catch{continue}t.push(i)}this.items=t}toJSON(){return this.items.map(e=>e.toJSON())}toTextObject(){const e=super.toTextObjectEmpty();for(const t of this.items){const n=t.toTextObject();let i=e[n[_e.NAME]];Array.isArray(i)||(i=[],e[n[_e.NAME]]=i),i.push(n)}return e}}ha.NAME="GeneralNames";const zo="-{5}",fa="\\n",fD=`[^${fa}]+`,pD=`${zo}BEGIN (${fD}(?=${zo}))${zo}`,gD=`${zo}END \\1${zo}`,Hs="\\n",mD=`[^:${fa}]+`,yD=`(?:[^${fa}]+${Hs}(?: +[^${fa}]+${Hs})*)`,wD="[a-zA-Z0-9=+/]+",bD=`(?:${wD}${Hs})+`,Jb=`${pD}${Hs}(?:((?:${mD}: ${yD})+))?${Hs}?(${bD})${gD}`;class Yt{static isPem(e){return typeof e=="string"&&new RegExp(Jb,"g").test(e)}static decodeWithHeaders(e){e=e.replace(/\r/g,"");const t=new RegExp(Jb,"g"),n=[];let i=null;for(;i=t.exec(e);){const s=i[3].replace(new RegExp(`[${fa}]+`,"g"),""),o={type:i[1],headers:[],rawData:ee.FromBase64(s)},a=i[2];if(a){const c=a.split(new RegExp(Hs,"g"));let l=null;for(const u of c){const[d,f]=u.split(/:(.*)/);if(f===void 0){if(!l)throw new Error("Cannot parse PEM string. Incorrect header value");l.value+=d.trim()}else l&&o.headers.push(l),l={key:d,value:f.trim()}}l&&o.headers.push(l)}n.push(o)}return n}static decode(e){return this.decodeWithHeaders(e).map(n=>n.rawData)}static decodeFirst(e){const t=this.decode(e);if(!t.length)throw new RangeError("PEM string doesn't contain any objects");return t[0]}static encode(e,t){if(Array.isArray(e)){const n=new Array;return t?e.forEach(i=>{if(!Y.isBufferSource(i))throw new TypeError("Cannot encode array of BufferSource in PEM format. Not all items of the array are BufferSource");n.push(this.encodeStruct({type:t,rawData:Y.toArrayBuffer(i)}))}):e.forEach(i=>{if(!("type"in i))throw new TypeError("Cannot encode array of PemStruct in PEM format. Not all items of the array are PemStrut");n.push(this.encodeStruct(i))}),n.join(`
`)}else{if(!t)throw new Error("Required argument 'tag' is missed");return this.encodeStruct({type:t,rawData:Y.toArrayBuffer(e)})}}static encodeStruct(e){var t;const n=e.type.toLocaleUpperCase(),i=[];if(i.push(`-----BEGIN ${n}-----`),!((t=e.headers)===null||t===void 0)&&t.length){for(const l of e.headers)i.push(`${l.key}: ${l.value}`);i.push("")}const s=ee.ToBase64(e.rawData);let o,a=0;const c=Array();for(;a<s.length&&(s.length-a<64?o=s.substring(a):(o=s.substring(a,a+64),a+=64),o.length!==0);)if(c.push(o),o.length<64)break;return i.push(...c),i.push(`-----END ${n}-----`),i.join(`
`)}}Yt.CertificateTag="CERTIFICATE";Yt.CrlTag="CRL";Yt.CertificateRequestTag="CERTIFICATE REQUEST";Yt.PublicKeyTag="PUBLIC KEY";Yt.PrivateKeyTag="PRIVATE KEY";class gn extends Jn{static isAsnEncoded(e){return Y.isBufferSource(e)||typeof e=="string"}static toArrayBuffer(e){if(typeof e=="string"){if(Yt.isPem(e))return Yt.decode(e)[0];if(ee.isHex(e))return ee.FromHex(e);if(ee.isBase64(e))return ee.FromBase64(e);if(ee.isBase64Url(e))return ee.FromBase64Url(e);throw new TypeError("Unsupported format of 'raw' argument. Must be one of DER, PEM, HEX, Base64, or Base4Url")}else{const t=ee.ToBinary(e);return Yt.isPem(t)?Yt.decode(t)[0]:ee.isHex(t)?ee.FromHex(t):ee.isBase64(t)?ee.FromBase64(t):ee.isBase64Url(t)?ee.FromBase64Url(t):Y.toArrayBuffer(e)}}constructor(...e){gn.isAsnEncoded(e[0])?super(gn.toArrayBuffer(e[0]),e[1]):super(e[0])}toString(e="pem"){switch(e){case"pem":return Yt.encode(this.rawData,this.tag);default:return super.toString(e)}}}class _r extends gn{static async create(e,t=lt.get()){if(e instanceof _r)return e;if(Pn.isCryptoKey(e)){if(e.type!=="public")throw new TypeError("Public key is required");const n=await t.subtle.exportKey("spki",e);return new _r(n)}else{if(e.publicKey)return e.publicKey;if(Y.isBufferSource(e))return new _r(e);throw new TypeError("Unsupported PublicKeyType")}}constructor(e){gn.isAsnEncoded(e)?super(e,xr):super(e),this.tag=Yt.PublicKeyTag}async export(...e){let t,n=["verify"],i={hash:"SHA-256",...this.algorithm};e.length>1?(i=e[0]||i,n=e[1]||n,t=e[2]||lt.get()):t=e[0]||lt.get();let s=this.rawData;const o=G.parse(this.rawData,xr);return o.algorithm.algorithm===jo&&(s=vD(o,s)),t.subtle.importKey("spki",s,i,!0,n)}onInit(e){const t=pt.resolve(qi),n=this.algorithm=t.toWebAlgorithm(e.algorithm);switch(e.algorithm.algorithm){case Fi:{const i=G.parse(e.subjectPublicKey,Rm),s=Y.toUint8Array(i.modulus);n.publicExponent=Y.toUint8Array(i.publicExponent),n.modulusLength=(s[0]?s:s.slice(1)).byteLength<<3;break}}}async getThumbprint(...e){var t;let n,i="SHA-1";return e.length>=1&&!(!((t=e[0])===null||t===void 0)&&t.subtle)?(i=e[0]||i,n=e[1]||lt.get()):n=e[0]||lt.get(),await n.subtle.digest(i,this.rawData)}async getKeyIdentifier(...e){let t,n="SHA-1";e.length===1?typeof e[0]=="string"?(n=e[0],t=lt.get()):t=e[0]:e.length===2?(n=e[0],t=e[1]):t=lt.get();const i=G.parse(this.rawData,xr);return await t.subtle.digest(n,i.subjectPublicKey)}toTextObject(){const e=this.toTextObjectEmpty(),t=G.parse(this.rawData,xr);switch(e.Algorithm=ji.serializeAlgorithm(t.algorithm),t.algorithm.algorithm){case ca:e["EC Point"]=t.subjectPublicKey;break;case Fi:default:e["Raw Data"]=t.subjectPublicKey}return e}}function vD(r,e){return r.algorithm=new X({algorithm:Fi,parameters:null}),e=G.serialize(r),e}class pa extends fr{static async create(e,t=!1,n=lt.get()){if("name"in e&&"serialNumber"in e)return new pa(e,t);const s=await(await _r.create(e,n)).getKeyIdentifier(n);return new pa(ee.ToHex(s),t)}constructor(...e){if(Y.isBufferSource(e[0]))super(e[0]);else if(typeof e[0]=="string"){const t=new gi({keyIdentifier:new hm(ee.FromHex(e[0]))});super(Df,e[1],G.serialize(t))}else{const t=e[0],n=t.name instanceof ha?G.parse(t.name.rawData,Rt):t.name,i=new gi({authorityCertIssuer:n,authorityCertSerialNumber:ee.FromHex(t.serialNumber)});super(Df,e[1],G.serialize(i))}}onInit(e){super.onInit(e);const t=G.parse(e.extnValue,gi);t.keyIdentifier&&(this.keyId=ee.ToHex(t.keyIdentifier)),(t.authorityCertIssuer||t.authorityCertSerialNumber)&&(this.certId={name:t.authorityCertIssuer||[],serialNumber:t.authorityCertSerialNumber?ee.ToHex(t.authorityCertSerialNumber):""})}toTextObject(){const e=this.toTextObjectWithoutValue(),t=G.parse(this.value,gi);return t.authorityCertIssuer&&(e["Authority Issuer"]=new ha(t.authorityCertIssuer).toTextObject()),t.authorityCertSerialNumber&&(e["Authority Serial Number"]=t.authorityCertSerialNumber),t.keyIdentifier&&(e[""]=t.keyIdentifier),e}}pa.NAME="Authority Key Identifier";class Dm extends fr{constructor(...e){if(Y.isBufferSource(e[0])){super(e[0]);const t=G.parse(this.value,Dl);this.ca=t.cA,this.pathLength=t.pathLenConstraint}else{const t=new Dl({cA:e[0],pathLenConstraint:e[1]});super(T1,e[2],G.serialize(t)),this.ca=e[0],this.pathLength=e[1]}}toTextObject(){const e=this.toTextObjectWithoutValue();return this.ca&&(e.CA=this.ca),this.pathLength!==void 0&&(e["Path Length"]=this.pathLength),e}}Dm.NAME="Basic Constraints";var e0;(function(r){r.serverAuth="1.3.6.1.5.5.7.3.1",r.clientAuth="1.3.6.1.5.5.7.3.2",r.codeSigning="1.3.6.1.5.5.7.3.3",r.emailProtection="1.3.6.1.5.5.7.3.4",r.timeStamping="1.3.6.1.5.5.7.3.8",r.ocspSigning="1.3.6.1.5.5.7.3.9"})(e0||(e0={}));class dA extends fr{constructor(...e){if(Y.isBufferSource(e[0])){super(e[0]);const t=G.parse(this.value,Fl);this.usages=t.map(n=>n)}else{const t=new Fl(e[0]);super(O1,e[1],G.serialize(t)),this.usages=e[0]}}toTextObject(){const e=this.toTextObjectWithoutValue();return e[""]=this.usages.map(t=>Zn.toString(t)).join(", "),e}}dA.NAME="Extended Key Usages";var t0;(function(r){r[r.digitalSignature=1]="digitalSignature",r[r.nonRepudiation=2]="nonRepudiation",r[r.keyEncipherment=4]="keyEncipherment",r[r.dataEncipherment=8]="dataEncipherment",r[r.keyAgreement=16]="keyAgreement",r[r.keyCertSign=32]="keyCertSign",r[r.cRLSign=64]="cRLSign",r[r.encipherOnly=128]="encipherOnly",r[r.decipherOnly=256]="decipherOnly"})(t0||(t0={}));class hA extends fr{constructor(...e){if(Y.isBufferSource(e[0])){super(e[0]);const t=G.parse(this.value,dh);this.usages=t.toNumber()}else{const t=new dh(e[0]);super(B1,e[1],G.serialize(t)),this.usages=e[0]}}toTextObject(){const e=this.toTextObjectWithoutValue(),t=G.parse(this.value,dh);return e[""]=t.toJSON().join(", "),e}}hA.NAME="Key Usages";class Rd extends fr{static async create(e,t=!1,n=lt.get()){const s=await(await _r.create(e,n)).getKeyIdentifier(n);return new Rd(ee.ToHex(s),t)}constructor(...e){if(Y.isBufferSource(e[0])){super(e[0]);const t=G.parse(this.value,$n);this.keyId=ee.ToHex(t)}else{const t=typeof e[0]=="string"?ee.FromHex(e[0]):e[0],n=new $n(t);super(M1,e[1],G.serialize(n)),this.keyId=ee.ToHex(t)}}toTextObject(){const e=this.toTextObjectWithoutValue(),t=G.parse(this.value,$n);return e[""]=t,e}}Rd.NAME="Subject Key Identifier";class fA extends fr{constructor(...e){Y.isBufferSource(e[0])?super(e[0]):super(L1,e[1],new ha(e[0]||[]).rawData)}onInit(e){super.onInit(e);const t=G.parse(e.extnValue,Qf);this.names=new ha(t)}toTextObject(){const e=this.toTextObjectWithoutValue(),t=this.names.toTextObject();for(const n in t)e[n]=t[n];return e}}fA.NAME="Subject Alternative Name";class pr{static register(e,t){this.items.set(e,t)}static create(e){const t=new fr(e),n=this.items.get(t.type);return n?new n(e):t}}pr.items=new Map;class pA extends fr{constructor(...e){var t;if(Y.isBufferSource(e[0])){super(e[0]);const n=G.parse(this.value,Ml);this.policies=n.map(i=>i.policyIdentifier)}else{const n=e[0],i=(t=e[1])!==null&&t!==void 0?t:!1,s=new Ml(n.map(o=>new cd({policyIdentifier:o})));super(P1,i,G.serialize(s)),this.policies=n}}toTextObject(){const e=this.toTextObjectWithoutValue();return e.Policy=this.policies.map(t=>new _e("",{},Zn.toString(t))),e}}pA.NAME="Certificate Policies";pr.register(P1,pA);class gA extends fr{constructor(...e){var t;if(Y.isBufferSource(e[0]))super(e[0]);else if(Array.isArray(e[0])&&typeof e[0][0]=="string"){const i=e[0].map(o=>new ao({distributionPoint:new Di({fullName:[new de({uniformResourceIdentifier:o})]})})),s=new ws(i);super($f,e[1],G.serialize(s))}else{const n=new ws(e[0]);super($f,e[1],G.serialize(n))}(t=this.distributionPoints)!==null&&t!==void 0||(this.distributionPoints=[])}onInit(e){super.onInit(e);const t=G.parse(e.extnValue,ws);this.distributionPoints=t}toTextObject(){const e=this.toTextObjectWithoutValue();return e["Distribution Point"]=this.distributionPoints.map(t=>{var n;const i={};return t.distributionPoint&&(i[""]=(n=t.distributionPoint.fullName)===null||n===void 0?void 0:n.map(s=>new Rn(s).toString()).join(", ")),t.reasons&&(i.Reasons=t.reasons.toString()),t.cRLIssuer&&(i["CRL Issuer"]=t.cRLIssuer.map(s=>s.toString()).join(", ")),i}),e}}gA.NAME="CRL Distribution Points";class mA extends fr{constructor(...e){var t,n,i,s;if(Y.isBufferSource(e[0]))super(e[0]);else if(e[0]instanceof ds){const o=new ds(e[0]);super(Nf,e[1],G.serialize(o))}else{const o=e[0],a=new ds;xc(a,o,Uw,"ocsp"),xc(a,o,Fw,"caIssuers"),xc(a,o,$w,"timeStamping"),xc(a,o,Vw,"caRepository"),super(Nf,e[1],G.serialize(a))}(t=this.ocsp)!==null&&t!==void 0||(this.ocsp=[]),(n=this.caIssuers)!==null&&n!==void 0||(this.caIssuers=[]),(i=this.timeStamping)!==null&&i!==void 0||(this.timeStamping=[]),(s=this.caRepository)!==null&&s!==void 0||(this.caRepository=[])}onInit(e){super.onInit(e),this.ocsp=[],this.caIssuers=[],this.timeStamping=[],this.caRepository=[],G.parse(e.extnValue,ds).forEach(n=>{switch(n.accessMethod){case Uw:this.ocsp.push(new Rn(n.accessLocation));break;case Fw:this.caIssuers.push(new Rn(n.accessLocation));break;case $w:this.timeStamping.push(new Rn(n.accessLocation));break;case Vw:this.caRepository.push(new Rn(n.accessLocation));break}})}toTextObject(){const e=this.toTextObjectWithoutValue();return this.ocsp.length&&Ac(e,"OCSP",this.ocsp),this.caIssuers.length&&Ac(e,"CA Issuers",this.caIssuers),this.timeStamping.length&&Ac(e,"Time Stamping",this.timeStamping),this.caRepository.length&&Ac(e,"CA Repository",this.caRepository),e}}mA.NAME="Authority Info Access";function Ac(r,e,t){if(t.length===1)r[e]=t[0].toTextObject();else{const n=new _e("");t.forEach((i,s)=>{const o=i.toTextObject(),a=`${o[_e.NAME]} ${s+1}`;let c=n[a];Array.isArray(c)||(c=[],n[a]=c),c.push(o)}),r[e]=n}}function xc(r,e,t,n){const i=e[n];i&&(Array.isArray(i)?i:[i]).forEach(o=>{typeof o=="string"&&(o=new Rn("url",o)),r.push(new Ua({accessMethod:t,accessLocation:G.parse(o.rawData,de)}))})}class go extends Jn{constructor(...e){let t;if(Y.isBufferSource(e[0]))t=Y.toArrayBuffer(e[0]);else{const n=e[0],i=Array.isArray(e[1])?e[1].map(s=>Y.toArrayBuffer(s)):[];t=G.serialize(new hn({type:n,values:i}))}super(t,hn)}onInit(e){this.type=e.type,this.values=e.values}toTextObject(){const e=this.toTextObjectWithoutValue();return e.Value=this.values.map(t=>new _e("",{"":t})),e}toTextObjectWithoutValue(){const e=this.toTextObjectEmpty();return e[_e.NAME]===go.NAME&&(e[_e.NAME]=Zn.toString(this.type)),e}}go.NAME="Attribute";class yA extends go{constructor(...e){var t;if(Y.isBufferSource(e[0]))super(e[0]);else{const n=new lu({printableString:e[0]});super(sA,[G.serialize(n)])}(t=this.password)!==null&&t!==void 0||(this.password="")}onInit(e){if(super.onInit(e),this.values[0]){const t=G.parse(this.values[0],lu);this.password=t.toString()}}toTextObject(){const e=this.toTextObjectWithoutValue();return e[_e.VALUE]=this.password,e}}yA.NAME="Challenge Password";class Lm extends go{constructor(...e){var t;if(Y.isBufferSource(e[0]))super(e[0]);else{const n=e[0],i=new Hn;for(const s of n)i.push(G.parse(s.rawData,dr));super(Nm,[G.serialize(i)])}(t=this.items)!==null&&t!==void 0||(this.items=[])}onInit(e){if(super.onInit(e),this.values[0]){const t=G.parse(this.values[0],Hn);this.items=t.map(n=>pr.create(G.serialize(n)))}}toTextObject(){const e=this.toTextObjectWithoutValue(),t=this.items.map(n=>n.toTextObject());for(const n of t)e[n[_e.NAME]]=n;return e}}Lm.NAME="Extensions";class Od{static register(e,t){this.items.set(e,t)}static create(e){const t=new go(e),n=this.items.get(t.type);return n?new n(e):t}}Od.items=new Map;const Xa="crypto.signatureFormatter";class SD{toAsnSignature(e,t){return Y.toArrayBuffer(t)}toWebSignature(e,t){return Y.toArrayBuffer(t)}}var Yc;let $p=Yc=class{static createPssParams(e,t){const n=Yc.getHashAlgorithm(e);return n?new Vi({hashAlgorithm:n,maskGenAlgorithm:new X({algorithm:Ed,parameters:G.serialize(n)}),saltLength:t}):null}static getHashAlgorithm(e){const t=pt.resolve(qi);return typeof e=="string"?t.toAsnAlgorithm({name:e}):typeof e=="object"&&e&&"name"in e?t.toAsnAlgorithm(e):null}toAsnAlgorithm(e){switch(e.name.toLowerCase()){case"rsassa-pkcs1-v1_5":if("hash"in e){let t;if(typeof e.hash=="string")t=e.hash;else if(e.hash&&typeof e.hash=="object"&&"name"in e.hash&&typeof e.hash.name=="string")t=e.hash.name.toUpperCase();else throw new Error("Cannot get hash algorithm name");switch(t.toLowerCase()){case"sha-1":return new X({algorithm:Jl,parameters:null});case"sha-256":return new X({algorithm:yp,parameters:null});case"sha-384":return new X({algorithm:eu,parameters:null});case"sha-512":return new X({algorithm:tu,parameters:null})}}else return new X({algorithm:Fi,parameters:null});break;case"rsa-pss":if("hash"in e){if(!("saltLength"in e&&typeof e.saltLength=="number"))throw new Error("Cannot get 'saltLength' from 'alg' argument");const t=Yc.createPssParams(e.hash,e.saltLength);if(!t)throw new Error("Cannot create PSS parameters");return new X({algorithm:jo,parameters:G.serialize(t)})}else return new X({algorithm:jo,parameters:null})}return null}toWebAlgorithm(e){switch(e.algorithm){case Fi:return{name:"RSASSA-PKCS1-v1_5"};case Jl:return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-1"}};case yp:return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case eu:return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}};case tu:return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}};case jo:if(e.parameters){const t=G.parse(e.parameters,Vi);return{name:"RSA-PSS",hash:pt.resolve(qi).toWebAlgorithm(t.hashAlgorithm),saltLength:t.saltLength}}else return{name:"RSA-PSS"}}return null}};$p=Yc=h([Cd()],$p);pt.registerSingleton(Qa,$p);let Vp=class{toAsnAlgorithm(e){switch(e.name.toLowerCase()){case"sha-1":return new X({algorithm:ru});case"sha-256":return new X({algorithm:nu});case"sha-384":return new X({algorithm:iu});case"sha-512":return new X({algorithm:su})}return null}toWebAlgorithm(e){switch(e.algorithm){case ru:return{name:"SHA-1"};case nu:return{name:"SHA-256"};case iu:return{name:"SHA-384"};case su:return{name:"SHA-512"}}return null}};Vp=h([Cd()],Vp);pt.registerSingleton(Qa,Vp);class lr{addPadding(e,t){const n=Y.toUint8Array(t),i=new Uint8Array(e);return i.set(n,e-n.length),i}removePadding(e,t=!1){let n=Y.toUint8Array(e);for(let i=0;i<n.length;i++)if(n[i]){n=n.slice(i);break}if(t&&n[0]>127){const i=new Uint8Array(n.length+1);return i.set(n,1),i.buffer}return n.buffer}toAsnSignature(e,t){if(e.name==="ECDSA"){const n=e.namedCurve,i=lr.namedCurveSize.get(n)||lr.defaultNamedCurveSize,s=new Zl,o=Y.toUint8Array(t);return s.r=this.removePadding(o.slice(0,i),!0),s.s=this.removePadding(o.slice(i,i+i),!0),G.serialize(s)}return null}toWebSignature(e,t){if(e.name==="ECDSA"){const n=G.parse(t,Zl),i=e.namedCurve,s=lr.namedCurveSize.get(i)||lr.defaultNamedCurveSize,o=this.addPadding(s,this.removePadding(n.r)),a=this.addPadding(s,this.removePadding(n.s));return NB(o,a)}return null}}lr.namedCurveSize=new Map;lr.defaultNamedCurveSize=32;const bh="1.3.101.110",r0="1.3.101.111",vh="1.3.101.112",n0="1.3.101.113";let qp=class{toAsnAlgorithm(e){let t=null;switch(e.name.toLowerCase()){case"ed25519":t=vh;break;case"x25519":t=bh;break;case"eddsa":switch(e.namedCurve.toLowerCase()){case"ed25519":t=vh;break;case"ed448":t=n0;break}break;case"ecdh-es":switch(e.namedCurve.toLowerCase()){case"x25519":t=bh;break;case"x448":t=r0;break}}return t?new X({algorithm:t}):null}toWebAlgorithm(e){switch(e.algorithm){case vh:return{name:"Ed25519"};case n0:return{name:"EdDSA",namedCurve:"Ed448"};case bh:return{name:"X25519"};case r0:return{name:"ECDH-ES",namedCurve:"X448"}}return null}};qp=h([Cd()],qp);pt.registerSingleton(Qa,qp);class ED extends gn{constructor(e){gn.isAsnEncoded(e)?super(e,ua):super(e),this.tag=Yt.CertificateRequestTag}onInit(e){this.tbs=G.serialize(e.certificationRequestInfo),this.publicKey=new _r(e.certificationRequestInfo.subjectPKInfo);const t=pt.resolve(qi);this.signatureAlgorithm=t.toWebAlgorithm(e.signatureAlgorithm),this.signature=e.signature,this.attributes=e.certificationRequestInfo.attributes.map(i=>Od.create(G.serialize(i)));const n=this.getAttribute(Nm);this.extensions=[],n instanceof Lm&&(this.extensions=n.items),this.subjectName=new cr(e.certificationRequestInfo.subject),this.subject=this.subjectName.toString()}getAttribute(e){for(const t of this.attributes)if(t.type===e)return t;return null}getAttributes(e){return this.attributes.filter(t=>t.type===e)}getExtension(e){for(const t of this.extensions)if(t.type===e)return t;return null}getExtensions(e){return this.extensions.filter(t=>t.type===e)}async verify(e=lt.get()){const t={...this.publicKey.algorithm,...this.signatureAlgorithm},n=await this.publicKey.export(t,["verify"],e),i=pt.resolveAll(Xa).reverse();let s=null;for(const a of i)if(s=a.toWebSignature(t,this.signature),s)break;if(!s)throw Error("Cannot convert WebCrypto signature value to ASN.1 format");return await e.subtle.verify(this.signatureAlgorithm,n,s,this.tbs)}toTextObject(){const e=this.toTextObjectEmpty(),t=G.parse(this.rawData,ua),n=t.certificationRequestInfo,i=new _e("",{Version:`${Li[n.version]} (${n.version})`,Subject:this.subject,"Subject Public Key Info":this.publicKey});if(this.attributes.length){const s=new _e("");for(const o of this.attributes){const a=o.toTextObject();s[a[_e.NAME]]=a}i.Attributes=s}return e.Data=i,e.Signature=new _e("",{Algorithm:ji.serializeAlgorithm(t.signatureAlgorithm),"":t.signature}),e}}ED.NAME="PKCS#10 Certificate Request";class Mm extends gn{constructor(e){gn.isAsnEncoded(e)?super(e,Mi):super(e),this.tag=Yt.CertificateTag}onInit(e){const t=e.tbsCertificate;this.tbs=G.serialize(t),this.serialNumber=ee.ToHex(t.serialNumber),this.subjectName=new cr(t.subject),this.subject=new cr(t.subject).toString(),this.issuerName=new cr(t.issuer),this.issuer=this.issuerName.toString();const n=pt.resolve(qi);this.signatureAlgorithm=n.toWebAlgorithm(e.signatureAlgorithm),this.signature=e.signatureValue;const i=t.validity.notBefore.utcTime||t.validity.notBefore.generalTime;if(!i)throw new Error("Cannot get 'notBefore' value");this.notBefore=i;const s=t.validity.notAfter.utcTime||t.validity.notAfter.generalTime;if(!s)throw new Error("Cannot get 'notAfter' value");this.notAfter=s,this.extensions=[],t.extensions&&(this.extensions=t.extensions.map(o=>pr.create(G.serialize(o)))),this.publicKey=new _r(t.subjectPublicKeyInfo)}getExtension(e){for(const t of this.extensions)if(typeof e=="string"){if(t.type===e)return t}else if(t instanceof e)return t;return null}getExtensions(e){return this.extensions.filter(t=>typeof e=="string"?t.type===e:t instanceof e)}async verify(e={},t=lt.get()){let n,i;const s=e.publicKey;try{if(!s)n={...this.publicKey.algorithm,...this.signatureAlgorithm},i=await this.publicKey.export(n,["verify"],t);else if("publicKey"in s)n={...s.publicKey.algorithm,...this.signatureAlgorithm},i=await s.publicKey.export(n,["verify"],t);else if(s instanceof _r)n={...s.algorithm,...this.signatureAlgorithm},i=await s.export(n,["verify"],t);else if(Y.isBufferSource(s)){const l=new _r(s);n={...l.algorithm,...this.signatureAlgorithm},i=await l.export(n,["verify"],t)}else n={...s.algorithm,...this.signatureAlgorithm},i=s}catch{return!1}const o=pt.resolveAll(Xa).reverse();let a=null;for(const l of o)if(a=l.toWebSignature(n,this.signature),a)break;if(!a)throw Error("Cannot convert ASN.1 signature value to WebCrypto format");const c=await t.subtle.verify(this.signatureAlgorithm,i,a,this.tbs);if(e.signatureOnly)return c;{const u=(e.date||new Date).getTime();return c&&this.notBefore.getTime()<u&&u<this.notAfter.getTime()}}async getThumbprint(...e){let t,n="SHA-1";return e[0]&&(e[0].subtle?t=e[0]:(n=e[0]||n,t=e[1])),t??(t=lt.get()),await t.subtle.digest(n,this.rawData)}async isSelfSigned(e=lt.get()){return this.subject===this.issuer&&await this.verify({signatureOnly:!0},e)}toTextObject(){const e=this.toTextObjectEmpty(),t=G.parse(this.rawData,Mi),n=t.tbsCertificate,i=new _e("",{Version:`${Li[n.version]} (${n.version})`,"Serial Number":n.serialNumber,"Signature Algorithm":ji.serializeAlgorithm(n.signature),Issuer:this.issuer,Validity:new _e("",{"Not Before":n.validity.notBefore.getTime(),"Not After":n.validity.notAfter.getTime()}),Subject:this.subject,"Subject Public Key Info":this.publicKey});if(n.issuerUniqueID&&(i["Issuer Unique ID"]=n.issuerUniqueID),n.subjectUniqueID&&(i["Subject Unique ID"]=n.subjectUniqueID),this.extensions.length){const s=new _e("");for(const o of this.extensions){const a=o.toTextObject();s[a[_e.NAME]]=a}i.Extensions=s}return e.Data=i,e.Signature=new _e("",{Algorithm:ji.serializeAlgorithm(t.signatureAlgorithm),"":t.signatureValue}),e}}Mm.NAME="Certificate";class AD{static async createSelfSigned(e,t=lt.get()){if(!e.keys.privateKey)throw new Error("Bad field 'keys' in 'params' argument. 'privateKey' is empty");if(!e.keys.publicKey)throw new Error("Bad field 'keys' in 'params' argument. 'publicKey' is empty");return this.create({serialNumber:e.serialNumber,subject:e.name,issuer:e.name,notBefore:e.notBefore,notAfter:e.notAfter,publicKey:e.keys.publicKey,signingKey:e.keys.privateKey,signingAlgorithm:e.signingAlgorithm,extensions:e.extensions},t)}static async create(e,t=lt.get()){var n;let i;e.publicKey instanceof _r?i=e.publicKey.rawData:"publicKey"in e.publicKey?i=e.publicKey.publicKey.rawData:Y.isBufferSource(e.publicKey)?i=e.publicKey:i=await t.subtle.exportKey("spki",e.publicKey);const s=e.serialNumber?Y.toUint8Array(ee.FromHex(e.serialNumber)):t.getRandomValues(new Uint8Array(16));s[0]>127&&(s[0]&=127),s.length>1&&s[0]===0&&(s[1]|=128);const o=e.notBefore||new Date,a=e.notAfter||new Date(o.getTime()+31536e6),c=new Mi({tbsCertificate:new tr({version:Li.v3,serialNumber:s,validity:new Fa({notBefore:o,notAfter:a}),extensions:new Hn(((n=e.extensions)===null||n===void 0?void 0:n.map(w=>G.parse(w.rawData,dr)))||[]),subjectPublicKeyInfo:G.parse(i,xr)})});if(e.subject){const w=e.subject instanceof cr?e.subject:new cr(e.subject);c.tbsCertificate.subject=G.parse(w.toArrayBuffer(),Ze)}if(e.issuer){const w=e.issuer instanceof cr?e.issuer:new cr(e.issuer);c.tbsCertificate.issuer=G.parse(w.toArrayBuffer(),Ze)}const l={hash:"SHA-256"},u="signingKey"in e?{...l,...e.signingAlgorithm,...e.signingKey.algorithm}:{...l,...e.signingAlgorithm},d=pt.resolve(qi);c.tbsCertificate.signature=c.signatureAlgorithm=d.toAsnAlgorithm(u);const f=G.serialize(c.tbsCertificate),m="signingKey"in e?await t.subtle.sign(u,e.signingKey,f):e.signature,g=pt.resolveAll(Xa).reverse();let y=null;for(const w of g)if(y=w.toAsnSignature(u,m),y)break;if(!y)throw Error("Cannot convert ASN.1 signature value to WebCrypto format");return c.signatureValue=y,new Mm(G.serialize(c))}}var i0;(function(r){r[r.unspecified=0]="unspecified",r[r.keyCompromise=1]="keyCompromise",r[r.cACompromise=2]="cACompromise",r[r.affiliationChanged=3]="affiliationChanged",r[r.superseded=4]="superseded",r[r.cessationOfOperation=5]="cessationOfOperation",r[r.certificateHold=6]="certificateHold",r[r.removeFromCRL=8]="removeFromCRL",r[r.privilegeWithdrawn=9]="privilegeWithdrawn",r[r.aACompromise=10]="aACompromise"})(i0||(i0={}));pr.register(T1,Dm);pr.register(O1,dA);pr.register(B1,hA);pr.register(M1,Rd);pr.register(Df,pa);pr.register(L1,fA);pr.register($f,gA);pr.register(Nf,mA);Od.register(sA,yA);Od.register(Nm,Lm);pt.registerSingleton(Xa,SD);pt.registerSingleton(Xa,lr);lr.namedCurveSize.set("P-256",32);lr.namedCurveSize.set("K-256",32);lr.namedCurveSize.set("P-384",48);lr.namedCurveSize.set("P-521",66);const Qr="/",wA=new TextEncoder().encode(Qr),_c=wA[0];class bt{_buf;constructor(e,t){if(typeof e=="string")this._buf=oe(e);else if(e instanceof Uint8Array)this._buf=e;else throw new Error("Invalid key, should be String of Uint8Array");if(t==null&&(t=!0),t&&this.clean(),this._buf.byteLength===0||this._buf[0]!==_c)throw new Error("Invalid key")}toString(e="utf8"){return ge(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new bt(e.join(Qr))}static random(){return new bt(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||typeof e=="string"?new bt(e):typeof e.uint8Array=="function"?new bt(e.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=wA),this._buf[0]!==_c){const e=new Uint8Array(this._buf.byteLength+1);e.fill(_c,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===_c;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),n=e.list();for(let i=0;i<t.length;i++){if(n.length<i+1)return!1;const s=t[i],o=n[i];if(s<o)return!0;if(s>o)return!1}return t.length<n.length}reverse(){return bt.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(Qr).slice(1)}type(){return xD(this.baseNamespace())}name(){return _D(this.baseNamespace())}instance(e){return new bt(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(Qr)||(e+=Qr),e+=this.type(),new bt(e)}parent(){const e=this.list();return e.length===1?new bt(Qr):new bt(e.slice(0,-1).join(Qr))}child(e){return this.toString()===Qr?e:e.toString()===Qr?this:new bt(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()===this.toString()?!1:e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()===this.toString()?!1:this.toString().startsWith(e.toString())}isTopLevel(){return this.list().length===1}concat(...e){return bt.withNamespaces([...this.namespaces(),...CD(e.map(t=>t.namespaces()))])}}function xD(r){const e=r.split(":");return e.length<2?"":e.slice(0,-1).join(":")}function _D(r){const e=r.split(":");return e[e.length-1]}function CD(r){return[].concat(...r)}class ID extends $r{async listen(){throw new EB("WebRTCTransport.createListener")}getAddrs(){return[]}updateAnnounceAddrs(){}async close(){}}const bA=Object.values(sl).map(r=>r.decoder).reduce((r,e)=>r.or(e)),kD=/^a=fingerprint:(?:\w+-[0-9]+)\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m;function TD(r){return r?.match(kD)?.groups?.fingerprint}function vA(r){const t=r.stringTuples().filter(n=>n[0]===zO).map(n=>n[1])[0];if(t===void 0||t==="")throw new le(`Couldn't find a certhash component of multiaddr: ${r.toString()}`);return t}function PD(r){return Qn(bA.decode(r))}function RD(r){const e=PD(vA(r)),t=BD(e.code),n=e.digest.reduce((s,o)=>s+o.toString(16).padStart(2,"0"),""),i=n.match(/.{1,2}/g);if(i==null)throw new SB(n,r.toString());return`${t} ${i.join(":").toUpperCase()}`}function OD(r){const e=r.split(":").map(i=>parseInt(i,16)),t=Uint8Array.from(e),n=qn(eo.code,t);return he(`/certhash/${va.encode(n.bytes)}`)}function BD(r){switch(r){case 17:return"sha-1";case 18:return"sha-256";case 19:return"sha-512";default:throw new AB(r)}}function ND(r,e){const{host:t,port:n,family:i}=r.toOptions(),s=RD(r);return{type:"answer",sdp:`v=0
o=- 0 0 IN IP${i} ${t}
s=-
t=0 0
a=ice-lite
m=application ${n} UDP/DTLS/SCTP webrtc-datachannel
c=IN IP${i} ${t}
a=mid:0
a=ice-options:ice2
a=ice-ufrag:${e}
a=ice-pwd:${e}
a=fingerprint:${s}
a=setup:passive
a=sctp-port:5000
a=max-message-size:${qu}
a=candidate:1467250027 1 UDP 1467250027 ${t} ${n} typ host
a=end-of-candidates
`}}function DD(r,e){const{host:t,port:n,family:i}=r.toOptions();return{type:"offer",sdp:`v=0
o=- 0 0 IN IP${i} ${t}
s=-
c=IN IP${i} ${t}
t=0 0
a=ice-options:ice2,trickle
m=application ${n} UDP/DTLS/SCTP webrtc-datachannel
a=mid:0
a=setup:active
a=ice-ufrag:${e}
a=ice-pwd:${e}
a=fingerprint:sha-256 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
a=sctp-port:5000
a=max-message-size:${qu}
a=candidate:1467250027 1 UDP 1467250027 ${t} ${n} typ host
a=end-of-candidates
`}}function s0(r,e){if(r.sdp===void 0)throw new le("Can't munge a missing SDP");const t=r.sdp.includes(`\r
`)?`\r
`:`
`;return r.sdp=r.sdp.replace(/\na=ice-ufrag:[^\n]*\n/,`
a=ice-ufrag:`+e+t).replace(/\na=ice-pwd:[^\n]*\n/,`
a=ice-pwd:`+e+t),r}const Sh=oe("libp2p-webrtc-noise:");function LD(r,e,t){const n=r.trim().toLowerCase().replaceAll(":",""),i=oe(n,"hex"),s=qn(eo.code,i),o=bA.decode(vA(e)),a=Sh.byteLength+s.bytes.byteLength+o.byteLength;return cn(t==="server"?[Sh,o,s.bytes]:[Sh,s.bytes,o],a)}const MD=Wg?"iceconnectionstatechange":"connectionstatechange";async function UD(r,e,t){const n=r.createDataChannel("",{negotiated:!0,id:0});try{if(t.role==="client"){t.log.trace("client creating local offer");const d=await r.createOffer();t.log.trace("client created local offer %s",d.sdp);const f=s0(d,e);t.log.trace("client setting local offer %s",f.sdp),await r.setLocalDescription(f);const m=ND(t.remoteAddr,e);t.log.trace("client setting server description %s",m.sdp),await r.setRemoteDescription(m)}else{const d=DD(t.remoteAddr,e);t.log.trace("server setting client %s %s",d.type,d.sdp),await r.setRemoteDescription(d),t.log.trace("server creating local answer");const f=await r.createAnswer();t.log.trace("server created local answer");const m=s0(f,e);t.log.trace("server setting local description %s",f.sdp),await r.setLocalDescription(m)}if(n.readyState!=="open"&&(t.log.trace("%s wait for handshake channel to open, starting status %s",t.role,n.readyState),await Ei(n,"open",t.signal)),t.log.trace("%s handshake channel opened",t.role),t.role==="server"){const d=r.remoteFingerprint()?.value??"";t.remoteAddr=t.remoteAddr.encapsulate(OD(d))}const i=TD(r.localDescription?.sdp);if(i==null)throw new Na("Could not get fingerprint from local description sdp");t.log.trace("%s performing noise handshake",t.role);const s=LD(i,t.remoteAddr,t.role),o=FS({prologueBytes:s})(t),a=Rl({channel:n,direction:"outbound",handshake:!0,logger:t.logger,...t.dataChannel??{}}),c=new _f(t,{peerConnection:r,remoteAddr:t.remoteAddr,timeline:{open:Date.now()},metrics:t.events});r.addEventListener(MD,()=>{switch(r.connectionState){case"failed":case"disconnected":case"closed":c.close().catch(d=>{t.log.error("error closing connection",d),c.abort(d)});break;default:break}}),t.events?.increment({peer_connection:!0});const l=new Kg(t,{peerConnection:r,metrics:t.events,dataChannelOptions:t.dataChannel});if(t.role==="client")return t.log.trace("%s secure inbound",t.role),await o.secureInbound(a,{remotePeer:t.remotePeerId,signal:t.signal,skipStreamMuxerNegotiation:!0}),t.log.trace("%s upgrade outbound",t.role),await t.upgrader.upgradeOutbound(c,{skipProtection:!0,skipEncryption:!0,muxerFactory:l,signal:t.signal});t.log.trace("%s secure outbound",t.role);const u=await o.secureOutbound(a,{remotePeer:t.remotePeerId,signal:t.signal,skipStreamMuxerNegotiation:!0});c.remoteAddr=c.remoteAddr.encapsulate(`/p2p/${u.remotePeer}`),t.log.trace("%s upgrade inbound",t.role),await t.upgrader.upgradeInbound(c,{skipProtection:!0,skipEncryption:!0,muxerFactory:l,signal:t.signal})}catch(i){throw n.close(),i}}async function FD(r,e,t,n){n==null&&(n=await RTCPeerConnection.generateCertificate({name:"ECDSA",namedCurve:"P-256"}));const i=typeof t=="function"?await t():t;return new RTCPeerConnection({...i??{},certificates:[n]})}async function $D(r){const e=await mS(r),t=await crypto.subtle.exportKey("pkcs8",e.privateKey);return["-----BEGIN PRIVATE KEY-----",...ge(new Uint8Array(t),"base64pad").split(/(.{64})/).filter(Boolean),"-----END PRIVATE KEY-----"].join(`
`)}class VD{log;metrics;components;init;certificate;privateKey;emitter;renewCertificateTask;constructor(e,t={}){if(this.log=e.logger.forComponent("libp2p:webrtc-direct"),this.components=e,this.init=t,this.emitter=new $r,t.certificateLifespan!=null&&t.certificateRenewalThreshold!=null&&t.certificateRenewalThreshold>=t.certificateLifespan)throw new le("Certificate renewal threshold must be less than certificate lifespan");e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc-direct_dialer_events_total",{label:"event",help:"Total count of WebRTC-direct dial events by type"})})}[Eu]=!0;[Symbol.toStringTag]="@libp2p/webrtc-direct";[Zt]=["@libp2p/transport"];async start(){this.certificate=await this.getCertificate()}async stop(){this.renewCertificateTask!=null&&clearTimeout(this.renewCertificateTask),this.certificate=void 0}async dial(e,t){this.log("dial %a",e),t.signal.throwIfAborted();let n;const i=e.getPeerId();i!=null&&(n=Ir(i));const s=yB(),o=await FD("client",s,typeof this.init.rtcConfiguration=="function"?await this.init.rtcConfiguration():this.init.rtcConfiguration??{});try{return await UD(o,s,{role:"client",log:this.log,logger:this.components.logger,metrics:this.components.metrics,events:this.metrics?.dialerEvents,signal:t.signal,remoteAddr:e,dataChannel:this.init.dataChannel,upgrader:t.upgrader,peerId:this.components.peerId,remotePeerId:n,privateKey:this.components.privateKey})}catch(a){throw o.close(),a}}createListener(e){if(this.certificate==null)throw new Wo;return new ID(this.components,{...this.init,...e,certificate:this.certificate,emitter:this.emitter})}listenFilter(e){return e.filter(vf.exactMatch)}dialFilter(e){return this.listenFilter(e)}async getCertificate(e){if(qD(this.init.certificate))return this.log("using provided TLS certificate"),this.init.certificate;const t=await this.loadOrCreatePrivateKey(),{pem:n,certhash:i}=await this.loadOrCreateCertificate(t,e);return{privateKey:await $D(t),pem:n,certhash:i}}async loadOrCreatePrivateKey(){if(this.privateKey!=null)return this.privateKey;const e=this.init.certificateKeychainName??JO,t=this.getKeychain();try{if(t==null)throw this.log("no keychain configured - not checking for stored private key"),new di;this.log.trace("checking for stored private key"),this.privateKey=await t.exportKey(e)}catch(n){if(n.name!=="NotFoundError")throw n;this.log.trace("generating private key"),this.privateKey=await gS("ECDSA","P-256"),t!=null?(this.log.trace("storing private key"),await t.importKey(e,this.privateKey)):this.log("no keychain configured - not storing private key")}return this.privateKey}async loadOrCreateCertificate(e,t){if(this.certificate!=null&&t!==!0)return this.certificate;let n;const i=new bt(this.init.certificateDatastoreKey??ZO),s=await mS(e);try{if(t===!0)throw this.log.trace("forcing renewal of TLS certificate"),new di;this.log.trace("checking for stored TLS certificate"),n=await this.loadCertificate(i,s)}catch(a){if(a.name!=="NotFoundError")throw a;this.log.trace("generating new TLS certificate"),n=await this.createCertificate(i,s)}let o=n.notAfter.getTime()-(this.init.certificateRenewalThreshold??Sw)-Date.now();return o<0&&(o=100),this.log("will renew TLS certificate after %d ms",o),this.renewCertificateTask=setTimeout(()=>{this.log("renewing TLS certificate"),this.getCertificate(!0).then(a=>{this.certificate=a,this.emitter.safeDispatchEvent("certificate:renew",{detail:a})}).catch(a=>{this.log.error("could not renew certificate - %e",a)})},o),{pem:n.toString("pem"),certhash:va.encode((await eo.digest(new Uint8Array(n.rawData))).bytes)}}async loadCertificate(e,t){const n=await this.components.datastore.get(e),i=new Mm(n),s=i.notAfter.getTime()-(this.init.certificateRenewalThreshold??Sw);if(Date.now()>s)throw this.log("stored TLS certificate has expired"),new di;this.log("loaded certificate, expires in %d ms",s);const o=await i.publicKey.export(crypto),a=await crypto.subtle.exportKey("raw",o),c=await crypto.subtle.exportKey("raw",t.publicKey);if(!et(new Uint8Array(a,0,a.byteLength),new Uint8Array(c,0,c.byteLength)))throw this.log("stored TLS certificate public key did not match public key from private key"),new di;return this.log("loaded certificate, expiry time is %o",s),i}async createCertificate(e,t){const n=new Date,i=new Date(Date.now()+(this.init.certificateLifespan??eB));n.setMilliseconds(0),i.setMilliseconds(0);const s=await AD.createSelfSigned({serialNumber:(BigInt(Math.random().toString().replace(".",""))*100000n).toString(16),name:"CN=example.com, C=US, L=CA, O=example, ST=CA",notBefore:n,notAfter:i,keys:t,extensions:[new Dm(!1,void 0,!0)]},crypto);return this.getKeychain()!=null?(this.log.trace("storing TLS certificate"),await this.components.datastore.put(e,oe(s.toString("pem")))):this.log("no keychain is configured so not storing TLS certificate since the private key will not be reused"),s}getKeychain(){try{return this.components.keychain}catch{}}}function qD(r){return r==null?!1:typeof r.privateKey=="string"&&typeof r.pem=="string"&&typeof r.certhash=="string"}function jD(r){return e=>new VD(e,r)}function zD(r){return e=>new IB(e,r)}const HD=[xt("tcp").code,xt("dns").code,xt("dnsaddr").code,xt("dns4").code,xt("dns6").code];function o0(r){return SA("sni",r)?.[1]}function a0(r){const e=SA("tcp",r)?.[1];return e==null?"":`:${e}`}function SA(r,e){let t;try{t=xt(r).code}catch{return}for(const[n,i]of e)if(n===t&&i!=null)return[n,i]}function c0(r){return r.some(([e,t])=>e===xt("tls").code)}function wr(r,e,t){const n=EA[xt(r).name];if(n==null)throw new Error(`Can't interpret protocol ${xt(r).name}`);const i=n(e,t);return r===xt("ip6").code?`[${i}]`:i}const EA={ip4:(r,e)=>r,ip6:(r,e)=>e.length===0?r:`[${r}]`,tcp:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`tcp://${wr(t[0],t[1]??"",e)}:${r}`},udp:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`udp://${wr(t[0],t[1]??"",e)}:${r}`},dnsaddr:(r,e)=>r,dns4:(r,e)=>r,dns6:(r,e)=>r,dns:(r,e)=>r,ipfs:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${wr(t[0],t[1]??"",e)}`},p2p:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${wr(t[0],t[1]??"",e)}`},http:(r,e)=>{const t=c0(e),n=o0(e),i=a0(e);if(t&&n!=null)return`https://${n}${i}`;const s=t?"https://":"http://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=wr(o[0],o[1]??"",e);return a=a.replace("tcp://",""),`${s}${a}`},"http-path":(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");const n=wr(t[0],t[1]??"",e),i=decodeURIComponent(r);return`${n}/${i}`},tls:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return wr(t[0],t[1]??"",e)},sni:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return wr(t[0],t[1]??"",e)},https:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let n=wr(t[0],t[1]??"",e);return n=n.replace("tcp://",""),`https://${n}`},ws:(r,e)=>{const t=c0(e),n=o0(e),i=a0(e);if(t&&n!=null)return`wss://${n}${i}`;const s=t?"wss://":"ws://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=wr(o[0],o[1]??"",e);return a=a.replace("tcp://",""),`${s}${a}`},wss:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let n=wr(t[0],t[1]??"",e);return n=n.replace("tcp://",""),`wss://${n}`}};function WD(r,e){const n=he(r).stringTuples(),i=n.pop();if(i==null)throw new Error("Unexpected end of multiaddr");const s=xt(i[0]),o=EA[s.name];if(o==null)throw new Error(`No interpreter found for ${s.name}`);let a=o(i[1]??"",n);return HD.includes(i[0])&&(a=a.replace(/^.*:\/\//,""),i[1]==="443"?a=`https://${a}`:a=`http://${a}`),(a.startsWith("http://")||a.startsWith("https://")||a.startsWith("ws://")||a.startsWith("wss://"))&&(a=new URL(a).toString(),a.endsWith("/")&&(a=a.substring(0,a.length-1))),a}const KD=async r=>{if(r.readyState>=2)throw new Error("socket closed");r.readyState!==1&&await new Promise((e,t)=>{function n(){r.removeEventListener("open",i),r.removeEventListener("error",s)}function i(){n(),e()}function s(o){n(),t(o.error??new Error(`connect ECONNREFUSED ${r.url}`))}r.addEventListener("open",i),r.addEventListener("error",s)})},GD=(r,e)=>(e=e??{},e.closeOnEnd=e.closeOnEnd!==!1,async n=>{for await(const i of n){try{await KD(r)}catch(s){if(s.message==="socket closed")break;throw s}if(r.readyState===r.CLOSING||r.readyState===r.CLOSED)break;r.send(i)}e.closeOnEnd!=null&&r.readyState<=1&&await new Promise((i,s)=>{r.addEventListener("close",o=>{if(o.wasClean||o.code===1006)i();else{const a=Object.assign(new Error("ws error"),{event:o});s(a)}}),setTimeout(()=>{r.close()})})});var ss={},Co={},l0;function YD(){if(l0)return Co;l0=1,Object.defineProperty(Co,"__esModule",{value:!0});class r{constructor(){this.pullQueue=[],this.pushQueue=[],this.eventHandlers={},this.isPaused=!1,this.isStopped=!1}push(n){if(this.isStopped)return;const i={value:n,done:!1};if(this.pullQueue.length){const s=this.pullQueue.shift();s&&s.resolve(i)}else this.pushQueue.push(Promise.resolve(i)),this.highWaterMark!==void 0&&this.pushQueue.length>=this.highWaterMark&&!this.isPaused&&(this.isPaused=!0,this.eventHandlers.highWater?this.eventHandlers.highWater():console&&console.warn(`EventIterator queue reached ${this.pushQueue.length} items`))}stop(){if(!this.isStopped){this.isStopped=!0,this.remove();for(const n of this.pullQueue)n.resolve({value:void 0,done:!0});this.pullQueue.length=0}}fail(n){if(!this.isStopped)if(this.isStopped=!0,this.remove(),this.pullQueue.length){for(const i of this.pullQueue)i.reject(n);this.pullQueue.length=0}else{const i=Promise.reject(n);i.catch(()=>{}),this.pushQueue.push(i)}}remove(){Promise.resolve().then(()=>{this.removeCallback&&this.removeCallback()})}[Symbol.asyncIterator](){return{next:n=>{const i=this.pushQueue.shift();return i?(this.lowWaterMark!==void 0&&this.pushQueue.length<=this.lowWaterMark&&this.isPaused&&(this.isPaused=!1,this.eventHandlers.lowWater&&this.eventHandlers.lowWater()),i):this.isStopped?Promise.resolve({value:void 0,done:!0}):new Promise((s,o)=>{this.pullQueue.push({resolve:s,reject:o})})},return:()=>(this.isStopped=!0,this.pushQueue.length=0,this.remove(),Promise.resolve({value:void 0,done:!0}))}}}class e{constructor(n,{highWaterMark:i=100,lowWaterMark:s=1}={}){const o=new r;o.highWaterMark=i,o.lowWaterMark=s,o.removeCallback=n({push:a=>o.push(a),stop:()=>o.stop(),fail:a=>o.fail(a),on:(a,c)=>{o.eventHandlers[a]=c}})||(()=>{}),this[Symbol.asyncIterator]=()=>o[Symbol.asyncIterator](),Object.freeze(this)}}return Co.EventIterator=e,Co.default=e,Co}var u0;function QD(){if(u0)return ss;u0=1,Object.defineProperty(ss,"__esModule",{value:!0});const r=YD();ss.EventIterator=r.EventIterator;function e(t,n,i){return new r.EventIterator(({push:s})=>(this.addEventListener(t,s,n),()=>this.removeEventListener(t,s,n)),i)}return ss.subscribe=e,ss.default=r.EventIterator,ss}var XD=QD();function d0(r){return r instanceof ArrayBuffer||r?.constructor?.name==="ArrayBuffer"&&typeof r?.byteLength=="number"}const ZD=r=>{r.binaryType="arraybuffer";const e=async()=>{await new Promise((s,o)=>{if(n){s();return}if(i!=null){o(i);return}const a=u=>{r.removeEventListener("open",c),r.removeEventListener("error",l),u()},c=()=>{a(s)},l=u=>{a(()=>{o(u.error??new Error(`connect ECONNREFUSED ${r.url}`))})};r.addEventListener("open",c),r.addEventListener("error",l)})},t=async function*(){const s=new XD.EventIterator(({push:o,stop:a,fail:c})=>{const l=d=>{let f=null;typeof d.data=="string"&&(f=oe(d.data)),d0(d.data)&&(f=new Uint8Array(d.data)),d.data instanceof Uint8Array&&(f=d.data),f!=null&&o(f)},u=d=>{c(d.error??new Error("Socket error"))};return r.addEventListener("message",l),r.addEventListener("error",u),r.addEventListener("close",a),()=>{r.removeEventListener("message",l),r.removeEventListener("error",u),r.removeEventListener("close",a)}},{highWaterMark:1/0});await e();for await(const o of s)yield d0(o)?new Uint8Array(o):o}();let n=r.readyState===1,i;return r.addEventListener("open",()=>{n=!0,i=null}),r.addEventListener("close",()=>{n=!1,i=null}),r.addEventListener("error",s=>{n||(i=s.error??new Error(`connect ECONNREFUSED ${r.url}`))}),Object.assign(t,{connected:e})},JD=(r,e)=>{e=e??{};const t=ZD(r);let n=e.remoteAddress,i=e.remotePort;if(r.url!=null)try{const o=new URL(r.url);n=o.hostname,i=parseInt(o.port,10)}catch{}if(n==null||i==null)throw new Error("Remote connection did not have address and/or port");return{sink:GD(r,e),source:t,connected:async()=>{await t.connected()},close:async()=>{(r.readyState===r.CONNECTING||r.readyState===r.OPEN)&&await new Promise(o=>{r.addEventListener("close",()=>{o()}),r.close()})},destroy:()=>{r.terminate!=null?r.terminate():r.close()},remoteAddress:n,remotePort:i,socket:r}},eL=WebSocket,tL={"http:":"ws:","https:":"wss:"},h0="ws:",rL=(r,e)=>{if(r.startsWith("//")&&(r=`${e?.protocol??h0}${r}`),r.startsWith("/")&&e!=null){const n=e.protocol??h0,i=e.host,s=e.port!=null&&i?.endsWith(`:${e.port}`)!==!0?`:${e.port}`:"";r=`${n}//${i}${s}${r}`}const t=new URL(r);for(const[n,i]of Object.entries(tL))t.protocol===n&&(t.protocol=i);return t};function nL(r,e){const t=typeof window>"u"?void 0:window.location;e=e??{};const n=rL(r,t),i=new eL(n.toString(),e.websocket);return JD(i,e)}function iL(r){return r.filter(e=>kl.exactMatch(e)||ra.exactMatch(e))}function sL(){throw new Error("WebSocket Servers can not be created in the browser!")}const oL=500;function aL(r,e,t){const n=t.logger.forComponent("libp2p:websockets:maconn"),i=t.metrics,s=t.metricPrefix??"",o={log:n,async sink(a){try{await r.sink(async function*(){for await(const c of a)c instanceof Uint8Array?yield c:yield c.subarray()}())}catch(c){c.type!=="aborted"&&n.error(c)}},source:r.source,remoteAddr:e,timeline:{open:Date.now()},async close(a={}){const c=Date.now();if(a.signal==null){const u=AbortSignal.timeout(oL);a={...a,signal:u}}const l=()=>{const{host:u,port:d}=o.remoteAddr.toOptions();n("timeout closing stream to %s:%s after %dms, destroying it manually",u,d,Date.now()-c),this.abort(new Ii("Socket close timeout"))};a.signal?.addEventListener("abort",l);try{await r.close()}catch(u){n.error("error closing WebSocket gracefully",u),this.abort(u)}finally{a.signal?.removeEventListener("abort",l),o.timeline.close=Date.now()}},abort(a){const{host:c,port:l}=o.remoteAddr.toOptions();n("timeout closing stream to %s:%s due to error",c,l,a),r.destroy(),o.timeline.close=Date.now(),i?.increment({[`${s}error`]:!0})}};return r.socket.addEventListener("close",()=>{i?.increment({[`${s}close`]:!0}),o.timeline.close==null&&(o.timeline.close=Date.now())},{once:!0}),o}class cL{log;init;logger;metrics;components;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:websockets"),this.logger=e.logger,this.components=e,this.init=t,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total",{label:"event",help:"Total count of WebSockets dialer events by type"})})}[Eu]=!0;[Symbol.toStringTag]="@libp2p/websockets";[Zt]=["@libp2p/transport"];async dial(e,t){this.log("dialing %s",e),t=t??{};const n=await this._connect(e,t),i=aL(n,e,{logger:this.logger,metrics:this.metrics?.dialerEvents});this.log("new outbound connection %s",i.remoteAddr);const s=await t.upgrader.upgradeOutbound(i,t);return this.log("outbound connection %s upgraded",i.remoteAddr),s}async _connect(e,t){t?.signal?.throwIfAborted();const n=e.toOptions();this.log("dialing %s:%s",n.host,n.port);const i=We(),s=nL(WD(e),this.init);s.socket.addEventListener("error",()=>{const o=new wv(`Could not connect to ${e.toString()}`);this.log.error("connection error:",o),this.metrics?.dialerEvents.increment({error:!0}),i.reject(o)});try{t.onProgress?.(new Re("websockets:open-connection")),await sr(Promise.race([s.connected(),i.promise]),t.signal)}catch(o){throw t.signal?.aborted&&this.metrics?.dialerEvents.increment({abort:!0}),s.close().catch(a=>{this.log.error("error closing raw socket",a)}),o}return this.log("connected %s",e),this.metrics?.dialerEvents.increment({connect:!0}),s}createListener(e){return sL({logger:this.logger,events:this.components.events,metrics:this.components.metrics},{...this.init,...e})}listenFilter(e){return e=Array.isArray(e)?e:[e],this.init?.filter!=null?this.init?.filter(e):iL(e)}dialFilter(e){return this.listenFilter(e)}}function lL(r={}){return e=>new cL(e,r)}function du(r){if(typeof r!="object"||r===null)return!1;const e=Object.getPrototypeOf(r);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in r)&&!(Symbol.iterator in r)}const{hasOwnProperty:AA}=Object.prototype,{propertyIsEnumerable:uL}=Object,Ws=(r,e,t)=>{Object.defineProperty(r,e,{value:t,writable:!0,enumerable:!0,configurable:!0})},dL=void 0,f0={concatArrays:!1,ignoreUndefined:!1},Bd=r=>{const e=[];for(const t in r)AA.call(r,t)&&e.push(t);if(Object.getOwnPropertySymbols){const t=Object.getOwnPropertySymbols(r);for(const n of t)uL.call(r,n)&&e.push(n)}return e};function mo(r){return Array.isArray(r)?hL(r):du(r)?fL(r):r}function hL(r){const e=r.slice(0,0);return Bd(r).forEach(t=>{Ws(e,t,mo(r[t]))}),e}function fL(r){const e=Object.getPrototypeOf(r)===null?Object.create(null):{};return Bd(r).forEach(t=>{Ws(e,t,mo(r[t]))}),e}const xA=(r,e,t,n)=>(t.forEach(i=>{typeof e[i]>"u"&&n.ignoreUndefined||(i in r&&r[i]!==Object.getPrototypeOf(r)?Ws(r,i,jp(r[i],e[i],n)):Ws(r,i,mo(e[i])))}),r),pL=(r,e,t)=>{let n=r.slice(0,0),i=0;return[r,e].forEach(s=>{const o=[];for(let a=0;a<s.length;a++)AA.call(s,a)&&(o.push(String(a)),s===r?Ws(n,i++,s[a]):Ws(n,i++,mo(s[a])));n=xA(n,s,Bd(s).filter(a=>!o.includes(a)),t)}),n};function jp(r,e,t){return t.concatArrays&&Array.isArray(r)&&Array.isArray(e)?pL(r,e,t):!du(e)||!du(r)?mo(e):xA(r,e,Bd(e),t)}function _A(...r){const e=jp(mo(f0),this!==dL&&this||{},f0);let t={_:{}};for(const n of r)if(n!==void 0){if(!du(n))throw new TypeError("`"+n+"` is not an Option Object");t=jp(t,{_:n},e)}return t._}var Eh={exports:{}},p0;function gL(){return p0||(p0=1,function(r){var e=Object.prototype.hasOwnProperty,t="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(t=!1));function i(c,l,u){this.fn=c,this.context=l,this.once=u||!1}function s(c,l,u,d,f){if(typeof u!="function")throw new TypeError("The listener must be a function");var m=new i(u,d||c,f),g=t?t+l:l;return c._events[g]?c._events[g].fn?c._events[g]=[c._events[g],m]:c._events[g].push(m):(c._events[g]=m,c._eventsCount++),c}function o(c,l){--c._eventsCount===0?c._events=new n:delete c._events[l]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var l=[],u,d;if(this._eventsCount===0)return l;for(d in u=this._events)e.call(u,d)&&l.push(t?d.slice(1):d);return Object.getOwnPropertySymbols?l.concat(Object.getOwnPropertySymbols(u)):l},a.prototype.listeners=function(l){var u=t?t+l:l,d=this._events[u];if(!d)return[];if(d.fn)return[d.fn];for(var f=0,m=d.length,g=new Array(m);f<m;f++)g[f]=d[f].fn;return g},a.prototype.listenerCount=function(l){var u=t?t+l:l,d=this._events[u];return d?d.fn?1:d.length:0},a.prototype.emit=function(l,u,d,f,m,g){var y=t?t+l:l;if(!this._events[y])return!1;var w=this._events[y],x=arguments.length,T,v;if(w.fn){switch(w.once&&this.removeListener(l,w.fn,void 0,!0),x){case 1:return w.fn.call(w.context),!0;case 2:return w.fn.call(w.context,u),!0;case 3:return w.fn.call(w.context,u,d),!0;case 4:return w.fn.call(w.context,u,d,f),!0;case 5:return w.fn.call(w.context,u,d,f,m),!0;case 6:return w.fn.call(w.context,u,d,f,m,g),!0}for(v=1,T=new Array(x-1);v<x;v++)T[v-1]=arguments[v];w.fn.apply(w.context,T)}else{var b=w.length,A;for(v=0;v<b;v++)switch(w[v].once&&this.removeListener(l,w[v].fn,void 0,!0),x){case 1:w[v].fn.call(w[v].context);break;case 2:w[v].fn.call(w[v].context,u);break;case 3:w[v].fn.call(w[v].context,u,d);break;case 4:w[v].fn.call(w[v].context,u,d,f);break;default:if(!T)for(A=1,T=new Array(x-1);A<x;A++)T[A-1]=arguments[A];w[v].fn.apply(w[v].context,T)}}return!0},a.prototype.on=function(l,u,d){return s(this,l,u,d,!1)},a.prototype.once=function(l,u,d){return s(this,l,u,d,!0)},a.prototype.removeListener=function(l,u,d,f){var m=t?t+l:l;if(!this._events[m])return this;if(!u)return o(this,m),this;var g=this._events[m];if(g.fn)g.fn===u&&(!f||g.once)&&(!d||g.context===d)&&o(this,m);else{for(var y=0,w=[],x=g.length;y<x;y++)(g[y].fn!==u||f&&!g[y].once||d&&g[y].context!==d)&&w.push(g[y]);w.length?this._events[m]=w.length===1?w[0]:w:o(this,m)}return this},a.prototype.removeAllListeners=function(l){var u;return l?(u=t?t+l:l,this._events[u]&&o(this,u)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,r.exports=a}(Eh)),Eh.exports}var mL=gL();const yL=Oa(mL);function wL(r,e,t){let n=0,i=r.length;for(;i>0;){const s=Math.trunc(i/2);let o=n+s;t(r[o],e)<=0?(n=++o,i-=s+1):i=s}return n}let bL=class{#e=[];enqueue(e,t){t={priority:0,...t};const n={priority:t.priority,id:t.id,run:e};if(this.size===0||this.#e[this.size-1].priority>=t.priority){this.#e.push(n);return}const i=wL(this.#e,n,(s,o)=>o.priority-s.priority);this.#e.splice(i,0,n)}setPriority(e,t){const n=this.#e.findIndex(s=>s.id===e);if(n===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[i]=this.#e.splice(n,1);this.enqueue(i.run,{priority:t,id:e})}dequeue(){return this.#e.shift()?.run}filter(e){return this.#e.filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return this.#e.length}};class zp extends yL{#e;#r;#t=0;#f;#a;#p=0;#i;#c;#n;#g;#s=0;#l;#o;#m;#b=1n;timeout;constructor(e){if(super(),e={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:bL,...e},!(typeof e.intervalCap=="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString()??""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString()??""}\` (${typeof e.interval})`);this.#e=e.carryoverConcurrencyCount,this.#r=e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0,this.#f=e.intervalCap,this.#a=e.interval,this.#n=new e.queueClass,this.#g=e.queueClass,this.concurrency=e.concurrency,this.timeout=e.timeout,this.#m=e.throwOnTimeout===!0,this.#o=e.autoStart===!1}get#v(){return this.#r||this.#t<this.#f}get#S(){return this.#s<this.#l}#E(){this.#s--,this.#u(),this.emit("next")}#A(){this.#w(),this.#y(),this.#c=void 0}get#x(){const e=Date.now();if(this.#i===void 0){const t=this.#p-e;if(t<0)this.#t=this.#e?this.#s:0;else return this.#c===void 0&&(this.#c=setTimeout(()=>{this.#A()},t)),!0}return!1}#u(){if(this.#n.size===0)return this.#i&&clearInterval(this.#i),this.#i=void 0,this.emit("empty"),this.#s===0&&this.emit("idle"),!1;if(!this.#o){const e=!this.#x;if(this.#v&&this.#S){const t=this.#n.dequeue();return t?(this.emit("active"),t(),e&&this.#y(),!0):!1}}return!1}#y(){this.#r||this.#i!==void 0||(this.#i=setInterval(()=>{this.#w()},this.#a),this.#p=Date.now()+this.#a)}#w(){this.#t===0&&this.#s===0&&this.#i&&(clearInterval(this.#i),this.#i=void 0),this.#t=this.#e?this.#s:0,this.#d()}#d(){for(;this.#u(););}get concurrency(){return this.#l}set concurrency(e){if(!(typeof e=="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);this.#l=e,this.#d()}async#_(e){return new Promise((t,n)=>{e.addEventListener("abort",()=>{n(e.reason)},{once:!0})})}setPriority(e,t){this.#n.setPriority(e,t)}async add(e,t={}){return t.id??=(this.#b++).toString(),t={timeout:this.timeout,throwOnTimeout:this.#m,...t},new Promise((n,i)=>{this.#n.enqueue(async()=>{this.#s++,this.#t++;try{t.signal?.throwIfAborted();let s=e({signal:t.signal});t.timeout&&(s=Hg(Promise.resolve(s),{milliseconds:t.timeout})),t.signal&&(s=Promise.race([s,this.#_(t.signal)]));const o=await s;n(o),this.emit("completed",o)}catch(s){if(s instanceof xE&&!t.throwOnTimeout){n();return}i(s),this.emit("error",s)}finally{this.#E()}},t),this.emit("add"),this.#u()})}async addAll(e,t){return Promise.all(e.map(async n=>this.add(n,t)))}start(){return this.#o?(this.#o=!1,this.#d(),this):this}pause(){this.#o=!0}clear(){this.#n=new this.#g}async onEmpty(){this.#n.size!==0&&await this.#h("empty")}async onSizeLessThan(e){this.#n.size<e||await this.#h("next",()=>this.#n.size<e)}async onIdle(){this.#s===0&&this.#n.size===0||await this.#h("idle")}async#h(e,t){return new Promise(n=>{const i=()=>{t&&!t()||(this.off(e,i),n())};this.on(e,i)})}get size(){return this.#n.size}sizeBy(e){return this.#n.filter(e).length}get pending(){return this.#s}get isPaused(){return this.#o}}function CA(r){const e=[Gn.A];return r==null?e:Array.isArray(r)?r.length===0?e:r:[r]}const IA=60;function kA(r){return{Status:r.Status??0,TC:r.TC??r.flag_tc??!1,RD:r.RD??r.flag_rd??!1,RA:r.RA??r.flag_ra??!1,AD:r.AD??r.flag_ad??!1,CD:r.CD??r.flag_cd??!1,Question:(r.Question??r.questions??[]).map(e=>({name:e.name,type:Gn[e.type]})),Answer:(r.Answer??r.answers??[]).map(e=>({name:e.name,type:Gn[e.type],TTL:e.TTL??e.ttl??IA,data:e.data instanceof Uint8Array?ge(e.data):e.data}))}}const vL=4;function g0(r,e={}){const t=new zp({concurrency:e.queryConcurrency??vL});return async(n,i={})=>{const s=new URLSearchParams;s.set("name",n),CA(i.types).forEach(a=>{s.append("type",Gn[a])}),i.onProgress?.(new Re("dns:query",{detail:n}));const o=await t.add(async()=>{const a=await fetch(`${r}?${s}`,{headers:{accept:"application/dns-json"},signal:i?.signal});if(a.status!==200)throw new Error(`Unexpected HTTP status: ${a.status} - ${a.statusText}`);const c=kA(await a.json());return i.onProgress?.(new Re("dns:response",{detail:c})),c},{signal:i.signal});if(o==null)throw new Error("No DNS response received");return o}}function SL(){return[g0("https://cloudflare-dns.com/dns-query"),g0("https://dns.google/resolve")]}var Ah,m0;function EL(){return m0||(m0=1,Ah=function(r){if(!r)throw Error("hashlru must have a max value, of type number, greater than 0");var e=0,t=Object.create(null),n=Object.create(null);function i(s,o){t[s]=o,e++,e>=r&&(e=0,n=t,t=Object.create(null))}return{has:function(s){return t[s]!==void 0||n[s]!==void 0},remove:function(s){t[s]!==void 0&&(t[s]=void 0),n[s]!==void 0&&(n[s]=void 0)},get:function(s){var o=t[s];if(o!==void 0)return o;if((o=n[s])!==void 0)return i(s,o),o},set:function(s,o){t[s]!==void 0?t[s]=o:i(s,o)},clear:function(){t=Object.create(null),n=Object.create(null)}}}),Ah}var AL=EL();const xL=Oa(AL);class _L{lru;constructor(e){this.lru=xL(e)}get(e,t){let n=!0;const i=[];for(const s of t){const o=this.getAnswers(e,s);if(o.length===0){n=!1;break}i.push(...o)}if(n)return kA({answers:i})}getAnswers(e,t){const n=`${e.toLowerCase()}-${t}`,i=this.lru.get(n);if(i!=null){const s=i.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:Gn[a.type]}));return s.length===0&&this.lru.remove(n),s}return[]}add(e,t){const n=`${e.toLowerCase()}-${t.type}`,i=this.lru.get(n)??[];i.push({expires:Date.now()+(t.TTL??IA)*1e3,value:t}),this.lru.set(n,i)}remove(e,t){const n=`${e.toLowerCase()}-${t}`;this.lru.remove(n)}clear(){this.lru.clear()}}function CL(r){return new _L(r)}const IL=1e3;class kL{resolvers;cache;constructor(e){this.resolvers={},this.cache=CL(e.cacheSize??IL),Object.entries(e.resolvers??{}).forEach(([t,n])=>{Array.isArray(n)||(n=[n]),t.endsWith(".")||(t=`${t}.`),this.resolvers[t]=n}),this.resolvers["."]==null&&(this.resolvers["."]=SL())}async query(e,t={}){const n=CA(t.types),i=t.cached!==!1?this.cache.get(e,n):void 0;if(i!=null)return t.onProgress?.(new Re("dns:cache",{detail:i})),i;const s=`${e.split(".").pop()}.`,o=(this.resolvers[s]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const c of o){if(t.signal?.aborted===!0)break;try{const l=await c(e,{...t,types:n});for(const u of l.Answer)this.cache.add(e,u);return l}catch(l){a.push(l),t.onProgress?.(new Re("dns:error",{detail:l}))}}throw a.length===1?a[0]:new AggregateError(a,`DNS lookup of ${e} ${n} failed`)}}var Gn;(function(r){r[r.A=1]="A",r[r.CNAME=5]="CNAME",r[r.TXT=16]="TXT",r[r.AAAA=28]="AAAA"})(Gn||(Gn={}));function TL(r={}){return new kL(r)}const Ht=-1,Hp={},PL={},RL=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,Ht,"ip6zone"],[43,8,"ipcidr"],[53,Ht,"dns",!0],[54,Ht,"dns4",!0],[55,Ht,"dns6",!0],[56,Ht,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,Ht,"unix",!1,!0],[421,Ht,"ipfs"],[421,Ht,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,Ht,"garlic64"],[448,0,"tls"],[449,Ht,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,Ht,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[481,Ht,"http-path"],[777,Ht,"memory"]];RL.forEach(r=>{const e=OL(...r);PL[e.code]=e,Hp[e.name]=e});function OL(r,e,t,n,i){return{code:r,size:e,name:t,resolvable:!!n,path:!!i}}function BL(r){{if(Hp[r]!=null)return Hp[r];throw new Error(`no protocol with name: ${r}`)}}const NL=32,{code:DL}=BL("dnsaddr");class LL extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}const TA=async function(e,t={}){const n=t.maxRecursiveDepth??NL;if(n===0)throw new LL("Max recursive depth reached");const[,i]=e.stringTuples().find(([l])=>l===DL)??[],o=await(t?.dns??TL()).query(`_dnsaddr.${i}`,{signal:t?.signal,types:[Gn.TXT]}),a=e.getPeerId(),c=[];for(const l of o.Answer){const u=l.data.replace(/["']/g,"").trim().split("=")[1];if(u==null||a!=null&&!u.includes(a))continue;const d=he(u);if(u.startsWith("/dnsaddr")){const f=await d.resolve({...t,maxRecursiveDepth:n-1});c.push(...f.map(m=>m.toString()))}else c.push(d.toString())}return c},ML={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter:r=>r},connectionManager:{resolvers:{dnsaddr:TA}},transportManager:{faultTolerance:Ho.FATAL_ALL}};async function UL(r){const e=_A(ML,r);if(e.connectionProtector===null&&globalThis.process?.env?.LIBP2P_FORCE_PNET!=null)throw new le("Private network is enforced, but no protector was provided");return e}const Ks=1e3,Gs=Ks*60,Ys=Gs*60,zi=Ys*24,FL=zi*7,$L=zi*365.25;function PA(r,e){try{if(typeof r=="string"&&r.length>0)return VL(r);if(typeof r=="number"&&isFinite(r))return e?.long?jL(r):qL(r);throw new Error("Value is not a string or number.")}catch(t){const n=zL(t)?`${t.message}. value=${JSON.stringify(r)}`:"An unknown error has occured.";throw new Error(n)}}function VL(r){if(r=String(r),r.length>100)throw new Error("Value exceeds the maximum length of 100 characters.");const e=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(r);if(!e)return NaN;const t=parseFloat(e[1]),n=(e[2]||"ms").toLowerCase();switch(n){case"years":case"year":case"yrs":case"yr":case"y":return t*$L;case"weeks":case"week":case"w":return t*FL;case"days":case"day":case"d":return t*zi;case"hours":case"hour":case"hrs":case"hr":case"h":return t*Ys;case"minutes":case"minute":case"mins":case"min":case"m":return t*Gs;case"seconds":case"second":case"secs":case"sec":case"s":return t*Ks;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:throw new Error(`The unit ${n} was matched, but no matching case exists.`)}}function qL(r){const e=Math.abs(r);return e>=zi?`${Math.round(r/zi)}d`:e>=Ys?`${Math.round(r/Ys)}h`:e>=Gs?`${Math.round(r/Gs)}m`:e>=Ks?`${Math.round(r/Ks)}s`:`${r}ms`}function jL(r){const e=Math.abs(r);return e>=zi?Cc(r,e,zi,"day"):e>=Ys?Cc(r,e,Ys,"hour"):e>=Gs?Cc(r,e,Gs,"minute"):e>=Ks?Cc(r,e,Ks,"second"):`${r} ms`}function Cc(r,e,t,n){const i=e>=t*1.5;return`${Math.round(r/t)} ${n}${i?"s":""}`}function zL(r){return typeof r=="object"&&r!==null&&"message"in r}function HL(r){t.debug=t,t.default=t,t.coerce=c,t.disable=s,t.enable=i,t.enabled=o,t.humanize=PA,t.destroy=l,Object.keys(r).forEach(u=>{t[u]=r[u]}),t.names=[],t.skips=[],t.formatters={};function e(u){let d=0;for(let f=0;f<u.length;f++)d=(d<<5)-d+u.charCodeAt(f),d|=0;return t.colors[Math.abs(d)%t.colors.length]}t.selectColor=e;function t(u){let d,f=null,m,g;function y(...w){if(!y.enabled)return;const x=y,T=Number(new Date),v=T-(d||T);x.diff=v,x.prev=d,x.curr=T,d=T,w[0]=t.coerce(w[0]),typeof w[0]!="string"&&w.unshift("%O");let b=0;w[0]=w[0].replace(/%([a-zA-Z%])/g,(R,C)=>{if(R==="%%")return"%";b++;const P=t.formatters[C];if(typeof P=="function"){const D=w[b];R=P.call(x,D),w.splice(b,1),b--}return R}),t.formatArgs.call(x,w),(x.log||t.log).apply(x,w)}return y.namespace=u,y.useColors=t.useColors(),y.color=t.selectColor(u),y.extend=n,y.destroy=t.destroy,Object.defineProperty(y,"enabled",{enumerable:!0,configurable:!1,get:()=>f!==null?f:(m!==t.namespaces&&(m=t.namespaces,g=t.enabled(u)),g),set:w=>{f=w}}),typeof t.init=="function"&&t.init(y),y}function n(u,d){const f=t(this.namespace+(typeof d>"u"?":":d)+u);return f.log=this.log,f}function i(u){t.save(u),t.namespaces=u,t.names=[],t.skips=[];let d;const f=(typeof u=="string"?u:"").split(/[\s,]+/),m=f.length;for(d=0;d<m;d++)f[d]&&(u=f[d].replace(/\*/g,".*?"),u[0]==="-"?t.skips.push(new RegExp("^"+u.substr(1)+"$")):t.names.push(new RegExp("^"+u+"$")))}function s(){const u=[...t.names.map(a),...t.skips.map(a).map(d=>"-"+d)].join(",");return t.enable(""),u}function o(u){if(u[u.length-1]==="*")return!0;let d,f;for(d=0,f=t.skips.length;d<f;d++)if(t.skips[d].test(u))return!1;for(d=0,f=t.names.length;d<f;d++)if(t.names[d].test(u))return!0;return!1}function a(u){return u.toString().substring(2,u.toString().length-2).replace(/\.\*\?$/,"*")}function c(u){return u instanceof Error?u.stack??u.message:u}function l(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.setupFormatters(t.formatters),t.enable(t.load()),t}var WL={};const hu=JL(),KL=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function GL(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/)!=null?!1:typeof document<"u"&&document.documentElement?.style?.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/)!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/)}function YL(r){if(r[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+r[0]+(this.useColors?"%c ":" ")+"+"+PA(this.diff),!this.useColors)return;const e="color: "+this.color;r.splice(1,0,e,"color: inherit");let t=0,n=0;r[0].replace(/%[a-zA-Z%]/g,i=>{i!=="%%"&&(t++,i==="%c"&&(n=t))}),r.splice(n,0,e)}const QL=console.debug??console.log??(()=>{});function XL(r){try{r?hu?.setItem("debug",r):hu?.removeItem("debug")}catch{}}function ZL(){let r;try{r=hu?.getItem("debug")}catch{}return!r&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(r=WL.DEBUG),r}function JL(){try{return localStorage}catch{}}function eM(r){r.j=function(e){try{return JSON.stringify(e)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}}const Qt=HL({formatArgs:YL,save:XL,load:ZL,useColors:GL,setupFormatters:eM,colors:KL,storage:hu,log:QL});Qt.formatters.b=r=>r==null?"undefined":Je.baseEncode(r);Qt.formatters.t=r=>r==null?"undefined":Dn.baseEncode(r);Qt.formatters.m=r=>r==null?"undefined":Pv.baseEncode(r);Qt.formatters.p=r=>r==null?"undefined":r.toString();Qt.formatters.c=r=>r==null?"undefined":r.toString();Qt.formatters.k=r=>r==null?"undefined":r.toString();Qt.formatters.a=r=>r==null?"undefined":r.toString();Qt.formatters.e=r=>r==null?"undefined":y0(r.stack)??y0(r.message)??r.toString();function tM(r){const e=()=>{};return e.enabled=!1,e.color="",e.diff=0,e.log=()=>{},e.namespace=r,e.destroy=()=>!0,e.extend=()=>e,e}function RA(){return{forComponent(r){return rM(r)}}}function rM(r){let e=tM(`${r}:trace`);return Qt.enabled(`${r}:trace`)&&Qt.names.map(t=>t.toString()).find(t=>t.includes(":trace"))!=null&&(e=Qt(`${r}:trace`)),Object.assign(Qt(r),{error:Qt(`${r}:error`),trace:e})}function y0(r){if(r!=null&&(r=r.trim(),r.length!==0))return r}function nM(r){return r[Symbol.asyncIterator]!=null}function Wp(r){if(nM(r))return(async()=>{const t=[];for await(const n of r)t.push(n);return t})();const e=[];for(const t of r)e.push(t);return e}let OA=class extends Error{static name="AbortError";name="AbortError";constructor(e="The operation was aborted",...t){super(e,...t)}};const Vn={},Hi=r=>{r.addEventListener("message",e=>{Hi.dispatchEvent("message",r,e)}),r.port!=null&&r.port.addEventListener("message",e=>{Hi.dispatchEvent("message",r,e)})};Hi.addEventListener=(r,e)=>{Vn[r]==null&&(Vn[r]=[]),Vn[r].push(e)};Hi.removeEventListener=(r,e)=>{Vn[r]!=null&&(Vn[r]=Vn[r].filter(t=>t===e))};Hi.dispatchEvent=function(r,e,t){Vn[r]!=null&&Vn[r].forEach(n=>n(e,t))};const w0="lock:worker:request-read",b0="lock:worker:abort-read-request",v0="lock:worker:release-read",S0="lock:master:grant-read",E0="lock:worker:request-write",A0="lock:worker:abort-write-request",x0="lock:worker:release-write",_0="lock:master:grant-write",iM=(r=10)=>Math.random().toString().substring(2,r+2),C0=(r,e,t,n,i,s,o)=>(a,c)=>{if(c.data==null)return;const l={type:c.data.type,name:c.data.name,identifier:c.data.identifier};c.data.type===n&&r.dispatchEvent(new MessageEvent(e,{data:{name:l.name,handler:async()=>{a.postMessage({type:o,name:l.name,identifier:l.identifier}),await new Promise(u=>{const d=f=>{if(f?.data==null)return;const m={type:f.data.type,name:f.data.name,identifier:f.data.identifier};m.type===s&&m.identifier===l.identifier&&(a.removeEventListener("message",d),u())};a.addEventListener("message",d)})}}})),l.type===i&&(a.postMessage({type:i,name:l.name,identifier:l.identifier}),r.dispatchEvent(new MessageEvent(t,{data:{name:l.name}})))},I0=(r,e,t,n,i)=>async s=>{s?.signal?.throwIfAborted();const o=iM();return globalThis.postMessage({type:e,identifier:o,name:r}),new Promise((a,c)=>{const l=()=>{process.send?.({type:t,identifier:o,name:r}),c(new OA)};s?.signal?.addEventListener("abort",l,{once:!0});const u=d=>{if(d?.data==null)return;const f={type:d.data.type,identifier:d.data.identifier};f.type===n&&f.identifier===o&&(globalThis.removeEventListener("message",u),s?.signal?.removeEventListener("abort",l),a(()=>{globalThis.postMessage({type:i,identifier:o,name:r})}))};globalThis.addEventListener("message",u)})},sM={singleProcess:!1},oM=r=>{if(r=Object.assign({},sM,r),!!globalThis.document||r.singleProcess){const t=new EventTarget;return Hi.addEventListener("message",C0(t,"requestReadLock","abortReadLockRequest",w0,b0,v0,S0)),Hi.addEventListener("message",C0(t,"requestWriteLock","abortWriteLockRequest",E0,A0,x0,_0)),t}return{isWorker:!0,readLock:t=>I0(t,w0,b0,S0,v0),writeLock:t=>I0(t,E0,A0,_0,x0)}},ri={};let rr;async function xh(r,e){let t,n;const i=new Promise((o,a)=>{t=o,n=a}),s=()=>{n(new OA)};return e?.signal?.addEventListener("abort",s,{once:!0}),r.add(async()=>{await new Promise(o=>{t(()=>{e?.signal?.removeEventListener("abort",s),o()})})},{signal:e?.signal}).catch(o=>{n(o)}),i}const aM=(r,e)=>{if(rr.isWorker===!0)return{readLock:rr.readLock(r,e),writeLock:rr.writeLock(r,e)};const t=new zp({concurrency:1});let n;return{async readLock(i){if(n!=null)return xh(n,i);n=new zp({concurrency:e.concurrency,autoStart:!1});const s=n,o=xh(n,i);return t.add(async()=>{s.start(),await s.onIdle().then(()=>{n===s&&(n=null)})}),o},async writeLock(i){return n=null,xh(t,i)}}},cM={name:"lock",concurrency:1/0,singleProcess:!1};function lM(r){const e=Object.assign({},cM,r);return rr==null&&(rr=oM(e),rr.isWorker!==!0&&(rr.addEventListener("requestReadLock",t=>{const n=t.data.name;if(ri[n]==null)return;const i=new AbortController,s=o=>{o.data.name===n&&i.abort()};rr.addEventListener("abortReadLockRequest",s),ri[n].readLock({signal:i.signal}).then(async o=>t.data.handler().finally(()=>{o()})).finally(()=>{rr.removeEventListener("abortReadLockRequest",s)})}),rr.addEventListener("requestWriteLock",async t=>{const n=t.data.name;if(ri[n]==null)return;const i=new AbortController,s=o=>{o.data.name===n&&i.abort()};rr.addEventListener("abortWriteLockRequest",s),ri[t.data.name].writeLock({signal:i.signal}).then(async o=>t.data.handler().finally(()=>{o()})).finally(()=>{rr.removeEventListener("abortWriteLockRequest",s)})}))),ri[e.name]==null&&(ri[e.name]=aM(e.name,e)),ri[e.name]}const uM=36e5,dM=216e5;var mi;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=De((i,s,o={})=>{o.lengthDelimited!==!1&&s.fork(),i.key!=null&&i.key!==""&&(s.uint32(10),s.string(i.key)),i.value!=null&&i.value.byteLength>0&&(s.uint32(18),s.bytes(i.value)),o.lengthDelimited!==!1&&s.ldelim()},(i,s,o={})=>{const a={key:"",value:Pe(0)},c=s==null?i.len:i.pos+s;for(;i.pos<c;){const l=i.uint32();switch(l>>>3){case 1:{a.key=i.string();break}case 2:{a.value=i.bytes();break}default:{i.skipType(l&7);break}}}return a})),n),t.encode=i=>Ne(i,t.codec()),t.decode=(i,s)=>Be(i,t.codec(),s)})(r.Peer$metadataEntry||(r.Peer$metadataEntry={})),function(t){let n;t.codec=()=>(n==null&&(n=De((i,s,o={})=>{o.lengthDelimited!==!1&&s.fork(),i.key!=null&&i.key!==""&&(s.uint32(10),s.string(i.key)),i.value!=null&&(s.uint32(18),pu.codec().encode(i.value,s)),o.lengthDelimited!==!1&&s.ldelim()},(i,s,o={})=>{const a={key:""},c=s==null?i.len:i.pos+s;for(;i.pos<c;){const l=i.uint32();switch(l>>>3){case 1:{a.key=i.string();break}case 2:{a.value=pu.codec().decode(i,i.uint32(),{limits:o.limits?.value});break}default:{i.skipType(l&7);break}}}return a})),n),t.encode=i=>Ne(i,t.codec()),t.decode=(i,s)=>Be(i,t.codec(),s)}(r.Peer$tagsEntry||(r.Peer$tagsEntry={}));let e;r.codec=()=>(e==null&&(e=De((t,n,i={})=>{if(i.lengthDelimited!==!1&&n.fork(),t.addresses!=null)for(const s of t.addresses)n.uint32(10),fu.codec().encode(s,n);if(t.protocols!=null)for(const s of t.protocols)n.uint32(18),n.string(s);if(t.publicKey!=null&&(n.uint32(34),n.bytes(t.publicKey)),t.peerRecordEnvelope!=null&&(n.uint32(42),n.bytes(t.peerRecordEnvelope)),t.metadata!=null&&t.metadata.size!==0)for(const[s,o]of t.metadata.entries())n.uint32(50),r.Peer$metadataEntry.codec().encode({key:s,value:o},n);if(t.tags!=null&&t.tags.size!==0)for(const[s,o]of t.tags.entries())n.uint32(58),r.Peer$tagsEntry.codec().encode({key:s,value:o},n);t.updated!=null&&(n.uint32(64),n.uint64Number(t.updated)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(i.limits?.addresses!=null&&s.addresses.length===i.limits.addresses)throw new Cr('Decode error - map field "addresses" had too many elements');s.addresses.push(fu.codec().decode(t,t.uint32(),{limits:i.limits?.addresses$}));break}case 2:{if(i.limits?.protocols!=null&&s.protocols.length===i.limits.protocols)throw new Cr('Decode error - map field "protocols" had too many elements');s.protocols.push(t.string());break}case 4:{s.publicKey=t.bytes();break}case 5:{s.peerRecordEnvelope=t.bytes();break}case 6:{if(i.limits?.metadata!=null&&s.metadata.size===i.limits.metadata)throw new By('Decode error - map field "metadata" had too many elements');const c=r.Peer$metadataEntry.codec().decode(t,t.uint32());s.metadata.set(c.key,c.value);break}case 7:{if(i.limits?.tags!=null&&s.tags.size===i.limits.tags)throw new By('Decode error - map field "tags" had too many elements');const c=r.Peer$tagsEntry.codec().decode(t,t.uint32(),{limits:{value:i.limits?.tags$value}});s.tags.set(c.key,c.value);break}case 8:{s.updated=t.uint64Number();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ne(t,r.codec()),r.decode=(t,n)=>Be(t,r.codec(),n)})(mi||(mi={}));var fu;(function(r){let e;r.codec=()=>(e==null&&(e=De((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.multiaddr!=null&&t.multiaddr.byteLength>0&&(n.uint32(10),n.bytes(t.multiaddr)),t.isCertified!=null&&(n.uint32(16),n.bool(t.isCertified)),t.observed!=null&&(n.uint32(24),n.uint64Number(t.observed)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={multiaddr:Pe(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.multiaddr=t.bytes();break}case 2:{s.isCertified=t.bool();break}case 3:{s.observed=t.uint64Number();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ne(t,r.codec()),r.decode=(t,n)=>Be(t,r.codec(),n)})(fu||(fu={}));var pu;(function(r){let e;r.codec=()=>(e==null&&(e=De((t,n,i={})=>{i.lengthDelimited!==!1&&n.fork(),t.value!=null&&t.value!==0&&(n.uint32(8),n.uint32(t.value)),t.expiry!=null&&(n.uint32(16),n.uint64(t.expiry)),i.lengthDelimited!==!1&&n.ldelim()},(t,n,i={})=>{const s={value:0},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{s.value=t.uint32();break}case 2:{s.expiry=t.uint64();break}default:{t.skipType(a&7);break}}}return s})),e),r.encode=t=>Ne(t,r.codec()),r.decode=(t,n)=>Be(t,r.codec(),n)})(pu||(pu={}));function hM(r,e){if(r.publicKey!=null||e.publicKey==null)return r;let t;if(r.type==="RSA"){const i=Je.decode(`z${r}`);t=Qn(i)}const n=jn(e.publicKey,t);return Qo(n)}function Kp(r,e,t){const n=mi.decode(e);return Gp(r,n,t)}function Gp(r,e,t){const n=new Map,i=BigInt(Date.now());for(const[s,o]of e.tags.entries())o.expiry!=null&&o.expiry<i||n.set(s,o);return{...e,id:hM(r,e),addresses:e.addresses.filter(({observed:s})=>s!=null&&s>Date.now()-t).map(({multiaddr:s,isCertified:o})=>({multiaddr:he(s),isCertified:o??!1})),metadata:e.metadata,peerRecordEnvelope:e.peerRecordEnvelope??void 0,tags:n}}function fM(r,e){return pM(r.addresses,e.addresses)&&gM(r.protocols,e.protocols)&&mM(r.publicKey,e.publicKey)&&yM(r.peerRecordEnvelope,e.peerRecordEnvelope)&&wM(r.metadata,e.metadata)&&bM(r.tags,e.tags)}function pM(r,e){return NA(r,e,(t,n)=>!(t.isCertified!==n.isCertified||!et(t.multiaddr,n.multiaddr)))}function gM(r,e){return NA(r,e,(t,n)=>t===n)}function mM(r,e){return BA(r,e)}function yM(r,e){return BA(r,e)}function wM(r,e){return DA(r,e,(t,n)=>et(t,n))}function bM(r,e){return DA(r,e,(t,n)=>t.value===n.value&&t.expiry===n.expiry)}function BA(r,e){return r==null&&e==null?!0:r!=null&&e!=null?et(r,e):!1}function NA(r,e,t){if(r.length!==e.length)return!1;for(let n=0;n<r.length;n++)if(!t(r[n],e[n]))return!1;return!0}function DA(r,e,t){if(r.size!==e.size)return!1;for(const[n,i]of r.entries()){const s=e.get(n);if(s==null||!t(i,s))return!1}return!0}const LA="/peers/";function Ic(r){if(!pv(r)||r.type==null)throw new le("Invalid PeerId");const e=r.toCID().toString();return new bt(`${LA}${e}`)}async function vM(r,e,t,n){const i=new Map;for(const s of t){if(s==null)continue;if(s.multiaddr instanceof Uint8Array&&(s.multiaddr=he(s.multiaddr)),!Du(s.multiaddr))throw new le("Multiaddr was invalid");if(!await e(r,s.multiaddr))continue;const o=s.isCertified??!1,a=s.multiaddr.toString(),c=i.get(a);c!=null?s.isCertified=c.isCertified||o:i.set(a,{multiaddr:s.multiaddr,isCertified:o})}return[...i.values()].sort((s,o)=>s.multiaddr.toString().localeCompare(o.multiaddr.toString())).map(({isCertified:s,multiaddr:o})=>{const a=o.getPeerId();return r.equals(a)&&(o=o.decapsulate(he(`/p2p/${r}`))),{isCertified:s,multiaddr:o.bytes}})}async function _h(r,e,t,n){if(e==null)throw new le("Invalid PeerData");if(e.publicKey!=null&&r.publicKey!=null&&!e.publicKey.equals(r.publicKey))throw new le("publicKey bytes do not match peer id publicKey bytes");const i=n.existingPeer?.peer;if(i!=null&&!r.equals(i.id))throw new le("peer id did not match existing peer id");let s=i?.addresses??[],o=new Set(i?.protocols??[]),a=i?.metadata??new Map,c=i?.tags??new Map,l=i?.peerRecordEnvelope;if(t==="patch"){if((e.multiaddrs!=null||e.addresses!=null)&&(s=[],e.multiaddrs!=null&&s.push(...e.multiaddrs.map(f=>({isCertified:!1,multiaddr:f}))),e.addresses!=null&&s.push(...e.addresses)),e.protocols!=null&&(o=new Set(e.protocols)),e.metadata!=null){const f=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);a=kc(f,{validate:k0})}if(e.tags!=null){const f=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags);c=kc(f,{validate:T0,map:P0})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}if(t==="merge"){if(e.multiaddrs!=null&&s.push(...e.multiaddrs.map(f=>({isCertified:!1,multiaddr:f}))),e.addresses!=null&&s.push(...e.addresses),e.protocols!=null&&(o=new Set([...o,...e.protocols])),e.metadata!=null){const f=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);for(const[m,g]of f)g==null?a.delete(m):a.set(m,g);a=kc([...a.entries()],{validate:k0})}if(e.tags!=null){const f=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags),m=new Map(c);for(const[g,y]of f)y==null?m.delete(g):m.set(g,y);c=kc([...m.entries()],{validate:T0,map:P0})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}let u;i?.id.publicKey!=null?u=nn(i.id.publicKey):e.publicKey!=null?u=nn(e.publicKey):r.publicKey!=null&&(u=nn(r.publicKey));const d={addresses:await vM(r,n.addressFilter??(async()=>!0),s,n.existingPeer?.peerPB.addresses),protocols:[...o.values()].sort((f,m)=>f.localeCompare(m)),metadata:a,tags:c,publicKey:u,peerRecordEnvelope:l};return d.addresses.forEach(f=>{f.observed=n.existingPeer?.peerPB.addresses?.find(m=>et(m.multiaddr,m.multiaddr))?.observed??Date.now()}),r.type!=="RSA"&&delete d.publicKey,d}function kc(r,e){const t=new Map;for(const[n,i]of r)i!=null&&e.validate(n,i);for(const[n,i]of r.sort(([s],[o])=>s.localeCompare(o)))i!=null&&t.set(n,e.map?.(n,i)??i);return t}function k0(r,e){if(typeof r!="string")throw new le("Metadata key must be a string");if(!(e instanceof Uint8Array))throw new le("Metadata value must be a Uint8Array")}function T0(r,e){if(typeof r!="string")throw new le("Tag name must be a string");if(e.value!=null){if(parseInt(`${e.value}`,10)!==e.value)throw new le("Tag value must be an integer");if(e.value<0||e.value>100)throw new le("Tag value must be between 0-100")}if(e.ttl!=null){if(parseInt(`${e.ttl}`,10)!==e.ttl)throw new le("Tag ttl must be an integer");if(e.ttl<0)throw new le("Tag ttl must be between greater than 0")}}function P0(r,e){let t;return e.expiry!=null&&(t=e.expiry),e.ttl!=null&&(t=BigInt(Date.now()+Number(e.ttl))),{value:e.value??0,expiry:t}}function MA(r){const e=r.toString().split("/")[2],t=Le.parse(e,Dn);return Ca(t)}function Ch(r,e,t){const n=MA(r);return Kp(n,e,t)}function SM(r,e){return{prefix:LA,filters:(r.filters??[]).map(t=>({key:n,value:i})=>t(Ch(n,i,e))),orders:(r.orders??[]).map(t=>(n,i)=>t(Ch(n.key,n.value,e),Ch(i.key,i.value,e)))}}class EM{peerId;datastore;lock;addressFilter;log;maxAddressAge;maxPeerAge;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.lock=lM({name:"peer-store",singleProcess:!0}),this.maxAddressAge=t.maxAddressAge??uM,this.maxPeerAge=t.maxPeerAge??dM}async has(e){try{return await this.load(e),!0}catch(t){if(t.name!=="NotFoundError")throw t}return!1}async delete(e){this.peerId.equals(e)||await this.datastore.delete(Ic(e))}async load(e){const t=Ic(e),n=await this.datastore.get(t),i=mi.decode(n);if(this.#t(e,i))throw await this.datastore.delete(t),new di;return Gp(e,i,this.peerId.equals(e)?1/0:this.maxAddressAge)}async save(e,t){const n=await this.#e(e),i=await _h(e,t,"patch",{addressFilter:this.addressFilter});return this.#r(e,i,n)}async patch(e,t){const n=await this.#e(e),i=await _h(e,t,"patch",{addressFilter:this.addressFilter,existingPeer:n});return this.#r(e,i,n)}async merge(e,t){const n=await this.#e(e),i=await _h(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:n});return this.#r(e,i,n)}async*all(e){for await(const{key:t,value:n}of this.datastore.query(SM(e??{},this.maxAddressAge))){const i=MA(t);if(i.equals(this.peerId))continue;const s=mi.decode(n);if(this.#t(i,s)){await this.datastore.delete(t);continue}yield Gp(i,s,this.peerId.equals(i)?1/0:this.maxAddressAge)}}async#e(e){try{const t=Ic(e),n=await this.datastore.get(t),i=mi.decode(n);if(this.#t(e,i))throw await this.datastore.delete(t),new di;return{peerPB:i,peer:Kp(e,n,this.maxAddressAge)}}catch(t){t.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",t)}}async#r(e,t,n){t.updated=Date.now();const i=mi.encode(t);return await this.datastore.put(Ic(e),i),{peer:Kp(e,i,this.maxAddressAge),previous:n?.peer,updated:n==null||!fM(t,n.peerPB)}}#t(e,t){if(t.updated==null)return!0;if(this.peerId.equals(e))return!1;const n=t.updated<Date.now()-this.maxPeerAge,i=Date.now()-this.maxAddressAge,s=t.addresses.filter(o=>o.observed!=null&&o.observed>i);return n&&s.length===0}}class AM{store;events;peerId;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new EM(e,t)}[Symbol.toStringTag]="@libp2p/peer-store";async forEach(e,t){this.log.trace("forEach await read lock");const n=await this.store.lock.readLock();this.log.trace("forEach got read lock");try{for await(const i of this.store.all(t))e(i)}finally{this.log.trace("forEach release read lock"),n()}}async all(e){this.log.trace("all await read lock");const t=await this.store.lock.readLock();this.log.trace("all got read lock");try{return await Wp(this.store.all(e))}finally{this.log.trace("all release read lock"),t()}}async delete(e){this.log.trace("delete await write lock");const t=await this.store.lock.writeLock();this.log.trace("delete got write lock");try{await this.store.delete(e)}finally{this.log.trace("delete release write lock"),t()}}async has(e){this.log.trace("has await read lock");const t=await this.store.lock.readLock();this.log.trace("has got read lock");try{return await this.store.has(e)}finally{this.log.trace("has release read lock"),t()}}async get(e){this.log.trace("get await read lock");const t=await this.store.lock.readLock();this.log.trace("get got read lock");try{return await this.store.load(e)}finally{this.log.trace("get release read lock"),t()}}async getInfo(e){const t=await this.get(e);return{id:t.id,multiaddrs:t.addresses.map(({multiaddr:n})=>n)}}async save(e,t){this.log.trace("save await write lock");const n=await this.store.lock.writeLock();this.log.trace("save got write lock");try{const i=await this.store.save(e,t);return this.#e(e,i),i.peer}finally{this.log.trace("save release write lock"),n()}}async patch(e,t){this.log.trace("patch await write lock");const n=await this.store.lock.writeLock();this.log.trace("patch got write lock");try{const i=await this.store.patch(e,t);return this.#e(e,i),i.peer}finally{this.log.trace("patch release write lock"),n()}}async merge(e,t){this.log.trace("merge await write lock");const n=await this.store.lock.writeLock();this.log.trace("merge got write lock");try{const i=await this.store.merge(e,t);return this.#e(e,i),i.peer}finally{this.log.trace("merge release write lock"),n()}}async consumePeerRecord(e,t){const n=await Ur.openAndCertify(e,Xt.DOMAIN),i=Ca(n.publicKey.toCID());if(t?.equals(i)===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",t,i),!1;const s=Xt.createFromProtobuf(n.payload);let o;try{o=await this.get(i)}catch(a){if(a.name!=="NotFoundError")throw a}if(o?.peerRecordEnvelope!=null){const a=await Ur.createFromProtobuf(o.peerRecordEnvelope),c=Xt.createFromProtobuf(a.payload);if(c.seqNumber>=s.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",c.seqNumber,s.seqNumber),!1}return await this.patch(s.peerId,{peerRecordEnvelope:e,addresses:s.multiaddrs.map(a=>({isCertified:!0,multiaddr:a}))}),!0}#e(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))}}function xM(r,e={}){return new AM(r,e)}class gu extends Error{static name="NotFoundError";static code="ERR_NOT_FOUND";name=gu.name;code=gu.code;constructor(e="Not Found"){super(e)}}function _M(r){return r[Symbol.asyncIterator]!=null}function os(r,e){let t=0;if(_M(r))return async function*(){for await(const c of r)await e(c,t++)&&(yield c)}();const n=HS(r),{value:i,done:s}=n.next();if(s===!0)return function*(){}();const o=e(i,t++);if(typeof o.then=="function")return async function*(){await o&&(yield i);for await(const c of n)await e(c,t++)&&(yield c)}();const a=e;return function*(){o===!0&&(yield i);for(const c of n)a(c,t++)&&(yield c)}()}function CM(r){return r[Symbol.asyncIterator]!=null}function R0(r,e){return CM(r)?async function*(){yield*(await Wp(r)).sort(e)}():function*(){yield*Wp(r).sort(e)}()}function IM(r){return r[Symbol.asyncIterator]!=null}function O0(r,e){return IM(r)?async function*(){let t=0;if(!(e<1)){for await(const n of r)if(yield n,t++,t===e)return}}():function*(){let t=0;if(!(e<1)){for(const n of r)if(yield n,t++,t===e)return}}()}class kM{put(e,t,n){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:n,value:i}of e)await this.put(n,i,t),yield n}async*getMany(e,t={}){for await(const n of e)yield{key:n,value:await this.get(n,t)}}async*deleteMany(e,t={}){for await(const n of e)await this.delete(n,t),yield n}batch(){let e=[],t=[];return{put(n,i){e.push({key:n,value:i})},delete(n){t.push(n)},commit:async n=>{await Af(this.putMany(e,n)),e=[],await Af(this.deleteMany(t,n)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let n=this._all(e,t);if(e.prefix!=null){const i=e.prefix;n=os(n,s=>s.key.toString().startsWith(i))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((i,s)=>os(i,s),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((i,s)=>R0(i,s),n)),e.offset!=null){let i=0;const s=e.offset;n=os(n,()=>i++>=s)}return e.limit!=null&&(n=O0(n,e.limit)),n}queryKeys(e,t){let n=this._allKeys(e,t);if(e.prefix!=null){const i=e.prefix;n=os(n,s=>s.toString().startsWith(i))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((i,s)=>os(i,s),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((i,s)=>R0(i,s),n)),e.offset!=null){const i=e.offset;let s=0;n=os(n,()=>s++>=i)}return e.limit!=null&&(n=O0(n,e.limit)),n}}class TM extends kM{data;constructor(){super(),this.data=new Map}put(e,t,n){return n?.signal?.throwIfAborted(),this.data.set(e.toString(),t),e}get(e,t){t?.signal?.throwIfAborted();const n=this.data.get(e.toString());if(n==null)throw new gu;return n}has(e,t){return t?.signal?.throwIfAborted(),this.data.has(e.toString())}delete(e,t){t?.signal?.throwIfAborted(),this.data.delete(e.toString())}*_all(e,t){t?.signal?.throwIfAborted();for(const[n,i]of this.data.entries())yield{key:new bt(n),value:i},t?.signal?.throwIfAborted()}*_allKeys(e,t){t?.signal?.throwIfAborted();for(const n of this.data.keys())yield new bt(n),t?.signal?.throwIfAborted()}}const B0=864e13,PM=448,Ih=449,RM=53,OM=54,BM=55,NM=56;class DM{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=new Map}has(e){const t=this.findHost(e);for(const n of this.mappings.values())if(n.domain===t)return!0;return!1}add(e,t){t.forEach(n=>{this.log("add DNS mapping %s to %s",n,e);const i=Ba(n)===!0;this.mappings.set(n,{domain:e,verified:i,expires:i?B0-Date.now():0,lastVerified:i?B0-Date.now():void 0})})}remove(e){const t=this.findHost(e);let n=!1;for(const[i,s]of this.mappings.entries())s.domain===t&&(this.log("removing %s to %s DNS mapping %e",i,s.domain,new Error("where")),this.mappings.delete(i),n=n||s.verified);return n}getAll(e){const t=[];for(let n=0;n<e.length;n++){const s=e[n].multiaddr.stringTuples(),o=s[0][1];if(o!=null)for(const[a,c]of this.mappings.entries()){if(o!==a)continue;this.maybeAddSNITuple(s,c.domain)&&(e.splice(n,1),n--,t.push({multiaddr:he(`/${s.map(u=>[xt(u[0]).name,u[1]].join("/")).join("/")}`),verified:c.verified,type:"dns-mapping",expires:c.expires,lastVerified:c.lastVerified}))}}return t}maybeAddSNITuple(e,t){for(let n=0;n<e.length;n++)if(e[n][0]===PM&&e[n+1]?.[0]!==Ih)return e.splice(n+1,0,[Ih,t]),!0;return!1}confirm(e,t){const n=this.findHost(e);let i=!1;for(const[s,o]of this.mappings.entries())o.domain===n&&(this.log("marking %s to %s DNS mapping as verified",s,o.domain),i=o.verified,o.verified=!0,o.expires=Date.now()+t,o.lastVerified=Date.now());return i}unconfirm(e,t){const n=this.findHost(e);let i=!1;for(const[s,o]of this.mappings.entries())o.domain===n&&(this.log("removing verification of %s to %s DNS mapping",s,o.domain),i=i||o.verified,o.verified=!1,o.expires=Date.now()+t);return i}findHost(e){for(const t of e.stringTuples())if(t[0]===Ih||t[0]===RM||t[0]===OM||t[0]===BM||t[0]===NM)return t[1]}}const kh=4,Th=41,Ph=6,LM=273;class MM{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=new Map}has(e){const t=e.stringTuples();for(const n of this.mappings.values())for(const i of n)if(i.externalIp===t[0][1])return!0;return!1}add(e,t,n,i=t,s="tcp"){const o=`${e}-${t}-${s}`,a=this.mappings.get(o)??[],c={internalIp:e,internalPort:t,externalIp:n,externalPort:i,externalFamily:Pi(n)?4:6,protocol:s,verified:!1,expires:0};a.push(c),this.mappings.set(o,a)}remove(e){const t=e.stringTuples(),n=t[0][1]??"",i=t[1][0]===Ph?"tcp":"udp",s=parseInt(t[1][1]??"0");let o=!1;for(const[a,c]of this.mappings.entries()){for(let l=0;l<c.length;l++){const u=c[l];u.externalIp===n&&u.externalPort===s&&u.protocol===i&&(this.log("removing %s:%s to %s:%s %s IP mapping",u.externalIp,u.externalPort,n,s,i),o=o||u.verified,c.splice(l,1),l--)}c.length===0&&this.mappings.delete(a)}return o}getAll(e){const t=[];for(const{multiaddr:n}of e){const i=n.stringTuples();let s;if((i[0][0]===kh||i[0][0]===Th)&&i[1][0]===Ph?s=`${i[0][1]}-${i[1][1]}-tcp`:(i[0][0]===kh||i[0][0]===Th)&&i[1][0]===LM&&(s=`${i[0][1]}-${i[1][1]}-udp`),s==null)continue;const o=this.mappings.get(s);if(o!=null)for(const a of o)i[0][0]=a.externalFamily===4?kh:Th,i[0][1]=a.externalIp,i[1][1]=`${a.externalPort}`,t.push({multiaddr:he(`/${i.map(c=>[xt(c[0]).name,c[1]].join("/")).join("/")}`),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return t}confirm(e,t){const i=e.stringTuples()[0][1];let s=!1;for(const o of this.mappings.values())for(const a of o)a.externalIp===i&&(this.log("marking %s to %s IP mapping as verified",a.internalIp,a.externalIp),s=a.verified,a.verified=!0,a.expires=Date.now()+t,a.lastVerified=Date.now());return s}unconfirm(e,t){const n=e.stringTuples(),i=n[0][1]??"",s=n[1][0]===Ph?"tcp":"udp",o=parseInt(n[1][1]??"0");let a=!1;for(const c of this.mappings.values())for(let l=0;l<c.length;l++){const u=c[l];u.externalIp===i&&u.externalPort===o&&u.protocol===s&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",u.externalIp,u.externalPort,i,o,s),a=a||u.verified,u.verified=!1,u.expires=Date.now()+t)}return a}}function UM(r){try{for(const{code:e,value:t}of r.getComponents())if(e!==Ta&&t!=null){if(e===Ts)return t.startsWith("169.254.");if(e===Un)return t.toLowerCase().startsWith("fe80")}}catch{}return!1}const FM={maxObservedAddresses:10};class $M{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=new Map,this.maxObservedAddresses=t.maxObservedAddresses??FM.maxObservedAddresses}has(e){return this.addresses.has(e.toString())}removePrefixed(e){for(const t of this.addresses.keys())t.toString().startsWith(e)&&this.addresses.delete(t)}add(e){this.addresses.size!==this.maxObservedAddresses&&(Ri(e)||UM(e)||(this.log("adding observed address %a",e),this.addresses.set(e.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([e,t])=>({multiaddr:he(e),verified:t.verified,type:"observed",expires:t.expires,lastVerified:t.lastVerified}))}remove(e){const t=this.addresses.get(e.toString())?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(e.toString()),t}confirm(e,t){const n=e.toString(),i=this.addresses.get(n)??{verified:!1,expires:Date.now()+t,lastVerified:Date.now()},s=i.verified;return i.verified=!0,i.expires=Date.now()+t,i.lastVerified=Date.now(),this.log("marking observed address %a as verified",n),this.addresses.set(n,i),s}}const VM=[Ts,Un,Ng,Dg,Nu,Lg];function N0(r){try{for(const{code:e}of r.getComponents())if(e!==Ta)return VM.includes(e)}catch{}return!1}const qM={maxObservedAddresses:10};class jM{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=new Map,this.maxObservedAddresses=t.maxObservedAddresses??qM.maxObservedAddresses}get(e,t){if(Ri(e))return{multiaddr:e,verified:!0,type:"transport",expires:Date.now()+t,lastVerified:Date.now()};const n=this.toKey(e);let i=this.addresses.get(n);return i==null&&(i={verified:!N0(e),expires:0},this.addresses.set(n,i)),{multiaddr:e,verified:i.verified,type:"transport",expires:i.expires,lastVerified:i.lastVerified}}has(e){const t=this.toKey(e);return this.addresses.has(t)}remove(e){const t=this.toKey(e),n=this.addresses.get(t)?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(t),n}confirm(e,t){const n=this.toKey(e),i=this.addresses.get(n)??{verified:!1,expires:0,lastVerified:0},s=i.verified;return i.verified=!0,i.expires=Date.now()+t,i.lastVerified=Date.now(),this.addresses.set(n,i),s}unconfirm(e,t){const n=this.toKey(e),i=this.addresses.get(n)??{verified:!1,expires:0},s=i.verified;return i.verified=!1,i.expires=Date.now()+t,this.addresses.set(n,i),s}toKey(e){if(N0(e)){const t=e.toOptions();return`${t.host}-${t.port}-${t.transport}`}return e.toString()}}const D0=6e4,L0={addressVerificationTTL:D0*10,addressVerificationRetry:D0*5},zM=r=>r;function Rh(r,e){const t=r.getPeerId();return t!=null&&Ir(t).equals(e)&&(r=r.decapsulate(he(`/p2p/${e.toString()}`))),r}class HM{log;components;listen;announce;appendAnnounce;announceFilter;observed;dnsMappings;ipMappings;transportAddresses;observedAddressFilter;addressVerificationTTL;addressVerificationRetry;constructor(e,t={}){const{listen:n=[],announce:i=[],appendAnnounce:s=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=n.map(o=>o.toString()),this.announce=new Set(i.map(o=>o.toString())),this.appendAnnounce=new Set(s.map(o=>o.toString())),this.observed=new $M(e,t),this.dnsMappings=new DM(e,t),this.ipMappings=new MM(e,t),this.transportAddresses=new jM(e,t),this.announceFilter=t.announceFilter??zM,this.observedAddressFilter=Bs(1024),this.addressVerificationTTL=t.addressVerificationTTL??L0.addressVerificationTTL,this.addressVerificationRetry=t.addressVerificationRetry??L0.addressVerificationRetry,this._updatePeerStoreAddresses=Ef(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),e.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}[Symbol.toStringTag]="@libp2p/address-manager";_updatePeerStoreAddresses(){const e=this.getAddresses().map(t=>t.getPeerId()===this.components.peerId.toString()?t.decapsulate(`/p2p/${this.components.peerId.toString()}`):t);this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch(t=>{this.log.error("error updating addresses",t)})}getListenAddrs(){return Array.from(this.listen).map(e=>he(e))}getAnnounceAddrs(){return Array.from(this.announce).map(e=>he(e))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(e=>he(e))}getObservedAddrs(){return this.observed.getAll().map(e=>e.multiaddr)}addObservedAddr(e){const t=e.stringTuples(),n=`${t[0][1]}:${t[1][1]}`;this.observedAddressFilter.has(n)||(this.observedAddressFilter.add(n),e=Rh(e,this.components.peerId),!this.ipMappings.has(e)&&(this.dnsMappings.has(e)||this.observed.add(e)))}confirmObservedAddr(e,t){e=Rh(e,this.components.peerId);let n=!0;(t?.type==="transport"||this.transportAddresses.has(e))&&!this.transportAddresses.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="dns-mapping"||this.dnsMappings.has(e))&&!this.dnsMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="ip-mapping"||this.ipMappings.has(e))&&!this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="observed"||this.observed.has(e))&&(this.maybeUpgradeToIPMapping(e)?(this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL),n=!1):!this.observed.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1)),n||this._updatePeerStoreAddresses()}removeObservedAddr(e,t){e=Rh(e,this.components.peerId),this.observed.has(e)&&this.observed.remove(e),this.transportAddresses.has(e)&&this.transportAddresses.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.dnsMappings.has(e)&&this.dnsMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.ipMappings.has(e)&&this.ipMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry)}getAddresses(){const e=new Set,t=this.getAddressesWithMetadata().filter(n=>{if(!n.verified)return!1;const i=n.multiaddr.toString();return e.has(i)?!1:(e.add(i),!0)}).map(n=>n.multiaddr);return this.announceFilter(t.map(n=>{const i=he(n);return i.protos().pop()?.path===!0||i.getPeerId()===this.components.peerId.toString()?i:i.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const e=this.getAnnounceAddrs();if(e.length>0)return this.components.transportManager.getListeners().forEach(i=>{i.updateAnnounceAddrs(e)}),e.map(i=>({multiaddr:i,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let t=[];t=t.concat(this.components.transportManager.getAddrs().map(i=>this.transportAddresses.get(i,this.addressVerificationTTL)));const n=this.getAppendAnnounceAddrs();return n.length>0&&(this.components.transportManager.getListeners().forEach(i=>{i.updateAnnounceAddrs(n)}),t=t.concat(n.map(i=>({multiaddr:i,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),t=t.concat(this.observed.getAll()),t=t.concat(this.ipMappings.getAll(t)),t=t.concat(this.dnsMappings.getAll(t)),t}addDNSMapping(e,t){this.dnsMappings.add(e,t)}removeDNSMapping(e){this.dnsMappings.remove(he(`/dns/${e}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(e,t,n,i=t,s="tcp"){this.ipMappings.add(e,t,n,i,s),this.observed.removePrefixed(`/ip${Pi(n)?4:6}/${n}/${s}/${i}`)}removePublicAddressMapping(e,t,n,i=t,s="tcp"){this.ipMappings.remove(he(`/ip${Pi(n)?4:6}/${n}/${s}/${i}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(e){if(this.ipMappings.has(e))return!1;const t=e.toOptions();if(t.family===6||t.host==="127.0.0.1"||Ba(t.host)===!0)return!1;const n=this.components.transportManager.getListeners(),i=[s=>ra.exactMatch(s)||kl.exactMatch(s),s=>Il.exactMatch(s),s=>CR.exactMatch(s)];for(const s of i){if(!s(e))continue;const o=n.filter(l=>l.getAddrs().filter(u=>u.toOptions().family===4&&s(u)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(l=>l.toOptions().host!=="127.0.0.1").pop();if(a==null)continue;const c=a.toOptions();return this.observed.remove(e),this.ipMappings.add(c.host,c.port,t.host,t.port,t.transport),!0}return!1}}var M0;(function(r){r.NOT_STARTED_YET="The libp2p node is not started yet",r.NOT_FOUND="Not found"})(M0||(M0={}));class WM extends Error{constructor(e="Missing service"){super(e),this.name="MissingServiceError"}}class KM extends Error{constructor(e="Unmet service dependencies"){super(e),this.name="UnmetServiceDependenciesError"}}class Oh extends Error{constructor(e="No content routers available"){super(e),this.name="NoContentRoutersError"}}class U0 extends Error{constructor(e="No peer routers available"){super(e),this.name="NoPeerRoutersError"}}class GM extends Error{constructor(e="Should not try to find self"){super(e),this.name="QueriedForSelfError"}}class YM extends Error{constructor(e="Unhandled protocol error"){super(e),this.name="UnhandledProtocolError"}}class QM extends Error{constructor(e="Duplicate protocol handler error"){super(e),this.name="DuplicateProtocolHandlerError"}}class F0 extends Error{constructor(e="Dial denied error"){super(e),this.name="DialDeniedError"}}class XM extends Error{constructor(e="No transport was configured to listen on this address"){super(e),this.name="UnsupportedListenAddressError"}}class ZM extends Error{constructor(e="Configured listen addresses could not be listened on"){super(e),this.name="UnsupportedListenAddressesError"}}class JM extends Error{constructor(e="No valid addresses"){super(e),this.name="NoValidAddressesError"}}class e3 extends Error{constructor(e="Connection intercepted"){super(e),this.name="ConnectionInterceptedError"}}class t3 extends Error{constructor(e="Connection denied"){super(e),this.name="ConnectionDeniedError"}}class Tc extends Error{constructor(e="Stream is not multiplexed"){super(e),this.name="MuxerUnavailableError"}}class Pc extends Error{constructor(e="Encryption failed"){super(e),this.name="EncryptionFailedError"}}class r3 extends Error{constructor(e="Transport unavailable"){super(e),this.name="TransportUnavailableError"}}class n3{components={};_started=!1;constructor(e={}){this.components={};for(const[t,n]of Object.entries(e))this.components[t]=n;this.components.logger==null&&(this.components.logger=RA())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter(t=>ug(t)).map(async t=>{await t[e]?.()}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const i3=["metrics","connectionProtector","dns"],s3=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function o3(r={}){const e=new n3(r);return new Proxy(e,{get(n,i,s){if(typeof i=="string"&&!s3.includes(i)){const o=e.components[i];if(o==null&&!i3.includes(i))throw new WM(`${i} not set`);return o}return Reflect.get(n,i,s)},set(n,i,s){return typeof i=="string"?e.components[i]=s:Reflect.set(n,i,s),!0}})}function a3(r){const e={};for(const t of Object.values(r.components))for(const n of c3(t))e[n]=!0;for(const t of Object.values(r.components))for(const n of l3(t))if(e[n]!==!0)throw new KM(`Service "${u3(t)}" required capability "${n}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function c3(r){return Array.isArray(r?.[Zt])?r[Zt]:[]}function l3(r){return Array.isArray(r?.[As])?r[As]:[]}function u3(r){return r?.[Symbol.toStringTag]??r?.toString()??"unknown"}const d3=4,h3=41;function f3(r={}){return{denyDialPeer:async()=>!1,denyDialMultiaddr:async e=>{if(ra.matches(e))return!1;const t=e.stringTuples();return t[0][0]===d3||t[0][0]===h3?!!Ba(`${t[0][1]}`):!1},denyInboundConnection:async()=>!1,denyOutboundConnection:async()=>!1,denyInboundEncryptedConnection:async()=>!1,denyOutboundEncryptedConnection:async()=>!1,denyInboundUpgradedConnection:async()=>!1,denyOutboundUpgradedConnection:async()=>!1,filterMultiaddrForPeer:async()=>!0,...r}}const $0=()=>{const r=new Error("Delay aborted");return r.name="AbortError",r},p3=new WeakMap;function g3({clearTimeout:r,setTimeout:e}={}){return(t,{value:n,signal:i}={})=>{if(i?.aborted)return Promise.reject($0());let s,o,a;const c=r??clearTimeout,l=()=>{c(s),a($0())},u=()=>{i&&i.removeEventListener("abort",l)},d=new Promise((f,m)=>{o=()=>{u(),f(n)},a=m,s=(e??setTimeout)(o,t)});return i&&i.addEventListener("abort",l,{once:!0}),p3.set(d,()=>{c(s),s=null,o()}),d}}const UA=g3();class m3{memoryStorage;points;duration;blockDuration;execEvenly;execEvenlyMinDelayMs;keyPrefix;constructor(e={}){this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.execEvenly=e.execEvenly??!1,this.execEvenlyMinDelayMs=e.execEvenlyMinDelayMs??this.duration*1e3/this.points,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new y3}async consume(e,t=1,n={}){const i=this.getKey(e),s=this._getKeySecDuration(n);let o=this.memoryStorage.incrby(i,t,s);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+t&&(o=this.memoryStorage.set(i,o.consumedPoints,this.blockDuration)),new KR("Rate limit exceeded",o);if(this.execEvenly&&o.msBeforeNext>0&&!o.isFirstInDuration){let a=Math.ceil(o.msBeforeNext/(o.remainingPoints+2));a<this.execEvenlyMinDelayMs&&(a=o.consumedPoints*this.execEvenlyMinDelayMs),await UA(a)}return o}penalty(e,t=1,n={}){const i=this.getKey(e),s=this._getKeySecDuration(n),o=this.memoryStorage.incrby(i,t,s);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(e,t=1,n={}){const i=this.getKey(e),s=this._getKeySecDuration(n),o=this.memoryStorage.incrby(i,-t,s);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(e,t){const n=t*1e3,i=this.points+1;return this.memoryStorage.set(this.getKey(e),i,t),{remainingPoints:0,msBeforeNext:n===0?-1:n,consumedPoints:i,isFirstInDuration:!1}}set(e,t,n=0){const i=(n>=0?n:this.duration)*1e3;return this.memoryStorage.set(this.getKey(e),t,n),{remainingPoints:0,msBeforeNext:i===0?-1:i,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return t!=null&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return e?.customDuration!=null&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class y3{storage;constructor(){this.storage=new Map}incrby(e,t,n){const i=this.storage.get(e);if(i!=null){const s=i.expiresAt!=null?i.expiresAt.getTime()-new Date().getTime():-1;return i.expiresAt==null||s>0?(i.value+=t,{remainingPoints:0,msBeforeNext:s,consumedPoints:i.value,isFirstInDuration:!1}):this.set(e,t,n)}return this.set(e,t,n)}set(e,t,n){const i=n*1e3,s=this.storage.get(e);s!=null&&clearTimeout(s.timeoutId);const o={value:t,expiresAt:i>0?new Date(Date.now()+i):void 0};return this.storage.set(e,o),i>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(e)},i),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:i===0?-1:i,consumedPoints:o.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(t!=null)return{remainingPoints:0,msBeforeNext:t.expiresAt!=null?t.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}delete(e){const t=this.storage.get(e);return t!=null?(t.timeoutId!=null&&clearTimeout(t.timeoutId),this.storage.delete(e),!0):!1}}function FA(r){if(pv(r))return{peerId:r,multiaddrs:[]};let e=Array.isArray(r)?r:[r],t;if(e.length>0){const n=e[0].getPeerId();t=n==null?void 0:Ir(n),e.forEach(i=>{if(!Du(i))throw new ag("Invalid multiaddr");const s=i.getPeerId();if(s==null){if(t!=null)throw new le("Multiaddrs must all have the same peer id or have no peer id")}else{const o=Ir(s);if(t?.equals(o)!==!0)throw new le("Multiaddrs must all have the same peer id or have no peer id")}})}return e=e.filter(n=>!SR.exactMatch(n)),{peerId:t,multiaddrs:e}}const w3=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function b3(r,e){const t=r?.streams?.map(i=>i.protocol)??[],n=e?.closableProtocols??w3;if(!(t.filter(i=>i!=null&&!n.includes(i)).length>0))try{await r?.close(e)}catch(i){r?.abort(i)}}const $A=1e4,v3=1e4,V0=1e4,VA=25,S3=5,E3=10,A3=5,x3="last-dial-failure",_3="last-dial-success",qA=500,jA=100,zA=50;async function C3(r,e){let t=!1;for(const i of Mg.keys())if(t=r.protoNames().includes(i),t)break;if(!t)return[r];const n=await r.resolve(e);return e.log("resolved %s to",r,n.map(i=>i.toString())),n}function Yp(r){try{let e;if(typeof r=="string"?e=he(r):e=r,!e.protoNames().includes("ipcidr")){const n=e.protoNames().includes("ip6")?"/ipcidr/128":"/ipcidr/32";e=e.encapsulate(n)}return dR(e)}catch{throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${r}`)}}const I3={maxConnections:jA};class k3{maxConnections;connectionManager;peerStore;allow;events;log;constructor(e,t={}){this.maxConnections=t.maxConnections??I3.maxConnections,this.allow=(t.allow??[]).map(n=>Yp(n)),this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(e=>{this.log.error("error while pruning connections %e",e)})}async _maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length;if(this.log("checking max connections limit %d/%d",t,this.maxConnections),t<=this.maxConnections)return;const n=new $u;for(const a of e){const c=a.remotePeer;if(!n.has(c)){n.set(c,0);try{const l=await this.peerStore.get(c);n.set(c,[...l.tags.values()].reduce((u,d)=>u+d.value,0))}catch(l){l.name!=="NotFoundError"&&this.log.error("error loading peer tags",l)}}}const i=this.sortConnections(e,n),s=Math.max(t-this.maxConnections,0),o=[];for(const a of i)if(this.log("too many connections open - closing a connection to %p",a.remotePeer),this.allow.some(l=>l.contains(a.remoteAddr.nodeAddress().address))||o.push(a),o.length===s)break;await Promise.all(o.map(async a=>{await b3(a,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:o})}sortConnections(e,t){return e.sort((n,i)=>{const s=n.timeline.open,o=i.timeline.open;return s<o?1:s>o?-1:0}).sort((n,i)=>n.direction==="outbound"&&i.direction==="inbound"?1:n.direction==="inbound"&&i.direction==="outbound"?-1:0).sort((n,i)=>n.streams.length>i.streams.length?1:n.streams.length<i.streams.length?-1:0).sort((n,i)=>{const s=t.get(n.remotePeer)??0,o=t.get(i.remotePeer)??0;return s>o?1:s<o?-1:0})}}class T3 extends yE{constructor(e={}){super({...e,sort:(t,n)=>t.options.priority>n.options.priority?-1:t.options.priority<n.options.priority?1:0})}}function P3(r){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(r)||/^::1$/.test(r)}function q0(r){if(!EE(r))return!1;const{address:e}=r.nodeAddress();return P3(e)}function R3(r,e){const t=Il.exactMatch(r.multiaddr),n=Il.exactMatch(e.multiaddr);if(t&&!n)return-1;if(!t&&n)return 1;const i=kl.exactMatch(r.multiaddr),s=kl.exactMatch(e.multiaddr);if(i&&!s)return-1;if(!i&&s)return 1;const o=ra.exactMatch(r.multiaddr),a=ra.exactMatch(e.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=Sf.exactMatch(r.multiaddr),l=Sf.exactMatch(e.multiaddr);if(c&&!l)return-1;if(!c&&l)return 1;const u=vf.exactMatch(r.multiaddr),d=vf.exactMatch(e.multiaddr);if(u&&!d)return-1;if(!u&&d)return 1;const f=uw.exactMatch(r.multiaddr),m=uw.exactMatch(e.multiaddr);return f&&!m?-1:!f&&m?1:0}function O3(r,e){const t=q0(r.multiaddr),n=q0(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function B3(r,e){const t=Ri(r.multiaddr),n=Ri(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function N3(r,e){return r.isCertified&&!e.isCertified?-1:!r.isCertified&&e.isCertified?1:0}function D3(r,e){const t=zn.exactMatch(r.multiaddr),n=zn.exactMatch(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function L3(r){return r.sort(R3).sort(N3).sort(D3).sort(B3).sort(O3)}const Rc={maxParallelDials:zA,maxDialQueueLength:qA,maxPeerAddrsToDial:VA,dialTimeout:$A};class M3{queue;components;addressSorter;maxPeerAddrsToDial;maxDialQueueLength;dialTimeout;shutDownController;connections;log;constructor(e,t={}){this.addressSorter=t.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??Rc.maxPeerAddrsToDial,this.maxDialQueueLength=t.maxDialQueueLength??Rc.maxDialQueueLength,this.dialTimeout=t.dialTimeout??Rc.dialTimeout,this.connections=t.connections??new $u,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.shutDownController=new AbortController,this.shutDownController.signal;for(const[n,i]of Object.entries(t.resolvers??{}))Mg.set(n,i);this.queue=new T3({concurrency:t.maxParallelDials??Rc.maxParallelDials,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("error",n=>{n.detail?.name!==Ii.name&&this.log.error("error in dial queue - %e",n.detail)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){const{peerId:n,multiaddrs:i}=FA(e),s=Array.from(this.connections.values()).flat().find(a=>t.force===!0?!1:a.remotePeer.equals(n)?!0:i.find(c=>c.equals(a.remoteAddr)));if(s?.status==="open")return this.log("already connected to %a",s.remoteAddr),t.onProgress?.(new Re("dial-queue:already-connected")),s;const o=this.queue.queue.find(a=>{if(n?.equals(a.options.peerId)===!0)return!0;const c=a.options.multiaddrs;if(c==null)return!1;for(const l of i)if(c.has(l.toString()))return!0;return!1});if(o!=null){this.log("joining existing dial target for %p",n);for(const a of i)o.options.multiaddrs.add(a.toString());return t.onProgress?.(new Re("dial-queue:already-in-dial-queue")),o.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new Do("Dial queue is full");return this.log("creating dial target for %p",n,i.map(a=>a.toString())),t.onProgress?.(new Re("dial-queue:add-to-dial-queue")),this.queue.add(async a=>{a.onProgress?.(new Re("dial-queue:start-dial"));const c=qr([this.shutDownController.signal,a.signal]);try{return await this.dialPeer(a,c)}finally{c.clear()}},{peerId:n,priority:t.priority??HA,multiaddrs:new Set(i.map(a=>a.toString())),signal:t.signal??AbortSignal.timeout(this.dialTimeout),onProgress:t.onProgress})}async dialPeer(e,t){const n=e.peerId,i=e.multiaddrs,s=new Set;let o=e.multiaddrs.size===0,a=0,c=0;const l=[];for(this.log("starting dial to %p",n);o||i.size>0;){c++,o=!1;const u=[],d=new Set(e.multiaddrs);i.clear(),this.log("calculating addrs to dial %p from %s",n,[...d]);const f=await this.calculateMultiaddrs(n,d,{...e,signal:t});for(const m of f){if(s.has(m.multiaddr.toString())){this.log.trace("skipping previously failed multiaddr %a while dialing %p",m.multiaddr,n);continue}u.push(m)}this.log("%s dial to %p with %s",c===1?"starting":"continuing",n,u.map(m=>m.multiaddr.toString())),e?.onProgress?.(new Re("dial-queue:calculated-addresses",u));for(const m of u){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,e.peerId),new Do("Peer had more than maxPeerAddrsToDial");a++;try{const g=await this.components.transportManager.dial(m.multiaddr,{...e,signal:t});this.log("dial to %a succeeded",m.multiaddr);try{await this.components.peerStore.merge(g.remotePeer,{multiaddrs:[g.remoteAddr],metadata:{[_3]:oe(Date.now().toString())}})}catch(y){this.log.error("could not update last dial failure key for %p",n,y)}return g}catch(g){if(this.log.error("dial failed to %a",m.multiaddr,g),s.add(m.multiaddr.toString()),n!=null)try{await this.components.peerStore.merge(n,{metadata:{[x3]:oe(Date.now().toString())}})}catch(y){this.log.error("could not update last dial failure key for %p",n,y)}if(t.aborted)throw new lg(g.message);l.push(g)}}}throw l.length===1?l[0]:new AggregateError(l,"All multiaddr dials failed")}async calculateMultiaddrs(e,t=new Set,n={}){const i=[...t].map(d=>({multiaddr:he(d),isCertified:!1}));if(e!=null){if(this.components.peerId.equals(e))throw new Do("Tried to dial self");if(await this.components.connectionGater.denyDialPeer?.(e)===!0)throw new F0("The dial request is blocked by gater.allowDialPeer");if(i.length===0){this.log("loading multiaddrs for %p",e);try{const d=await this.components.peerStore.get(e);i.push(...d.addresses),this.log("loaded multiaddrs for %p",e,i.map(({multiaddr:f})=>f.toString()))}catch(d){if(d.name!=="NotFoundError")throw d}}if(i.length===0){this.log("looking up multiaddrs for %p in the peer routing",e);try{const d=await this.components.peerRouting.findPeer(e,n);this.log("found multiaddrs for %p in the peer routing",e,i.map(({multiaddr:f})=>f.toString())),i.push(...d.multiaddrs.map(f=>({multiaddr:f,isCertified:!1})))}catch(d){d.name==="NoPeerRoutersError"?this.log("no peer routers configured",e):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",e,d)}}}let s=(await Promise.all(i.map(async d=>{const f=await C3(d.multiaddr,{dns:this.components.dns,...n,log:this.log});return f.length===1&&f[0].equals(d.multiaddr)?d:f.map(m=>({multiaddr:m,isCertified:!1}))}))).flat();if(e!=null){const d=`/p2p/${e.toString()}`;s=s.map(f=>f.multiaddr.protos().pop()?.path===!0?f:f.multiaddr.getPeerId()==null?{multiaddr:f.multiaddr.encapsulate(d),isCertified:f.isCertified}:f)}const o=s.filter(d=>{if(this.components.transportManager.dialTransportForMultiaddr(d.multiaddr)==null)return!1;const f=d.multiaddr.getPeerId();return e!=null&&f!=null?e.equals(f):!0}),a=new Map;for(const d of o){const f=d.multiaddr.toString(),m=a.get(f);if(m!=null){m.isCertified=m.isCertified||d.isCertified||!1;continue}a.set(f,d)}const c=[...a.values()];if(c.length===0)throw new JM("The dial request has no valid addresses");const l=[];for(const d of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(d.multiaddr)||l.push(d);const u=this.addressSorter==null?L3(l):l.sort(this.addressSorter);if(u.length===0)throw new F0("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",e??"unknown peer",s.map(({multiaddr:d})=>d.toString())),this.log.trace("addresses for %p after filtering",e??"unknown peer",u.map(({multiaddr:d})=>d.toString())),u}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const n=await this.calculateMultiaddrs(void 0,new Set(e.map(i=>i.toString())),t);return t.runOnLimitedConnection===!1?n.find(i=>!zn.matches(i.multiaddr))!=null:!0}catch(n){this.log.trace("error calculating if multiaddr(s) were dialable",n)}return!1}}var Bh={},Nh,j0;function U3(){if(j0)return Nh;j0=1;function r(e,t){typeof t=="boolean"&&(t={forever:t}),this._originalTimeouts=JSON.parse(JSON.stringify(e)),this._timeouts=e,this._options=t||{},this._maxRetryTime=t&&t.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}return Nh=r,r.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},r.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},r.prototype.retry=function(e){if(this._timeout&&clearTimeout(this._timeout),!e)return!1;var t=new Date().getTime();if(e&&t-this._operationStart>=this._maxRetryTime)return this._errors.push(e),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(e);var n=this._timeouts.shift();if(n===void 0)if(this._cachedTimeouts)this._errors.splice(0,this._errors.length-1),n=this._cachedTimeouts.slice(-1);else return!1;var i=this;return this._timer=setTimeout(function(){i._attempts++,i._operationTimeoutCb&&(i._timeout=setTimeout(function(){i._operationTimeoutCb(i._attempts)},i._operationTimeout),i._options.unref&&i._timeout.unref()),i._fn(i._attempts)},n),this._options.unref&&this._timer.unref(),!0},r.prototype.attempt=function(e,t){this._fn=e,t&&(t.timeout&&(this._operationTimeout=t.timeout),t.cb&&(this._operationTimeoutCb=t.cb));var n=this;this._operationTimeoutCb&&(this._timeout=setTimeout(function(){n._operationTimeoutCb()},n._operationTimeout)),this._operationStart=new Date().getTime(),this._fn(this._attempts)},r.prototype.try=function(e){console.log("Using RetryOperation.try() is deprecated"),this.attempt(e)},r.prototype.start=function(e){console.log("Using RetryOperation.start() is deprecated"),this.attempt(e)},r.prototype.start=r.prototype.try,r.prototype.errors=function(){return this._errors},r.prototype.attempts=function(){return this._attempts},r.prototype.mainError=function(){if(this._errors.length===0)return null;for(var e={},t=null,n=0,i=0;i<this._errors.length;i++){var s=this._errors[i],o=s.message,a=(e[o]||0)+1;e[o]=a,a>=n&&(t=s,n=a)}return t},Nh}var z0;function F3(){return z0||(z0=1,function(r){var e=U3();r.operation=function(t){var n=r.timeouts(t);return new e(n,{forever:t&&(t.forever||t.retries===1/0),unref:t&&t.unref,maxRetryTime:t&&t.maxRetryTime})},r.timeouts=function(t){if(t instanceof Array)return[].concat(t);var n={retries:10,factor:2,minTimeout:1*1e3,maxTimeout:1/0,randomize:!1};for(var i in t)n[i]=t[i];if(n.minTimeout>n.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var s=[],o=0;o<n.retries;o++)s.push(this.createTimeout(o,n));return t&&t.forever&&!s.length&&s.push(this.createTimeout(o,n)),s.sort(function(a,c){return a-c}),s},r.createTimeout=function(t,n){var i=n.randomize?Math.random()+1:1,s=Math.round(i*Math.max(n.minTimeout,1)*Math.pow(n.factor,t));return s=Math.min(s,n.maxTimeout),s},r.wrap=function(t,n,i){if(n instanceof Array&&(i=n,n=null),!i){i=[];for(var s in t)typeof t[s]=="function"&&i.push(s)}for(var o=0;o<i.length;o++){var a=i[o],c=t[a];t[a]=function(u){var d=r.operation(n),f=Array.prototype.slice.call(arguments,1),m=f.pop();f.push(function(g){d.retry(g)||(g&&(arguments[0]=d.mainError()),m.apply(this,arguments))}),d.attempt(function(){u.apply(t,f)})}.bind(t,c),t[a].options=n}}}(Bh)),Bh}var Dh,H0;function $3(){return H0||(H0=1,Dh=F3()),Dh}var V3=$3();const q3=Oa(V3),j3=Object.prototype.toString,z3=r=>j3.call(r)==="[object Error]",H3=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Load failed","Network request failed","fetch failed","terminated"]);function W3(r){return r&&z3(r)&&r.name==="TypeError"&&typeof r.message=="string"?r.message==="Load failed"?r.stack===void 0:H3.has(r.message):!1}class K3 extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,{message:e}=e):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}const W0=(r,e,t)=>{const n=t.retries-(e-1);return r.attemptNumber=e,r.retriesLeft=n,r};async function G3(r,e){return new Promise((t,n)=>{e={...e},e.onFailedAttempt??=()=>{},e.shouldRetry??=()=>!0,e.retries??=10;const i=q3.operation(e),s=()=>{i.stop(),n(e.signal?.reason)};e.signal&&!e.signal.aborted&&e.signal.addEventListener("abort",s,{once:!0});const o=()=>{e.signal?.removeEventListener("abort",s),i.stop()};i.attempt(async a=>{try{const c=await r(a);o(),t(c)}catch(c){try{if(!(c instanceof Error))throw new TypeError(`Non-error was thrown: "${c}". You should only throw errors.`);if(c instanceof K3)throw c.originalError;if(c instanceof TypeError&&!W3(c))throw c;if(W0(c,a,e),await e.shouldRetry(c)||(i.stop(),n(c)),await e.onFailedAttempt(c),!i.retry(c))throw i.mainError()}catch(l){W0(l,a,e),o(),n(l)}}})})}class Y3{log;queue;started;peerStore;retries;retryInterval;backoffFactor;connectionManager;events;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.queue=new Vu({concurrency:t.maxParallelReconnects??A3,metricName:"libp2p_reconnect_queue",metrics:e.metrics}),this.started=!1,this.retries=t.retries??5,this.backoffFactor=t.backoffFactor,this.retryInterval=t.retryInterval,this.events=e.events,e.events.addEventListener("peer:disconnect",n=>{this.maybeReconnect(n.detail).catch(i=>{this.log.error("failed to maybe reconnect to %p - %e",n.detail,i)})})}async maybeReconnect(e){if(!this.started)return;const t=await this.peerStore.get(e);K0(t)&&(this.queue.has(e)||this.queue.add(async n=>{await G3(async i=>{if(this.started)try{await this.connectionManager.openConnection(e,{signal:n?.signal})}catch(s){throw this.log("reconnecting to %p attempt %d of %d failed - %e",e,i,this.retries,s),s}},{signal:n?.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:e}).catch(async n=>{this.log.error("failed to reconnect to %p - %e",e,n);const i={};[...t.tags.keys()].forEach(s=>{s.startsWith(og)&&(i[s]=void 0)}),await this.peerStore.merge(e,{tags:i}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:e})}).catch(async n=>{this.log.error("failed to remove keep-alive tag from %p - %e",e,n)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>K0(t)]});await Promise.all(e.map(async t=>{await this.connectionManager.openConnection(t.id).catch(n=>{this.log.error(n)})}))}).catch(e=>{this.log.error(e)})}stop(){this.started=!1,this.queue.abort()}}function K0(r){for(const e of r.tags.keys())if(e.startsWith(og))return!0;return!1}const HA=50,Lh={maxConnections:jA,inboundConnectionThreshold:S3,maxIncomingPendingConnections:E3};class Q3{started;connections;allow;deny;maxIncomingPendingConnections;incomingPendingConnections;outboundPendingConnections;maxConnections;dialQueue;reconnectQueue;connectionPruner;inboundConnectionRateLimiter;peerStore;metrics;events;log;peerId;constructor(e,t={}){if(this.maxConnections=t.maxConnections??Lh.maxConnections,this.maxConnections<1)throw new le("Connection Manager maxConnections must be greater than 0");this.connections=new $u,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(t.allow??[]).map(n=>Yp(n)),this.deny=(t.deny??[]).map(n=>Yp(n)),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??Lh.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new m3({points:t.inboundConnectionThreshold??Lh.inboundConnectionThreshold,duration:1}),this.connectionPruner=new k3({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{maxConnections:this.maxConnections,allow:t.allow?.map(n=>he(n))}),this.dialQueue=new M3(e,{addressSorter:t.addressSorter,maxParallelDials:t.maxParallelDials??zA,maxDialQueueLength:t.maxDialQueueLength??qA,maxPeerAddrsToDial:t.maxPeerAddrsToDial??VA,dialTimeout:t.dialTimeout??$A,resolvers:t.resolvers??{dnsaddr:TA},connections:this.connections}),this.reconnectQueue=new Y3({events:e.events,peerStore:e.peerStore,logger:e.logger,connectionManager:this},{retries:t.reconnectRetries,retryInterval:t.reconnectRetryInterval,backoffFactor:t.reconnectBackoffFactor,maxParallelReconnects:t.maxParallelReconnects})}[Symbol.toStringTag]="@libp2p/connection-manager";async start(){this.metrics?.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const e={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const t of this.connections.values())for(const n of t)e[n.direction]++;return e}}),this.metrics?.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const e={};for(const t of this.connections.values())for(const n of t)for(const i of n.streams){const s=`${i.direction} ${i.protocol??"unnegotiated"}`;e[s]=(e[s]??0)+1}return e}}),this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const e={};for(const n of this.connections.values())for(const i of n){const s={};for(const o of i.streams){const a=`${o.direction} ${o.protocol??"unnegotiated"}`;s[a]=(s[a]??0)+1}for(const[o,a]of Object.entries(s))e[o]=e[o]??[],e[o].push(a)}const t={};for(let[n,i]of Object.entries(e)){i=i.sort((o,a)=>o-a);const s=Math.floor(i.length*.9);t[n]=i[s]}return t}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await Ev(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await Av(this.reconnectQueue,this.dialQueue,this.connectionPruner);const e=[];for(const t of this.connections.values())for(const n of t)e.push((async()=>{try{await n.close()}catch(i){this.log.error(i)}})());this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}onConnect(e){this._onConnect(e).catch(t=>{this.log.error(t)})}async _onConnect(e){const{detail:t}=e;if(!this.started){await t.close();return}if(t.status!=="open")return;const n=t.remotePeer,i=!this.connections.has(n),s=this.connections.get(n)??[];s.push(t),this.connections.set(n,s),n.publicKey!=null&&n.type==="RSA"&&await this.peerStore.patch(n,{publicKey:n.publicKey}),i&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e,n=t.remotePeer,s=(this.connections.get(n)??[]).filter(o=>o.id!==t.id);this.connections.set(n,s),s.length===0&&(this.log("onDisconnect remove all connections for peer %p",n),this.connections.delete(n),this.events.safeDispatchEvent("peer:disconnect",{detail:t.remotePeer}))}getConnections(e){if(e!=null)return this.connections.get(e)??[];let t=[];for(const n of this.connections.values())t=t.concat(n);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){if(!this.started)throw new Wo("Not started");this.outboundPendingConnections++;try{t.signal?.throwIfAborted();const{peerId:n}=FA(e);if(this.peerId.equals(n))throw new bv("Can not dial self");if(n!=null&&t.force!==!0){this.log("dial %p",n);const a=this.getConnections(n).find(c=>c.limits==null);if(a!=null)return this.log("had an existing non-limited connection to %p",n),t.onProgress?.(new Re("dial-queue:already-connected")),a}const i=await this.dialQueue.dial(e,{...t,priority:t.priority??HA});if(i.status!=="open")throw new yv("Remote closed connection during opening");let s=this.connections.get(i.remotePeer);s==null&&(s=[],this.connections.set(i.remotePeer,s));let o=!1;for(const a of s)if(a.id===i.id&&(o=!0),t.force!==!0&&a.id!==i.id&&a.remoteAddr.equals(i.remoteAddr))return i.abort(new ag("Duplicate multiaddr connection")),a;return o||s.push(i),i}finally{this.outboundPendingConnections--}}async closeConnections(e,t={}){const n=this.connections.get(e)??[];await Promise.all(n.map(async i=>{try{await i.close(t)}catch(s){i.abort(s)}}))}async acceptIncomingConnection(e){if(this.deny.some(i=>i.contains(e.remoteAddr.nodeAddress().address)))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some(i=>i.contains(e.remoteAddr.nodeAddress().address)))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(e.remoteAddr.isThinWaistAddress()){const i=e.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(i,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,i),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map(n=>he(n))}))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}class Mh{movingAverage;variance;deviation;forecast;timeSpan;previousTime;constructor(e){this.timeSpan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timeSpan)}push(e,t=Date.now()){if(this.previousTime!=null){const n=this.alpha(t,this.previousTime),i=e-this.movingAverage,s=n*i;this.movingAverage=n*e+(1-n)*this.movingAverage,this.variance=(1-n)*(this.variance+i*s),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+n*i}else this.movingAverage=e;this.previousTime=t}}const X3=1.2,Z3=2,J3=5e3,e8=6e4,t8=5e3;class r8{success;failure;next;metric;timeoutMultiplier;failureMultiplier;minTimeout;maxTimeout;constructor(e={}){const t=e.interval??t8;this.success=new Mh(t),this.failure=new Mh(t),this.next=new Mh(t),this.failureMultiplier=e.failureMultiplier??Z3,this.timeoutMultiplier=e.timeoutMultiplier??X3,this.minTimeout=e.minTimeout??J3,this.maxTimeout=e.maxTimeout??e8,e.metricName!=null&&(this.metric=e.metrics?.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){let t=Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier));t<this.minTimeout&&(t=this.minTimeout),t>this.maxTimeout&&(t=this.maxTimeout);const n=AbortSignal.timeout(t),i=qr([e.signal,n]);return i.start=Date.now(),i.timeout=t,i}cleanUp(e){const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),this.metric?.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),this.metric?.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}const n8=1e4,i8="1.0.0",s8="ping",o8="ipfs",G0=32,a8=!0;class c8{protocol;components;log;heartbeatInterval;pingIntervalMs;abortController;timeout;abortConnectionOnPingFailure;constructor(e,t={}){this.components=e,this.protocol=`/${t.protocolPrefix??o8}/${s8}/${i8}`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??n8,this.abortConnectionOnPingFailure=t.abortConnectionOnPingFailure??a8,this.timeout=new r8({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}[Symbol.toStringTag]="@libp2p/connection-monitor";[Zt]=["@libp2p/connection-monitor"];start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(e=>{Promise.resolve().then(async()=>{let t=Date.now();try{const n=this.timeout.getTimeoutSignal({signal:this.abortController?.signal}),i=await e.newStream(this.protocol,{signal:n,runOnLimitedConnection:!0}),s=gl(i);t=Date.now(),await Promise.all([s.write(Ig(G0),{signal:n}),s.read({bytes:G0,signal:n})]),e.rtt=Date.now()-t,await s.unwrap().close({signal:n})}catch(n){if(n.name!=="UnsupportedProtocolError")throw n;e.rtt=(Date.now()-t)/2}}).catch(t=>{this.log.error("error during heartbeat",t),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),e.abort(t)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){this.abortController?.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}class l8{routers;started;components;constructor(e,t){this.routers=t.routers??[],this.started=!1,this.components=e,this.findProviders=e.metrics?.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],i)=>({...i,cid:n.toString()}),getAttributesFromYieldedValue:(n,i)=>({...i,providers:[...Array.isArray(i.providers)?i.providers:[],n.id.toString()]})})??this.findProviders,this.provide=e.metrics?.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],i)=>({...i,cid:n.toString()})})??this.provide,this.cancelReprovide=e.metrics?.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],i)=>({...i,cid:n.toString()})})??this.cancelReprovide,this.put=e.metrics?.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([n])=>({key:ge(n,"base36")})})??this.put,this.get=e.metrics?.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([n])=>({key:ge(n,"base36")})})??this.get}[Symbol.toStringTag]="@libp2p/content-routing";isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(this.routers.length===0)throw new Oh("No content routers available");const n=this,i=new Si;for await(const s of ml(...n.routers.filter(o=>o.findProviders instanceof Function).map(o=>o.findProviders(e,t))))s!=null&&(s.multiaddrs.length>0&&await this.components.peerStore.merge(s.id,{multiaddrs:s.multiaddrs}),!i.has(s.id)&&(i.add(s.id),yield s))}async provide(e,t={}){if(this.routers.length===0)throw new Oh("No content routers available");await Promise.all(this.routers.filter(n=>n.provide instanceof Function).map(async n=>{await n.provide(e,t)}))}async cancelReprovide(e,t={}){if(this.routers.length===0)throw new Oh("No content routers available");await Promise.all(this.routers.filter(n=>n.cancelReprovide instanceof Function).map(async n=>{await n.cancelReprovide(e,t)}))}async put(e,t,n){if(!this.isStarted())throw new Wo;await Promise.all(this.routers.filter(i=>i.put instanceof Function).map(async i=>{await i.put(e,t,n)}))}async get(e,t){if(!this.isStarted())throw new Wo;return Promise.any(this.routers.filter(n=>n.get instanceof Function).map(async n=>n.get(e,t)))}}class u8{log;peerId;peerStore;routers;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[],this.findPeer=e.metrics?.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],i)=>({...i,peer:n.toString()})})??this.findPeer,this.getClosestPeers=e.metrics?.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],i)=>({...i,key:ge(n,"base36")}),getAttributesFromYieldedValue:(n,i)=>({...i,peers:[...Array.isArray(i.peers)?i.peers:[],n.id.toString()]})})??this.getClosestPeers}[Symbol.toStringTag]="@libp2p/peer-routing";async findPeer(e,t){if(this.routers.length===0)throw new U0("No peer routers available");if(e.toString()===this.peerId.toString())throw new GM("Should not try to find self");const n=this,i=ml(...this.routers.filter(s=>s.findPeer instanceof Function).map(s=>async function*(){try{yield await s.findPeer(e,t)}catch(o){n.log.error(o)}}()));for await(const s of i)if(s!=null)return s.multiaddrs.length>0&&await this.peerStore.merge(s.id,{multiaddrs:s.multiaddrs}),s;throw new di}async*getClosestPeers(e,t={}){if(this.routers.length===0)throw new U0("No peer routers available");const n=this,i=Bs(1024);for await(const s of wE(async function*(){const o=ml(...n.routers.filter(a=>a.getClosestPeers instanceof Function).map(a=>a.getClosestPeers(e,t)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await n.findPeer(a.id,{...t,useCache:!1})}catch(c){n.log.error("could not find peer multiaddrs",c);return}return a}}()))s!=null&&(s.multiaddrs.length>0&&await this.peerStore.merge(s.id,{multiaddrs:s.multiaddrs}),!i.has(s.id.toMultihash().bytes)&&(i.add(s.id.toMultihash().bytes),yield s))}}class d8 extends $r{peerRouting;log;walking;walkers;shutdownController;walkController;needNext;constructor(e){super(),this.log=e.logger.forComponent("libp2p:random-walk"),this.peerRouting=e.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}[Symbol.toStringTag]="@libp2p/random-walk";start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(e){this.walking||this.startWalk(),this.walkers++;const t=qr([this.shutdownController.signal,e?.signal]);try{for(;;)this.needNext?.resolve(),this.needNext=We(),yield(await Ei(this,"walk:peer",t,{errorEvent:"walk:error"})).detail}finally{t.clear(),this.walkers--,this.walkers===0&&(this.walkController?.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const e=qr([this.walkController.signal,this.shutdownController.signal]),t=Date.now();let n=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const i=Ig(32);let s=Date.now();for await(const o of this.peerRouting.getClosestPeers(i,{signal:e}))e.aborted&&this.log("aborting walk"),e.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",o.id,Date.now()-s,this.walkers),n++,this.safeDispatchEvent("walk:peer",{detail:o}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await sr(this.needNext.promise,e)),s=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",i,this.walkers,n)}catch(i){this.log.error("random walk errored",i),this.safeDispatchEvent("walk:error",{detail:i})}this.log("no walkers left, ended walk")}).catch(i=>{this.log.error("random walk errored",i)}).finally(()=>{this.log("finished walk, found %d peers after %dms",n,Date.now()-t),this.walking=!1})}}const WA=32,KA=64;class h8{log;topologies;handlers;components;constructor(e){this.log=e.logger.forComponent("libp2p:registrar"),this.topologies=new Map,this.handlers=new Map,this.components=e,this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}[Symbol.toStringTag]="@libp2p/registrar";getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(t==null)throw new YM(`No handler registered for protocol ${e}`);return t}getTopologies(e){const t=this.topologies.get(e);return t==null?[]:[...t.values()]}async handle(e,t,n){if(this.handlers.has(e)&&n?.force!==!0)throw new QM(`Handler already registered for protocol ${e}`);const i=_A.bind({ignoreUndefined:!0})({maxInboundStreams:WA,maxOutboundStreams:KA},n);this.handlers.set(e,{handler:t,options:i}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]})}async unhandle(e){(Array.isArray(e)?e:[e]).forEach(n=>{this.handlers.delete(n)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()})}async register(e,t){if(t==null)throw new le("invalid topology");const n=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let i=this.topologies.get(e);return i==null&&(i=new Map,this.topologies.set(e,i)),i.set(n,t),n}unregister(e){for(const[t,n]of this.topologies.entries())n.has(e)&&(n.delete(e),n.size===0&&this.topologies.delete(t))}_onDisconnect(e){const t=e.detail;this.components.peerStore.get(t).then(n=>{for(const i of n.protocols){const s=this.topologies.get(i);if(s!=null)for(const o of s.values())o.filter?.has(t)!==!1&&(o.filter?.remove(t),o.onDisconnect?.(t))}}).catch(n=>{n.name!=="NotFoundError"&&this.log.error("could not inform topologies of disconnecting peer %p",t,n)})}_onPeerUpdate(e){const{peer:t,previous:n}=e.detail,i=(n?.protocols??[]).filter(s=>!t.protocols.includes(s));for(const s of i){const o=this.topologies.get(s);if(o!=null)for(const a of o.values())a.filter?.has(t.id)!==!1&&(a.filter?.remove(t.id),a.onDisconnect?.(t.id))}}_onPeerIdentify(e){const t=e.detail.protocols,n=e.detail.connection,i=e.detail.peerId;for(const s of t){const o=this.topologies.get(s);if(o!=null)for(const a of o.values())n.limits!=null&&a.notifyOnLimitedConnection!==!0||a.filter?.has(i)!==!0&&(a.filter?.add(i),a.onConnect?.(i,n))}}}class f8 extends Map{metric;constructor(e){super();const{name:t,metrics:n}=e;this.metric=n.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function GA(r){const{name:e,metrics:t}=r;let n;return t!=null?n=new f8({name:e,metrics:t}):n=new Map,n}class p8{log;components;transports;listeners;faultTolerance;started;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=new Map,this.listeners=GA({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??Ho.FATAL_ALL}[Symbol.toStringTag]="@libp2p/transport-manager";add(e){const t=e[Symbol.toStringTag];if(t==null)throw new le("Transport must have a valid tag");if(this.transports.has(t))throw new le(`There is already a transport with the tag ${t}`);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,n]of this.listeners)for(this.log("closing listeners for %s",t);n.length>0;){const i=n.pop();i!=null&&e.push(i.close())}await Promise.all(e),this.log("all listeners closed");for(const t of this.listeners.keys())this.listeners.set(t,[]);this.started=!1}async dial(e,t){const n=this.dialTransportForMultiaddr(e);if(n==null)throw new r3(`No transport available for address ${String(e)}`);return t?.onProgress?.(new Re("transport-manager:selected-transport",n[Symbol.toStringTag])),n.dial(e,{...t,upgrader:this.components.upgrader})}getAddrs(){let e=[];for(const t of this.listeners.values())for(const n of t)e=[...e,...n.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values())if(t.dialFilter([e]).length>0)return t}listenTransportForMultiaddr(e){for(const t of this.transports.values())if(t.listenFilter([e]).length>0)return t}async listen(e){if(!this.isStarted())throw new Wo("Not started");if(e==null||e.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const t={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};e.forEach(s=>{t.errors.set(s.toString(),new XM)});const n=[];for(const[s,o]of this.transports.entries()){const a=o.listenFilter(e);for(const c of a){this.log("creating listener for %s on %a",s,c);const l=o.createListener({upgrader:this.components.upgrader});let u=this.listeners.get(s)??[];u==null&&(u=[],this.listeners.set(s,u)),u.push(l),l.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:l})}),l.addEventListener("close",()=>{const d=u.findIndex(f=>f===l);u.splice(d,1),this.components.events.safeDispatchEvent("transport:close",{detail:l})}),cw.matches(c)?t.ipv4.attempts++:lw.matches(c)&&t.ipv6.attempts++,n.push(l.listen(c).then(()=>{t.errors.delete(c.toString()),cw.matches(c)&&t.ipv4.success++,lw.matches(c)&&t.ipv6.success++},d=>{throw this.log.error("transport %s could not listen on address %a - %e",s,c,d),t.errors.set(c.toString(),d),d}))}}const i=await Promise.allSettled(n);if(!(i.length>0&&i.every(s=>s.status==="fulfilled"))){if(this.ipv6Unsupported(t)){this.log("all IPv4 addresses succeed but all IPv6 failed");return}if(this.faultTolerance===Ho.NO_FATAL){this.log("failed to listen on any address but fault tolerance allows this");return}throw new ZM(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...t.errors.entries()].map(([s,o])=>`
  ${s}: ${`${o.stack??o}`.split(`
`).join(`
  `)}
`).join("")}`)}}ipv6Unsupported(e){if(e.ipv4.attempts===0||e.ipv6.attempts===0)return!1;const t=e.ipv4.attempts===e.ipv4.success,n=e.ipv6.success===0;return t&&n}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const n=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const i=t.pop();i!=null&&n.push(i.close())}await Promise.all(n),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}const Ut="/multistream/1.0.0",Um=1024,g8=oe(`
`);async function Po(r,e,t){await r.write(e,t)}async function m8(r,e,t){await r.writeV(e,t)}async function y8(r,e){const t=await r.read(e);if(t.byteLength===0||t.get(t.byteLength-1)!==g8[0])throw e.log.error("Invalid mss message - missing newline",t),new Et("Missing newline");return t.sublist(0,-1)}async function bs(r,e){const t=await y8(r,e);return ge(t.subarray())}async function Uh(r,e,t){if(e=Array.isArray(e)?[...e]:[e],e.length===1&&t.negotiateFully===!1)return w8(r,e[0],t);const n=Cs(r,{...t,maxDataLength:Um}),i=e.shift();if(i==null)throw new Error("At least one protocol must be specified");t.log.trace('select: write ["%s", "%s"]',Ut,i);const s=oe(`${Ut}
`),o=oe(`${i}
`);await m8(n,[s,o],t),t.log.trace("select: reading multistream-select header");let a=await bs(n,t);if(t.log.trace('select: read "%s"',a),a===Ut&&(t.log.trace("select: reading protocol response"),a=await bs(n,t),t.log.trace('select: read "%s"',a)),a===i)return{stream:n.unwrap(),protocol:i};for(const c of e){t.log.trace('select: write "%s"',c),await Po(n,oe(`${c}
`),t),t.log.trace("select: reading protocol response");const l=await bs(n,t);if(t.log.trace('select: read "%s" for "%s"',l,c),l===c)return{stream:n.unwrap(),protocol:c}}throw new cg("protocol selection failed")}function w8(r,e,t){const n=r.sink.bind(r),i=r.source;let s=!1,o=!1;const a=We();let c=!1,l=!1;const u=We();let d=!1,f=!1;const m=We(),g=Cs({sink:n,source:i},{...t,maxDataLength:Um});r.sink=async T=>{const{sink:v}=g.unwrap();await v(async function*(){let b=!1;for await(const A of T){if(l&&await u.promise,c)yield A;else{l=!0,t.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink',Ut,e,A.byteLength);const R=`${e}
`;yield new be(Uint8Array.from([19]),oe(`${Ut}
`),gs(R.length),oe(R),A).subarray(),t.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink',Ut,e,A.byteLength),c=!0,l=!1,u.resolve(),y().catch(C=>{t.log.error("could not finish optimistic protocol negotiation of %s",e,C)})}b=!0}b||await y()}())};async function y(){if(o){t.log.trace("optimistic: already negotiating %s stream",e),await a.promise;return}o=!0;try{c||(t.log.trace("optimistic: doing send protocol for %s stream",e),await w()),d||(t.log.trace("optimistic: doing read protocol for %s stream",e),await x())}finally{o=!1,s=!0,a.resolve()}}async function w(){if(l){await u.promise;return}l=!0;try{t.log.trace('optimistic: write ["%s", "%s", data] in source',Ut,e),await g.writeV([oe(`${Ut}
`),oe(`${e}
`)]),t.log.trace('optimistic: wrote ["%s", "%s", data] in source',Ut,e)}finally{c=!0,l=!1,u.resolve()}}async function x(){if(f){await m.promise;return}f=!0;try{t.log.trace("optimistic: reading multistream select header");let T=await bs(g,t);if(t.log.trace('optimistic: read multistream select header "%s"',T),T===Ut&&(T=await bs(g,t)),t.log.trace('optimistic: read protocol "%s", expecting "%s"',T,e),T!==e)throw new cg("protocol selection failed")}finally{d=!0,f=!1,m.resolve()}}if(r.source=async function*(){await y(),t.log.trace('optimistic: reading data from "%s" stream',e),yield*g.unwrap().source}(),r.closeRead!=null){const T=r.closeRead.bind(r);r.closeRead=async v=>{s||await y().catch(b=>{t.log.error("could not negotiate protocol before close read",b)}),await T(v)}}if(r.closeWrite!=null){const T=r.closeWrite.bind(r);r.closeWrite=async v=>{s||await y().catch(b=>{t.log.error("could not negotiate protocol before close write",b)}),await T(v)}}if(r.close!=null){const T=r.close.bind(r);r.close=async v=>{const b=[];l&&b.push(u.promise),f&&b.push(m.promise),b.length>0?await sr(Promise.all(b),v?.signal):(s=!0,o=!1,a.resolve()),await T(v)}}return{stream:r,protocol:e}}async function Fh(r,e,t){e=Array.isArray(e)?e:[e],t.log.trace("handle: available protocols %s",e);const n=Cs(r,{...t,maxDataLength:Um,maxLengthLength:2});for(;;){t.log.trace("handle: reading incoming string");const i=await bs(n,t);if(t.log.trace('handle: read "%s"',i),i===Ut){t.log.trace('handle: respond with "%s" for "%s"',Ut,i),await Po(n,oe(`${Ut}
`),t),t.log.trace('handle: responded with "%s" for "%s"',Ut,i);continue}if(e.includes(i))return t.log.trace('handle: respond with "%s" for "%s"',i,i),await Po(n,oe(`${i}
`),t),t.log.trace('handle: responded with "%s" for "%s"',i,i),{stream:n.unwrap(),protocol:i};if(i==="ls"){const s=new be(...e.map(o=>fl.single(oe(`${o}
`))),oe(`
`));t.log.trace('handle: respond with "%s" for %s',e,i),await Po(n,s,t),t.log.trace('handle: responded with "%s" for %s',e,i);continue}t.log.trace('handle: respond with "na" for "%s"',i),await Po(n,oe(`na
`),t),t.log('handle: responded with "na" for "%s"',i)}}const b8=500;class v8{id;remoteAddr;remotePeer;direction;timeline;multiplexer;encryption;status;limits;log;tags;_newStream;_close;_abort;_getStreams;constructor(e){const{remoteAddr:t,remotePeer:n,newStream:i,close:s,abort:o,getStreams:a}=e;this.id=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`,this.remoteAddr=t,this.remotePeer=n,this.direction=e.direction,this.status="open",this.timeline=e.timeline,this.multiplexer=e.multiplexer,this.encryption=e.encryption,this.limits=e.limits,this.log=e.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`),this.remoteAddr.getPeerId()==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),this._newStream=i,this._close=s,this._abort=o,this._getStreams=a,this.tags=[]}[Symbol.toStringTag]="Connection";[a_]=!0;get streams(){return this._getStreams()}async newStream(e,t){if(this.status==="closing")throw new u_("the connection is being closed");if(this.status==="closed")throw new yv("the connection is closed");if(Array.isArray(e)||(e=[e]),this.limits!=null&&t?.runOnLimitedConnection!==!0)throw new vv("Cannot open protocol stream on limited connection");const n=await this._newStream(e,t);return n.direction="outbound",n}async close(e={}){if(!(this.status==="closed"||this.status==="closing")){if(this.log("closing connection to %a",this.remoteAddr),this.status="closing",e.signal==null){const t=AbortSignal.timeout(b8);e={...e,signal:t}}try{this.log.trace("closing underlying transport"),await this._close(e),this.log.trace("updating timeline with close time"),this.status="closed",this.timeline.close=Date.now()}catch(t){this.log.error("error encountered during graceful close of connection to %a",this.remoteAddr,t),this.abort(t)}}}abort(e){this.status!=="closed"&&(this.log.error("aborting connection to %a due to error",this.remoteAddr,e),this.status="closing",this._abort(e),this.status="closed",this.timeline.close=Date.now())}}function S8(r){return new v8(r)}function E8(r,e){try{const{options:t}=e.getHandler(r);return t.maxInboundStreams}catch(t){if(t.name!=="UnhandledProtocolError")throw t}return WA}function A8(r,e,t={}){try{const{options:n}=e.getHandler(r);if(n.maxOutboundStreams!=null)return n.maxOutboundStreams}catch(n){if(n.name!=="UnhandledProtocolError")throw n}return t.maxOutboundStreams??KA}function Y0(r,e,t){let n=0;return t.streams.forEach(i=>{i.direction===e&&i.protocol===r&&n++}),n}class x8{components;connectionEncrypters;streamMuxers;inboundUpgradeTimeout;inboundStreamProtocolNegotiationTimeout;outboundStreamProtocolNegotiationTimeout;events;metrics;constructor(e,t){this.components=e,this.connectionEncrypters=new Map,t.connectionEncrypters.forEach(n=>{this.connectionEncrypters.set(n.protocol,n)}),this.streamMuxers=new Map,t.streamMuxers.forEach(n=>{this.streamMuxers.set(n.protocol,n)}),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??v3,this.inboundStreamProtocolNegotiationTimeout=t.inboundStreamProtocolNegotiationTimeout??V0,this.outboundStreamProtocolNegotiationTimeout=t.outboundStreamProtocolNegotiationTimeout??V0,this.events=e.events,this.metrics={dials:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total")}}[Symbol.toStringTag]="@libp2p/upgrader";async shouldBlockConnection(e,...t){const n=this.components.connectionGater[e];if(n==null)return;if(await n.apply(this.components.connectionGater,t)===!0)throw new e3(`The multiaddr connection is blocked by gater.${e}`)}createInboundAbortSignal(e){return qr([AbortSignal.timeout(this.inboundUpgradeTimeout),e])}async upgradeInbound(e,t){let n=!1;const i=this.createInboundAbortSignal(t.signal);try{if(this.metrics.dials?.increment({inbound:!0}),n=await this.components.connectionManager.acceptIncomingConnection(e),!n)throw new t3("Connection denied");await this.shouldBlockConnection("denyInboundConnection",e),await this._performUpgrade(e,"inbound",{...t,signal:i})}catch(s){throw this.metrics.errors?.increment({inbound:!0}),s}finally{i.clear(),n&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t){try{this.metrics.dials?.increment({outbound:!0});const n=e.remoteAddr.getPeerId();let i;n!=null&&(i=Ir(n),await this.shouldBlockConnection("denyOutboundConnection",i,e));let s="outbound";return t.initiator===!1&&(s="inbound"),await this._performUpgrade(e,s,t)}catch(n){throw this.metrics.errors?.increment({outbound:!0}),n}}async _performUpgrade(e,t,n){let i,s,o,a,c;this.components.metrics?.trackMultiaddrConnection(e),e.log.trace("starting the %s connection upgrade",t);let l=e;if(n?.skipProtection!==!0){const u=this.components.connectionProtector;u!=null&&(e.log("protecting the %s connection",t),l=await u.protect(e,n))}try{if(i=l,n?.skipEncryption!==!0){n?.onProgress?.(new Re(`upgrader:encrypt-${t}-connection`)),{conn:i,remotePeer:s,protocol:c,streamMuxer:a}=await(t==="inbound"?this._encryptInbound(l,n):this._encryptOutbound(l,n));const u={...l,...i};await this.shouldBlockConnection(t==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",s,u)}else{const u=e.remoteAddr.getPeerId();if(u==null)throw new ag(`${t} connection that skipped encryption must have a peer id`);const d=Ir(u);c="native",s=d}if(s.equals(this.components.peerId)){const u=new bv("Can not dial self");throw e.abort(u),u}if(o=i,n?.muxerFactory!=null)a=n.muxerFactory;else if(a==null&&this.streamMuxers.size>0){n?.onProgress?.(new Re(`upgrader:multiplex-${t}-connection`));const u=await(t==="inbound"?this._multiplexInbound({...l,...i},this.streamMuxers,n):this._multiplexOutbound({...l,...i},this.streamMuxers,n));a=u.muxerFactory,o=u.stream}}catch(u){throw e.log.error("failed to upgrade inbound connection %s %a - %e",t==="inbound"?"from":"to",e.remoteAddr,u),u}return await this.shouldBlockConnection(t==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",s,e),e.log("successfully upgraded %s connection",t),this._createConnection({cryptoProtocol:c,direction:t,maConn:e,upgradedConn:o,muxerFactory:a,remotePeer:s,limits:n?.limits})}_createConnection(e){const{cryptoProtocol:t,direction:n,maConn:i,upgradedConn:s,remotePeer:o,muxerFactory:a,limits:c}=e;let l,u,d;a!=null&&(l=a.createStreamMuxer({direction:n,onIncomingStream:g=>{d!=null&&Promise.resolve().then(async()=>{const y=this.components.registrar.getProtocols(),w=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout),{stream:x,protocol:T}=await Fh(g,y,{signal:w,log:g.log,yieldBytes:!1});if(d==null)return;d.log("incoming stream opened on %s",T);const v=E8(T,this.components.registrar);if(Y0(T,"inbound",d)===v){const A=new g_(`Too many inbound protocol streams for protocol "${T}" - limit ${v}`);throw g.abort(A),A}g.source=x.source,g.sink=x.sink,g.protocol=T,x.closeWrite!=null&&(g.closeWrite=x.closeWrite),x.closeRead!=null&&(g.closeRead=x.closeRead),x.close!=null&&(g.close=x.close),await this.components.peerStore.merge(o,{protocols:[T]}),this.components.metrics?.trackProtocolStream(g,d),this._onStream({connection:d,stream:g,protocol:T})}).catch(async y=>{d.log.error("error handling incoming stream id %s - %e",g.id,y),g.timeline.close==null&&await g.close()})}}),u=async(g,y={})=>{if(l==null)throw new Tc("Connection is not multiplexed");d.log.trace("starting new stream for protocols %s",g);const w=await l.newStream();d.log.trace("started new stream %s for protocols %s",w.id,g);try{if(y.signal==null){w.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",g);const A=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);y={...y,signal:A}}w.log.trace("selecting protocol from protocols %s",g);const{stream:x,protocol:T}=await Uh(w,g,{...y,log:w.log,yieldBytes:!0});w.log.trace("selected protocol %s",T);const v=A8(T,this.components.registrar,y),b=Y0(T,"outbound",d);if(b>=v){const A=new Sv(`Too many outbound protocol streams for protocol "${T}" - ${b}/${v}`);throw w.abort(A),A}return await this.components.peerStore.merge(o,{protocols:[T]}),w.source=x.source,w.sink=x.sink,w.protocol=T,x.closeWrite!=null&&(w.closeWrite=x.closeWrite),x.closeRead!=null&&(w.closeRead=x.closeRead),x.close!=null&&(w.close=x.close),this.components.metrics?.trackProtocolStream(w,d),w}catch(x){throw d.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",n==="inbound"?"from":"to",e.maConn.remoteAddr,g,x),w.timeline.close==null&&w.abort(x),x}},Promise.all([l.sink(s.source),s.sink(l.source)]).catch(g=>{d.log.error("error piping data through muxer - %e",g)}));const f=i.timeline;i.timeline=new Proxy(f,{set:(...g)=>(g[1]==="close"&&g[2]!=null&&f.close==null&&(async()=>{try{d.status==="open"&&await d.close()}catch(y){d.log.error("error closing connection after timeline close %e",y)}finally{this.events.safeDispatchEvent("connection:close",{detail:d})}})().catch(y=>{d.log.error("error thrown while dispatching connection:close event %e",y)}),Reflect.set(...g))}),i.timeline.upgraded=Date.now();const m=()=>{throw new Tc("Connection is not multiplexed")};return d=S8({remoteAddr:i.remoteAddr,remotePeer:o,status:"open",direction:n,timeline:i.timeline,multiplexer:l?.protocol,encryption:t,limits:c,logger:this.components.logger,newStream:u??m,getStreams:()=>l?.streams??[],close:async g=>{await l?.close(g),await i.close(g)},abort:g=>{i.abort(g),l?.abort(g)}}),this.events.safeDispatchEvent("connection:open",{detail:d}),d.__maConnTimeline=f,d}_onStream(e){const{connection:t,stream:n,protocol:i}=e,{handler:s,options:o}=this.components.registrar.getHandler(i);if(t.limits!=null&&o.runOnLimitedConnection!==!0)throw new vv("Cannot open protocol stream on limited connection");s({connection:t,stream:n})}async _encryptInbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{const{stream:i,protocol:s}=await Fh(e,n,{...t,log:e.log}),o=this.connectionEncrypters.get(s);if(o==null)throw new Pc(`no crypto module found for ${s}`);return e.log("encrypting inbound connection to %a using %s",e.remoteAddr,s),{...await o.secureInbound(i,t),protocol:s}}catch(i){throw e.log.error("encrypting inbound connection from %a failed",e.remoteAddr,i),new Pc(i.message)}}async _encryptOutbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{e.log.trace("selecting encrypter from %s",n);const{stream:i,protocol:s}=await Uh(e,n,{...t,log:e.log,yieldBytes:!0}),o=this.connectionEncrypters.get(s);if(o==null)throw new Pc(`no crypto module found for ${s}`);return e.log("encrypting outbound connection to %a using %s",e.remoteAddr,s),{...await o.secureOutbound(i,t),protocol:s}}catch(i){throw e.log.error("encrypting outbound connection to %a failed",e.remoteAddr,i),new Pc(i.message)}}async _multiplexOutbound(e,t,n){const i=Array.from(t.keys());e.log("outbound selecting muxer %s",i);try{e.log.trace("selecting stream muxer from %s",i);const{stream:s,protocol:o}=await Uh(e,i,{...n,log:e.log,yieldBytes:!0});e.log("selected %s as muxer protocol",o);const a=t.get(o);return{stream:s,muxerFactory:a}}catch(s){throw e.log.error("error multiplexing outbound connection",s),new Tc(String(s))}}async _multiplexInbound(e,t,n){const i=Array.from(t.keys());e.log("inbound handling muxers %s",i);try{const{stream:s,protocol:o}=await Fh(e,i,{...n,log:e.log}),a=t.get(o);return{stream:s,muxerFactory:a}}catch(s){throw e.log.error("error multiplexing inbound connection",s),new Tc(String(s))}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}const YA="2.8.8",QA="js-libp2p";function _8(r,e){return`${r??QA}/${e??YA} browser/${globalThis.navigator.userAgent}`}class C8 extends $r{peerId;peerStore;contentRouting;peerRouting;metrics;services;logger;status;components;log;constructor(e){super(),this.status="stopped";const t=new $r,n=t.dispatchEvent.bind(t);t.dispatchEvent=l=>{const u=n(l),d=this.dispatchEvent(new CustomEvent(l.type,{detail:l.detail}));return u||d},this.peerId=e.peerId,this.logger=e.logger??RA(),this.log=this.logger.forComponent("libp2p"),this.services={};const i=e.nodeInfo?.name??QA,s=e.nodeInfo?.version??YA,o=this.components=o3({peerId:e.peerId,privateKey:e.privateKey,nodeInfo:{name:i,version:s,userAgent:e.nodeInfo?.userAgent??_8(i,s)},logger:this.logger,events:t,datastore:e.datastore??new TM,connectionGater:f3(e.connectionGater),dns:e.dns});this.peerStore=this.configureComponent("peerStore",xM(o,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),e.metrics!=null&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),o.events.addEventListener("peer:update",l=>{if(l.detail.previous==null){const u={id:l.detail.peer.id,multiaddrs:l.detail.peer.addresses.map(d=>d.multiaddr)};o.events.safeDispatchEvent("peer:discovery",{detail:u})}}),e.connectionProtector!=null&&this.configureComponent("connectionProtector",e.connectionProtector(o)),this.components.upgrader=new x8(this.components,{connectionEncrypters:(e.connectionEncrypters??[]).map((l,u)=>this.configureComponent(`connection-encryption-${u}`,l(this.components))),streamMuxers:(e.streamMuxers??[]).map((l,u)=>this.configureComponent(`stream-muxers-${u}`,l(this.components))),inboundUpgradeTimeout:e.connectionManager?.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:e.connectionManager?.inboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:e.connectionManager?.outboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout}),this.configureComponent("transportManager",new p8(this.components,e.transportManager)),this.configureComponent("connectionManager",new Q3(this.components,e.connectionManager)),e.connectionMonitor?.enabled!==!1&&this.configureComponent("connectionMonitor",new c8(this.components,e.connectionMonitor)),this.configureComponent("registrar",new h8(this.components)),this.configureComponent("addressManager",new HM(this.components,e.addresses));const a=(e.peerRouters??[]).map((l,u)=>this.configureComponent(`peer-router-${u}`,l(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new u8(this.components,{routers:a}));const c=(e.contentRouters??[]).map((l,u)=>this.configureComponent(`content-router-${u}`,l(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new l8(this.components,{routers:c})),this.configureComponent("randomWalk",new d8(this.components)),(e.peerDiscovery??[]).forEach((l,u)=>{this.configureComponent(`peer-discovery-${u}`,l(this.components)).addEventListener("peer",f=>{this.#e(f)})}),e.transports?.forEach((l,u)=>{this.components.transportManager.add(this.configureComponent(`transport-${u}`,l(this.components)))}),e.services!=null)for(const l of Object.keys(e.services)){const u=e.services[l],d=u(this.components);if(d==null){this.log.error("service factory %s returned null or undefined instance",l);continue}this.services[l]=d,this.configureComponent(l,d),d[ay]!=null&&(this.log("registering service %s for content routing",l),c.push(d[ay])),d[ly]!=null&&(this.log("registering service %s for peer routing",l),a.push(d[ly])),d[cy]!=null&&(this.log("registering service %s for peer discovery",l),d[cy].addEventListener?.("peer",f=>{this.#e(f)}))}a3(o)}configureComponent(e,t){return t==null&&this.log.error("component %s was null or undefined",e),this.components[e]=t,t}async start(){if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await this.components.beforeStart?.(),await this.components.start(),await this.components.afterStart?.(),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started")}catch(e){throw this.log.error("An error occurred starting libp2p",e),this.status="started",await this.stop(),e}}}async stop(){this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await this.components.beforeStop?.(),await this.components.stop(),await this.components.afterStop?.(),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new Si;for(const t of this.components.connectionManager.getConnections())e.add(t.remotePeer);return Array.from(e)}async dial(e,t={}){return this.components.connectionManager.openConnection(e,{priority:75,...t})}async dialProtocol(e,t,n={}){if(t==null)throw new le("no protocols were provided to open a stream");if(t=Array.isArray(t)?t:[t],t.length===0)throw new le("no protocols were provided to open a stream");return(await this.dial(e,n)).newStream(t,n)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e,t={}){Du(e)&&(e=Ir(e.getPeerId()??"")),await this.components.connectionManager.closeConnections(e,t)}async getPublicKey(e,t={}){if(this.log("getPublicKey %p",e),e.publicKey!=null)return e.publicKey;try{const o=await this.peerStore.get(e);if(o.id.publicKey!=null)return o.id.publicKey}catch(o){if(o.name!=="NotFoundError")throw o}const n=cn([oe("/pk/"),e.toMultihash().bytes]),i=await this.contentRouting.get(n,t),s=jn(i);return await this.peerStore.patch(e,{publicKey:s}),s}async handle(e,t,n){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async i=>{await this.components.registrar.handle(i,t,n)}))}async unhandle(e){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async t=>{await this.components.registrar.unhandle(t)}))}async register(e,t){return this.components.registrar.register(e,t)}unregister(e){this.components.registrar.unregister(e)}async isDialable(e,t={}){return this.components.connectionManager.isDialable(e,t)}#e(e){const{detail:t}=e;if(t.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(t.id,{multiaddrs:t.multiaddrs}).catch(n=>{this.log.error(n)})}}async function I8(r={}){r.privateKey??=await gS("Ed25519");const e=new C8({...await UL(r),peerId:bk(r.privateKey)});return r.start!==!1&&await e.start(),e}var Dr;(function(r){(function(n){n.UNUSED="UNUSED",n.CONNECT="CONNECT",n.SYNC="SYNC"})(r.Type||(r.Type={}));let e;(function(n){n[n.UNUSED=0]="UNUSED",n[n.CONNECT=100]="CONNECT",n[n.SYNC=300]="SYNC"})(e||(e={})),function(n){n.codec=()=>ln(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=De((n,i,s={})=>{if(s.lengthDelimited!==!1&&i.fork(),n.type!=null&&(i.uint32(8),r.Type.codec().encode(n.type,i)),n.observedAddresses!=null)for(const o of n.observedAddresses)i.uint32(18),i.bytes(o);s.lengthDelimited!==!1&&i.ldelim()},(n,i,s={})=>{const o={observedAddresses:[]},a=i==null?n.len:n.pos+i;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{if(s.limits?.observedAddresses!=null&&o.observedAddresses.length===s.limits.observedAddresses)throw new Cr('Decode error - map field "observedAddresses" had too many elements');o.observedAddresses.push(n.bytes());break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>Ne(n,r.codec()),r.decode=(n,i)=>Be(n,r.codec(),i)})(Dr||(Dr={}));function Q0(r,e){return zn.matches(r)||e.dialTransportForMultiaddr(r)==null?!1:ER.matches(r)?!0:xR.matches(r)?Ba(r.toOptions().host)===!1:!1}const X0=1024*4,Z0=100,Oc={timeout:5e3,retries:3,maxInboundStreams:1,maxOutboundStreams:1};class k8{started;timeout;retries;maxInboundStreams;maxOutboundStreams;peerStore;registrar;connectionManager;addressManager;transportManager;topologyId;log;constructor(e,t){this.log=e.logger.forComponent("libp2p:dcutr"),this.started=!1,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.connectionManager=e.connectionManager,this.transportManager=e.transportManager,this.timeout=t.timeout??Oc.timeout,this.retries=t.retries??Oc.retries,this.maxInboundStreams=t.maxInboundStreams??Oc.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??Oc.maxOutboundStreams}[Symbol.toStringTag]="@libp2p/dcutr";[As]=["@libp2p/identify"];isStarted(){return this.started}async start(){this.started||(this.topologyId=await this.registrar.register(Bc,{notifyOnLimitedConnection:!0,onConnect:(e,t)=>{zn.exactMatch(t.remoteAddr)&&t.direction==="inbound"&&this.upgradeInbound(t).catch(n=>{this.log.error("error during outgoing DCUtR attempt",n)})}}),await this.registrar.handle(Bc,e=>{this.handleIncomingUpgrade(e.stream,e.connection).catch(t=>{this.log.error("error during incoming DCUtR attempt",t),e.stream.abort(t)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:!0}),this.started=!0)}async stop(){await this.registrar.unhandle(Bc),this.topologyId!=null&&this.registrar.unregister(this.topologyId),this.started=!1}async upgradeInbound(e){if(await this.attemptUnilateralConnectionUpgrade(e))return;let t;for(let n=0;n<this.retries;n++){const i={signal:AbortSignal.timeout(this.timeout)};try{t=await e.newStream([Bc],{signal:i.signal,runOnLimitedConnection:!0});const s=Jt(t,{maxDataLength:X0}).pb(Dr);this.log("B sending connect to %p",e.remotePeer);const o=Date.now();await s.write({type:Dr.Type.CONNECT,observedAddresses:this.addressManager.getAddresses().map(d=>d.bytes)},i),this.log("B receiving connect from %p",e.remotePeer);const a=await s.read(i);if(a.type!==Dr.Type.CONNECT)throw this.log("A sent wrong message type"),new Et("DCUtR message type was incorrect");const c=this.getDialableMultiaddrs(a.observedAddresses);if(c.length===0)throw this.log("A did not have any dialable multiaddrs"),new Et("DCUtR connect message had no multiaddrs");const l=Date.now()-o;this.log("A sending sync, rtt %dms",l),await s.write({type:Dr.Type.SYNC,observedAddresses:[]},i),this.log("A waiting for half RTT"),await UA(l/2),this.log("B dialing",c);const u=await this.connectionManager.openConnection(c,{signal:i.signal,priority:Z0,force:!0,initiator:!1});this.log("DCUtR to %p succeeded to address %a, closing relayed connection",e.remotePeer,u.remoteAddr),await e.close(i);break}catch(s){if(this.log.error("error while attempting DCUtR on attempt %d of %d",n+1,this.retries,s),t?.abort(s),n===this.retries)throw s}finally{t!=null&&await t.close(i)}}}async attemptUnilateralConnectionUpgrade(e){const n=(await this.peerStore.get(e.remotePeer)).addresses.map(i=>{const s=i.multiaddr;return s.getPeerId()==null?s.encapsulate(`/p2p/${e.remotePeer}`):s}).filter(i=>Q0(i,this.transportManager));if(n.length>0){const i=AbortSignal.timeout(this.timeout);try{this.log("attempting unilateral connection upgrade to %a",n);const s=await this.connectionManager.openConnection(n,{signal:i,force:!0});if(zn.exactMatch(s.remoteAddr))throw new Error("Could not open a new, non-limited, connection");return this.log("unilateral connection upgrade to %p succeeded via %a, closing relayed connection",e.remotePeer,s.remoteAddr),await e.close({signal:i}),!0}catch(s){this.log.error("unilateral connection upgrade to %p on addresses %a failed",e.remotePeer,n,s)}}else this.log("peer %p has no public addresses, not attempting unilateral connection upgrade",e.remotePeer);return!1}async handleIncomingUpgrade(e,t){const n={signal:AbortSignal.timeout(this.timeout)};try{const i=Jt(e,{maxDataLength:X0}).pb(Dr);this.log("A receiving connect");const s=await i.read(n);if(s.type!==Dr.Type.CONNECT)throw this.log("B sent wrong message type"),new Et("DCUtR message type was incorrect");if(s.observedAddresses.length===0)throw this.log("B sent no multiaddrs"),new Et("DCUtR connect message had no multiaddrs");const o=this.getDialableMultiaddrs(s.observedAddresses);if(o.length===0)throw this.log("B had no dialable multiaddrs"),new Et("DCUtR connect message had no dialable multiaddrs");if(this.log("A sending connect"),await i.write({type:Dr.Type.CONNECT,observedAddresses:this.addressManager.getAddresses().map(l=>l.bytes)}),this.log("A receiving sync"),(await i.read(n)).type!==Dr.Type.SYNC)throw new Et("DCUtR message type was incorrect");this.log("A dialing",o);const c=await this.connectionManager.openConnection(o,{signal:n.signal,priority:Z0,force:!0});this.log("DCUtR to %p succeeded via %a, closing relayed connection",t.remotePeer,c.remoteAddr),await t.close(n)}catch(i){this.log.error("incoming DCUtR from %p failed",t.remotePeer,i),e.abort(i)}finally{await e.close(n)}}getDialableMultiaddrs(e){const t=[];for(const n of e)if(!(n==null||n.length===0))try{const i=he(n);if(!Q0(i,this.transportManager))continue;t.push(i)}catch{}return t}}const Bc="/libp2p/dcutr";function T8(r={}){return e=>new k8(e,r)}function P8(r,e,t){let n,i;function s(){const a={signal:i.signal};if(t?.timeout!=null){const c=qr([i.signal,AbortSignal.timeout(t.timeout)]);a.signal=c}Promise.resolve().then(async()=>{await r(a)}).catch(()=>{}).finally(()=>{i.signal.aborted||(n=setTimeout(s,e))})}let o=!1;return{setInterval:a=>{e!==a&&(e=a,n!=null&&(clearTimeout(n),n=setTimeout(s,e)))},setTimeout:a=>{t??={},t.timeout=a},start:()=>{o||(o=!0,i=new AbortController,i.signal,t?.runImmediately===!0?queueMicrotask(()=>{s()}):n=setTimeout(s,e))},stop:()=>{clearTimeout(n),i?.abort(),o=!1}}}const R8="libp2p",O8="autonat",B8="1.0.0",N8=3e4,D8=2,L8=20,M8=80,U8=8192;var qe;(function(r){(function(i){i.DIAL="DIAL",i.DIAL_RESPONSE="DIAL_RESPONSE"})(r.MessageType||(r.MessageType={}));let e;(function(i){i[i.DIAL=0]="DIAL",i[i.DIAL_RESPONSE=1]="DIAL_RESPONSE"})(e||(e={})),function(i){i.codec=()=>ln(e)}(r.MessageType||(r.MessageType={})),function(i){i.OK="OK",i.E_DIAL_ERROR="E_DIAL_ERROR",i.E_DIAL_REFUSED="E_DIAL_REFUSED",i.E_BAD_REQUEST="E_BAD_REQUEST",i.E_INTERNAL_ERROR="E_INTERNAL_ERROR"}(r.ResponseStatus||(r.ResponseStatus={}));let t;(function(i){i[i.OK=0]="OK",i[i.E_DIAL_ERROR=100]="E_DIAL_ERROR",i[i.E_DIAL_REFUSED=101]="E_DIAL_REFUSED",i[i.E_BAD_REQUEST=200]="E_BAD_REQUEST",i[i.E_INTERNAL_ERROR=300]="E_INTERNAL_ERROR"})(t||(t={})),function(i){i.codec=()=>ln(t)}(r.ResponseStatus||(r.ResponseStatus={})),function(i){let s;i.codec=()=>(s==null&&(s=De((o,a,c={})=>{if(c.lengthDelimited!==!1&&a.fork(),o.id!=null&&(a.uint32(10),a.bytes(o.id)),o.addrs!=null)for(const l of o.addrs)a.uint32(18),a.bytes(l);c.lengthDelimited!==!1&&a.ldelim()},(o,a,c={})=>{const l={addrs:[]},u=a==null?o.len:o.pos+a;for(;o.pos<u;){const d=o.uint32();switch(d>>>3){case 1:{l.id=o.bytes();break}case 2:{if(c.limits?.addrs!=null&&l.addrs.length===c.limits.addrs)throw new Cr('Decode error - map field "addrs" had too many elements');l.addrs.push(o.bytes());break}default:{o.skipType(d&7);break}}}return l})),s),i.encode=o=>Ne(o,i.codec()),i.decode=(o,a)=>Be(o,i.codec(),a)}(r.PeerInfo||(r.PeerInfo={})),function(i){let s;i.codec=()=>(s==null&&(s=De((o,a,c={})=>{c.lengthDelimited!==!1&&a.fork(),o.peer!=null&&(a.uint32(10),r.PeerInfo.codec().encode(o.peer,a)),c.lengthDelimited!==!1&&a.ldelim()},(o,a,c={})=>{const l={},u=a==null?o.len:o.pos+a;for(;o.pos<u;){const d=o.uint32();switch(d>>>3){case 1:{l.peer=r.PeerInfo.codec().decode(o,o.uint32(),{limits:c.limits?.peer});break}default:{o.skipType(d&7);break}}}return l})),s),i.encode=o=>Ne(o,i.codec()),i.decode=(o,a)=>Be(o,i.codec(),a)}(r.Dial||(r.Dial={})),function(i){let s;i.codec=()=>(s==null&&(s=De((o,a,c={})=>{c.lengthDelimited!==!1&&a.fork(),o.status!=null&&(a.uint32(8),r.ResponseStatus.codec().encode(o.status,a)),o.statusText!=null&&(a.uint32(18),a.string(o.statusText)),o.addr!=null&&(a.uint32(26),a.bytes(o.addr)),c.lengthDelimited!==!1&&a.ldelim()},(o,a,c={})=>{const l={},u=a==null?o.len:o.pos+a;for(;o.pos<u;){const d=o.uint32();switch(d>>>3){case 1:{l.status=r.ResponseStatus.codec().decode(o);break}case 2:{l.statusText=o.string();break}case 3:{l.addr=o.bytes();break}default:{o.skipType(d&7);break}}}return l})),s),i.encode=o=>Ne(o,i.codec()),i.decode=(o,a)=>Be(o,i.codec(),a)}(r.DialResponse||(r.DialResponse={}));let n;r.codec=()=>(n==null&&(n=De((i,s,o={})=>{o.lengthDelimited!==!1&&s.fork(),i.type!=null&&(s.uint32(8),r.MessageType.codec().encode(i.type,s)),i.dial!=null&&(s.uint32(18),r.Dial.codec().encode(i.dial,s)),i.dialResponse!=null&&(s.uint32(26),r.DialResponse.codec().encode(i.dialResponse,s)),o.lengthDelimited!==!1&&s.ldelim()},(i,s,o={})=>{const a={},c=s==null?i.len:i.pos+s;for(;i.pos<c;){const l=i.uint32();switch(l>>>3){case 1:{a.type=r.MessageType.codec().decode(i);break}case 2:{a.dial=r.Dial.codec().decode(i,i.uint32(),{limits:o.limits?.dial});break}case 3:{a.dialResponse=r.DialResponse.codec().decode(i,i.uint32(),{limits:o.limits?.dialResponse});break}default:{i.skipType(l&7);break}}}return a})),n),r.encode=i=>Ne(i,r.codec()),r.decode=(i,s)=>Be(i,r.codec(),s)})(qe||(qe={}));const F8=4,$8=8;class V8{components;protocol;timeout;maxInboundStreams;maxOutboundStreams;maxMessageSize;started;log;topologyId;dialResults;findPeers;addressFilter;connectionThreshold;constructor(e,t){this.components=e,this.log=e.logger.forComponent("libp2p:auto-nat"),this.started=!1,this.protocol=`/${t.protocolPrefix??R8}/${O8}/${B8}`,this.timeout=t.timeout??N8,this.maxInboundStreams=t.maxInboundStreams??D8,this.maxOutboundStreams=t.maxOutboundStreams??L8,this.connectionThreshold=t.connectionThreshold??M8,this.maxMessageSize=t.maxMessageSize??U8,this.dialResults=GA({name:"libp2p_autonat_dial_results",metrics:e.metrics}),this.findPeers=P8(this.findRandomPeers.bind(this),6e4),this.addressFilter=Bs(1024)}[Symbol.toStringTag]="@libp2p/autonat";[Zt]=["@libp2p/autonat"];get[As](){return["@libp2p/identify"]}isStarted(){return this.started}async start(){this.started||(await this.components.registrar.handle(this.protocol,e=>{this.handleIncomingAutonatStream(e).catch(t=>{this.log.error("error handling incoming autonat stream - %e",t)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams}),this.topologyId=await this.components.registrar.register(this.protocol,{onConnect:(e,t)=>{this.verifyExternalAddresses(t).catch(n=>{this.log.error("could not verify addresses - %e",n)})}}),this.findPeers.start(),this.started=!0)}async stop(){await this.components.registrar.unhandle(this.protocol),this.topologyId!=null&&await this.components.registrar.unhandle(this.topologyId),this.dialResults.clear(),this.findPeers.stop(),this.started=!1}allAddressesAreVerified(){return this.components.addressManager.getAddressesWithMetadata().every(e=>e.expires>Date.now()?!0:e.verified)}async findRandomPeers(e){if(this.allAddressesAreVerified())return;const t=qr([AbortSignal.timeout(1e4),e?.signal]);try{this.log("starting random walk to find peers to run AutoNAT");for await(const n of this.components.randomWalk.walk({signal:t})){if(!await this.components.connectionManager.isDialable(n.multiaddrs)){this.log.trace("random peer %p was not dialable %s",n.id,n.multiaddrs.map(i=>i.toString()).join(", "));continue}try{this.log.trace("dial random peer %p",n.id),await this.components.connectionManager.openConnection(n.multiaddrs,{signal:t})}catch{}if(this.allAddressesAreVerified()){this.log("stopping random walk, all addresses are verified");return}if(!this.hasConnectionCapacity()){this.log("stopping random walk, too close to max connections");return}}}catch{}}async handleIncomingAutonatStream(e){const t=AbortSignal.timeout(this.timeout),n=Jt(e.stream,{maxDataLength:this.maxMessageSize}).pb(qe);try{const i=await n.read({signal:t}),s=await this.handleAutonatMessage(i,e.connection,{signal:t});await n.write(s,{signal:t}),await n.unwrap().unwrap().close({signal:t})}catch(i){this.log.error("error handling incoming autonat stream - %e",i),e.stream.abort(i)}}async handleAutonatMessage(e,t,n){const i=this.components.addressManager.getAddresses().map(d=>d.toOptions().host),s=e.dial;if(s==null)return this.log.error("dial was missing from message"),{type:qe.MessageType.DIAL_RESPONSE,dialResponse:{status:qe.ResponseStatus.E_BAD_REQUEST,statusText:"No Dial message found in message"}};let o;const a=s.peer;if(a?.id==null)return this.log.error("PeerId missing from message"),{type:qe.MessageType.DIAL_RESPONSE,dialResponse:{status:qe.ResponseStatus.E_BAD_REQUEST,statusText:"missing peer info"}};try{const d=Qn(a.id);o=ro(d)}catch(d){return this.log.error("invalid PeerId - %e",d),{type:qe.MessageType.DIAL_RESPONSE,dialResponse:{status:qe.ResponseStatus.E_BAD_REQUEST,statusText:"bad peer id"}}}if(this.log("incoming request from %p",o),!t.remotePeer.equals(o))return this.log("target peer %p did not equal sending peer %p",o,t.remotePeer),{type:qe.MessageType.DIAL_RESPONSE,dialResponse:{status:qe.ResponseStatus.E_BAD_REQUEST,statusText:"peer id mismatch"}};const c=a.addrs.map(d=>he(d)).filter(d=>{const f=d.toOptions();return Ri(d)?!1:f.host!==t.remoteAddr.toOptions().host?(this.log.trace("not dialing %a - target host did not match remote host %a",d,t.remoteAddr),!1):i.includes(f.host)?!1:this.components.transportManager.dialTransportForMultiaddr(d)==null?(this.log.trace("not dialing %a - transport unsupported",d),!1):!0}).map(d=>(d.getPeerId()==null&&(d=d.encapsulate(`/p2p/${o.toString()}`)),d));if(c.length===0)return this.log("refused to dial all multiaddrs for %p from message",o),{type:qe.MessageType.DIAL_RESPONSE,dialResponse:{status:qe.ResponseStatus.E_DIAL_REFUSED,statusText:"no dialable addresses"}};this.log("dial multiaddrs %s for peer %p",c.map(d=>d.toString()).join(", "),o);let l="",u=c[0];for(const d of c){let f;u=d;try{if(f=await this.components.connectionManager.openConnection(d,n),!f.remoteAddr.equals(d))throw this.log.error("tried to dial %a but dialed %a",d,f.remoteAddr),new Error("Unexpected remote address");return this.log("successfully dialed %p via %a",o,d),{type:qe.MessageType.DIAL_RESPONSE,dialResponse:{status:qe.ResponseStatus.OK,addr:f.remoteAddr.decapsulateCode(xt("p2p").code).bytes}}}catch(m){this.log.error("could not dial %p - %e",o,m),l=m.message}finally{f!=null&&await f.close()}}return{type:qe.MessageType.DIAL_RESPONSE,dialResponse:{status:qe.ResponseStatus.E_DIAL_ERROR,statusText:l,addr:u.bytes}}}getFirstUnverifiedMultiaddr(e,t){const n=this.components.addressManager.getAddressesWithMetadata().sort((i,s)=>i.type==="observed"&&s.type!=="observed"?1:s.type==="observed"&&i.type!=="observed"?-1:0).filter(i=>!(!(i.expires<Date.now())||i.multiaddr.toOptions().family===6&&(!t||!SE(i.multiaddr))||Ri(i.multiaddr)));for(const i of n){const s=i.multiaddr.toString();let o=this.dialResults.get(s);if(o!=null){if(o.networkSegments.includes(e)){this.log.trace("%a already has a network segment result from %s",o.multiaddr,e);continue}if(o.queue.size>10){this.log.trace("%a already has enough peers queued",o.multiaddr);continue}}if(o==null){const a=i.expires<Date.now();if(a&&this.addressFilter.remove?.(s),this.addressFilter.has(s))continue;this.addressFilter.add(s),this.log.trace("creating dial result %s %s",a?"to revalidate":"for",s),o={multiaddr:i.multiaddr,success:0,failure:0,networkSegments:[],verifyingPeers:NR(),queue:new Vu({concurrency:3,maxSize:50}),type:i.type,lastVerified:i.lastVerified},this.dialResults.set(s,o)}return o}}removeOutdatedMultiaddrResults(){const e=new Set(this.components.addressManager.getAddressesWithMetadata().filter(({expires:t})=>t<Date.now()).map(({multiaddr:t})=>t.toString()));for(const t of this.dialResults.keys())e.has(t)||(this.log.trace("remove results for %a",t),this.dialResults.delete(t))}async verifyExternalAddresses(e){if(!this.isStarted())return;this.removeOutdatedMultiaddrResults();const n=(await this.components.peerStore.get(e.remotePeer)).addresses.some(({multiaddr:o})=>o.toOptions().family===6),i=this.getNetworkSegment(e.remoteAddr),s=this.getFirstUnverifiedMultiaddr(i,n);if(s==null){this.log.trace("no unverified public addresses found for peer %p to verify, not requesting verification",e.remotePeer);return}if(!this.hasConnectionCapacity()){s.lastVerified!=null?(this.log("automatically re-verifying %a because we are too close to the connection limit",s.multiaddr),this.confirmAddress(s)):this.log("skipping verifying %a because we are too close to the connection limit",s.multiaddr);return}s.queue.add(async o=>{await this.askPeerToVerify(e,i,o)},{peerId:e.remotePeer,multiaddr:s.multiaddr}).catch(o=>{s?.result==null&&this.log.error("error from %p verifying address %a - %e",e.remotePeer,s?.multiaddr,o)})}async askPeerToVerify(e,t,n){let i=this.dialResults.get(n.multiaddr.toString());if(i==null){this.log("%a was verified while %p was queued",n.multiaddr,e.remotePeer);return}const s=AbortSignal.timeout(this.timeout);this.log.trace("asking %p to verify multiaddr %s",e.remotePeer,n.multiaddr);const o=await e.newStream(this.protocol,{signal:s});try{const a=Jt(o).pb(qe),[,c]=await Promise.all([a.write({type:qe.MessageType.DIAL,dial:{peer:{id:this.components.peerId.toMultihash().bytes,addrs:[n.multiaddr.bytes]}}},{signal:s}),a.read({signal:s})]);if(c.type!==qe.MessageType.DIAL_RESPONSE||c.dialResponse==null){this.log("invalid autonat response from %p - %j",e.remotePeer,c);return}const l=c.dialResponse.status;if(this.log.trace("autonat response from %p for %a is %s",e.remotePeer,n.multiaddr,l),l!==qe.ResponseStatus.OK&&l!==qe.ResponseStatus.E_DIAL_ERROR)return;if(i=this.dialResults.get(n.multiaddr.toString()),i==null){this.log.trace("peer reported %a as %s but there is no result object",n.multiaddr,c.dialResponse.status);return}if(i.networkSegments.includes(t)){this.log.trace("%a results included network segment %s",n.multiaddr,t);return}if(i.result!=null){this.log.trace("already resolved result for %a, ignoring response from",n.multiaddr,e.remotePeer);return}if(i.verifyingPeers.has(e.remotePeer)){this.log.trace("peer %p has already verified %a, ignoring response",e.remotePeer,n.multiaddr);return}if(i.verifyingPeers.add(e.remotePeer),i.networkSegments.push(t),l===qe.ResponseStatus.OK){if(i.success++,i.type!=="observed"){this.confirmAddress(i);return}}else l===qe.ResponseStatus.E_DIAL_ERROR&&i.failure++;this.log("%a success %d failure %d",i.multiaddr,i.success,i.failure),i.success===F8&&this.confirmAddress(i),i.failure===$8&&this.unconfirmAddress(i)}finally{try{await o.close({signal:s})}catch(a){o.abort(a)}}}hasConnectionCapacity(){const t=this.components.connectionManager.getConnections().length,n=this.components.connectionManager.getMaxConnections();return t/n*100<this.connectionThreshold}confirmAddress(e){this.log("%s address %a is externally dialable",e.type,e.multiaddr),this.components.addressManager.confirmObservedAddr(e.multiaddr),this.dialResults.delete(e.multiaddr.toString()),e.result=!0,e.queue.abort()}unconfirmAddress(e){this.log("%s address %a is not externally dialable",e.type,e.multiaddr),this.components.addressManager.removeObservedAddr(e.multiaddr),this.dialResults.delete(e.multiaddr.toString()),e.result=!1,e.queue.abort()}getNetworkSegment(e){const t=e.toOptions();return t.family===4?t.host.split(".")[0].padStart(3,"0"):t.host.split(":")[0].padStart(4,"0")}}function q8(r={}){return e=>new V8(e,r)}class j8{mode;connections;activeTransfer;finished;selectedFile;activePeerId;activeStream;transferConnectionId;constructor(){this.mode="idle",this.connections=new Map,this.activeTransfer=!1,this.finished=!1,this.selectedFile=null,this.activePeerId=null,this.activeStream=null,this.transferConnectionId=null}setMode(e){this.mode=e}getMode(){return this.mode}reset(){this.mode="idle",this.connections.clear(),this.activeTransfer=!1,this.finished=!1,this.selectedFile=null,this.activePeerId=null,this.activeStream=null,this.transferConnectionId=null}addConnection(e,t){const n=this.connections.get(e.toString())||new Map;n.set(t.id,t),this.connections.set(e.toString(),n)}removeConnection(e,t){const n=this.connections.get(e);n?.delete(t),n&&this.connections.set(e,n)}removeAllConnectionsWithPeer(e){this.connections.delete(e)}getConnectionsForPeer(e){return this.connections.get(e)}getAllConnections(){return Array.from(this.connections.values())}setActiveTransfer(){this.activeTransfer=!0}clearActiveTransfer(){this.activeTransfer=!1}isTransferActive(){return!!this.activeTransfer}setTransferConnectionId(e){this.transferConnectionId=e}getTransferConnectionId(){return this.transferConnectionId}setSelectedFile(e){this.selectedFile=e}getSelectedFile(){return this.selectedFile}clearSelectedFile(){this.selectedFile=null}setActivePeer(e){this.activePeerId=e}getActivePeer(){return this.activePeerId}setActiveStream(e){this.activeStream=e}getActiveStream(){return this.activeStream}isFinished(){return this.finished||!1}declareFinished(){this.finished=!0}}class z8{node;appState;errorHandler;config;fileTransferHandler;connectionUpgrades;retryAttempts;constructor(e,t,n,i,s){this.node=e,this.appState=t,this.errorHandler=n,this.config=i,this.fileTransferHandler=s,this.connectionUpgrades=new Map,this.retryAttempts=new Map}async onConnectionEstablished(e){const t=e.detail,n=t.remotePeer,i=n.toString(),s=t.remoteAddr.toString();if(console.log(`Connection OPENED with: ${i} on ${s}`),s.includes("/p2p-circuit")&&!s.includes("/webrtc")){const o=t.close.bind(t);let a=!0;t.close=async()=>{if(this.appState.isFinished())return o();if(a){console.log(`Blocking premature close of circuit connection to ${i}`);return}return o()},setTimeout(()=>{a=!1;const c=this.connectionUpgrades.get(i);c&&c.webrtc&&c.webrtc.status==="open"&&console.log("Allowing circuit connection closure - WebRTC established")},3e4)}this.appState.addConnection(n,t),this.connectionUpgrades.has(t.id)||this.connectionUpgrades.set(t.id,{relay:null,webrtc:null,upgrading:!1,stable:!1}),await this.handleConnectionType(t,i,s)}async onConnectionClosed(e){const t=e.detail.remotePeer.toString(),n=e.detail.id;this.connectionUpgrades.delete(n),this.appState.isTransferActive()&&t===this.appState.getActivePeer()&&this.appState.getTransferConnectionId()===n&&!this.appState.isFinished()&&(this.errorHandler.reconnecting(),this.appState.getMode()==="sender"?await this.onSenderConnectionError(e):this.appState.getMode()==="receiver"&&await this.onReceiverConnectionError(t)),this.appState.removeConnection(t,n)}async onReceiverConnectionError(e){const t=new Promise(i=>{const s=o=>{o.detail.remotePeer.toString()===e&&this.appState.isTransferActive()&&(this.node.removeEventListener("connection:open",s),i())};this.node.addEventListener("connection:open",s)}),n=new Promise(i=>{setTimeout(()=>{i()},3e4)});try{await Promise.race([t,n])}catch{}await this.fileTransferHandler.transferComplete(),this.errorHandler.tryAgainError()}async onSenderConnectionError(e){const t=e.detail.remotePeer.toString(),n=2e3;let i=this.retryAttempts.get(t)||0;for(;i<4;){console.log(`Attempting to reconnect to ${t}...`);try{await this.dialPeer(e.detail.remotePeer,{signal:AbortSignal.timeout(5e3)}),this.errorHandler.reconnected();break}catch{i++,this.retryAttempts.set(t,i),await new Promise(o=>setTimeout(o,n*i))}}i>=4&&(this.appState.declareFinished(),await this.node.stop(),this.errorHandler.tryAgainError())}async dialPeer(e,t={}){try{return await this.node.dial(e,t)}catch(n){throw n}}async closePeer(e){const t=this.appState.getConnectionsForPeer(e.toString());if(t)for(const n of t.values())n&&(await n.close(),t.delete(n.id))}async upgradeConnection(e){const t=this.connectionUpgrades.get(e);!t||t.upgrading||(t.upgrading=!0,t.relay&&t.webrtc&&setTimeout(()=>{},5e3))}async waitForWebRTCStream(e,t=3e4){const n=e;return n.channel?n.channel.readyState==="open"?e:new Promise((i,s)=>{const o=setTimeout(()=>{s(new Error("WebRTC stream open timeout"))},t),a=()=>{clearTimeout(o),n.channel.removeEventListener("open",a),n.channel.removeEventListener("error",c),i(e)},c=l=>{clearTimeout(o),n.channel.removeEventListener("open",a),n.channel.removeEventListener("error",c),s(l)};n.channel.addEventListener("open",a),n.channel.addEventListener("error",c)}):e}async handleConnectionType(e,t,n){const i=this.connectionUpgrades.get(e.id);if(!i)return;const s=this.config.getRelayAddress();if(n.includes("/p2p-circuit")&&!n.includes("/webrtc"))i.relay=e,console.log(`Relay connection established for ${t}`);else if(n.includes("/webrtc")){if(i.webrtc=e,this.appState.getMode()==="sender"&&this.appState.getSelectedFile()!=null){const o=he(n),a=await this.node.dialProtocol(o,this.config.getFileTransferProtocol());this.appState.setTransferConnectionId(e.id),this.appState.setActivePeer(t),this.appState.setActiveStream(await this.waitForWebRTCStream(a)),await this.waitForWebRTCStream(a).then(()=>{this.fileTransferHandler.startFileTransfer()})}console.log(`WebRTC connection established for ${t}`)}else n===s&&(i.relay=e,console.log(`Direct relay connection established for ${t}`))}}/**
 * @license
 * web-streams-polyfill v4.1.0
 * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
 * This code is released under the MIT license.
 * SPDX-License-Identifier: MIT
 */function ga(){}function at(r){return typeof r=="object"&&r!==null||typeof r=="function"}const XA=ga;function Se(r,e){try{Object.defineProperty(r,"name",{value:e,configurable:!0})}catch{}}const Fm=Promise,H8=Promise.resolve.bind(Fm),W8=Promise.prototype.then,K8=Promise.reject.bind(Fm),G8=H8;function It(r){return new Fm(r)}function Ce(r){return It(e=>e(r))}function se(r){return K8(r)}function Lr(r,e,t){return W8.call(r,e,t)}function kr(r,e,t){Lr(Lr(r,e,t),void 0,XA)}function $h(r,e){kr(r,e)}function Qp(r,e){kr(r,void 0,e)}function _i(r,e,t){return Lr(r,e,t)}function Za(r){Lr(r,void 0,XA)}let Ci=r=>{if(typeof queueMicrotask=="function")Ci=queueMicrotask;else{const e=Ce(void 0);Ci=t=>Lr(e,t)}return Ci(r)};function Qs(r,e,t){if(typeof r!="function")throw new TypeError("Argument is not a function");return Function.prototype.apply.call(r,e,t)}function yo(r,e,t){try{return Ce(Qs(r,e,t))}catch(n){return se(n)}}class gr{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push(e){const t=this._back;let n=t;t._elements.length===16383&&(n={_elements:[],_next:void 0}),t._elements.push(e),n!==t&&(this._back=n,t._next=n),++this._size}shift(){const e=this._front;let t=e;const n=this._cursor;let i=n+1;const s=e._elements,o=s[n];return i===16384&&(t=e._next,i=0),--this._size,this._cursor=i,e!==t&&(this._front=t),s[n]=void 0,o}forEach(e){let t=this._cursor,n=this._front,i=n._elements;for(;!(t===i.length&&n._next===void 0||t===i.length&&(n=n._next,i=n._elements,t=0,i.length===0));)e(i[t]),++t}peek(){const e=this._front,t=this._cursor;return e._elements[t]}}const ZA=Symbol("[[AbortSteps]]"),JA=Symbol("[[ErrorSteps]]"),$m=Symbol("[[CancelSteps]]"),Vm=Symbol("[[PullSteps]]"),qm=Symbol("[[ReleaseSteps]]");function ex(r,e){r._ownerReadableStream=e,e._reader=r,e._state==="readable"?Xp(r):e._state==="closed"?function(t){Xp(t),rx(t)}(r):tx(r,e._storedError)}function jm(r,e){return Er(r._ownerReadableStream,e)}function tn(r){const e=r._ownerReadableStream;e._state==="readable"?zm(r,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):function(t,n){tx(t,n)}(r,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),e._readableStreamController[qm](),e._reader=void 0,r._ownerReadableStream=void 0}function mu(r){return new TypeError("Cannot "+r+" a stream using a released reader")}function Xp(r){r._closedPromise=It((e,t)=>{r._closedPromise_resolve=e,r._closedPromise_reject=t})}function tx(r,e){Xp(r),zm(r,e)}function zm(r,e){r._closedPromise_reject!==void 0&&(Za(r._closedPromise),r._closedPromise_reject(e),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0)}function rx(r){r._closedPromise_resolve!==void 0&&(r._closedPromise_resolve(void 0),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0)}const J0=Number.isFinite||function(r){return typeof r=="number"&&isFinite(r)},Y8=Math.trunc||function(r){return r<0?Math.ceil(r):Math.floor(r)};function On(r,e){if(r!==void 0&&typeof(t=r)!="object"&&typeof t!="function")throw new TypeError(`${e} is not an object.`);var t}function ei(r,e){if(typeof r!="function")throw new TypeError(`${e} is not a function.`)}function nx(r,e){if(!function(t){return typeof t=="object"&&t!==null||typeof t=="function"}(r))throw new TypeError(`${e} is not an object.`)}function Wi(r,e,t){if(r===void 0)throw new TypeError(`Parameter ${e} is required in '${t}'.`)}function ev(r,e,t){if(r===void 0)throw new TypeError(`${e} is required in '${t}'.`)}function ix(r){return Number(r)}function tv(r){return r===0?0:r}function Hm(r,e){const t=Number.MAX_SAFE_INTEGER;let n=Number(r);if(n=tv(n),!J0(n))throw new TypeError(`${e} is not a finite number`);if(n=function(i){return tv(Y8(i))}(n),n<0||n>t)throw new TypeError(`${e} is outside the accepted range of 0 to ${t}, inclusive`);return J0(n)&&n!==0?n:0}function Wm(r,e){if(!An(r))throw new TypeError(`${e} is not a ReadableStream.`)}function vs(r){return new ci(r)}function sx(r,e){r._reader._readRequests.push(e)}function Km(r,e,t){const n=r._reader._readRequests.shift();t?n._closeSteps():n._chunkSteps(e)}function Nd(r){return r._reader._readRequests.length}function ox(r){const e=r._reader;return e!==void 0&&!!Bn(e)}class ci{constructor(e){if(Wi(e,1,"ReadableStreamDefaultReader"),Wm(e,"First parameter"),Nn(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");ex(this,e),this._readRequests=new gr}get closed(){return Bn(this)?this._closedPromise:se(Nc("closed"))}cancel(e=void 0){return Bn(this)?this._ownerReadableStream===void 0?se(mu("cancel")):jm(this,e):se(Nc("cancel"))}read(){if(!Bn(this))return se(Nc("read"));if(this._ownerReadableStream===void 0)return se(mu("read from"));let e,t;const n=It((i,s)=>{e=i,t=s});return ma(this,{_chunkSteps:i=>e({value:i,done:!1}),_closeSteps:()=>e({value:void 0,done:!0}),_errorSteps:i=>t(i)}),n}releaseLock(){if(!Bn(this))throw Nc("releaseLock");this._ownerReadableStream!==void 0&&function(e){tn(e);const t=new TypeError("Reader was released");ax(e,t)}(this)}}function Bn(r){return!!at(r)&&!!Object.prototype.hasOwnProperty.call(r,"_readRequests")&&r instanceof ci}function ma(r,e){const t=r._ownerReadableStream;t._disturbed=!0,t._state==="closed"?e._closeSteps():t._state==="errored"?e._errorSteps(t._storedError):t._readableStreamController[Vm](e)}function ax(r,e){const t=r._readRequests;r._readRequests=new gr,t.forEach(n=>{n._errorSteps(e)})}function Nc(r){return new TypeError(`ReadableStreamDefaultReader.prototype.${r} can only be used on a ReadableStreamDefaultReader`)}var Vh,qh,jh;function Ro(r){return r.slice()}function cx(r,e,t,n,i){new Uint8Array(r).set(new Uint8Array(t,n,i),e)}Object.defineProperties(ci.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),Se(ci.prototype.cancel,"cancel"),Se(ci.prototype.read,"read"),Se(ci.prototype.releaseLock,"releaseLock"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(ci.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0});let Ki=r=>(Ki=typeof r.transfer=="function"?e=>e.transfer():typeof structuredClone=="function"?e=>structuredClone(e,{transfer:[e]}):e=>e,Ki(r)),Gi=r=>(Gi=typeof r.detached=="boolean"?e=>e.detached:e=>e.byteLength===0,Gi(r));function lx(r,e,t){if(r.slice)return r.slice(e,t);const n=t-e,i=new ArrayBuffer(n);return cx(i,0,r,e,n),i}function Oo(r,e){const t=r[e];if(t!=null){if(typeof t!="function")throw new TypeError(`${String(e)} is not a function`);return t}}function rv(r){try{const e=r.done,t=r.value;return Lr(G8(t),n=>({done:e,value:n}))}catch(e){return se(e)}}const Ja=(jh=(Vh=Symbol.asyncIterator)!==null&&Vh!==void 0?Vh:(qh=Symbol.for)===null||qh===void 0?void 0:qh.call(Symbol,"Symbol.asyncIterator"))!==null&&jh!==void 0?jh:"@@asyncIterator";function ux(r,e="sync",t){if(t===void 0)if(e==="async"){if((t=Oo(r,Ja))===void 0)return function(i){const s={next(){let o;try{o=dx(i)}catch(a){return se(a)}return rv(o)},return(o){let a;try{const c=Oo(i.iterator,"return");if(c===void 0)return Ce({done:!0,value:o});a=Qs(c,i.iterator,[o])}catch(c){return se(c)}return at(a)?rv(a):se(new TypeError("The iterator.return() method must return an object"))}};return{iterator:s,nextMethod:s.next,done:!1}}(ux(r,"sync",Oo(r,Symbol.iterator)))}else t=Oo(r,Symbol.iterator);if(t===void 0)throw new TypeError("The object is not iterable");const n=Qs(t,r,[]);if(!at(n))throw new TypeError("The iterator method must return an object");return{iterator:n,nextMethod:n.next,done:!1}}function dx(r){const e=Qs(r.nextMethod,r.iterator,[]);if(!at(e))throw new TypeError("The iterator.next() method must return an object");return e}class hx{constructor(e,t){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=e,this._preventCancel=t}next(){const e=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?_i(this._ongoingPromise,e,e):e(),this._ongoingPromise}return(e){const t=()=>this._returnSteps(e);return this._ongoingPromise=this._ongoingPromise?_i(this._ongoingPromise,t,t):t(),this._ongoingPromise}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:!0});const e=this._reader;let t,n;const i=It((s,o)=>{t=s,n=o});return ma(e,{_chunkSteps:s=>{this._ongoingPromise=void 0,Ci(()=>t({value:s,done:!1}))},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,tn(e),t({value:void 0,done:!0})},_errorSteps:s=>{this._ongoingPromise=void 0,this._isFinished=!0,tn(e),n(s)}}),i}_returnSteps(e){if(this._isFinished)return Promise.resolve({value:e,done:!0});this._isFinished=!0;const t=this._reader;if(!this._preventCancel){const n=jm(t,e);return tn(t),_i(n,()=>({value:e,done:!0}))}return tn(t),Ce({value:e,done:!0})}}const fx={next(){return nv(this)?this._asyncIteratorImpl.next():se(iv("next"))},return(r){return nv(this)?this._asyncIteratorImpl.return(r):se(iv("return"))},[Ja](){return this}};function nv(r){if(!at(r)||!Object.prototype.hasOwnProperty.call(r,"_asyncIteratorImpl"))return!1;try{return r._asyncIteratorImpl instanceof hx}catch{return!1}}function iv(r){return new TypeError(`ReadableStreamAsyncIterator.${r} can only be used on a ReadableSteamAsyncIterator`)}Object.defineProperty(fx,Ja,{enumerable:!1});const px=Number.isNaN||function(r){return r!=r};function sv(r){const e=lx(r.buffer,r.byteOffset,r.byteOffset+r.byteLength);return new Uint8Array(e)}function Zp(r){const e=r._queue.shift();return r._queueTotalSize-=e.size,r._queueTotalSize<0&&(r._queueTotalSize=0),e.value}function Gm(r,e,t){if(typeof(n=t)!="number"||px(n)||n<0||t===1/0)throw new RangeError("Size must be a finite, non-NaN, non-negative number.");var n;r._queue.push({value:e,size:t}),r._queueTotalSize+=t}function ti(r){r._queue=new gr,r._queueTotalSize=0}function gx(r){return r===DataView}class hs{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!zh(this))throw Hh("view");return this._view}respond(e){if(!zh(this))throw Hh("respond");if(Wi(e,1,"respond"),e=Hm(e,"First parameter"),this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");if(Gi(this._view.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");Jc(this._associatedReadableByteStreamController,e)}respondWithNewView(e){if(!zh(this))throw Hh("respondWithNewView");if(Wi(e,1,"respondWithNewView"),!ArrayBuffer.isView(e))throw new TypeError("You can only respond with array buffer views");if(this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");if(Gi(e.buffer))throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");el(this._associatedReadableByteStreamController,e)}}Object.defineProperties(hs.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),Se(hs.prototype.respond,"respond"),Se(hs.prototype.respondWithNewView,"respondWithNewView"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(hs.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});class _n{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!li(this))throw Io("byobRequest");return eg(this)}get desiredSize(){if(!li(this))throw Io("desiredSize");return Cx(this)}close(){if(!li(this))throw Io("close");if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const e=this._controlledReadableByteStream._state;if(e!=="readable")throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`);Bo(this)}enqueue(e){if(!li(this))throw Io("enqueue");if(Wi(e,1,"enqueue"),!ArrayBuffer.isView(e))throw new TypeError("chunk must be an array buffer view");if(e.byteLength===0)throw new TypeError("chunk must have non-zero byteLength");if(e.buffer.byteLength===0)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw new TypeError("stream is closed or draining");const t=this._controlledReadableByteStream._state;if(t!=="readable")throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be enqueued to`);Zc(this,e)}error(e=void 0){if(!li(this))throw Io("error");ir(this,e)}[$m](e){mx(this),ti(this);const t=this._cancelAlgorithm(e);return Dd(this),t}[Vm](e){const t=this._controlledReadableByteStream;if(this._queueTotalSize>0)return void _x(this,e);const n=this._autoAllocateChunkSize;if(n!==void 0){let i;try{i=new ArrayBuffer(n)}catch(o){return void e._errorSteps(o)}const s={buffer:i,bufferByteLength:n,byteOffset:0,byteLength:n,bytesFilled:0,minimumFill:1,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(s)}sx(t,e),Zi(this)}[qm](){if(this._pendingPullIntos.length>0){const e=this._pendingPullIntos.peek();e.readerType="none",this._pendingPullIntos=new gr,this._pendingPullIntos.push(e)}}}function li(r){return!!at(r)&&!!Object.prototype.hasOwnProperty.call(r,"_controlledReadableByteStream")&&r instanceof _n}function zh(r){return!!at(r)&&!!Object.prototype.hasOwnProperty.call(r,"_associatedReadableByteStreamController")&&r instanceof hs}function Zi(r){if(function(t){const n=t._controlledReadableByteStream;return n._state!=="readable"||t._closeRequested||!t._started?!1:!!(ox(n)&&Nd(n)>0||Qm(n)&&Tx(n)>0||Cx(t)>0)}(r)){if(r._pulling)return void(r._pullAgain=!0);r._pulling=!0,kr(r._pullAlgorithm(),()=>(r._pulling=!1,r._pullAgain&&(r._pullAgain=!1,Zi(r)),null),t=>(ir(r,t),null))}}function mx(r){Ym(r),r._pendingPullIntos=new gr}function yx(r,e){let t=!1;r._state==="closed"&&(t=!0);const n=wx(e);e.readerType==="default"?Km(r,n,t):function(i,s,o){const a=i._reader,c=a._readIntoRequests.shift();o?c._closeSteps(s):c._chunkSteps(s)}(r,n,t)}function Qc(r,e){for(let t=0;t<e.length;++t)yx(r,e[t])}function wx(r){const e=r.bytesFilled,t=r.elementSize;return new r.viewConstructor(r.buffer,r.byteOffset,e/t)}function Xc(r,e,t,n){r._queue.push({buffer:e,byteOffset:t,byteLength:n}),r._queueTotalSize+=n}function bx(r,e,t,n){let i;try{i=lx(e,t,t+n)}catch(s){throw ir(r,s),s}Xc(r,i,0,n)}function vx(r,e){e.bytesFilled>0&&bx(r,e.buffer,e.byteOffset,e.bytesFilled),Ss(r)}function Sx(r,e){const t=Math.min(r._queueTotalSize,e.byteLength-e.bytesFilled),n=e.bytesFilled+t;let i=t,s=!1;const o=n-n%e.elementSize;o>=e.minimumFill&&(i=o-e.bytesFilled,s=!0);const a=r._queue;for(;i>0;){const c=a.peek(),l=Math.min(i,c.byteLength),u=e.byteOffset+e.bytesFilled;cx(e.buffer,u,c.buffer,c.byteOffset,l),c.byteLength===l?a.shift():(c.byteOffset+=l,c.byteLength-=l),r._queueTotalSize-=l,Ex(r,l,e),i-=l}return s}function Ex(r,e,t){t.bytesFilled+=e}function Ax(r){r._queueTotalSize===0&&r._closeRequested?(Dd(r),ec(r._controlledReadableByteStream)):Zi(r)}function Ym(r){r._byobRequest!==null&&(r._byobRequest._associatedReadableByteStreamController=void 0,r._byobRequest._view=null,r._byobRequest=null)}function Jp(r){const e=[];for(;r._pendingPullIntos.length>0&&r._queueTotalSize!==0;){const t=r._pendingPullIntos.peek();Sx(r,t)&&(Ss(r),e.push(t))}return e}function Q8(r,e,t,n){const i=r._controlledReadableByteStream,s=e.constructor,o=function(f){return gx(f)?1:f.BYTES_PER_ELEMENT}(s),{byteOffset:a,byteLength:c}=e,l=t*o;let u;try{u=Ki(e.buffer)}catch(f){return void n._errorSteps(f)}const d={buffer:u,bufferByteLength:u.byteLength,byteOffset:a,byteLength:c,bytesFilled:0,minimumFill:l,elementSize:o,viewConstructor:s,readerType:"byob"};if(r._pendingPullIntos.length>0)return r._pendingPullIntos.push(d),void ov(i,n);if(i._state!=="closed"){if(r._queueTotalSize>0){if(Sx(r,d)){const f=wx(d);return Ax(r),void n._chunkSteps(f)}if(r._closeRequested){const f=new TypeError("Insufficient bytes to fill elements in the given buffer");return ir(r,f),void n._errorSteps(f)}}r._pendingPullIntos.push(d),ov(i,n),Zi(r)}else{const f=new s(d.buffer,d.byteOffset,0);n._closeSteps(f)}}function xx(r,e){const t=r._pendingPullIntos.peek();Ym(r),r._controlledReadableByteStream._state==="closed"?function(n,i){i.readerType==="none"&&Ss(n);const s=n._controlledReadableByteStream;if(Qm(s)){const o=[];for(let a=0;a<Tx(s);++a)o.push(Ss(n));Qc(s,o)}}(r,t):function(n,i,s){if(Ex(0,i,s),s.readerType==="none"){vx(n,s);const c=Jp(n);return void Qc(n._controlledReadableByteStream,c)}if(s.bytesFilled<s.minimumFill)return;Ss(n);const o=s.bytesFilled%s.elementSize;if(o>0){const c=s.byteOffset+s.bytesFilled;bx(n,s.buffer,c-o,o)}s.bytesFilled-=o;const a=Jp(n);yx(n._controlledReadableByteStream,s),Qc(n._controlledReadableByteStream,a)}(r,e,t),Zi(r)}function Ss(r){return r._pendingPullIntos.shift()}function Dd(r){r._pullAlgorithm=void 0,r._cancelAlgorithm=void 0}function Bo(r){const e=r._controlledReadableByteStream;if(!r._closeRequested&&e._state==="readable")if(r._queueTotalSize>0)r._closeRequested=!0;else{if(r._pendingPullIntos.length>0){const t=r._pendingPullIntos.peek();if(t.bytesFilled%t.elementSize!=0){const n=new TypeError("Insufficient bytes to fill elements in the given buffer");throw ir(r,n),n}}Dd(r),ec(e)}}function Zc(r,e){const t=r._controlledReadableByteStream;if(r._closeRequested||t._state!=="readable")return;const{buffer:n,byteOffset:i,byteLength:s}=e;if(Gi(n))throw new TypeError("chunk's buffer is detached and so cannot be enqueued");const o=Ki(n);if(r._pendingPullIntos.length>0){const a=r._pendingPullIntos.peek();if(Gi(a.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");Ym(r),a.buffer=Ki(a.buffer),a.readerType==="none"&&vx(r,a)}if(ox(t))(function(a){const c=a._controlledReadableByteStream._reader;for(;c._readRequests.length>0;){if(a._queueTotalSize===0)return;_x(a,c._readRequests.shift())}})(r),Nd(t)===0?Xc(r,o,i,s):(r._pendingPullIntos.length>0&&Ss(r),Km(t,new Uint8Array(o,i,s),!1));else if(Qm(t)){Xc(r,o,i,s);const a=Jp(r);Qc(r._controlledReadableByteStream,a)}else Xc(r,o,i,s);Zi(r)}function ir(r,e){const t=r._controlledReadableByteStream;t._state==="readable"&&(mx(r),ti(r),Dd(r),Yx(t,e))}function _x(r,e){const t=r._queue.shift();r._queueTotalSize-=t.byteLength,Ax(r);const n=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);e._chunkSteps(n)}function eg(r){if(r._byobRequest===null&&r._pendingPullIntos.length>0){const e=r._pendingPullIntos.peek(),t=new Uint8Array(e.buffer,e.byteOffset+e.bytesFilled,e.byteLength-e.bytesFilled),n=Object.create(hs.prototype);(function(i,s,o){i._associatedReadableByteStreamController=s,i._view=o})(n,r,t),r._byobRequest=n}return r._byobRequest}function Cx(r){const e=r._controlledReadableByteStream._state;return e==="errored"?null:e==="closed"?0:r._strategyHWM-r._queueTotalSize}function Jc(r,e){const t=r._pendingPullIntos.peek();if(r._controlledReadableByteStream._state==="closed"){if(e!==0)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}else{if(e===0)throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");if(t.bytesFilled+e>t.byteLength)throw new RangeError("bytesWritten out of range")}t.buffer=Ki(t.buffer),xx(r,e)}function el(r,e){const t=r._pendingPullIntos.peek();if(r._controlledReadableByteStream._state==="closed"){if(e.byteLength!==0)throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream")}else if(e.byteLength===0)throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");if(t.byteOffset+t.bytesFilled!==e.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(t.bufferByteLength!==e.buffer.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");if(t.bytesFilled+e.byteLength>t.byteLength)throw new RangeError("The region specified by view is larger than byobRequest");const n=e.byteLength;t.buffer=Ki(e.buffer),xx(r,n)}function Ix(r,e,t,n,i,s,o){e._controlledReadableByteStream=r,e._pullAgain=!1,e._pulling=!1,e._byobRequest=null,e._queue=e._queueTotalSize=void 0,ti(e),e._closeRequested=!1,e._started=!1,e._strategyHWM=s,e._pullAlgorithm=n,e._cancelAlgorithm=i,e._autoAllocateChunkSize=o,e._pendingPullIntos=new gr,r._readableStreamController=e,kr(Ce(t()),()=>(e._started=!0,Zi(e),null),a=>(ir(e,a),null))}function Hh(r){return new TypeError(`ReadableStreamBYOBRequest.prototype.${r} can only be used on a ReadableStreamBYOBRequest`)}function Io(r){return new TypeError(`ReadableByteStreamController.prototype.${r} can only be used on a ReadableByteStreamController`)}function X8(r,e){if((r=`${r}`)!="byob")throw new TypeError(`${e} '${r}' is not a valid enumeration value for ReadableStreamReaderMode`);return r}function kx(r){return new ui(r)}function ov(r,e){r._reader._readIntoRequests.push(e)}function Tx(r){return r._reader._readIntoRequests.length}function Qm(r){const e=r._reader;return e!==void 0&&!!yi(e)}Object.defineProperties(_n.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),Se(_n.prototype.close,"close"),Se(_n.prototype.enqueue,"enqueue"),Se(_n.prototype.error,"error"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(_n.prototype,Symbol.toStringTag,{value:"ReadableByteStreamController",configurable:!0});class ui{constructor(e){if(Wi(e,1,"ReadableStreamBYOBReader"),Wm(e,"First parameter"),Nn(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");if(!li(e._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");ex(this,e),this._readIntoRequests=new gr}get closed(){return yi(this)?this._closedPromise:se(Dc("closed"))}cancel(e=void 0){return yi(this)?this._ownerReadableStream===void 0?se(mu("cancel")):jm(this,e):se(Dc("cancel"))}read(e,t={}){if(!yi(this))return se(Dc("read"));if(!ArrayBuffer.isView(e))return se(new TypeError("view must be an array buffer view"));if(e.byteLength===0)return se(new TypeError("view must have non-zero byteLength"));if(e.buffer.byteLength===0)return se(new TypeError("view's buffer must have non-zero byteLength"));if(Gi(e.buffer))return se(new TypeError("view's buffer has been detached"));let n;try{n=function(c,l){var u;return On(c,l),{min:Hm((u=c?.min)!==null&&u!==void 0?u:1,`${l} has member 'min' that`)}}(t,"options")}catch(c){return se(c)}const i=n.min;if(i===0)return se(new TypeError("options.min must be greater than 0"));if(function(c){return gx(c.constructor)}(e)){if(i>e.byteLength)return se(new RangeError("options.min must be less than or equal to view's byteLength"))}else if(i>e.length)return se(new RangeError("options.min must be less than or equal to view's length"));if(this._ownerReadableStream===void 0)return se(mu("read from"));let s,o;const a=It((c,l)=>{s=c,o=l});return Px(this,e,i,{_chunkSteps:c=>s({value:c,done:!1}),_closeSteps:c=>s({value:c,done:!0}),_errorSteps:c=>o(c)}),a}releaseLock(){if(!yi(this))throw Dc("releaseLock");this._ownerReadableStream!==void 0&&function(e){tn(e);const t=new TypeError("Reader was released");Rx(e,t)}(this)}}function yi(r){return!!at(r)&&!!Object.prototype.hasOwnProperty.call(r,"_readIntoRequests")&&r instanceof ui}function Px(r,e,t,n){const i=r._ownerReadableStream;i._disturbed=!0,i._state==="errored"?n._errorSteps(i._storedError):Q8(i._readableStreamController,e,t,n)}function Rx(r,e){const t=r._readIntoRequests;r._readIntoRequests=new gr,t.forEach(n=>{n._errorSteps(e)})}function Dc(r){return new TypeError(`ReadableStreamBYOBReader.prototype.${r} can only be used on a ReadableStreamBYOBReader`)}function tg(r,e){const{highWaterMark:t}=r;if(t===void 0)return e;if(px(t)||t<0)throw new RangeError("Invalid highWaterMark");return t}function Ox(r){const{size:e}=r;return e||(()=>1)}function Bx(r,e){On(r,e);const t=r?.highWaterMark,n=r?.size;return{highWaterMark:t===void 0?void 0:ix(t),size:n===void 0?void 0:Z8(n,`${e} has member 'size' that`)}}function Z8(r,e){return ei(r,e),t=>ix(r(t))}function J8(r,e,t){return ei(r,t),n=>yo(r,e,[n])}function e4(r,e,t){return ei(r,t),()=>yo(r,e,[])}function t4(r,e,t){return ei(r,t),n=>Qs(r,e,[n])}function r4(r,e,t){return ei(r,t),(n,i)=>yo(r,e,[n,i])}function Nx(r,e){if(!fs(r))throw new TypeError(`${e} is not a WritableStream.`)}Object.defineProperties(ui.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),Se(ui.prototype.cancel,"cancel"),Se(ui.prototype.read,"read"),Se(ui.prototype.releaseLock,"releaseLock"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(ui.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});class Cn{constructor(e={},t={}){e===void 0?e=null:nx(e,"First parameter");const n=Bx(t,"Second parameter"),i=function(o,a){On(o,a);const c=o?.abort,l=o?.close,u=o?.start,d=o?.type,f=o?.write;return{abort:c===void 0?void 0:J8(c,o,`${a} has member 'abort' that`),close:l===void 0?void 0:e4(l,o,`${a} has member 'close' that`),start:u===void 0?void 0:t4(u,o,`${a} has member 'start' that`),write:f===void 0?void 0:r4(f,o,`${a} has member 'write' that`),type:d}}(e,"First parameter");if(n4(this),i.type!==void 0)throw new RangeError("Invalid type is specified");const s=Ox(n);(function(o,a,c,l){const u=Object.create(wu.prototype);let d,f,m,g;d=a.start!==void 0?()=>a.start(u):()=>{},f=a.write!==void 0?y=>a.write(y,u):()=>Ce(void 0),m=a.close!==void 0?()=>a.close():()=>Ce(void 0),g=a.abort!==void 0?y=>a.abort(y):()=>Ce(void 0),s4(o,u,d,f,m,g,c,l)})(this,i,tg(n,1),s)}get locked(){if(!fs(this))throw Mc("locked");return Es(this)}abort(e=void 0){return fs(this)?Es(this)?se(new TypeError("Cannot abort a stream that already has a writer")):yu(this,e):se(Mc("abort"))}close(){return fs(this)?Es(this)?se(new TypeError("Cannot close a stream that already has a writer")):Mr(this)?se(new TypeError("Cannot close an already-closing stream")):Lx(this):se(Mc("close"))}getWriter(){if(!fs(this))throw Mc("getWriter");return Dx(this)}}function Dx(r){return new xn(r)}function n4(r){r._state="writable",r._storedError=void 0,r._writer=void 0,r._writableStreamController=void 0,r._writeRequests=new gr,r._inFlightWriteRequest=void 0,r._closeRequest=void 0,r._inFlightCloseRequest=void 0,r._pendingAbortRequest=void 0,r._backpressure=!1}function fs(r){return!!at(r)&&!!Object.prototype.hasOwnProperty.call(r,"_writableStreamController")&&r instanceof Cn}function Es(r){return r._writer!==void 0}function yu(r,e){var t;if(r._state==="closed"||r._state==="errored")return Ce(void 0);r._writableStreamController._abortReason=e,(t=r._writableStreamController._abortController)===null||t===void 0||t.abort(e);const n=r._state;if(n==="closed"||n==="errored")return Ce(void 0);if(r._pendingAbortRequest!==void 0)return r._pendingAbortRequest._promise;let i=!1;n==="erroring"&&(i=!0,e=void 0);const s=It((o,a)=>{r._pendingAbortRequest={_promise:void 0,_resolve:o,_reject:a,_reason:e,_wasAlreadyErroring:i}});return r._pendingAbortRequest._promise=s,i||Xm(r,e),s}function Lx(r){const e=r._state;if(e==="closed"||e==="errored")return se(new TypeError(`The stream (in ${e} state) is not in the writable state and cannot be closed`));const t=It((s,o)=>{const a={_resolve:s,_reject:o};r._closeRequest=a}),n=r._writer;var i;return n!==void 0&&r._backpressure&&e==="writable"&&ry(n),Gm(i=r._writableStreamController,Vx,0),Ld(i),t}function rg(r,e){r._state!=="writable"?Zm(r):Xm(r,e)}function Xm(r,e){const t=r._writableStreamController;r._state="erroring",r._storedError=e;const n=r._writer;n!==void 0&&Ux(n,e),!function(i){return!(i._inFlightWriteRequest===void 0&&i._inFlightCloseRequest===void 0)}(r)&&t._started&&Zm(r)}function Zm(r){r._state="errored",r._writableStreamController[JA]();const e=r._storedError;if(r._writeRequests.forEach(n=>{n._reject(e)}),r._writeRequests=new gr,r._pendingAbortRequest===void 0)return void Lc(r);const t=r._pendingAbortRequest;if(r._pendingAbortRequest=void 0,t._wasAlreadyErroring)return t._reject(e),void Lc(r);kr(r._writableStreamController[ZA](t._reason),()=>(t._resolve(),Lc(r),null),n=>(t._reject(n),Lc(r),null))}function Mr(r){return r._closeRequest!==void 0||r._inFlightCloseRequest!==void 0}function Lc(r){r._closeRequest!==void 0&&(r._closeRequest._reject(r._storedError),r._closeRequest=void 0);const e=r._writer;e!==void 0&&ty(e,r._storedError)}function Jm(r,e){const t=r._writer;t!==void 0&&e!==r._backpressure&&(e?function(n){Md(n)}(t):ry(t)),r._backpressure=e}Object.defineProperties(Cn.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),Se(Cn.prototype.abort,"abort"),Se(Cn.prototype.close,"close"),Se(Cn.prototype.getWriter,"getWriter"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Cn.prototype,Symbol.toStringTag,{value:"WritableStream",configurable:!0});class xn{constructor(e){if(Wi(e,1,"WritableStreamDefaultWriter"),Nx(e,"First parameter"),Es(e))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=e,e._writer=this;const t=e._state;if(t==="writable")!Mr(e)&&e._backpressure?Md(this):av(this),tl(this);else if(t==="erroring")ig(this,e._storedError),tl(this);else if(t==="closed")av(this),tl(n=this),Hx(n);else{const i=e._storedError;ig(this,i),zx(this,i)}var n}get closed(){return ni(this)?this._closedPromise:se(ii("closed"))}get desiredSize(){if(!ni(this))throw ii("desiredSize");if(this._ownerWritableStream===void 0)throw No("desiredSize");return function(e){const t=e._ownerWritableStream,n=t._state;return n==="errored"||n==="erroring"?null:n==="closed"?0:qx(t._writableStreamController)}(this)}get ready(){return ni(this)?this._readyPromise:se(ii("ready"))}abort(e=void 0){return ni(this)?this._ownerWritableStream===void 0?se(No("abort")):function(t,n){return yu(t._ownerWritableStream,n)}(this,e):se(ii("abort"))}close(){if(!ni(this))return se(ii("close"));const e=this._ownerWritableStream;return e===void 0?se(No("close")):Mr(e)?se(new TypeError("Cannot close an already-closing stream")):Mx(this)}releaseLock(){if(!ni(this))throw ii("releaseLock");this._ownerWritableStream!==void 0&&Fx(this)}write(e=void 0){return ni(this)?this._ownerWritableStream===void 0?se(No("write to")):$x(this,e):se(ii("write"))}}function ni(r){return!!at(r)&&!!Object.prototype.hasOwnProperty.call(r,"_ownerWritableStream")&&r instanceof xn}function Mx(r){return Lx(r._ownerWritableStream)}function i4(r,e){r._closedPromiseState==="pending"?ty(r,e):function(t,n){zx(t,n)}(r,e)}function Ux(r,e){r._readyPromiseState==="pending"?Wx(r,e):function(t,n){ig(t,n)}(r,e)}function Fx(r){const e=r._ownerWritableStream,t=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");Ux(r,t),i4(r,t),e._writer=void 0,r._ownerWritableStream=void 0}function $x(r,e){const t=r._ownerWritableStream,n=t._writableStreamController,i=function(a,c){if(a._strategySizeAlgorithm===void 0)return 1;try{return a._strategySizeAlgorithm(c)}catch(l){return ng(a,l),1}}(n,e);if(t!==r._ownerWritableStream)return se(No("write to"));const s=t._state;if(s==="errored")return se(t._storedError);if(Mr(t)||s==="closed")return se(new TypeError("The stream is closing or closed and cannot be written to"));if(s==="erroring")return se(t._storedError);const o=function(a){return It((c,l)=>{const u={_resolve:c,_reject:l};a._writeRequests.push(u)})}(t);return function(a,c,l){try{Gm(a,c,l)}catch(d){return void ng(a,d)}const u=a._controlledWritableStream;!Mr(u)&&u._state==="writable"&&Jm(u,ey(a)),Ld(a)}(n,e,i),o}Object.defineProperties(xn.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),Se(xn.prototype.abort,"abort"),Se(xn.prototype.close,"close"),Se(xn.prototype.releaseLock,"releaseLock"),Se(xn.prototype.write,"write"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(xn.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});const Vx={};class wu{constructor(){throw new TypeError("Illegal constructor")}get abortReason(){if(!Wh(this))throw Kh("abortReason");return this._abortReason}get signal(){if(!Wh(this))throw Kh("signal");if(this._abortController===void 0)throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");return this._abortController.signal}error(e=void 0){if(!Wh(this))throw Kh("error");this._controlledWritableStream._state==="writable"&&jx(this,e)}[ZA](e){const t=this._abortAlgorithm(e);return bu(this),t}[JA](){ti(this)}}function Wh(r){return!!at(r)&&!!Object.prototype.hasOwnProperty.call(r,"_controlledWritableStream")&&r instanceof wu}function s4(r,e,t,n,i,s,o,a){e._controlledWritableStream=r,r._writableStreamController=e,e._queue=void 0,e._queueTotalSize=void 0,ti(e),e._abortReason=void 0,e._abortController=function(){if(typeof AbortController=="function")return new AbortController}(),e._started=!1,e._strategySizeAlgorithm=a,e._strategyHWM=o,e._writeAlgorithm=n,e._closeAlgorithm=i,e._abortAlgorithm=s;const c=ey(e);Jm(r,c),kr(Ce(t()),()=>(e._started=!0,Ld(e),null),l=>(e._started=!0,rg(r,l),null))}function bu(r){r._writeAlgorithm=void 0,r._closeAlgorithm=void 0,r._abortAlgorithm=void 0,r._strategySizeAlgorithm=void 0}function qx(r){return r._strategyHWM-r._queueTotalSize}function Ld(r){const e=r._controlledWritableStream;if(!r._started||e._inFlightWriteRequest!==void 0)return;if(e._state==="erroring")return void Zm(e);if(r._queue.length===0)return;const t=r._queue.peek().value;t===Vx?function(n){const i=n._controlledWritableStream;(function(o){o._inFlightCloseRequest=o._closeRequest,o._closeRequest=void 0})(i),Zp(n);const s=n._closeAlgorithm();bu(n),kr(s,()=>(function(o){o._inFlightCloseRequest._resolve(void 0),o._inFlightCloseRequest=void 0,o._state==="erroring"&&(o._storedError=void 0,o._pendingAbortRequest!==void 0&&(o._pendingAbortRequest._resolve(),o._pendingAbortRequest=void 0)),o._state="closed";const a=o._writer;a!==void 0&&Hx(a)}(i),null),o=>(function(a,c){a._inFlightCloseRequest._reject(c),a._inFlightCloseRequest=void 0,a._pendingAbortRequest!==void 0&&(a._pendingAbortRequest._reject(c),a._pendingAbortRequest=void 0),rg(a,c)}(i,o),null))}(r):function(n,i){const s=n._controlledWritableStream;(function(a){a._inFlightWriteRequest=a._writeRequests.shift()})(s);const o=n._writeAlgorithm(i);kr(o,()=>{(function(c){c._inFlightWriteRequest._resolve(void 0),c._inFlightWriteRequest=void 0})(s);const a=s._state;if(Zp(n),!Mr(s)&&a==="writable"){const c=ey(n);Jm(s,c)}return Ld(n),null},a=>(s._state==="writable"&&bu(n),function(c,l){c._inFlightWriteRequest._reject(l),c._inFlightWriteRequest=void 0,rg(c,l)}(s,a),null))}(r,t)}function ng(r,e){r._controlledWritableStream._state==="writable"&&jx(r,e)}function ey(r){return qx(r)<=0}function jx(r,e){const t=r._controlledWritableStream;bu(r),Xm(t,e)}function Mc(r){return new TypeError(`WritableStream.prototype.${r} can only be used on a WritableStream`)}function Kh(r){return new TypeError(`WritableStreamDefaultController.prototype.${r} can only be used on a WritableStreamDefaultController`)}function ii(r){return new TypeError(`WritableStreamDefaultWriter.prototype.${r} can only be used on a WritableStreamDefaultWriter`)}function No(r){return new TypeError("Cannot "+r+" a stream using a released writer")}function tl(r){r._closedPromise=It((e,t)=>{r._closedPromise_resolve=e,r._closedPromise_reject=t,r._closedPromiseState="pending"})}function zx(r,e){tl(r),ty(r,e)}function ty(r,e){r._closedPromise_reject!==void 0&&(Za(r._closedPromise),r._closedPromise_reject(e),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0,r._closedPromiseState="rejected")}function Hx(r){r._closedPromise_resolve!==void 0&&(r._closedPromise_resolve(void 0),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0,r._closedPromiseState="resolved")}function Md(r){r._readyPromise=It((e,t)=>{r._readyPromise_resolve=e,r._readyPromise_reject=t}),r._readyPromiseState="pending"}function ig(r,e){Md(r),Wx(r,e)}function av(r){Md(r),ry(r)}function Wx(r,e){r._readyPromise_reject!==void 0&&(Za(r._readyPromise),r._readyPromise_reject(e),r._readyPromise_resolve=void 0,r._readyPromise_reject=void 0,r._readyPromiseState="rejected")}function ry(r){r._readyPromise_resolve!==void 0&&(r._readyPromise_resolve(void 0),r._readyPromise_resolve=void 0,r._readyPromise_reject=void 0,r._readyPromiseState="fulfilled")}Object.defineProperties(wu.prototype,{abortReason:{enumerable:!0},signal:{enumerable:!0},error:{enumerable:!0}}),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(wu.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});const cv=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof global<"u"?global:void 0,o4=function(){const r=cv?.DOMException;return function(e){if(typeof e!="function"&&typeof e!="object"||e.name!=="DOMException")return!1;try{return new e,!0}catch{return!1}}(r)?r:void 0}()||function(){const r=function(e,t){this.message=e||"",this.name=t||"Error",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)};return Se(r,"DOMException"),r.prototype=Object.create(Error.prototype),Object.defineProperty(r.prototype,"constructor",{value:r,writable:!0,configurable:!0}),r}();function lv(r,e,t,n,i,s){const o=vs(r),a=Dx(e);r._disturbed=!0;let c=!1,l=Ce(void 0);return It((u,d)=>{let f;if(s!==void 0){if(f=()=>{const A=s.reason!==void 0?s.reason:new o4("Aborted","AbortError"),R=[];n||R.push(()=>e._state==="writable"?yu(e,A):Ce(void 0)),i||R.push(()=>r._state==="readable"?Er(r,A):Ce(void 0)),T(()=>Promise.all(R.map(C=>C())),!0,A)},s.aborted)return void f();s.addEventListener("abort",f)}var m,g,y;if(x(r,o._closedPromise,A=>(n?v(!0,A):T(()=>yu(e,A),!0,A),null)),x(e,a._closedPromise,A=>(i?v(!0,A):T(()=>Er(r,A),!0,A),null)),m=r,g=o._closedPromise,y=()=>(t?v():T(()=>function(A){const R=A._ownerWritableStream,C=R._state;return Mr(R)||C==="closed"?Ce(void 0):C==="errored"?se(R._storedError):Mx(A)}(a)),null),m._state==="closed"?y():$h(g,y),Mr(e)||e._state==="closed"){const A=new TypeError("the destination writable stream closed before all data could be piped to it");i?v(!0,A):T(()=>Er(r,A),!0,A)}function w(){const A=l;return Lr(l,()=>A!==l?w():void 0)}function x(A,R,C){A._state==="errored"?C(A._storedError):Qp(R,C)}function T(A,R,C){function P(){return kr(A(),()=>b(R,C),D=>b(!0,D)),null}c||(c=!0,e._state!=="writable"||Mr(e)?P():$h(w(),P))}function v(A,R){c||(c=!0,e._state!=="writable"||Mr(e)?b(A,R):$h(w(),()=>b(A,R)))}function b(A,R){return Fx(a),tn(o),s!==void 0&&s.removeEventListener("abort",f),A?d(R):u(void 0),null}Za(It((A,R)=>{(function C(P){P?A():Lr(c?Ce(!0):Lr(a._readyPromise,()=>It((D,z)=>{ma(o,{_chunkSteps:$=>{l=Lr($x(a,$),void 0,ga),D(!1)},_closeSteps:()=>D(!0),_errorSteps:z})})),C,R)})(!1)}))})}class In{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!Uc(this))throw Fc("desiredSize");return ny(this)}close(){if(!Uc(this))throw Fc("close");if(!Js(this))throw new TypeError("The stream is not in a state that permits close");Xs(this)}enqueue(e=void 0){if(!Uc(this))throw Fc("enqueue");if(!Js(this))throw new TypeError("The stream is not in a state that permits enqueue");return Zs(this,e)}error(e=void 0){if(!Uc(this))throw Fc("error");Yn(this,e)}[$m](e){ti(this);const t=this._cancelAlgorithm(e);return vu(this),t}[Vm](e){const t=this._controlledReadableStream;if(this._queue.length>0){const n=Zp(this);this._closeRequested&&this._queue.length===0?(vu(this),ec(t)):ya(this),e._chunkSteps(n)}else sx(t,e),ya(this)}[qm](){}}function Uc(r){return!!at(r)&&!!Object.prototype.hasOwnProperty.call(r,"_controlledReadableStream")&&r instanceof In}function ya(r){if(Kx(r)){if(r._pulling)return void(r._pullAgain=!0);r._pulling=!0,kr(r._pullAlgorithm(),()=>(r._pulling=!1,r._pullAgain&&(r._pullAgain=!1,ya(r)),null),e=>(Yn(r,e),null))}}function Kx(r){const e=r._controlledReadableStream;return!Js(r)||!r._started?!1:Nn(e)&&Nd(e)>0?!0:ny(r)>0}function vu(r){r._pullAlgorithm=void 0,r._cancelAlgorithm=void 0,r._strategySizeAlgorithm=void 0}function Xs(r){if(!Js(r))return;const e=r._controlledReadableStream;r._closeRequested=!0,r._queue.length===0&&(vu(r),ec(e))}function Zs(r,e){if(!Js(r))return;const t=r._controlledReadableStream;if(Nn(t)&&Nd(t)>0)Km(t,e,!1);else{let n;try{n=r._strategySizeAlgorithm(e)}catch(i){throw Yn(r,i),i}try{Gm(r,e,n)}catch(i){throw Yn(r,i),i}}ya(r)}function Yn(r,e){const t=r._controlledReadableStream;t._state==="readable"&&(ti(r),vu(r),Yx(t,e))}function ny(r){const e=r._controlledReadableStream._state;return e==="errored"?null:e==="closed"?0:r._strategyHWM-r._queueTotalSize}function Js(r){const e=r._controlledReadableStream._state;return!r._closeRequested&&e==="readable"}function Gx(r,e,t,n,i,s,o){e._controlledReadableStream=r,e._queue=void 0,e._queueTotalSize=void 0,ti(e),e._started=!1,e._closeRequested=!1,e._pullAgain=!1,e._pulling=!1,e._strategySizeAlgorithm=o,e._strategyHWM=s,e._pullAlgorithm=n,e._cancelAlgorithm=i,r._readableStreamController=e,kr(Ce(t()),()=>(e._started=!0,ya(e),null),a=>(Yn(e,a),null))}function Fc(r){return new TypeError(`ReadableStreamDefaultController.prototype.${r} can only be used on a ReadableStreamDefaultController`)}function a4(r,e){return li(r._readableStreamController)?function(t){let n,i,s,o,a,c=vs(t),l=!1,u=!1,d=!1,f=!1,m=!1;const g=It(C=>{a=C});function y(C){Qp(C._closedPromise,P=>(C!==c||(ir(s._readableStreamController,P),ir(o._readableStreamController,P),f&&m||a(void 0)),null))}function w(){yi(c)&&(tn(c),c=vs(t),y(c)),ma(c,{_chunkSteps:C=>{Ci(()=>{u=!1,d=!1;const P=C;let D=C;if(!f&&!m)try{D=sv(C)}catch(z){return ir(s._readableStreamController,z),ir(o._readableStreamController,z),void a(Er(t,z))}f||Zc(s._readableStreamController,P),m||Zc(o._readableStreamController,D),l=!1,u?T():d&&v()})},_closeSteps:()=>{l=!1,f||Bo(s._readableStreamController),m||Bo(o._readableStreamController),s._readableStreamController._pendingPullIntos.length>0&&Jc(s._readableStreamController,0),o._readableStreamController._pendingPullIntos.length>0&&Jc(o._readableStreamController,0),f&&m||a(void 0)},_errorSteps:()=>{l=!1}})}function x(C,P){Bn(c)&&(tn(c),c=kx(t),y(c));const D=P?o:s,z=P?s:o;Px(c,C,1,{_chunkSteps:$=>{Ci(()=>{u=!1,d=!1;const j=P?m:f;if(P?f:m)j||el(D._readableStreamController,$);else{let q;try{q=sv($)}catch(ie){return ir(D._readableStreamController,ie),ir(z._readableStreamController,ie),void a(Er(t,ie))}j||el(D._readableStreamController,$),Zc(z._readableStreamController,q)}l=!1,u?T():d&&v()})},_closeSteps:$=>{l=!1;const j=P?m:f,q=P?f:m;j||Bo(D._readableStreamController),q||Bo(z._readableStreamController),$!==void 0&&(j||el(D._readableStreamController,$),!q&&z._readableStreamController._pendingPullIntos.length>0&&Jc(z._readableStreamController,0)),j&&q||a(void 0)},_errorSteps:()=>{l=!1}})}function T(){if(l)return u=!0,Ce(void 0);l=!0;const C=eg(s._readableStreamController);return C===null?w():x(C._view,!1),Ce(void 0)}function v(){if(l)return d=!0,Ce(void 0);l=!0;const C=eg(o._readableStreamController);return C===null?w():x(C._view,!0),Ce(void 0)}function b(C){if(f=!0,n=C,m){const P=Ro([n,i]),D=Er(t,P);a(D)}return g}function A(C){if(m=!0,i=C,f){const P=Ro([n,i]),D=Er(t,P);a(D)}return g}function R(){}return s=dv(R,T,b),o=dv(R,v,A),y(c),[s,o]}(r):function(t,n){const i=vs(t);let s,o,a,c,l,u=!1,d=!1,f=!1,m=!1;const g=It(v=>{l=v});function y(){return u?(d=!0,Ce(void 0)):(u=!0,ma(i,{_chunkSteps:v=>{Ci(()=>{d=!1;const b=v,A=v;f||Zs(a._readableStreamController,b),m||Zs(c._readableStreamController,A),u=!1,d&&y()})},_closeSteps:()=>{u=!1,f||Xs(a._readableStreamController),m||Xs(c._readableStreamController),f&&m||l(void 0)},_errorSteps:()=>{u=!1}}),Ce(void 0))}function w(v){if(f=!0,s=v,m){const b=Ro([s,o]),A=Er(t,b);l(A)}return g}function x(v){if(m=!0,o=v,f){const b=Ro([s,o]),A=Er(t,b);l(A)}return g}function T(){}return a=Su(T,y,w),c=Su(T,y,x),Qp(i._closedPromise,v=>(Yn(a._readableStreamController,v),Yn(c._readableStreamController,v),f&&m||l(void 0),null)),[a,c]}(r)}function c4(r){return at(e=r)&&e.getReader!==void 0?function(t){let n;function i(){let o;try{o=t.read()}catch(a){return se(a)}return _i(o,a=>{if(!at(a))throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");if(a.done)Xs(n._readableStreamController);else{const c=a.value;Zs(n._readableStreamController,c)}})}function s(o){try{return Ce(t.cancel(o))}catch(a){return se(a)}}return n=Su(ga,i,s,0),n}(r.getReader()):function(t){let n;const i=ux(t,"async");function s(){let a;try{a=dx(i)}catch(c){return se(c)}return _i(Ce(a),c=>{if(!at(c))throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");if(c.done)Xs(n._readableStreamController);else{const l=c.value;Zs(n._readableStreamController,l)}})}function o(a){const c=i.iterator;let l;try{l=Oo(c,"return")}catch(u){return se(u)}return l===void 0?Ce(void 0):_i(yo(l,c,[a]),u=>{if(!at(u))throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object")})}return n=Su(ga,s,o,0),n}(r);var e}function l4(r,e,t){return ei(r,t),n=>yo(r,e,[n])}function u4(r,e,t){return ei(r,t),n=>yo(r,e,[n])}function d4(r,e,t){return ei(r,t),n=>Qs(r,e,[n])}function h4(r,e){if((r=`${r}`)!="bytes")throw new TypeError(`${e} '${r}' is not a valid enumeration value for ReadableStreamType`);return r}function uv(r,e){On(r,e);const t=r?.preventAbort,n=r?.preventCancel,i=r?.preventClose,s=r?.signal;return s!==void 0&&function(o,a){if(!function(c){if(typeof c!="object"||c===null)return!1;try{return typeof c.aborted=="boolean"}catch{return!1}}(o))throw new TypeError(`${a} is not an AbortSignal.`)}(s,`${e} has member 'signal' that`),{preventAbort:!!t,preventCancel:!!n,preventClose:!!i,signal:s}}Object.defineProperties(In.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),Se(In.prototype.close,"close"),Se(In.prototype.enqueue,"enqueue"),Se(In.prototype.error,"error"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(In.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});let Tt=class{constructor(e={},t={}){e===void 0?e=null:nx(e,"First parameter");const n=Bx(t,"Second parameter"),i=function(s,o){On(s,o);const a=s,c=a?.autoAllocateChunkSize,l=a?.cancel,u=a?.pull,d=a?.start,f=a?.type;return{autoAllocateChunkSize:c===void 0?void 0:Hm(c,`${o} has member 'autoAllocateChunkSize' that`),cancel:l===void 0?void 0:l4(l,a,`${o} has member 'cancel' that`),pull:u===void 0?void 0:u4(u,a,`${o} has member 'pull' that`),start:d===void 0?void 0:d4(d,a,`${o} has member 'start' that`),type:f===void 0?void 0:h4(f,`${o} has member 'type' that`)}}(e,"First parameter");if(iy(this),i.type==="bytes"){if(n.size!==void 0)throw new RangeError("The strategy for a byte stream cannot have a size function");(function(s,o,a){const c=Object.create(_n.prototype);let l,u,d;l=o.start!==void 0?()=>o.start(c):()=>{},u=o.pull!==void 0?()=>o.pull(c):()=>Ce(void 0),d=o.cancel!==void 0?m=>o.cancel(m):()=>Ce(void 0);const f=o.autoAllocateChunkSize;if(f===0)throw new TypeError("autoAllocateChunkSize must be greater than 0");Ix(s,c,l,u,d,a,f)})(this,i,tg(n,0))}else{const s=Ox(n);(function(o,a,c,l){const u=Object.create(In.prototype);let d,f,m;d=a.start!==void 0?()=>a.start(u):()=>{},f=a.pull!==void 0?()=>a.pull(u):()=>Ce(void 0),m=a.cancel!==void 0?g=>a.cancel(g):()=>Ce(void 0),Gx(o,u,d,f,m,c,l)})(this,i,tg(n,1),s)}}get locked(){if(!An(this))throw si("locked");return Nn(this)}cancel(e=void 0){return An(this)?Nn(this)?se(new TypeError("Cannot cancel a stream that already has a reader")):Er(this,e):se(si("cancel"))}getReader(e=void 0){if(!An(this))throw si("getReader");return function(t,n){On(t,n);const i=t?.mode;return{mode:i===void 0?void 0:X8(i,`${n} has member 'mode' that`)}}(e,"First parameter").mode===void 0?vs(this):kx(this)}pipeThrough(e,t={}){if(!An(this))throw si("pipeThrough");Wi(e,1,"pipeThrough");const n=function(s,o){On(s,o);const a=s?.readable;ev(a,"readable","ReadableWritablePair"),Wm(a,`${o} has member 'readable' that`);const c=s?.writable;return ev(c,"writable","ReadableWritablePair"),Nx(c,`${o} has member 'writable' that`),{readable:a,writable:c}}(e,"First parameter"),i=uv(t,"Second parameter");if(Nn(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(Es(n.writable))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");return Za(lv(this,n.writable,i.preventClose,i.preventAbort,i.preventCancel,i.signal)),n.readable}pipeTo(e,t={}){if(!An(this))return se(si("pipeTo"));if(e===void 0)return se("Parameter 1 is required in 'pipeTo'.");if(!fs(e))return se(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));let n;try{n=uv(t,"Second parameter")}catch(i){return se(i)}return Nn(this)?se(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):Es(e)?se(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):lv(this,e,n.preventClose,n.preventAbort,n.preventCancel,n.signal)}tee(){if(!An(this))throw si("tee");return Ro(a4(this))}values(e=void 0){if(!An(this))throw si("values");return function(t,n){const i=vs(t),s=new hx(i,n),o=Object.create(fx);return o._asyncIteratorImpl=s,o}(this,function(t,n){return On(t,n),{preventCancel:!!t?.preventCancel}}(e,"First parameter").preventCancel)}[Ja](e){return this.values(e)}static from(e){return c4(e)}};function Su(r,e,t,n=1,i=()=>1){const s=Object.create(Tt.prototype);return iy(s),Gx(s,Object.create(In.prototype),r,e,t,n,i),s}function dv(r,e,t){const n=Object.create(Tt.prototype);return iy(n),Ix(n,Object.create(_n.prototype),r,e,t,0,void 0),n}function iy(r){r._state="readable",r._reader=void 0,r._storedError=void 0,r._disturbed=!1}function An(r){return!!at(r)&&!!Object.prototype.hasOwnProperty.call(r,"_readableStreamController")&&r instanceof Tt}function Nn(r){return r._reader!==void 0}function Er(r,e){if(r._disturbed=!0,r._state==="closed")return Ce(void 0);if(r._state==="errored")return se(r._storedError);ec(r);const t=r._reader;if(t!==void 0&&yi(t)){const n=t._readIntoRequests;t._readIntoRequests=new gr,n.forEach(i=>{i._closeSteps(void 0)})}return _i(r._readableStreamController[$m](e),ga)}function ec(r){r._state="closed";const e=r._reader;if(e!==void 0&&(rx(e),Bn(e))){const t=e._readRequests;e._readRequests=new gr,t.forEach(n=>{n._closeSteps()})}}function Yx(r,e){r._state="errored",r._storedError=e;const t=r._reader;t!==void 0&&(zm(t,e),Bn(t)?ax(t,e):Rx(t,e))}function si(r){return new TypeError(`ReadableStream.prototype.${r} can only be used on a ReadableStream`)}Object.defineProperties(Tt,{from:{enumerable:!0}}),Object.defineProperties(Tt.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),Se(Tt.from,"from"),Se(Tt.prototype.cancel,"cancel"),Se(Tt.prototype.getReader,"getReader"),Se(Tt.prototype.pipeThrough,"pipeThrough"),Se(Tt.prototype.pipeTo,"pipeTo"),Se(Tt.prototype.tee,"tee"),Se(Tt.prototype.values,"values"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Tt.prototype,Symbol.toStringTag,{value:"ReadableStream",configurable:!0}),Object.defineProperty(Tt.prototype,Ja,{value:Tt.prototype.values,writable:!0,configurable:!0});const f4=r=>r.byteLength;Se(f4,"size");const p4=()=>1;Se(p4,"size");function g4(r,e){Yn(r._readable._readableStreamController,e),sy(r,e)}function sy(r,e){y4(r._transformStreamController),ng(r._writable._writableStreamController,e),m4(r)}function m4(r){r._backpressure&&Qx(r,!1)}function Qx(r,e){r._backpressureChangePromise!==void 0&&r._backpressureChangePromise_resolve(),r._backpressureChangePromise=It(t=>{r._backpressureChangePromise_resolve=t}),r._backpressure=e}class as{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!$c(this))throw Vc("desiredSize");return ny(this._controlledTransformStream._readable._readableStreamController)}enqueue(e=void 0){if(!$c(this))throw Vc("enqueue");w4(this,e)}error(e=void 0){if(!$c(this))throw Vc("error");var t;t=e,g4(this._controlledTransformStream,t)}terminate(){if(!$c(this))throw Vc("terminate");(function(e){const t=e._controlledTransformStream;Xs(t._readable._readableStreamController);const n=new TypeError("TransformStream terminated");sy(t,n)})(this)}}function $c(r){return!!at(r)&&!!Object.prototype.hasOwnProperty.call(r,"_controlledTransformStream")&&r instanceof as}function y4(r){r._transformAlgorithm=void 0,r._flushAlgorithm=void 0,r._cancelAlgorithm=void 0}function w4(r,e){const t=r._controlledTransformStream,n=t._readable._readableStreamController;if(!Js(n))throw new TypeError("Readable side is not in a state that permits enqueue");try{Zs(n,e)}catch(s){throw sy(t,s),t._readable._storedError}(function(s){return!Kx(s)})(n)!==t._backpressure&&Qx(t,!0)}function Vc(r){return new TypeError(`TransformStreamDefaultController.prototype.${r} can only be used on a TransformStreamDefaultController`)}Object.defineProperties(as.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),Se(as.prototype.enqueue,"enqueue"),Se(as.prototype.error,"error"),Se(as.prototype.terminate,"terminate"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(as.prototype,Symbol.toStringTag,{value:"TransformStreamDefaultController",configurable:!0});var Gh={exports:{}};/*! streamsaver. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */var hv;function b4(){return hv||(hv=1,function(r){((e,t)=>{r.exports=t()})("streamSaver",()=>{const e=typeof window=="object"?window:this;e.HTMLElement||console.warn("streamsaver is meant to run on browsers main thread");let t=null,n=!1;const i=g=>{try{g()}catch{}},s=e.WebStreamsPolyfill||{},o=e.isSecureContext;let a=/constructor/i.test(e.HTMLElement)||!!e.safari||!!e.WebKitPoint;const c=o||"MozAppearance"in document.documentElement.style?"iframe":"navigate",l={createWriteStream:m,WritableStream:e.WritableStream||s.WritableStream,supported:!0,version:{full:"2.0.5",major:2,minor:0,dot:5},mitm:"https://jimmywarting.github.io/StreamSaver.js/mitm.html?version=2.0.0"};function u(g){if(!g)throw new Error("meh");const y=document.createElement("iframe");return y.hidden=!0,y.src=g,y.loaded=!1,y.name="iframe",y.isIframe=!0,y.postMessage=(...w)=>y.contentWindow.postMessage(...w),y.addEventListener("load",()=>{y.loaded=!0},{once:!0}),document.body.appendChild(y),y}function d(g){const y="width=200,height=100",w=document.createDocumentFragment(),x={frame:e.open(g,"popup",y),loaded:!1,isIframe:!1,isPopup:!0,remove(){x.frame.close()},addEventListener(...v){w.addEventListener(...v)},dispatchEvent(...v){w.dispatchEvent(...v)},removeEventListener(...v){w.removeEventListener(...v)},postMessage(...v){x.frame.postMessage(...v)}},T=v=>{v.source===x.frame&&(x.loaded=!0,e.removeEventListener("message",T),x.dispatchEvent(new Event("load")))};return e.addEventListener("message",T),x}try{new Response(new ReadableStream),o&&!("serviceWorker"in navigator)&&(a=!0)}catch{a=!0}i(()=>{const{readable:g}=new TransformStream,y=new MessageChannel;y.port1.postMessage(g,[g]),y.port1.close(),y.port2.close(),n=!0,Object.defineProperty(l,"TransformStream",{configurable:!1,writable:!1,value:TransformStream})});function f(){t||(t=o?u(l.mitm):d(l.mitm))}function m(g,y,w){let x={size:null,pathname:null,writableStrategy:void 0,readableStrategy:void 0},T=0,v=null,b=null,A=null;if(Number.isFinite(y)?([w,y]=[y,w],console.warn("[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream"),x.size=w,x.writableStrategy=y):y&&y.highWaterMark?(console.warn("[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream"),x.size=w,x.writableStrategy=y):x=y||{},!a){f(),b=new MessageChannel,g=encodeURIComponent(g.replace(/\//g,":")).replace(/['()]/g,escape).replace(/\*/g,"%2A");const C={transferringReadable:n,pathname:x.pathname||Math.random().toString().slice(-6)+"/"+g,headers:{"Content-Type":"application/octet-stream; charset=utf-8","Content-Disposition":"attachment; filename*=UTF-8''"+g}};x.size&&(C.headers["Content-Length"]=x.size);const P=[C,"*",[b.port2]];if(n){const D=c==="iframe"?void 0:{transform($,j){if(!($ instanceof Uint8Array))throw new TypeError("Can only write Uint8Arrays");T+=$.length,j.enqueue($),v&&(location.href=v,v=null)},flush(){v&&(location.href=v)}};A=new l.TransformStream(D,x.writableStrategy,x.readableStrategy);const z=A.readable;b.port1.postMessage({readableStream:z},[z])}b.port1.onmessage=D=>{D.data.download?c==="navigate"?(t.remove(),t=null,T?location.href=D.data.download:v=D.data.download):(t.isPopup&&(t.remove(),t=null,c==="iframe"&&u(l.mitm)),u(D.data.download)):D.data.abort&&(R=[],b.port1.postMessage("abort"),b.port1.onmessage=null,b.port1.close(),b.port2.close(),b=null)},t.loaded?t.postMessage(...P):t.addEventListener("load",()=>{t.postMessage(...P)},{once:!0})}let R=[];return!a&&A&&A.writable||new l.WritableStream({write(C){if(!(C instanceof Uint8Array))throw new TypeError("Can only write Uint8Arrays");if(a){R.push(C);return}b.port1.postMessage(C),T+=C.length,v&&(location.href=v,v=null)},close(){if(a){const C=new Blob(R,{type:"application/octet-stream; charset=utf-8"}),P=document.createElement("a");P.href=URL.createObjectURL(C),P.download=g,P.click()}else b.port1.postMessage("end")},abort(){R=[],b.port1.postMessage("abort"),b.port1.onmessage=null,b.port1.close(),b.port2.close(),b=null}},x.writableStrategy)}return l})}(Gh)),Gh.exports}var v4=b4();const Yh=Oa(v4);class S4{node;appState;progressTracker;uiManager;protocol;wakeLock=null;hash;transferProgressBytes;receivedFileStream=null;receivedFileWriter=null;fileNameFromHeader;fileSizeFromHeader;fileTypeFromHeader;fileHashFromHeader;headerReceived;receivedBytesTotal;constructor(e,t,n,i){this.node=e,this.appState=t,this.progressTracker=n,this.uiManager=i,this.protocol="/fileferry/filetransfer/1.0.0",this.wakeLock=null,this.hash=2166136261,this.transferProgressBytes=0,this.receivedFileStream=null,this.receivedFileWriter=null,this.fileNameFromHeader="downloaded_file",this.fileSizeFromHeader=0,this.fileTypeFromHeader="application/octet-stream",this.fileHashFromHeader=0,this.headerReceived=!1,this.receivedBytesTotal=0,Yh.WritableStream=Cn,Yh.mitm="https://fileferry.xyz/streamsaver/mitm.html",window.WritableStream=Cn}setupFileTransferProtocol(){const e=async({stream:t,connection:n})=>{this.getWakelock(),this.appState.setActivePeer(n.remotePeer.toString()),this.appState.setTransferConnectionId(n.id),this.appState.isTransferActive()?(console.log("Resuming file transfer after reconnection."),this.appState.setActiveStream(t)):(this.appState.setActiveStream(t),this.appState.setActiveTransfer()),await this.handleFileTransfer()};this.node.handle(this.protocol,e)}async startFileTransfer(){try{const e=this.appState.getActiveStream(),t=this.appState.getSelectedFile();if(!e||!t)throw new Error("No active stream or file to start transfer.");this.appState.isTransferActive()?(console.log("Resuming file transfer after reconnection."),await this.sendFileToStream(e,t)):(this.appState.setActiveTransfer(),await this.sendFileToStream(e,t)),this.appState.isFinished()&&await this.transferComplete()}catch{}}async handleFileTransfer(){try{const e=this.appState.getActiveStream();if(!e)throw new Error("No active stream to handle transfer.");await this.receiveFileFromStream(e),this.appState.isFinished()&&await this.transferComplete()}catch{}}async sendFileToStream(e,t,n=16384){try{const i=await this.createFileHeader(t),s=new TextEncoder().encode(i+`
`);let o=0;const a=e.channel,c=a.bufferedAmountLowThreshold||1024*64,l=async function*(){yield new be(s),await new Promise(u=>setTimeout(u,1));for(let u=0;u<t.size;u+=n){const d=t.slice(u,Math.min(u+n,t.size)),f=new Uint8Array(await d.arrayBuffer());if(o<this.transferProgressBytes){o+=f.length;continue}yield new be(f),a.bufferedAmount>c&&await new Promise(m=>{a.addEventListener("bufferedamountlow",()=>m(),{once:!0})}),o+=f.length,this.transferProgressBytes+=f.length,this.progressTracker.updateProgress(this.transferProgressBytes,t.size,"send")}}.bind(this);await Rg(l(),e.sink),this.progressTracker.updateProgress(this.transferProgressBytes,t.size,"send",!0),this.transferProgressBytes=0}catch(i){throw i}}async createFileHeader(e){return JSON.stringify({name:e.name,size:e.size,type:e.type||"application/octet-stream",hash:await this.senderHash()})}async receiveFileFromStream(e){try{for await(const t of e.source){if(!t||t.length===0)continue;const n=t.subarray();if(this.headerReceived)this.receivedFileWriter!=null&&(await this.receivedFileWriter.write(n),this.hash=this.fnv1aHash(n,this.hash),this.receivedBytesTotal+=n.length,this.progressTracker.updateProgress(this.receivedBytesTotal,this.fileSizeFromHeader,"receive"));else{const i=this.parseFileHeader(n);i.header&&(this.fileNameFromHeader=i.header.name||this.fileNameFromHeader,this.fileSizeFromHeader=i.header.size||this.fileSizeFromHeader,this.fileTypeFromHeader=i.header.type||this.fileTypeFromHeader,this.fileHashFromHeader=Number(i.header.hash)||this.fileHashFromHeader,this.headerReceived=!0,console.log(`Receiving file: ${this.fileNameFromHeader} (${this.fileSizeFromHeader} bytes)`),this.receivedFileStream===null&&(this.receivedFileStream=Yh.createWriteStream(this.fileNameFromHeader,{size:this.fileSizeFromHeader})),this.receivedFileWriter===null&&(this.receivedFileWriter=this.receivedFileStream.getWriter())),i.bodyData&&i.bodyData.length>0&&this.receivedFileWriter!=null&&(await this.receivedFileWriter.write(i.bodyData),this.receivedBytesTotal+=i.bodyData.length,this.progressTracker.updateProgress(this.receivedBytesTotal,this.fileSizeFromHeader,"receive"))}if(this.headerReceived&&this.receivedBytesTotal>=this.fileSizeFromHeader&&this.fileSizeFromHeader>0){this.progressTracker.updateProgress(this.receivedBytesTotal,this.fileSizeFromHeader,"receive",!0),this.uiManager.showReceivedFileDetails(this.fileNameFromHeader,this.fileSizeFromHeader),this.receivedFileWriter!=null&&(this.hash!=this.fileHashFromHeader?(this.uiManager.showErrorPopup("Sorry mate, the file's hash does not match. The file may be corrupted."),await this.receivedFileWriter.abort("File hash mismatch")):await this.receivedFileWriter.close(),this.receivedFileWriter=null),this.appState.clearActiveTransfer(),await this.closeActiveStream();break}}}catch(t){throw t}}async closeActiveStream(){const e=this.appState.getActiveStream();e&&(await e.close(),this.appState.setActiveStream(null))}parseFileHeader(e){try{const t=new TextDecoder("utf-8",{fatal:!1}).decode(e),n=t.indexOf(`
`);if(n!==-1){const i=t.substring(0,n),o=new TextEncoder().encode(i+`
`).length;try{const a=JSON.parse(i),c=o<e.byteLength?e.subarray(o):null;return{header:a,bodyData:c}}catch{return{header:null,bodyData:e}}}return{header:null,bodyData:e}}catch{return{header:null,bodyData:e}}}async getWakelock(){if("wakeLock"in navigator){async function e(){let t=null;try{return t=await navigator.wakeLock.request("screen"),t}catch{return null}}this.wakeLock=await e()||null}}async releaseWakelock(){this.wakeLock?.release().catch(e=>{})}fnv1aHash(e,t){let n=t;for(let i of e)n=(i^n)*16777619&4294967295;return n}async senderHash(){const e=this.appState.getSelectedFile(),t=16384;if(e===null)return 0;const n=async function*(){for(let s=0;s<e.size;s+=t){const a=await e.slice(s,Math.min(s+t,e.size)).arrayBuffer();yield new Uint8Array(a)}}.bind(this);let i=this.hash;for await(const s of n())i=this.fnv1aHash(s,i);return i}async transferComplete(){if(this.appState.isTransferActive()&&this.appState.getMode()==="receiver")try{this.receivedFileWriter?.close(),this.closeActiveStream()}catch{}this.appState.declareFinished(),await this.node.stop(),this.releaseWakelock()}}class E4{node;appState;errorHandler;relayPeerId;relayMultiaddr;reservationStatus;constructor(e,t,n){this.node=e,this.appState=t,this.errorHandler=n,this.relayPeerId=null,this.relayMultiaddr=null,this.reservationStatus=null}async connectToRelay(e){try{if(this.relayMultiaddr=he(e),!this.relayMultiaddr.getPeerId())throw new Error("Could not parse PeerId from relay multiaddr");this.relayPeerId=this.parseRelayPeerId(this.relayMultiaddr),console.log(`Connecting to relay: ${e}`),console.log(`Relay peer ID: ${this.relayPeerId}`);const n=await this.node.dial(this.relayMultiaddr,{signal:AbortSignal.timeout(1e4)});return console.log(`Successfully connected to relay: ${this.relayPeerId}`),n}catch(t){const n=t;throw console.error(`Failed to connect to relay: ${n.message}`),this.errorHandler.handleConnectionError(n,{relay:e}),t}}async waitForRelayAddress(){return new Promise((e,t)=>{let n,i=0;const s=60,o=()=>{i++;const c=this.getCircuitAddress();if(c){console.log(`Circuit address obtained: ${c.toString()}`),clearInterval(n),e(c);return}if(i>=s){clearInterval(n),t(new Error("Timeout: Could not obtain a circuit address via relay."));return}console.log(`Waiting for circuit address... (attempt ${i}/${s})`)},a=this.getCircuitAddress();if(a){console.log(`Circuit address already available: ${a.toString()}`),e(a);return}n=window.setInterval(o,500)})}isConnectedToRelay(){if(!this.relayPeerId)return console.log("No relay peer ID set"),!1;const e=this.appState.getConnectionsForPeer(this.relayPeerId.toString());if(!e)return!1;let t=!1;for(const n of e.values())if(n!==void 0&&n.status==="open"){t=!0;break}return console.log(`Relay connection status: ${t?"connected":"disconnected"}`),t}getCircuitAddress(){return this.node.getMultiaddrs().find(t=>t.toString().includes("/p2p-circuit"))}async reserveRelay(){try{return this.isConnectedToRelay()?await this.waitForRelayAddress()?(this.reservationStatus="reserved",console.log("Relay reservation successful"),!0):!1:(console.log("Not connected to relay, cannot reserve"),!1)}catch(e){const t=e;return console.error(`Relay reservation failed: ${t.message}`),this.errorHandler.handleConnectionError(t,{operation:"reserveRelay"}),!1}}async releaseRelay(){try{if(this.reservationStatus!=="reserved")return console.log("No active relay reservation to release"),!0;if(console.log("Releasing relay reservation..."),this.relayPeerId){const e=this.appState.getConnectionsForPeer(this.relayPeerId.toString());if(e)for(const t of e.values())t&&t.status==="open"&&(await t.close(),console.log("Relay connection closed"));this.appState.removeAllConnectionsWithPeer(this.relayPeerId.toString())}return this.reservationStatus=null,console.log("Relay reservation released"),!0}catch(e){const t=e;return console.error(`Failed to release relay: ${t.message}`),this.errorHandler.handleConnectionError(t,{operation:"releaseRelay"}),!1}}parseRelayPeerId(e){try{const t=e.getPeerId();if(!t)throw new Error("No peer ID found in multiaddr");if(!e.protos().find(i=>i.name==="p2p"))throw new Error("Multiaddr does not contain a p2p component");return console.log(`Parsed relay peer ID: ${t}`),{toString:()=>t}}catch(t){const n=t;return console.error(`Failed to parse relay peer ID: ${n.message}`),this.errorHandler.handleConnectionError(n,{operation:"parseRelayPeerId"}),null}}validateRelayConnection(e){if(!e)return console.log("No connection provided for validation"),!1;if(e.status!=="open")return console.log(`Connection status is ${e.status}, not open`),!1;if(!this.relayPeerId)return console.log("No relay peer ID to validate against"),!1;const t=e.remotePeer.toString()===this.relayPeerId.toString();return console.log(`Relay connection validation: ${t?"valid":"invalid"}`),t}getRelayPeerId(){return this.relayPeerId}getRelayMultiaddr(){return this.relayMultiaddr}getReservationStatus(){return this.reservationStatus}async canUseRelay(){return this.isConnectedToRelay()?!0:(console.log("Cannot use relay: not connected"),!1)}getRelayInfo(){return{peerId:this.relayPeerId?.toString(),multiaddr:this.relayMultiaddr?.toString(),connected:this.isConnectedToRelay(),reservationStatus:this.reservationStatus,circuitAddress:this.getCircuitAddress()?.toString()}}}class A4{geoLocUrl;hostUrl;geoUserUrl;cacheKey;cacheDuration;constructor(){this.geoLocUrl="https://raw.githubusercontent.com/pradt2/always-online-stun/master/geoip_cache.txt",this.hostUrl="https://raw.githubusercontent.com/pradt2/always-online-stun/master/valid_hosts.txt",this.geoUserUrl="https://geoip.fileferry.xyz",this.cacheKey="userGeoData",this.cacheDuration=48*60*60*1e3}async getClosestStunServer(){try{const e=await this.fetchGeoData(),t=await this.getUserGeoData(),n=await this.fetchStunServers();return this.findClosestServer(t,e,n)}catch(e){console.error("Error in getClosestStunServer:",e),this.clearExpiredCache();return}}async fetchGeoData(){return await(await fetch(this.geoLocUrl)).json()}async getUserGeoData(){const e=this.getCachedGeoData();if(e)return e;const t=await fetch(this.geoUserUrl);if(!t.ok)throw new Error(`Failed to fetch user geo data: ${t.status} ${t.statusText}`);const n=await t.json();return this.setCachedGeoData(n),n}calculateDistance(e,t,n,i){return Math.sqrt(Math.pow(e-n,2)+Math.pow(t-i,2))}findClosestServer(e,t,n){const{lat:i,lon:s}=e;return n.trim().split(`
`).map(o=>{const a=o.split(":")[0];if(!t[a])return[o,1/0];const[c,l]=t[a];if(typeof c!="number"||typeof l!="number")return[o,1/0];const u=this.calculateDistance(i,s,c,l);return[o,u]}).reduce(([o,a],[c,l])=>a<=l?[o,a]:[c,l])[0]}getCachedGeoData(){const e=localStorage.getItem(this.cacheKey);if(e){const t=JSON.parse(e);if(t.expiry&&t.expiry>Date.now())return t.data;localStorage.removeItem(this.cacheKey)}return null}setCachedGeoData(e){const t={data:e,expiry:Date.now()+this.cacheDuration};localStorage.setItem(this.cacheKey,JSON.stringify(t))}clearExpiredCache(){localStorage.removeItem(this.cacheKey)}async fetchStunServers(){return await(await fetch(this.hostUrl)).text()}validateStunServer(e){return!!(e&&e.includes(":")&&e.split(":").length===2)}}var qc={exports:{}},fv;function x4(){return fv||(fv=1,function(r,e){var t=globalThis.require&&e||{};(function(n,i){let s=globalThis.crypto;i._sep=/[\s,:-]+/,i._mword="mnemonic",i._normalize=function(o){return o.normalize("NFKD").trim().toLowerCase()},i.generate=async function(o=128){let a=o/8,c=s.getRandomValues(new Uint8Array(a));return await i.encode(c)},i.encode=async function(o){let a=8*o.length,c=a/32;o=new Uint8Array(o);let l=await s.subtle.digest("SHA-256",o),u=new Uint8Array(l),d="";o.forEach(function(x){let T=x.toString(2).padStart(8,"0");d+=T});let m=u[0].toString(2);m=m.padStart(8,"0");let g=m.slice(0,c);d+=g;let y=[];for(let x=0;x<a+c;x+=11){let T=parseInt(d.slice(x,x+11).padStart(8,"0"),2);y.push(T)}return y.map(function(x){return i.base2048[x]}).join(" ")},i.verify=async function(o){return await i.decode(o),!0},i.checksum=i.verify,i.decode=async function(o,a){o=i._normalize(o);let c=[];o.split(i._sep).forEach(function(v){let b=i.base2048.indexOf(v);if(b<0){let A=new Error(`dashphrase.js: decode failed: unknown word '${v}'`);throw A.code="E_UNKNOWN_WORD",A}c.push(b)});let u=c.map(function(v){return v.toString(2).padStart(11,"0")}).join(""),d=Math.floor(u.length/32),f=u.length-d,m=u.slice(-d),g=[];for(let v=0;v<f;v+=8){let b=u.slice(v,v+8),A=parseInt(b,2);A>=0&&g.push(A)}let y=Uint8Array.from(g),w=await s.subtle.digest("SHA-256",y),T=new Uint8Array(w)[0].toString(2).padStart(8,"0").slice(0,d);if(T!==m&&a?.verify!==!1){let v=new Error(`dashphrase.js: bad checksum: expected '${T}' but got '${m}'`);throw v.code="E_BAD_CHECKSUM",v}return y},i.toSeed=async function(o,a="",c={}){c.verify!==!1&&await i.verify(o),o=i._normalize(o),a=a.normalize("NFKD");let u=new TextEncoder().encode(o),d=new TextEncoder().encode(i._mword+a),y=await i._pbkdf2(u,d,2048,512,"SHA-512");return new Uint8Array(y)},i.pbkdf2=i.toSeed,i._pbkdf2=async function(a,c,l,u,d){let f=!1,m=await s.subtle.importKey("raw",a,{name:"PBKDF2"},f,["deriveKey"]);f=!0;let g=await s.subtle.deriveKey({name:"PBKDF2",salt:c,iterations:l,hash:d},m,{name:"HMAC",hash:d,length:u},f,["sign","verify"]),y=await s.subtle.exportKey("raw",g);return new Uint8Array(y)},i._sha256=async function(o,a=""){o=i._normalize(o),a=a.normalize("NFKD");let c=new TextEncoder().encode(o),l=new TextEncoder().encode(a),u=new Uint8Array(c.length+l.length),d=0;for(let m=0;m<c.length;m+=1)u[d]=c[m],d+=1;for(let m=0;m<l.length;m+=1)u[d]=l[m],d+=1;let f=await s.subtle.digest("SHA-256",u);return new Uint8Array(f)},i.CATMONIC="cat swing flag economy stadium alone churn speed unique patch report train",i.ZOOMONIC="zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",i.ZECRET="TREZOR",i.ZEED="ac27495480225222079d7be181583751e86f571027b0497b5b5d11218e0a8a13332572917f0f8e5a589620c6f15b11c61dee327651a14c34e18231052e48c069",i.base2048="abandon ability able about above absent absorb abstract absurd abuse access accident account accuse achieve acid acoustic acquire across act action actor actress actual adapt add addict address adjust admit adult advance advice aerobic affair afford afraid again age agent agree ahead aim air airport aisle alarm album alcohol alert alien all alley allow almost alone alpha already also alter always amateur amazing among amount amused analyst anchor ancient anger angle angry animal ankle announce annual another answer antenna antique anxiety any apart apology appear apple approve april arch arctic area arena argue arm armed armor army around arrange arrest arrive arrow art artefact artist artwork ask aspect assault asset assist assume asthma athlete atom attack attend attitude attract auction audit august aunt author auto autumn average avocado avoid awake aware away awesome awful awkward axis baby bachelor bacon badge bag balance balcony ball bamboo banana banner bar barely bargain barrel base basic basket battle beach bean beauty because become beef before begin behave behind believe below belt bench benefit best betray better between beyond bicycle bid bike bind biology bird birth bitter black blade blame blanket blast bleak bless blind blood blossom blouse blue blur blush board boat body boil bomb bone bonus book boost border boring borrow boss bottom bounce box boy bracket brain brand brass brave bread breeze brick bridge brief bright bring brisk broccoli broken bronze broom brother brown brush bubble buddy budget buffalo build bulb bulk bullet bundle bunker burden burger burst bus business busy butter buyer buzz cabbage cabin cable cactus cage cake call calm camera camp can canal cancel candy cannon canoe canvas canyon capable capital captain car carbon card cargo carpet carry cart case cash casino castle casual cat catalog catch category cattle caught cause caution cave ceiling celery cement census century cereal certain chair chalk champion change chaos chapter charge chase chat cheap check cheese chef cherry chest chicken chief child chimney choice choose chronic chuckle chunk churn cigar cinnamon circle citizen city civil claim clap clarify claw clay clean clerk clever click client cliff climb clinic clip clock clog close cloth cloud clown club clump cluster clutch coach coast coconut code coffee coil coin collect color column combine come comfort comic common company concert conduct confirm congress connect consider control convince cook cool copper copy coral core corn correct cost cotton couch country couple course cousin cover coyote crack cradle craft cram crane crash crater crawl crazy cream credit creek crew cricket crime crisp critic crop cross crouch crowd crucial cruel cruise crumble crunch crush cry crystal cube culture cup cupboard curious current curtain curve cushion custom cute cycle dad damage damp dance danger daring dash daughter dawn day deal debate debris decade december decide decline decorate decrease deer defense define defy degree delay deliver demand demise denial dentist deny depart depend deposit depth deputy derive describe desert design desk despair destroy detail detect develop device devote diagram dial diamond diary dice diesel diet differ digital dignity dilemma dinner dinosaur direct dirt disagree discover disease dish dismiss disorder display distance divert divide divorce dizzy doctor document dog doll dolphin domain donate donkey donor door dose double dove draft dragon drama drastic draw dream dress drift drill drink drip drive drop drum dry duck dumb dune during dust dutch duty dwarf dynamic eager eagle early earn earth easily east easy echo ecology economy edge edit educate effort egg eight either elbow elder electric elegant element elephant elevator elite else embark embody embrace emerge emotion employ empower empty enable enact end endless endorse enemy energy enforce engage engine enhance enjoy enlist enough enrich enroll ensure enter entire entry envelope episode equal equip era erase erode erosion error erupt escape essay essence estate eternal ethics evidence evil evoke evolve exact example excess exchange excite exclude excuse execute exercise exhaust exhibit exile exist exit exotic expand expect expire explain expose express extend extra eye eyebrow fabric face faculty fade faint faith fall false fame family famous fan fancy fantasy farm fashion fat fatal father fatigue fault favorite feature february federal fee feed feel female fence festival fetch fever few fiber fiction field figure file film filter final find fine finger finish fire firm first fiscal fish fit fitness fix flag flame flash flat flavor flee flight flip float flock floor flower fluid flush fly foam focus fog foil fold follow food foot force forest forget fork fortune forum forward fossil foster found fox fragile frame frequent fresh friend fringe frog front frost frown frozen fruit fuel fun funny furnace fury future gadget gain galaxy gallery game gap garage garbage garden garlic garment gas gasp gate gather gauge gaze general genius genre gentle genuine gesture ghost giant gift giggle ginger giraffe girl give glad glance glare glass glide glimpse globe gloom glory glove glow glue goat goddess gold good goose gorilla gospel gossip govern gown grab grace grain grant grape grass gravity great green grid grief grit grocery group grow grunt guard guess guide guilt guitar gun gym habit hair half hammer hamster hand happy harbor hard harsh harvest hat have hawk hazard head health heart heavy hedgehog height hello helmet help hen hero hidden high hill hint hip hire history hobby hockey hold hole holiday hollow home honey hood hope horn horror horse hospital host hotel hour hover hub huge human humble humor hundred hungry hunt hurdle hurry hurt husband hybrid ice icon idea identify idle ignore ill illegal illness image imitate immense immune impact impose improve impulse inch include income increase index indicate indoor industry infant inflict inform inhale inherit initial inject injury inmate inner innocent input inquiry insane insect inside inspire install intact interest into invest invite involve iron island isolate issue item ivory jacket jaguar jar jazz jealous jeans jelly jewel job join joke journey joy judge juice jump jungle junior junk just kangaroo keen keep ketchup key kick kid kidney kind kingdom kiss kit kitchen kite kitten kiwi knee knife knock know lab label labor ladder lady lake lamp language laptop large later latin laugh laundry lava law lawn lawsuit layer lazy leader leaf learn leave lecture left leg legal legend leisure lemon lend length lens leopard lesson letter level liar liberty library license life lift light like limb limit link lion liquid list little live lizard load loan lobster local lock logic lonely long loop lottery loud lounge love loyal lucky luggage lumber lunar lunch luxury lyrics machine mad magic magnet maid mail main major make mammal man manage mandate mango mansion manual maple marble march margin marine market marriage mask mass master match material math matrix matter maximum maze meadow mean measure meat mechanic medal media melody melt member memory mention menu mercy merge merit merry mesh message metal method middle midnight milk million mimic mind minimum minor minute miracle mirror misery miss mistake mix mixed mixture mobile model modify mom moment monitor monkey monster month moon moral more morning mosquito mother motion motor mountain mouse move movie much muffin mule multiply muscle museum mushroom music must mutual myself mystery myth naive name napkin narrow nasty nation nature near neck need negative neglect neither nephew nerve nest net network neutral never news next nice night noble noise nominee noodle normal north nose notable note nothing notice novel now nuclear number nurse nut oak obey object oblige obscure observe obtain obvious occur ocean october odor off offer office often oil okay old olive olympic omit once one onion online only open opera opinion oppose option orange orbit orchard order ordinary organ orient original orphan ostrich other outdoor outer output outside oval oven over own owner oxygen oyster ozone pact paddle page pair palace palm panda panel panic panther paper parade parent park parrot party pass patch path patient patrol pattern pause pave payment peace peanut pear peasant pelican pen penalty pencil people pepper perfect permit person pet phone photo phrase physical piano picnic picture piece pig pigeon pill pilot pink pioneer pipe pistol pitch pizza place planet plastic plate play please pledge pluck plug plunge poem poet point polar pole police pond pony pool popular portion position possible post potato pottery poverty powder power practice praise predict prefer prepare present pretty prevent price pride primary print priority prison private prize problem process produce profit program project promote proof property prosper protect proud provide public pudding pull pulp pulse pumpkin punch pupil puppy purchase purity purpose purse push put puzzle pyramid quality quantum quarter question quick quit quiz quote rabbit raccoon race rack radar radio rail rain raise rally ramp ranch random range rapid rare rate rather raven raw razor ready real reason rebel rebuild recall receive recipe record recycle reduce reflect reform refuse region regret regular reject relax release relief rely remain remember remind remove render renew rent reopen repair repeat replace report require rescue resemble resist resource response result retire retreat return reunion reveal review reward rhythm rib ribbon rice rich ride ridge rifle right rigid ring riot ripple risk ritual rival river road roast robot robust rocket romance roof rookie room rose rotate rough round route royal rubber rude rug rule run runway rural sad saddle sadness safe sail salad salmon salon salt salute same sample sand satisfy satoshi sauce sausage save say scale scan scare scatter scene scheme school science scissors scorpion scout scrap screen script scrub sea search season seat second secret section security seed seek segment select sell seminar senior sense sentence series service session settle setup seven shadow shaft shallow share shed shell sheriff shield shift shine ship shiver shock shoe shoot shop short shoulder shove shrimp shrug shuffle shy sibling sick side siege sight sign silent silk silly silver similar simple since sing siren sister situate six size skate sketch ski skill skin skirt skull slab slam sleep slender slice slide slight slim slogan slot slow slush small smart smile smoke smooth snack snake snap sniff snow soap soccer social sock soda soft solar soldier solid solution solve someone song soon sorry sort soul sound soup source south space spare spatial spawn speak special speed spell spend sphere spice spider spike spin spirit split spoil sponsor spoon sport spot spray spread spring spy square squeeze squirrel stable stadium staff stage stairs stamp stand start state stay steak steel stem step stereo stick still sting stock stomach stone stool story stove strategy street strike strong struggle student stuff stumble style subject submit subway success such sudden suffer sugar suggest suit summer sun sunny sunset super supply supreme sure surface surge surprise surround survey suspect sustain swallow swamp swap swarm swear sweet swift swim swing switch sword symbol symptom syrup system table tackle tag tail talent talk tank tape target task taste tattoo taxi teach team tell ten tenant tennis tent term test text thank that theme then theory there they thing this thought three thrive throw thumb thunder ticket tide tiger tilt timber time tiny tip tired tissue title toast tobacco today toddler toe together toilet token tomato tomorrow tone tongue tonight tool tooth top topic topple torch tornado tortoise toss total tourist toward tower town toy track trade traffic tragic train transfer trap trash travel tray treat tree trend trial tribe trick trigger trim trip trophy trouble truck true truly trumpet trust truth try tube tuition tumble tuna tunnel turkey turn turtle twelve twenty twice twin twist two type typical ugly umbrella unable unaware uncle uncover under undo unfair unfold unhappy uniform unique unit universe unknown unlock until unusual unveil update upgrade uphold upon upper upset urban urge usage use used useful useless usual utility vacant vacuum vague valid valley valve van vanish vapor various vast vault vehicle velvet vendor venture venue verb verify version very vessel veteran viable vibrant vicious victory video view village vintage violin virtual virus visa visit visual vital vivid vocal voice void volcano volume vote voyage wage wagon wait walk wall walnut want warfare warm warrior wash wasp waste water wave way wealth weapon wear weasel weather web wedding weekend weird welcome west wet whale what wheat wheel when where whip whisper wide width wife wild will win window wine wing wink winner winter wire wisdom wise wish witness wolf woman wonder wood wool word work world worry worth wrap wreck wrestle wrist write wrong yard year yellow you young youth zebra zero zone zoo".normalize("NFKD").split(" "),n.DashPhrase=i})(globalThis.window||{},t),r.exports=t}(qc,qc.exports)),qc.exports}var _4=x4();const C4=Oa(_4);class I4{apiUrl;constructor(e){this.apiUrl=e}async generatePhrase(){const e=await C4.generate(16);return[self.crypto.getRandomValues(new Uint32Array(1))[0]%100,...e.split(" ")].join("-")}async registerPhrase(e,t){try{const n=await this.makeApiRequest("/phrase","POST",{Maddr:t.toString(),Phrase:e});if(!n.ok)throw new Error(`Failed to register phrase. Status: ${n.status}`);return await n.json()}catch(n){throw this.handleApiError(n),n}}async lookupPhrase(e){try{const t=await this.makeApiRequest(`/phrase/${encodeURIComponent(e)}`,"GET");if(!t.ok)throw new Error(`Failed to lookup phrase. Status: ${t.status}`);return await t.json()}catch(t){throw this.handleApiError(t),t}}async makeApiRequest(e,t,n=null){const i=`${this.apiUrl}${e}`,s={method:t,headers:{"Content-type":"application/json; charset=UTF-8"}};return n&&(s.body=JSON.stringify(n)),await fetch(i,s)}handleApiError(e){console.error("API Error:",e)}validatePhrase(e){return e!=null&&e.trim().length>0}sanitizePhrase(e){return e.trim().toLowerCase()}}class k4{appState;elements;theme="light";onFileSelected=()=>{};onPhraseEntered=()=>{};onReceiveModeRequested=()=>{};constructor(e){this.appState=e,this.elements=this.getUIElements(),this.initTheme(),this.clearPhrase()}showSenderMode(){this.hideElement("initialDropUI"),this.showElement("fileInfoArea")}showSendingInProgress(){this.hideElement("fileInfoArea"),this.showElement("sendInProgress")}showReceiverMode(){this.hideElement("initialReceiveUI"),this.showElement("receiveInProgress")}showHome(){window.location.reload()}showSendWindow(){this.showElement("goBackButton","flex"),this.hideElement("goSendButton"),this.hideElement("goReceiveButton"),this.showElement("sendWindow"),this.hideElement("receiveWindow")}showReceiveWindow(){this.showElement("goBackButton","flex"),this.hideElement("goSendButton"),this.hideElement("goReceiveButton"),this.showElement("receiveWindow"),this.hideElement("sendWindow")}resetUI(){this.showHome(),this.clearFileDisplay(),this.hideErrorPopup()}initTheme(){this.theme=localStorage.theme||this.getSystemTheme(),document.documentElement.classList.add(this.theme)}toggleTheme(){this.theme==="light"?(this.theme="dark",localStorage.theme="dark",document.documentElement.classList.remove("light"),document.documentElement.classList.add("dark")):(this.theme="light",localStorage.theme="light",document.documentElement.classList.remove("dark"),document.documentElement.classList.add("light"))}getSystemTheme(){return window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?(localStorage.theme="dark","dark"):(localStorage.theme="light","light")}displaySelectedFile(e){this.updateElement("fileNameDisplay",e.name),this.updateElement("fileSizeDisplay",`${(e.size/1024/1024).toFixed(2)} MB`)}showFileProgress(e,t){const{percentage:n,current:i,total:s,rate:o}=e,a=t==="send"?"sendProgressBar":"receiveProgressBar",c=t==="send"?"sendProgressText":"receiveProgressText",l=t==="send"?"sendRate":"receiveRate";this.updateProgressBar(a,n),this.updateElement(c,`${i} MB / ${s} MB`),this.updateElement(l,`${o} Mbps`)}showReceivedFileDetails(e,t){this.updateElement("receivedFileName",e),this.updateElement("receivedFileSize",`${(t/1024/1024).toFixed(2)} MB`)}showTransferComplete(e){const t=e==="send"?"sendInProgress":"receiveInProgress",n=e==="send"?"sendComplete":"receiveComplete";this.hideElement(t),this.showElement(n)}updateProgressBar(e,t){const n=document.getElementById(e);n&&(n.style.width=`${t}%`)}clearFileDisplay(){this.updateElement("fileNameDisplay",""),this.updateElement("fileSizeDisplay","")}showReconnecting(){this.appState.getMode()==="sender"?(this.hideElement("sendInProgress"),this.showElement("reconnectingSend")):this.appState.getMode()==="receiver"&&(this.hideElement("receiveInProgress"),this.showElement("reconnectingReceive"))}hideReconnecting(){this.appState.getMode()==="sender"?(this.hideElement("reconnectingSend"),this.showElement("sendInProgress")):this.appState.getMode()==="receiver"&&(this.hideElement("reconnectingReceive"),this.showElement("receiveInProgress"))}showErrorPopup(e){this.updateElement("errorMessageText",e),this.elements.errorWindow?.classList.remove("hidden")}hideErrorPopup(){this.elements.errorWindow?.classList.add("hidden")}setupEventListeners(){this.setupFileHandlers(),this.setupButtonHandlers(),this.setupErrorHandlers()}setupFileHandlers(){const e=this.elements.dropZone,t=this.elements.fileInput;e?.addEventListener("dragover",this.handleDragOver.bind(this)),e?.addEventListener("drop",this.handleFileDrop.bind(this)),t?.addEventListener("change",this.handleFileSelect.bind(this))}setupButtonHandlers(){this.elements.sun?.addEventListener("click",()=>this.toggleTheme()),this.elements.moon?.addEventListener("click",()=>this.toggleTheme()),this.elements.selectFileButton?.addEventListener("click",()=>this.elements.fileInput?.click()),this.elements.goSendButton?.addEventListener("click",this.showSendWindow.bind(this)),this.elements.goReceiveButton?.addEventListener("click",this.showReceiveWindow.bind(this)),this.elements.goBackButton?.addEventListener("click",this.showHome.bind(this)),this.elements.copyPhraseButton?.addEventListener("click",this.copyPhrase.bind(this)),this.elements.receiveModeButton?.addEventListener("click",()=>{const t=document.getElementById("phraseInput").value.trim();if(!t){this.showErrorPopup("Please enter a valid phrase.");return}this.showReceiverMode(),this.onPhraseEntered(t)})}setupErrorHandlers(){const e=this.elements.errorWindow,t=this.elements.closeErrorButton;e?.addEventListener("click",n=>{n.target===e&&(this.hideErrorPopup(),this.resetUI())}),t?.addEventListener("click",()=>{this.hideErrorPopup(),this.resetUI()})}handleDragOver(e){e.preventDefault()}handleFileDrop(e){e.preventDefault();let t=null;if(e.dataTransfer?.items){const n=[...e.dataTransfer.items].find(i=>i.kind==="file");n&&(t=n.getAsFile())}else e.dataTransfer?.files&&e.dataTransfer.files.length>0&&(t=e.dataTransfer.files[0]);t&&(this.appState.setSelectedFile(t),this.displaySelectedFile(t),this.onFileSelected(t))}handleFileSelect(e){const t=e.target;if(t.files&&t.files[0]){const n=t.files[0];this.appState.setSelectedFile(n),this.displaySelectedFile(n),this.onFileSelected(n)}}showPhrase(e){this.updateElement("generatedPhraseDisplay",e)}copyPhrase(){this.elements.generatedPhraseDisplay?.innerText&&navigator.clipboard.writeText(this.elements.generatedPhraseDisplay.innerText)}clearPhrase(){const e=document.getElementById("phraseInput");e&&(e.value="")}updateElement(e,t){const n=document.getElementById(e);n&&(n.textContent=t)}showElement(e,t="block"){const n=document.getElementById(e);n&&(n.style.display=t)}hideElement(e){const t=document.getElementById(e);t&&(t.style.display="none")}getUIElements(){return{dropZone:document.getElementById("drop_zone"),fileInput:document.getElementById("fileInput"),copyPhraseButton:document.getElementById("copyPhraseButton"),receiveModeButton:document.getElementById("receiveModeButton"),goSendButton:document.getElementById("goSendButton"),goReceiveButton:document.getElementById("goReceiveButton"),goBackButton:document.getElementById("goBackButton"),selectFileButton:document.getElementById("selectFileButton"),errorWindow:document.getElementById("errorWindow"),closeErrorButton:document.getElementById("closeErrorButton"),generatedPhraseDisplay:document.getElementById("generatedPhraseDisplay"),sun:document.getElementById("sun"),moon:document.getElementById("moon")}}}class T4{uiManager;lastUpdateTime;lastBytes;updateInterval;constructor(e){this.uiManager=e,this.lastUpdateTime=0,this.lastBytes=0,this.updateInterval=250}updateProgress(e,t,n,i=!1){const s=Date.now(),o=s-this.lastUpdateTime;if(!i&&o<this.updateInterval)return;const a=o/1e3,c=e-this.lastBytes;let l=0;a>0&&c>0&&(l=c/a*8/(1024*1024));const u=t>0?e/t*100:0,d=(e/(1024*1024)).toFixed(2),f=(t/(1024*1024)).toFixed(2);if(console.log("Receive progress: "+u.toFixed(2)+"% ("+d+" MB / "+f+" MB)"),this.uiManager.showSendingInProgress(),u>=100)this.uiManager.showTransferComplete(n);else{const m={percentage:u,current:d,total:f,rate:l.toFixed(2)};this.uiManager.showFileProgress(m,n)}this.lastUpdateTime=s,this.lastBytes=e}}class P4{uiManager;constructor(e){this.uiManager=e}handleConnectionError(e,t){const n=`Connection error: ${e.message}`;this.logError(e,t),this.uiManager.showErrorPopup(n)}tryAgainError(){this.uiManager.showErrorPopup("The FileFerry got lost at sea, make sure your maps are in order and try again.")}handleTransferError(e,t){const n=`Transfer error: ${e.message}`;this.logError(e,t),this.uiManager.showErrorPopup(n)}handleApiError(e,t){const n=`API error: ${e.message}`;this.logError(e,t),this.uiManager.showErrorPopup(n)}reconnecting(){this.uiManager.showReconnecting()}reconnected(){this.uiManager.hideReconnecting()}logError(e,t){console.error("Error:",e.message,"Context:",t)}isNetworkError(e){return e.message.includes("network")||e.message.includes("connection")||e.code==="NETWORK_ERROR"}isTimeoutError(e){return e.message.includes("timeout")||e.message.includes("timed out")||e.code==="TIMEOUT"}isRecoverableError(e){return this.isNetworkError(e)||this.isTimeoutError(e)}}class R4{config;constructor(){this.config={relay:{address:"/dns4/relay.fileferry.xyz/tcp/443/tls/ws/p2p/12D3KooWPUXghsjtba2yaKbxJAPUpCgZ1UzciEdCPzohBQi7wiPg",timeout:3e4},api:{url:"https://exchange.fileferry.xyz",timeout:1e4},transfer:{chunkSize:256*256,protocol:"/fileferry/filetransfer/1.0.0"},stun:{fallback:"stun:l.google.com:19302",timeout:5e3},debug:!0}}getRelayAddress(){return this.config.relay.address}getApiUrl(){return this.config.api.url}getStunServers(){return[this.config.stun.fallback,"turn:relay.fileferry.xyz:3478?transport=udp","turn:relay.fileferry.xyz:3478?transport=tcp"]}getTransferSettings(){return this.config.transfer}getFileTransferProtocol(){return this.config.transfer.protocol}validateConfig(){const e=["relay.address","api.url","transfer.protocol"];for(const t of e)if(!this.getConfigValue(t))throw new Error(`Missing required configuration: ${t}`);return!0}getConfigValue(e,t=null){const n=e.split(".");let i=this.config;for(const s of n){if(i[s]===void 0)return t;i=i[s]}return i}}class O4{config;appState;node;services;managers;constructor(){this.config=new R4,this.appState=new j8,this.node=null,this.services={},this.managers={}}async initialize(){try{this.config.validateConfig(),await this.setupServices(),await this.setupLibp2pNode(),await this.setupManagers(),await this.setupUI(),console.log("FileFerry app initialized successfully")}catch(e){throw console.error("Failed to initialize app:",e),e}}async setupServices(){this.services.stun=new A4,this.services.phrase=new I4(this.config.getApiUrl())}async setupLibp2pNode(){const e=await this.getStunConfiguration();console.log(e);const t={addresses:{listen:["/p2p-circuit","/webrtc"]},transports:[lO(),zD({rtcConfiguration:{iceServers:[{urls:e},{urls:"turn:relay.fileferry.xyz:3478?transport=udp",username:"ferryCaptain",credential:"i^YV13eTPOHdVzWm#2t5"},{urls:"turn:relay.fileferry.xyz:3478?transport=tcp",username:"ferryCaptain",credential:"i^YV13eTPOHdVzWm#2t5"}]}}),jD(),lL()],connectionEncrypters:[FS()],streamMuxers:[YT({maxStreamWindowSize:1024*1024*4})],connectionManager:{maxConnections:50,dialTimeout:3e4},connectionGater:{denyDialMultiaddr:()=>!1},services:{autoNAT:q8(),dcutr:T8(),identify:OO(),identifyPush:BO(),ping:VO()}};this.node=await I8(t),await this.node.start(),console.log(`Node started with Peer ID: ${this.node.peerId.toString()}`)}async setupManagers(){if(!this.node)throw new Error("Libp2p node is not initialized.");this.managers.ui=new k4(this.appState),this.managers.error=new P4(this.managers.ui),this.managers.progress=new T4(this.managers.ui),this.managers.fileTransfer=new S4(this.node,this.appState,this.managers.progress,this.managers.ui),this.managers.relay=new E4(this.node,this.appState,this.managers.error),this.managers.connection=new z8(this.node,this.appState,this.managers.error,this.config,this.managers.fileTransfer),this.setupEventListeners(),this.managers.fileTransfer.setupFileTransferProtocol()}async setupUI(){if(!this.managers.ui)throw new Error("UIManager not initialized");this.managers.ui.setupEventListeners(),this.managers.ui.onFileSelected=this.handleFileSelected.bind(this),this.managers.ui.onPhraseEntered=this.handlePhraseEntered.bind(this),this.managers.ui.onReceiveModeRequested=this.handleReceiveModeRequested.bind(this)}setupEventListeners(){!this.node||!this.managers.connection||(this.node.addEventListener("connection:open",this.managers.connection.onConnectionEstablished.bind(this.managers.connection)),this.node.addEventListener("connection:close",this.managers.connection.onConnectionClosed.bind(this.managers.connection)))}async getStunConfiguration(){if(!this.services.stun)return this.config.getStunServers()[0];try{const e=await this.services.stun.getClosestStunServer();return e?`stun:${e}`:this.config.getStunServers()[0]}catch(e){return console.warn("Could not fetch closest STUN server:",e),this.config.getStunServers()[0]}}async handleFileSelected(e){if(!(!this.managers.ui||!this.managers.error))try{this.managers.ui.showSenderMode(),await this.startSenderMode(e)}catch(t){this.managers.error.handleTransferError(t,{operation:"fileSelected",direction:"send"})}}async handlePhraseEntered(e){if(this.managers.error)try{await this.startReceiverMode(e)}catch(t){this.managers.error.handleApiError(t,{operation:"phraseEntered"})}}async handleReceiveModeRequested(){this.managers.ui&&this.managers.ui.showReceiverMode()}async startSenderMode(e){if(!(!this.services.phrase||!this.managers.relay||!this.managers.error))try{this.appState.setSelectedFile(e),this.appState.setMode("sender"),console.log("Starting sender mode...");const t=await this.services.phrase.generatePhrase();console.log(`Generated phrase: ${t}`);const n=document.getElementById("generatedPhraseDisplay");n&&(n.textContent=t),await this.managers.relay.connectToRelay(this.config.getRelayAddress());const i=await this.managers.relay.waitForRelayAddress();console.log("Registering phrase..."),await this.services.phrase.registerPhrase(t,i),console.log("Sender mode setup complete. Waiting for receiver...")}catch(t){throw console.error("Failed to start sender mode:",t),this.managers.error.handleTransferError(t,{operation:"startSenderMode",direction:"send"}),this.appState.setMode("idle"),t}}async startReceiverMode(e){if(!this.appState||!this.services.phrase||!this.managers.relay||!this.managers.connection||!this.node)return;this.appState.setMode("receiver");const t=await this.services.phrase.lookupPhrase(e);if(!t.maddr)throw new Error("No address found for phrase");await this.managers.relay.connectToRelay(this.config.getRelayAddress()),await this.managers.relay.waitForRelayAddress();const n=he(t.maddr),i=await this.managers.connection.dialPeer(n,{signal:AbortSignal.timeout(6e4)});console.log(`Connected to sender via phrase: ${e}`),this.appState.setActivePeer(i.remotePeer.toString());const s=setInterval(()=>{if(!this.node){clearInterval(s);return}const a=this.node.getConnections(i.remotePeer).find(c=>c.remoteAddr.toString().includes("/webrtc"));a&&a.status==="open"&&(clearInterval(s),console.log("WebRTC connection established, circuit can now be closed safely"))},1e3)}async start(){await this.initialize()}async stop(){this.node&&await this.node.stop(),this.appState.reset(),console.log("FileFerry app stopped")}}const Xx=new O4;document.addEventListener("DOMContentLoaded",async()=>{try{await Xx.start()}catch(r){console.error("Failed to start FileFerry app:",r)}});window.addEventListener("unhandledrejection",r=>{console.error("Unhandled promise rejection:",r.reason)});window.addEventListener("error",r=>{console.error("Global error:",r.error)});window.fileFerryApp=Xx;
