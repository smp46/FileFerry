(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function t(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(s){if(s.ep)return;s.ep=!0;const i=t(s);fetch(s.href,i)}})();const Jg=Symbol.for("@libp2p/connection"),El=Symbol.for("@libp2p/content-routing"),_l=Symbol.for("@libp2p/peer-discovery"),lc=Symbol.for("@libp2p/peer-id");function Zd(r){return!!r?.[lc]}const xl=Symbol.for("@libp2p/peer-routing"),uc="keep-alive",Zi=Symbol.for("@libp2p/transport");var Wn;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(Wn||(Wn={}));let Er=class extends Error{static name="AbortError";constructor(e="The operation was aborted"){super(e),this.name="AbortError"}};class em extends Error{static name="UnexpectedPeerError";constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}}let Jd=class extends Error{static name="InvalidCryptoExchangeError";constructor(e="Invalid crypto exchange"){super(e),this.name="InvalidCryptoExchangeError"}};class K extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}}class eh extends Error{static name="InvalidPublicKeyError";constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}}class tm extends Error{static name="ConnectionClosingError";constructor(e="The connection is closing"){super(e),this.name="ConnectionClosingError"}}class th extends Error{static name="ConnectionClosedError";constructor(e="The connection is closed"){super(e),this.name="ConnectionClosedError"}}class rh extends Error{static name="ConnectionFailedError";constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}}class xn extends Error{static name="MuxerClosedError";constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}}class rm extends Error{static name="StreamResetError";constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}}class ba extends Error{static name="StreamStateError";constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}}let va=class extends Error{static name="NotFoundError";constructor(e="Not found"){super(e),this.name="NotFoundError"}};class nh extends Error{static name="InvalidPeerIdError";constructor(e="Invalid PeerID"){super(e),this.name="InvalidPeerIdError"}}class Ji extends Error{static name="InvalidMultiaddrError";constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}}class nm extends Error{static name="InvalidCIDError";constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}}class sm extends Error{static name="InvalidMultihashError";constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}}class dc extends Error{static name="UnsupportedProtocolError";constructor(e="Unsupported protocol error"){super(e),this.name="UnsupportedProtocolError"}}class mt extends Error{static name="InvalidMessageError";constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}}class im extends Error{static name="ProtocolError";constructor(e="Protocol error"){super(e),this.name="ProtocolError"}}let hc=class extends Error{static name="TimeoutError";constructor(e="Timed out"){super(e),this.name="TimeoutError"}};class ci extends Error{static name="NotStartedError";constructor(e="Not started"){super(e),this.name="NotStartedError"}}class Nn extends Error{static name="DialError";constructor(e="Dial error"){super(e),this.name="DialError"}}class Sa extends Error{static name="ListenError";constructor(e="Listen error"){super(e),this.name="ListenError"}}class sh extends Error{static name="LimitedConnectionError";constructor(e="Limited connection"){super(e),this.name="LimitedConnectionError"}}class om extends Error{static name="TooManyInboundProtocolStreamsError";constructor(e="Too many inbound protocol streams"){super(e),this.name="TooManyInboundProtocolStreamsError"}}class ih extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}}class fc extends Error{static name="UnsupportedKeyTypeError";constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}}class Qt extends EventTarget{#e=new Map;constructor(){super()}listenerCount(e){const t=this.#e.get(e);return t==null?0:t.length}addEventListener(e,t,n){super.addEventListener(e,t,n);let s=this.#e.get(e);s==null&&(s=[],this.#e.set(e,s)),s.push({callback:t,once:(n!==!0&&n!==!1&&n?.once)??!1})}removeEventListener(e,t,n){super.removeEventListener(e.toString(),t??null,n);let s=this.#e.get(e);s!=null&&(s=s.filter(({callback:i})=>i!==t),this.#e.set(e,s))}dispatchEvent(e){const t=super.dispatchEvent(e);let n=this.#e.get(e.type);return n==null||(n=n.filter(({once:s})=>!s),this.#e.set(e.type,n)),t}safeDispatchEvent(e,t={}){return this.dispatchEvent(new CustomEvent(e,t))}}function pc(r){return r!=null&&typeof r.start=="function"&&typeof r.stop=="function"}async function oh(...r){const e=[];for(const t of r)pc(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStart!=null&&await t.beforeStart()})),await Promise.all(e.map(async t=>{await t.start()})),await Promise.all(e.map(async t=>{t.afterStart!=null&&await t.afterStart()}))}async function ah(...r){const e=[];for(const t of r)pc(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStop!=null&&await t.beforeStop()})),await Promise.all(e.map(async t=>{await t.stop()})),await Promise.all(e.map(async t=>{t.afterStop!=null&&await t.afterStop()}))}const rt=Symbol.for("@libp2p/service-capabilities"),li=Symbol.for("@libp2p/service-dependencies");function am(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function eo(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function cm(r){return new TextEncoder().encode(r)}function lm(r){return new TextDecoder().decode(r)}function um(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var s=0;s<r.length;s++){var i=r.charAt(s),o=i.charCodeAt(0);if(t[o]!==255)throw new TypeError(i+" is ambiguous");t[o]=s}var a=r.length,c=r.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function d(f){if(f instanceof Uint8Array||(ArrayBuffer.isView(f)?f=new Uint8Array(f.buffer,f.byteOffset,f.byteLength):Array.isArray(f)&&(f=Uint8Array.from(f))),!(f instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(f.length===0)return"";for(var g=0,m=0,S=0,x=f.length;S!==x&&f[S]===0;)S++,g++;for(var w=(x-S)*u+1>>>0,y=new Uint8Array(w);S!==x;){for(var v=f[S],C=0,E=w-1;(v!==0||C<m)&&E!==-1;E--,C++)v+=256*y[E]>>>0,y[E]=v%a>>>0,v=v/a>>>0;if(v!==0)throw new Error("Non-zero carry");m=C,S++}for(var A=w-m;A!==w&&y[A]===0;)A++;for(var T=c.repeat(g);A<w;++A)T+=r.charAt(y[A]);return T}function h(f){if(typeof f!="string")throw new TypeError("Expected String");if(f.length===0)return new Uint8Array;var g=0;if(f[g]!==" "){for(var m=0,S=0;f[g]===c;)m++,g++;for(var x=(f.length-g)*l+1>>>0,w=new Uint8Array(x);f[g];){var y=t[f.charCodeAt(g)];if(y===255)return;for(var v=0,C=x-1;(y!==0||v<S)&&C!==-1;C--,v++)y+=a*w[C]>>>0,w[C]=y%256>>>0,y=y/256>>>0;if(y!==0)throw new Error("Non-zero carry");S=v,g++}if(f[g]!==" "){for(var E=x-S;E!==x&&w[E]===0;)E++;for(var A=new Uint8Array(m+(x-E)),T=m;E!==x;)A[T++]=w[E++];return A}}}function p(f){var g=h(f);if(g)return g;throw new Error(`Non-${e} character`)}return{encode:d,decodeUnsafe:h,decode:p}}var dm=um,hm=dm;class fm{name;prefix;baseEncode;constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}let pm=class{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,n){this.name=e,this.prefix=t;const s=t.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return ch(this,e)}};class gm{decoders;constructor(e){this.decoders=e}or(e){return ch(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n!=null)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function ch(r,e){return new gm({...r.decoders??{[r.prefix]:r},...e.decoders??{[e.prefix]:e}})}class mm{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,n,s){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=s,this.encoder=new fm(e,t,n),this.decoder=new pm(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function to({name:r,prefix:e,encode:t,decode:n}){return new mm(r,e,t,n)}function os({name:r,prefix:e,alphabet:t}){const{encode:n,decode:s}=hm(t,r);return to({prefix:e,name:r,encode:n,decode:i=>eo(s(i))})}function ym(r,e,t,n){let s=r.length;for(;r[s-1]==="=";)--s;const i=new Uint8Array(s*t/8|0);let o=0,a=0,c=0;for(let l=0;l<s;++l){const u=e[r[l]];if(u===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<t|u,o+=t,o>=8&&(o-=8,i[c++]=255&a>>o)}if(o>=t||(255&a<<8-o)!==0)throw new SyntaxError("Unexpected end of data");return i}function wm(r,e,t){const n=e[e.length-1]==="=",s=(1<<t)-1;let i="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>t;)o-=t,i+=e[s&a>>o];if(o!==0&&(i+=e[s&a<<t-o]),n)for(;(i.length*t&7)!==0;)i+="=";return i}function bm(r){const e={};for(let t=0;t<r.length;++t)e[r[t]]=t;return e}function Re({name:r,prefix:e,bitsPerChar:t,alphabet:n}){const s=bm(n);return to({prefix:e,name:r,encode(i){return wm(i,n,t)},decode(i){return ym(i,s,t,r)}})}const be=os({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),vm=os({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),Sm=Object.freeze(Object.defineProperty({__proto__:null,base58btc:be,base58flickr:vm},Symbol.toStringTag,{value:"Module"})),Pt=Re({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Em=Re({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),_m=Re({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),xm=Re({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Am=Re({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Cm=Re({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Im=Re({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Tm=Re({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Pm=Re({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),km=Object.freeze(Object.defineProperty({__proto__:null,base32:Pt,base32hex:Am,base32hexpad:Im,base32hexpadupper:Tm,base32hexupper:Cm,base32pad:_m,base32padupper:xm,base32upper:Em,base32z:Pm},Symbol.toStringTag,{value:"Module"})),Js=os({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Rm=os({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),Lm=Object.freeze(Object.defineProperty({__proto__:null,base36:Js,base36upper:Rm},Symbol.toStringTag,{value:"Module"}));var Dm=lh,Al=128,Mm=-128,Om=Math.pow(2,31);function lh(r,e,t){e=e||[],t=t||0;for(var n=t;r>=Om;)e[t++]=r&255|Al,r/=128;for(;r&Mm;)e[t++]=r&255|Al,r>>>=7;return e[t]=r|0,lh.bytes=t-n+1,e}var Fm=Ea,Nm=128,Cl=127;function Ea(r,n){var t=0,n=n||0,s=0,i=n,o,a=r.length;do{if(i>=a)throw Ea.bytes=0,new RangeError("Could not decode varint");o=r[i++],t+=s<28?(o&Cl)<<s:(o&Cl)*Math.pow(2,s),s+=7}while(o>=Nm);return Ea.bytes=i-n,t}var Bm=Math.pow(2,7),Um=Math.pow(2,14),$m=Math.pow(2,21),qm=Math.pow(2,28),Wm=Math.pow(2,35),zm=Math.pow(2,42),Km=Math.pow(2,49),Hm=Math.pow(2,56),Vm=Math.pow(2,63),Gm=function(r){return r<Bm?1:r<Um?2:r<$m?3:r<qm?4:r<Wm?5:r<zm?6:r<Km?7:r<Hm?8:r<Vm?9:10},jm={encode:Dm,decode:Fm,encodingLength:Gm},ui=jm;function _a(r,e=0){return[ui.decode(r,e),ui.decode.bytes]}function di(r,e,t=0){return ui.encode(r,e,t),e}function hi(r){return ui.encodingLength(r)}function zn(r,e){const t=e.byteLength,n=hi(r),s=n+hi(t),i=new Uint8Array(s+t);return di(r,i,0),di(t,i,n),i.set(e,s),new gc(r,t,e,i)}function rr(r){const e=eo(r),[t,n]=_a(e),[s,i]=_a(e.subarray(n)),o=e.subarray(n+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new gc(t,s,o,e)}function Ym(r,e){if(r===e)return!0;{const t=e;return r.code===t.code&&r.size===t.size&&t.bytes instanceof Uint8Array&&am(r.bytes,t.bytes)}}class gc{code;size;digest;bytes;constructor(e,t,n,s){this.code=e,this.size=t,this.digest=n,this.bytes=s}}function Il(r,e){const{bytes:t,version:n}=r;switch(n){case 0:return Qm(t,xa(r),e??be.encoder);default:return Zm(t,xa(r),e??Pt.encoder)}}const Tl=new WeakMap;function xa(r){const e=Tl.get(r);if(e==null){const t=new Map;return Tl.set(r,t),t}return e}class le{code;version;multihash;bytes;"/";constructor(e,t,n,s){this.code=t,this.version=e,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==An)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Jm)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return le.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=zn(e,t);return le.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return le.equals(this,e)}static equals(e,t){const n=t;return n!=null&&e.code===n.code&&e.version===n.version&&Ym(e.multihash,n.multihash)}toString(e){return Il(this,e)}toJSON(){return{"/":Il(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof le)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:n,code:s,multihash:i,bytes:o}=t;return new le(n,s,i,o??Pl(n,s,i.bytes))}else if(t[ey]===!0){const{version:n,multihash:s,code:i}=t,o=rr(s);return le.create(n,i,o)}else return null}static create(e,t,n){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==An)throw new Error(`Version 0 CID must use dag-pb (code: ${An}) block encoding`);return new le(e,t,n,n.bytes)}case 1:{const s=Pl(e,t,n.bytes);return new le(e,t,n,s)}default:throw new Error("Invalid version")}}static createV0(e){return le.create(0,An,e)}static createV1(e,t){return le.create(1,e,t)}static decode(e){const[t,n]=le.decodeFirst(e);if(n.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=le.inspectBytes(e),n=t.size-t.multihashSize,s=eo(e.subarray(n,n+t.multihashSize));if(s.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=s.subarray(t.multihashSize-t.digestSize),o=new gc(t.multihashCode,t.digestSize,i,s);return[t.version===0?le.createV0(o):le.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[d,h]=_a(e.subarray(t));return t+=h,d};let s=n(),i=An;if(s===18?(s=0,t=0):i=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=t,a=n(),c=n(),l=t+c,u=l-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:u,size:l}}static parse(e,t){const[n,s]=Xm(e,t),i=le.decode(s);if(i.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return xa(i).set(n,e),i}}function Xm(r,e){switch(r[0]){case"Q":{const t=e??be;return[be.prefix,t.decode(`${be.prefix}${r}`)]}case be.prefix:{const t=e??be;return[be.prefix,t.decode(r)]}case Pt.prefix:{const t=e??Pt;return[Pt.prefix,t.decode(r)]}case Js.prefix:{const t=e??Js;return[Js.prefix,t.decode(r)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],e.decode(r)]}}}function Qm(r,e,t){const{prefix:n}=t;if(n!==be.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const s=e.get(n);if(s==null){const i=t.encode(r).slice(1);return e.set(n,i),i}else return s}function Zm(r,e,t){const{prefix:n}=t,s=e.get(n);if(s==null){const i=t.encode(r);return e.set(n,i),i}else return s}const An=112,Jm=18;function Pl(r,e,t){const n=hi(r),s=n+hi(e),i=new Uint8Array(s+t.byteLength);return di(r,i,0),di(e,i,n),i.set(t,s),i}const ey=Symbol.for("@ipld/js-cid/CID"),uh=0,ty="identity",dh=eo;function ry(r){return zn(uh,dh(r))}const as={code:uh,name:ty,encode:dh,digest:ry};function ke(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function ae(r=0){return new Uint8Array(r)}function St(r=0){return new Uint8Array(r)}function ut(r,e){e==null&&(e=r.reduce((s,i)=>s+i.length,0));const t=St(e);let n=0;for(const s of r)t.set(s,n),n+=s.length;return t}const hh=Symbol.for("@achingbrain/uint8arraylist");function kl(r,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(const n of r){const s=t+n.byteLength;if(e<s)return{buf:n,index:e-t};t=s}throw new RangeError("index is out of bounds")}function _s(r){return!!r?.[hh]}class J{bufs;length;[hh]=!0;constructor(...e){this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const n of e)if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.push(n);else if(_s(n))t+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const n of e.reverse())if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.unshift(n);else if(_s(n))t+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){const t=kl(this.bufs,e);return t.buf[t.index]}set(e,t){const n=kl(this.bufs,e);n.buf[n.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let n=0;n<e.length;n++)this.set(t+n,e[n]);else if(_s(e))for(let n=0;n<e.length;n++)this.set(t+n,e.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){const{bufs:n,length:s}=this._subList(e,t);return ut(n,s)}subarray(e,t){const{bufs:n,length:s}=this._subList(e,t);return n.length===1?n[0]:ut(n,s)}sublist(e,t){const{bufs:n,length:s}=this._subList(e,t),i=new J;return i.length=s,i.bufs=[...n],i}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};const n=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],a=s,c=a+o.byteLength;if(s=c,e>=c)continue;const l=e>=a&&e<c,u=t>a&&t<=c;if(l&&u){if(e===a&&t===c){n.push(o);break}const d=e-a;n.push(o.subarray(d,d+(t-e)));break}if(l){if(e===0){n.push(o);continue}n.push(o.subarray(e-a));continue}if(u){if(t===c){n.push(o);break}n.push(o.subarray(0,t-a));break}n.push(o)}return{bufs:n,length:t-e}}indexOf(e,t=0){if(!_s(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const n=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const s=n.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let d=0;d<i;d++)o[d]=-1;for(let d=0;d<s;d++)o[n[d]]=d;const a=o,c=this.byteLength-n.byteLength,l=n.byteLength-1;let u;for(let d=t;d<=c;d+=u){u=0;for(let h=l;h>=0;h--){const p=this.get(d+h);if(n[h]!==p){u=Math.max(1,h-a[p]);break}}if(u===0)return d}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const n=St(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,t),this.write(n,e)}getInt16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,t)}setInt16(e,t,n){const s=ae(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,t,n),this.write(s,e)}getInt32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,t)}setInt32(e,t,n){const s=ae(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,t,n),this.write(s,e)}getBigInt64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,t)}setBigInt64(e,t,n){const s=ae(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,t,n),this.write(s,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const n=St(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,t),this.write(n,e)}getUint16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,t)}setUint16(e,t,n){const s=ae(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,t,n),this.write(s,e)}getUint32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,t)}setUint32(e,t,n){const s=ae(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,t,n),this.write(s,e)}getBigUint64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,t)}setBigUint64(e,t,n){const s=ae(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,t,n),this.write(s,e)}getFloat32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,t)}setFloat32(e,t,n){const s=ae(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,t,n),this.write(s,e)}getFloat64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,t)}setFloat64(e,t,n){const s=ae(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,t,n),this.write(s,e)}equals(e){if(e==null||!(e instanceof J)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!ke(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const n=new J;return n.bufs=e,t==null&&(t=e.reduce((s,i)=>s+i.byteLength,0)),n.length=t,n}}const ny=os({prefix:"9",name:"base10",alphabet:"0123456789"}),sy=Object.freeze(Object.defineProperty({__proto__:null,base10:ny},Symbol.toStringTag,{value:"Module"})),iy=Re({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),oy=Re({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),ay=Object.freeze(Object.defineProperty({__proto__:null,base16:iy,base16upper:oy},Symbol.toStringTag,{value:"Module"})),cy=Re({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),ly=Object.freeze(Object.defineProperty({__proto__:null,base2:cy},Symbol.toStringTag,{value:"Module"})),fh=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),uy=fh.reduce((r,e,t)=>(r[t]=e,r),[]),dy=fh.reduce((r,e,t)=>{const n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);return r[n]=t,r},[]);function hy(r){return r.reduce((e,t)=>(e+=uy[t],e),"")}function fy(r){const e=[];for(const t of r){const n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);const s=dy[n];if(s==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(s)}return new Uint8Array(e)}const py=to({prefix:"ðŸš€",name:"base256emoji",encode:hy,decode:fy}),gy=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:py},Symbol.toStringTag,{value:"Module"})),ph=Re({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),my=Re({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),gh=Re({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),yy=Re({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),wy=Object.freeze(Object.defineProperty({__proto__:null,base64:ph,base64pad:my,base64url:gh,base64urlpad:yy},Symbol.toStringTag,{value:"Module"})),by=Re({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),vy=Object.freeze(Object.defineProperty({__proto__:null,base8:by},Symbol.toStringTag,{value:"Module"})),Sy=to({prefix:"\0",name:"identity",encode:r=>lm(r),decode:r=>cm(r)}),Ey=Object.freeze(Object.defineProperty({__proto__:null,identity:Sy},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;function _y({name:r,code:e,encode:t}){return new xy(r,e,t)}class xy{name;code;encode;constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?zn(this.code,t):t.then(n=>zn(this.code,n))}else throw Error("Unknown type, must be binary type")}}function Ay(r){return async e=>new Uint8Array(await crypto.subtle.digest(r,e))}const mh=_y({name:"sha2-256",code:18,encode:Ay("SHA-256")}),fi={...Ey,...ly,...vy,...sy,...ay,...km,...Lm,...Sm,...wy,...gy};function yh(r,e,t,n){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:n}}}const Rl=yh("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),vo=yh("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);const e=St(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),wh={utf8:Rl,"utf-8":Rl,hex:fi.base16,latin1:vo,ascii:vo,binary:vo,...fi};function z(r,e="utf8"){const t=wh[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${r}`)}function G(r,e="utf8"){const t=wh[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(r).substring(1)}const Cy=parseInt("11111",2),Aa=parseInt("10000000",2),Iy=parseInt("01111111",2),Ll={0:Cn,1:Cn,2:Ty,3:Ry,4:Ly,5:ky,6:Py,16:Cn,22:Cn,48:Cn};function ro(r,e={offset:0}){const t=r[e.offset]&Cy;if(e.offset++,Ll[t]!=null)return Ll[t](r,e);throw new Error("No decoder for tag "+t)}function cs(r,e){let t=0;if((r[e.offset]&Aa)===Aa){const n=r[e.offset]&Iy;let s="0x";e.offset++;for(let i=0;i<n;i++,e.offset++)s+=r[e.offset].toString(16).padStart(2,"0");t=parseInt(s,16)}else t=r[e.offset],e.offset++;return t}function Cn(r,e){cs(r,e);const t=[];for(;!(e.offset>=r.byteLength);){const n=ro(r,e);if(n===null)break;t.push(n)}return t}function Ty(r,e){const t=cs(r,e),n=e.offset,s=e.offset+t,i=[];for(let o=n;o<s;o++)o===n&&r[o]===0||i.push(r[o]);return e.offset+=t,Uint8Array.from(i)}function Py(r,e){const t=cs(r,e),n=e.offset+t,s=r[e.offset];e.offset++;let i=0,o=0;s<40?(i=0,o=s):s<80?(i=1,o=s-40):(i=2,o=s-80);let a=`${i}.${o}`,c=[];for(;e.offset<n;){const l=r[e.offset];if(e.offset++,c.push(l&127),l<128){c.reverse();let u=0;for(let d=0;d<c.length;d++)u+=c[d]<<d*7;a+=`.${u}`,c=[]}}return a}function ky(r,e){return e.offset++,null}function Ry(r,e){const t=cs(r,e),n=r[e.offset];e.offset++;const s=r.subarray(e.offset,e.offset+t-1);if(e.offset+=t,n!==0)throw new Error("Unused bits in bit string is unimplemented");return s}function Ly(r,e){const t=cs(r,e),n=r.subarray(e.offset,e.offset+t);return e.offset+=t,n}function Dy(r){let e=r.toString(16);e.length%2===1&&(e="0"+e);const t=new J;for(let n=0;n<e.length;n+=2)t.append(Uint8Array.from([parseInt(`${e[n]}${e[n+1]}`,16)]));return t}function mc(r){if(r.byteLength<128)return Uint8Array.from([r.byteLength]);const e=Dy(r.byteLength);return new J(Uint8Array.from([e.byteLength|Aa]),e)}function Ca(r){const e=new J,t=128;return(r.subarray()[0]&t)===t&&e.append(Uint8Array.from([0])),e.append(r),new J(Uint8Array.from([2]),mc(e),e)}function bh(r){const e=Uint8Array.from([0]),t=new J(e,r);return new J(Uint8Array.from([3]),mc(t),t)}function Bn(r,e=48){const t=new J;for(const n of r)t.append(n);return new J(Uint8Array.from([e]),mc(t),t)}async function My(r,e,t,n){const s=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv??"P-256"},!1,["verify"]);n?.signal?.throwIfAborted();const i=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},s,e,t.subarray());return n?.signal?.throwIfAborted(),i}const Oy=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),Fy=Uint8Array.from([6,5,43,129,4,0,34]),Ny=Uint8Array.from([6,5,43,129,4,0,35]),By={ext:!0,kty:"EC",crv:"P-256"},Uy={ext:!0,kty:"EC",crv:"P-384"},$y={ext:!0,kty:"EC",crv:"P-521"},So=32,Eo=48,_o=66;function vh(r){const e=ro(r);return qy(e)}function qy(r){const e=r[1][1][0],t=1;let n,s;if(e.byteLength===So*2+1)return n=G(e.subarray(t,t+So),"base64url"),s=G(e.subarray(t+So),"base64url"),new xo({...By,key_ops:["verify"],x:n,y:s});if(e.byteLength===Eo*2+1)return n=G(e.subarray(t,t+Eo),"base64url"),s=G(e.subarray(t+Eo),"base64url"),new xo({...Uy,key_ops:["verify"],x:n,y:s});if(e.byteLength===_o*2+1)return n=G(e.subarray(t,t+_o),"base64url"),s=G(e.subarray(t+_o),"base64url"),new xo({...$y,key_ops:["verify"],x:n,y:s});throw new K(`coordinates were wrong length, got ${e.byteLength}, expected 65, 97 or 133`)}function Wy(r){return Bn([Ca(Uint8Array.from([1])),Bn([zy(r.crv)],160),Bn([bh(new J(Uint8Array.from([4]),z(r.x??"","base64url"),z(r.y??"","base64url")))],161)]).subarray()}function zy(r){if(r==="P-256")return Oy;if(r==="P-384")return Fy;if(r==="P-521")return Ny;throw new K(`Invalid curve ${r}`)}class xo{type="ECDSA";jwk;_raw;constructor(e){this.jwk=e}get raw(){return this._raw==null&&(this._raw=Wy(this.jwk)),this._raw}toMultihash(){return as.digest(kt(this))}toCID(){return le.createV1(114,this.toMultihash())}toString(){return be.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:ke(this.raw,e.raw)}async verify(e,t,n){return My(this.jwk,t,e,n)}}const Lr=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ky(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function pi(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function ls(r,...e){if(!Ky(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function yc(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");pi(r.outputLen),pi(r.blockLen)}function gi(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Hy(r,e){ls(r);const t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function _r(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function Ao(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function ft(r,e){return r<<32-e|r>>>e}function Vy(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}function Kn(r){return typeof r=="string"&&(r=Vy(r)),ls(r),r}function Gy(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];ls(s),e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const i=r[n];t.set(i,s),s+=i.length}return t}class Sh{}function Eh(r){const e=n=>r().update(Kn(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function no(r=32){if(Lr&&typeof Lr.getRandomValues=="function")return Lr.getRandomValues(new Uint8Array(r));if(Lr&&typeof Lr.randomBytes=="function")return Uint8Array.from(Lr.randomBytes(r));throw new Error("crypto.getRandomValues must be defined")}function jy(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const s=BigInt(32),i=BigInt(4294967295),o=Number(t>>s&i),a=Number(t&i),c=n?4:0,l=n?0:4;r.setUint32(e+c,o,n),r.setUint32(e+l,a,n)}function Yy(r,e,t){return r&e^~r&t}function Xy(r,e,t){return r&e^r&t^e&t}class _h extends Sh{constructor(e,t,n,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=s,this.buffer=new Uint8Array(e),this.view=Ao(this.buffer)}update(e){gi(this),e=Kn(e),ls(e);const{view:t,buffer:n,blockLen:s}=this,i=e.length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a===s){const c=Ao(e);for(;s<=i-o;o+=s)this.process(c,o);continue}n.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){gi(this),Hy(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:s,isLE:i}=this;let{pos:o}=this;t[o++]=128,_r(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(n,0),o=0);for(let d=o;d<s;d++)t[d]=0;jy(n,s-8,BigInt(this.length*8),i),this.process(n,0);const a=Ao(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=c/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<l;d++)a.setUint32(4*d,u[d],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:s,finished:i,destroyed:o,pos:a}=this;return e.destroyed=o,e.finished=i,e.length=s,e.pos=a,s%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}}const Mt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),De=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),xs=BigInt(2**32-1),Dl=BigInt(32);function Qy(r,e=!1){return e?{h:Number(r&xs),l:Number(r>>Dl&xs)}:{h:Number(r>>Dl&xs)|0,l:Number(r&xs)|0}}function Zy(r,e=!1){const t=r.length;let n=new Uint32Array(t),s=new Uint32Array(t);for(let i=0;i<t;i++){const{h:o,l:a}=Qy(r[i],e);[n[i],s[i]]=[o,a]}return[n,s]}const Ml=(r,e,t)=>r>>>t,Ol=(r,e,t)=>r<<32-t|e>>>t,Dr=(r,e,t)=>r>>>t|e<<32-t,Mr=(r,e,t)=>r<<32-t|e>>>t,As=(r,e,t)=>r<<64-t|e>>>t-32,Cs=(r,e,t)=>r>>>t-32|e<<64-t;function Et(r,e,t,n){const s=(e>>>0)+(n>>>0);return{h:r+t+(s/2**32|0)|0,l:s|0}}const Jy=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),ew=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,tw=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),rw=(r,e,t,n,s)=>e+t+n+s+(r/2**32|0)|0,nw=(r,e,t,n,s)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(s>>>0),sw=(r,e,t,n,s,i)=>e+t+n+s+i+(r/2**32|0)|0,iw=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Ot=new Uint32Array(64);class ow extends _h{constructor(e=32){super(64,e,8,!1),this.A=Mt[0]|0,this.B=Mt[1]|0,this.C=Mt[2]|0,this.D=Mt[3]|0,this.E=Mt[4]|0,this.F=Mt[5]|0,this.G=Mt[6]|0,this.H=Mt[7]|0}get(){const{A:e,B:t,C:n,D:s,E:i,F:o,G:a,H:c}=this;return[e,t,n,s,i,o,a,c]}set(e,t,n,s,i,o,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let d=0;d<16;d++,t+=4)Ot[d]=e.getUint32(t,!1);for(let d=16;d<64;d++){const h=Ot[d-15],p=Ot[d-2],f=ft(h,7)^ft(h,18)^h>>>3,g=ft(p,17)^ft(p,19)^p>>>10;Ot[d]=g+Ot[d-7]+f+Ot[d-16]|0}let{A:n,B:s,C:i,D:o,E:a,F:c,G:l,H:u}=this;for(let d=0;d<64;d++){const h=ft(a,6)^ft(a,11)^ft(a,25),p=u+h+Yy(a,c,l)+iw[d]+Ot[d]|0,g=(ft(n,2)^ft(n,13)^ft(n,22))+Xy(n,s,i)|0;u=l,l=c,c=a,a=o+p|0,o=i,i=s,s=n,n=p+g|0}n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(n,s,i,o,a,c,l,u)}roundClean(){_r(Ot)}destroy(){this.set(0,0,0,0,0,0,0,0),_r(this.buffer)}}const xh=Zy(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),aw=xh[0],cw=xh[1],Ft=new Uint32Array(80),Nt=new Uint32Array(80);class lw extends _h{constructor(e=64){super(128,e,16,!1),this.Ah=De[0]|0,this.Al=De[1]|0,this.Bh=De[2]|0,this.Bl=De[3]|0,this.Ch=De[4]|0,this.Cl=De[5]|0,this.Dh=De[6]|0,this.Dl=De[7]|0,this.Eh=De[8]|0,this.El=De[9]|0,this.Fh=De[10]|0,this.Fl=De[11]|0,this.Gh=De[12]|0,this.Gl=De[13]|0,this.Hh=De[14]|0,this.Hl=De[15]|0}get(){const{Ah:e,Al:t,Bh:n,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:l,El:u,Fh:d,Fl:h,Gh:p,Gl:f,Hh:g,Hl:m}=this;return[e,t,n,s,i,o,a,c,l,u,d,h,p,f,g,m]}set(e,t,n,s,i,o,a,c,l,u,d,h,p,f,g,m){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=d|0,this.Fl=h|0,this.Gh=p|0,this.Gl=f|0,this.Hh=g|0,this.Hl=m|0}process(e,t){for(let w=0;w<16;w++,t+=4)Ft[w]=e.getUint32(t),Nt[w]=e.getUint32(t+=4);for(let w=16;w<80;w++){const y=Ft[w-15]|0,v=Nt[w-15]|0,C=Dr(y,v,1)^Dr(y,v,8)^Ml(y,v,7),E=Mr(y,v,1)^Mr(y,v,8)^Ol(y,v,7),A=Ft[w-2]|0,T=Nt[w-2]|0,O=Dr(A,T,19)^As(A,T,61)^Ml(A,T,6),L=Mr(A,T,19)^Cs(A,T,61)^Ol(A,T,6),M=tw(E,L,Nt[w-7],Nt[w-16]),D=rw(M,C,O,Ft[w-7],Ft[w-16]);Ft[w]=D|0,Nt[w]=M|0}let{Ah:n,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:l,Dl:u,Eh:d,El:h,Fh:p,Fl:f,Gh:g,Gl:m,Hh:S,Hl:x}=this;for(let w=0;w<80;w++){const y=Dr(d,h,14)^Dr(d,h,18)^As(d,h,41),v=Mr(d,h,14)^Mr(d,h,18)^Cs(d,h,41),C=d&p^~d&g,E=h&f^~h&m,A=nw(x,v,E,cw[w],Nt[w]),T=sw(A,S,y,C,aw[w],Ft[w]),O=A|0,L=Dr(n,s,28)^As(n,s,34)^As(n,s,39),M=Mr(n,s,28)^Cs(n,s,34)^Cs(n,s,39),D=n&i^n&a^i&a,U=s&o^s&c^o&c;S=g|0,x=m|0,g=p|0,m=f|0,p=d|0,f=h|0,{h:d,l:h}=Et(l|0,u|0,T|0,O|0),l=a|0,u=c|0,a=i|0,c=o|0,i=n|0,o=s|0;const P=Jy(O,M,U);n=ew(P,T,L,D),s=P|0}({h:n,l:s}=Et(this.Ah|0,this.Al|0,n|0,s|0)),{h:i,l:o}=Et(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=Et(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:u}=Et(this.Dh|0,this.Dl|0,l|0,u|0),{h:d,l:h}=Et(this.Eh|0,this.El|0,d|0,h|0),{h:p,l:f}=Et(this.Fh|0,this.Fl|0,p|0,f|0),{h:g,l:m}=Et(this.Gh|0,this.Gl|0,g|0,m|0),{h:S,l:x}=Et(this.Hh|0,this.Hl|0,S|0,x|0),this.set(n,s,i,o,a,c,l,u,d,h,p,f,g,m,S,x)}roundClean(){_r(Ft,Nt)}destroy(){_r(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Ah=Eh(()=>new ow),uw=Eh(()=>new lw);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const wc=BigInt(0),Ia=BigInt(1);function us(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function bc(r){if(!us(r))throw new Error("Uint8Array expected")}function jt(r,e){if(typeof e!="boolean")throw new Error(r+" boolean expected, got "+e)}function Is(r){const e=r.toString(16);return e.length&1?"0"+e:e}function Ch(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?wc:BigInt("0x"+r)}const Ih=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",dw=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function Zr(r){if(bc(r),Ih)return r.toHex();let e="";for(let t=0;t<r.length;t++)e+=dw[r[t]];return e}const _t={_0:48,_9:57,A:65,F:70,a:97,f:102};function Fl(r){if(r>=_t._0&&r<=_t._9)return r-_t._0;if(r>=_t.A&&r<=_t.F)return r-(_t.A-10);if(r>=_t.a&&r<=_t.f)return r-(_t.a-10)}function mi(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(Ih)return Uint8Array.fromHex(r);const e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let s=0,i=0;s<t;s++,i+=2){const o=Fl(r.charCodeAt(i)),a=Fl(r.charCodeAt(i+1));if(o===void 0||a===void 0){const c=r[i]+r[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}n[s]=o*16+a}return n}function yr(r){return Ch(Zr(r))}function wr(r){return bc(r),Ch(Zr(Uint8Array.from(r).reverse()))}function ds(r,e){return mi(r.toString(16).padStart(e*2,"0"))}function Hn(r,e){return ds(r,e).reverse()}function fe(r,e,t){let n;if(typeof e=="string")try{n=mi(e)}catch(i){throw new Error(r+" must be hex string or Uint8Array, cause: "+i)}else if(us(e))n=Uint8Array.from(e);else throw new Error(r+" must be hex string or Uint8Array");const s=n.length;if(typeof t=="number"&&s!==t)throw new Error(r+" of length "+t+" expected, got "+s);return n}function Jr(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];bc(s),e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const i=r[n];t.set(i,s),s+=i.length}return t}const Co=r=>typeof r=="bigint"&&wc<=r;function vc(r,e,t){return Co(r)&&Co(e)&&Co(t)&&e<=r&&r<t}function Xe(r,e,t,n){if(!vc(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function hw(r){let e;for(e=0;r>wc;r>>=Ia,e+=1);return e}const so=r=>(Ia<<BigInt(r))-Ia,Io=r=>new Uint8Array(r),Nl=r=>Uint8Array.from(r);function fw(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=Io(r),s=Io(r),i=0;const o=()=>{n.fill(1),s.fill(0),i=0},a=(...d)=>t(s,n,...d),c=(d=Io(0))=>{s=a(Nl([0]),d),n=a(),d.length!==0&&(s=a(Nl([1]),d),n=a())},l=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let d=0;const h=[];for(;d<e;){n=a();const p=n.slice();h.push(p),d+=n.length}return Jr(...h)};return(d,h)=>{o(),c(d);let p;for(;!(p=h(l()));)c();return o(),p}}const pw={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||us(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function wn(r,e,t={}){const n=(s,i,o)=>{const a=pw[i];if(typeof a!="function")throw new Error("invalid validator function");const c=r[s];if(!(o&&c===void 0)&&!a(c,r))throw new Error("param "+String(s)+" is invalid. Expected "+i+", got "+c)};for(const[s,i]of Object.entries(e))n(s,i,!1);for(const[s,i]of Object.entries(t))n(s,i,!0);return r}function yi(r){const e=new WeakMap;return(t,...n)=>{const s=e.get(t);if(s!==void 0)return s;const i=r(t,...n);return e.set(t,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ge=BigInt(0),Pe=BigInt(1),fr=BigInt(2),gw=BigInt(3),Th=BigInt(4),Ph=BigInt(5),kh=BigInt(8);function ue(r,e){const t=r%e;return t>=Ge?t:e+t}function he(r,e,t){let n=r;for(;e-- >Ge;)n*=n,n%=t;return n}function Ta(r,e){if(r===Ge)throw new Error("invert: expected non-zero number");if(e<=Ge)throw new Error("invert: expected positive modulus, got "+e);let t=ue(r,e),n=e,s=Ge,i=Pe;for(;t!==Ge;){const a=n/t,c=n%t,l=s-i*a;n=t,t=c,s=i,i=l}if(n!==Pe)throw new Error("invert: does not exist");return ue(s,e)}function Rh(r,e){const t=(r.ORDER+Pe)/Th,n=r.pow(e,t);if(!r.eql(r.sqr(n),e))throw new Error("Cannot find square root");return n}function mw(r,e){const t=(r.ORDER-Ph)/kh,n=r.mul(e,fr),s=r.pow(n,t),i=r.mul(e,s),o=r.mul(r.mul(i,fr),s),a=r.mul(i,r.sub(o,r.ONE));if(!r.eql(r.sqr(a),e))throw new Error("Cannot find square root");return a}function yw(r){if(r<BigInt(3))throw new Error("sqrt is not defined for small field");let e=r-Pe,t=0;for(;e%fr===Ge;)e/=fr,t++;let n=fr;const s=hs(r);for(;Bl(s,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return Rh;let i=s.pow(n,e);const o=(e+Pe)/fr;return function(c,l){if(c.is0(l))return l;if(Bl(c,l)!==1)throw new Error("Cannot find square root");let u=t,d=c.mul(c.ONE,i),h=c.pow(l,e),p=c.pow(l,o);for(;!c.eql(h,c.ONE);){if(c.is0(h))return c.ZERO;let f=1,g=c.sqr(h);for(;!c.eql(g,c.ONE);)if(f++,g=c.sqr(g),f===u)throw new Error("Cannot find square root");const m=Pe<<BigInt(u-f-1),S=c.pow(d,m);u=f,d=c.sqr(S),h=c.mul(h,d),p=c.mul(p,S)}return p}}function ww(r){return r%Th===gw?Rh:r%kh===Ph?mw:yw(r)}const bw=(r,e)=>(ue(r,e)&Pe)===Pe,vw=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Sw(r){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=vw.reduce((n,s)=>(n[s]="function",n),e);return wn(r,t)}function Ew(r,e,t){if(t<Ge)throw new Error("invalid exponent, negatives unsupported");if(t===Ge)return r.ONE;if(t===Pe)return e;let n=r.ONE,s=e;for(;t>Ge;)t&Pe&&(n=r.mul(n,s)),s=r.sqr(s),t>>=Pe;return n}function Sc(r,e,t=!1){const n=new Array(e.length).fill(t?r.ZERO:void 0),s=e.reduce((o,a,c)=>r.is0(a)?o:(n[c]=o,r.mul(o,a)),r.ONE),i=r.inv(s);return e.reduceRight((o,a,c)=>r.is0(a)?o:(n[c]=r.mul(o,n[c]),r.mul(o,a)),i),n}function Bl(r,e){const t=(r.ORDER-Pe)/fr,n=r.pow(e,t),s=r.eql(n,r.ONE),i=r.eql(n,r.ZERO),o=r.eql(n,r.neg(r.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function Lh(r,e){e!==void 0&&pi(e);const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function hs(r,e,t=!1,n={}){if(r<=Ge)throw new Error("invalid field: expected ORDER > 0, got "+r);const{nBitLength:s,nByteLength:i}=Lh(r,e);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const a=Object.freeze({ORDER:r,isLE:t,BITS:s,BYTES:i,MASK:so(s),ZERO:Ge,ONE:Pe,create:c=>ue(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return Ge<=c&&c<r},is0:c=>c===Ge,isOdd:c=>(c&Pe)===Pe,neg:c=>ue(-c,r),eql:(c,l)=>c===l,sqr:c=>ue(c*c,r),add:(c,l)=>ue(c+l,r),sub:(c,l)=>ue(c-l,r),mul:(c,l)=>ue(c*l,r),pow:(c,l)=>Ew(a,c,l),div:(c,l)=>ue(c*Ta(l,r),r),sqrN:c=>c*c,addN:(c,l)=>c+l,subN:(c,l)=>c-l,mulN:(c,l)=>c*l,inv:c=>Ta(c,r),sqrt:n.sqrt||(c=>(o||(o=ww(r)),o(a,c))),toBytes:c=>t?Hn(c,i):ds(c,i),fromBytes:c=>{if(c.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+c.length);return t?wr(c):yr(c)},invertBatch:c=>Sc(a,c),cmov:(c,l,u)=>u?l:c});return Object.freeze(a)}function Dh(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function Mh(r){const e=Dh(r);return e+Math.ceil(e/2)}function _w(r,e,t=!1){const n=r.length,s=Dh(e),i=Mh(e);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);const o=t?wr(r):yr(r),a=ue(o,e-Pe)+Pe;return t?Hn(a,s):ds(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ul=BigInt(0),Pa=BigInt(1);function To(r,e){const t=e.negate();return r?t:e}function Oh(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function Po(r,e){Oh(r,e);const t=Math.ceil(e/r)+1,n=2**(r-1),s=2**r,i=so(r),o=BigInt(r);return{windows:t,windowSize:n,mask:i,maxNumber:s,shiftBy:o}}function $l(r,e,t){const{windowSize:n,mask:s,maxNumber:i,shiftBy:o}=t;let a=Number(r&s),c=r>>o;a>n&&(a-=i,c+=Pa);const l=e*n,u=l+Math.abs(a)-1,d=a===0,h=a<0,p=e%2!==0;return{nextN:c,offset:u,isZero:d,isNeg:h,isNegF:p,offsetF:l}}function xw(r,e){if(!Array.isArray(r))throw new Error("array expected");r.forEach((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)})}function Aw(r,e){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)})}const ko=new WeakMap,Fh=new WeakMap;function Ro(r){return Fh.get(r)||1}function Nh(r,e){return{constTimeNegate:To,hasPrecomputes(t){return Ro(t)!==1},unsafeLadder(t,n,s=r.ZERO){let i=t;for(;n>Ul;)n&Pa&&(s=s.add(i)),i=i.double(),n>>=Pa;return s},precomputeWindow(t,n){const{windows:s,windowSize:i}=Po(n,e),o=[];let a=t,c=a;for(let l=0;l<s;l++){c=a,o.push(c);for(let u=1;u<i;u++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(t,n,s){let i=r.ZERO,o=r.BASE;const a=Po(t,e);for(let c=0;c<a.windows;c++){const{nextN:l,offset:u,isZero:d,isNeg:h,isNegF:p,offsetF:f}=$l(s,c,a);s=l,d?o=o.add(To(p,n[f])):i=i.add(To(h,n[u]))}return{p:i,f:o}},wNAFUnsafe(t,n,s,i=r.ZERO){const o=Po(t,e);for(let a=0;a<o.windows&&s!==Ul;a++){const{nextN:c,offset:l,isZero:u,isNeg:d}=$l(s,a,o);if(s=c,!u){const h=n[l];i=i.add(d?h.negate():h)}}return i},getPrecomputes(t,n,s){let i=ko.get(n);return i||(i=this.precomputeWindow(n,t),t!==1&&ko.set(n,s(i))),i},wNAFCached(t,n,s){const i=Ro(t);return this.wNAF(i,this.getPrecomputes(i,t,s),n)},wNAFCachedUnsafe(t,n,s,i){const o=Ro(t);return o===1?this.unsafeLadder(t,n,i):this.wNAFUnsafe(o,this.getPrecomputes(o,t,s),n,i)},setWindowSize(t,n){Oh(n,e),Fh.set(t,n),ko.delete(t)}}}function Bh(r,e,t,n){xw(t,r),Aw(n,e);const s=t.length,i=n.length;if(s!==i)throw new Error("arrays of points and scalars must have equal length");const o=r.ZERO,a=hw(BigInt(s));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const l=so(c),u=new Array(Number(l)+1).fill(o),d=Math.floor((e.BITS-1)/c)*c;let h=o;for(let p=d;p>=0;p-=c){u.fill(o);for(let g=0;g<i;g++){const m=n[g],S=Number(m>>BigInt(p)&l);u[S]=u[S].add(t[g])}let f=o;for(let g=u.length-1,m=o;g>0;g--)m=m.add(u[g]),f=f.add(m);if(h=h.add(f),p!==0)for(let g=0;g<c;g++)h=h.double()}return h}function Ec(r){return Sw(r.Fp),wn(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Lh(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const pt=BigInt(0),Be=BigInt(1),ql=BigInt(2),Cw=BigInt(8),Iw={zip215:!0};function Tw(r){const e=Ec(r);return wn(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function Pw(r){const e=Tw(r),{Fp:t,n,prehash:s,hash:i,randomBytes:o,nByteLength:a,h:c}=e,l=ql<<BigInt(a*8)-Be,u=t.create,d=hs(e.n,e.nBitLength);function h(I,b){const _=t.sqr(I),R=t.sqr(b),N=t.add(t.mul(e.a,_),R),$=t.add(t.ONE,t.mul(e.d,t.mul(_,R)));return t.eql(N,$)}if(!h(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const p=e.uvRatio||((I,b)=>{try{return{isValid:!0,value:t.sqrt(I*t.inv(b))}}catch{return{isValid:!1,value:pt}}}),f=e.adjustScalarBytes||(I=>I),g=e.domain||((I,b,_)=>{if(jt("phflag",_),b.length||_)throw new Error("Contexts/pre-hash are not supported");return I});function m(I,b,_=!1){const R=_?Be:pt;Xe("coordinate "+I,b,R,l)}function S(I){if(!(I instanceof y))throw new Error("ExtendedPoint expected")}const x=yi((I,b)=>{const{ex:_,ey:R,ez:N}=I,$=I.is0();b==null&&(b=$?Cw:t.inv(N));const q=u(_*b),W=u(R*b),H=u(N*b);if($)return{x:pt,y:Be};if(H!==Be)throw new Error("invZ was invalid");return{x:q,y:W}}),w=yi(I=>{const{a:b,d:_}=e;if(I.is0())throw new Error("bad point: ZERO");const{ex:R,ey:N,ez:$,et:q}=I,W=u(R*R),H=u(N*N),j=u($*$),se=u(j*j),re=u(W*b),Ae=u(j*u(re+H)),ze=u(se+u(_*u(W*H)));if(Ae!==ze)throw new Error("bad point: equation left != right (1)");const Se=u(R*N),Le=u($*q);if(Se!==Le)throw new Error("bad point: equation left != right (2)");return!0});class y{constructor(b,_,R,N){m("x",b),m("y",_),m("z",R,!0),m("t",N),this.ex=b,this.ey=_,this.ez=R,this.et=N,Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(b){if(b instanceof y)throw new Error("extended point not allowed");const{x:_,y:R}=b||{};return m("x",_),m("y",R),new y(_,R,Be,u(_*R))}static normalizeZ(b){const _=Sc(t,b.map(R=>R.ez));return b.map((R,N)=>R.toAffine(_[N])).map(y.fromAffine)}static msm(b,_){return Bh(y,d,b,_)}_setWindowSize(b){E.setWindowSize(this,b)}assertValidity(){w(this)}equals(b){S(b);const{ex:_,ey:R,ez:N}=this,{ex:$,ey:q,ez:W}=b,H=u(_*W),j=u($*N),se=u(R*W),re=u(q*N);return H===j&&se===re}is0(){return this.equals(y.ZERO)}negate(){return new y(u(-this.ex),this.ey,this.ez,u(-this.et))}double(){const{a:b}=e,{ex:_,ey:R,ez:N}=this,$=u(_*_),q=u(R*R),W=u(ql*u(N*N)),H=u(b*$),j=_+R,se=u(u(j*j)-$-q),re=H+q,Ae=re-W,ze=H-q,Se=u(se*Ae),Le=u(re*ze),je=u(se*ze),st=u(Ae*re);return new y(Se,Le,st,je)}add(b){S(b);const{a:_,d:R}=e,{ex:N,ey:$,ez:q,et:W}=this,{ex:H,ey:j,ez:se,et:re}=b,Ae=u(N*H),ze=u($*j),Se=u(W*R*re),Le=u(q*se),je=u((N+$)*(H+j)-Ae-ze),st=Le-Se,_n=Le+Se,Sl=u(ze-_*Ae),Yg=u(je*st),Xg=u(_n*Sl),Qg=u(je*Sl),Zg=u(st*_n);return new y(Yg,Xg,Zg,Qg)}subtract(b){return this.add(b.negate())}wNAF(b){return E.wNAFCached(this,b,y.normalizeZ)}multiply(b){const _=b;Xe("scalar",_,Be,n);const{p:R,f:N}=this.wNAF(_);return y.normalizeZ([R,N])[0]}multiplyUnsafe(b,_=y.ZERO){const R=b;return Xe("scalar",R,pt,n),R===pt?C:this.is0()||R===Be?this:E.wNAFCachedUnsafe(this,R,y.normalizeZ,_)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return E.unsafeLadder(this,n).is0()}toAffine(b){return x(this,b)}clearCofactor(){const{h:b}=e;return b===Be?this:this.multiplyUnsafe(b)}static fromHex(b,_=!1){const{d:R,a:N}=e,$=t.BYTES;b=fe("pointHex",b,$),jt("zip215",_);const q=b.slice(),W=b[$-1];q[$-1]=W&-129;const H=wr(q),j=_?l:t.ORDER;Xe("pointHex.y",H,pt,j);const se=u(H*H),re=u(se-Be),Ae=u(R*se-N);let{isValid:ze,value:Se}=p(re,Ae);if(!ze)throw new Error("Point.fromHex: invalid y coordinate");const Le=(Se&Be)===Be,je=(W&128)!==0;if(!_&&Se===pt&&je)throw new Error("Point.fromHex: x=0 and x_0=1");return je!==Le&&(Se=u(-Se)),y.fromAffine({x:Se,y:H})}static fromPrivateKey(b){const{scalar:_}=O(b);return v.multiply(_)}toRawBytes(){const{x:b,y:_}=this.toAffine(),R=Hn(_,t.BYTES);return R[R.length-1]|=b&Be?128:0,R}toHex(){return Zr(this.toRawBytes())}}y.BASE=new y(e.Gx,e.Gy,Be,u(e.Gx*e.Gy)),y.ZERO=new y(pt,Be,Be,pt);const{BASE:v,ZERO:C}=y,E=Nh(y,a*8);function A(I){return ue(I,n)}function T(I){return A(wr(I))}function O(I){const b=t.BYTES;I=fe("private key",I,b);const _=fe("hashed private key",i(I),2*b),R=f(_.slice(0,b)),N=_.slice(b,2*b),$=T(R);return{head:R,prefix:N,scalar:$}}function L(I){const{head:b,prefix:_,scalar:R}=O(I),N=v.multiply(R),$=N.toRawBytes();return{head:b,prefix:_,scalar:R,point:N,pointBytes:$}}function M(I){return L(I).pointBytes}function D(I=Uint8Array.of(),...b){const _=Jr(...b);return T(i(g(_,fe("context",I),!!s)))}function U(I,b,_={}){I=fe("message",I),s&&(I=s(I));const{prefix:R,scalar:N,pointBytes:$}=L(b),q=D(_.context,R,I),W=v.multiply(q).toRawBytes(),H=D(_.context,W,$,I),j=A(q+H*N);Xe("signature.s",j,pt,n);const se=Jr(W,Hn(j,t.BYTES));return fe("result",se,t.BYTES*2)}const P=Iw;function k(I,b,_,R=P){const{context:N,zip215:$}=R,q=t.BYTES;I=fe("signature",I,2*q),b=fe("message",b),_=fe("publicKey",_,q),$!==void 0&&jt("zip215",$),s&&(b=s(b));const W=wr(I.slice(q,2*q));let H,j,se;try{H=y.fromHex(_,$),j=y.fromHex(I.slice(0,q),$),se=v.multiplyUnsafe(W)}catch{return!1}if(!$&&H.isSmallOrder())return!1;const re=D(N,j.toRawBytes(),H.toRawBytes(),b);return j.add(H.multiplyUnsafe(re)).subtract(se).clearCofactor().equals(y.ZERO)}return v._setWindowSize(8),{CURVE:e,getPublicKey:M,sign:U,verify:k,ExtendedPoint:y,utils:{getExtendedPublicKey:L,randomPrivateKey:()=>o(t.BYTES),precompute(I=8,b=y.BASE){return b._setWindowSize(I),b.multiply(BigInt(3)),b}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const In=BigInt(0),Or=BigInt(1),Ts=BigInt(2);function kw(r){return wn(r,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...r})}function Rw(r){const e=kw(r),{P:t,type:n,adjustScalarBytes:s,powPminus2:i}=e,o=n==="x25519";if(!o&&n!=="x448")throw new Error("invalid type");const a=o?255:448,c=o?32:56,l=BigInt(o?9:5),u=BigInt(o?121665:39081),d=o?Ts**BigInt(254):Ts**BigInt(447),h=o?BigInt(8)*Ts**BigInt(251)-Or:BigInt(4)*Ts**BigInt(445)-Or,p=d+h+Or,f=E=>ue(E,t),g=m(l);function m(E){return Hn(f(E),c)}function S(E){const A=fe("u coordinate",E,c);return o&&(A[31]&=127),f(wr(A))}function x(E){return wr(s(fe("scalar",E,c)))}function w(E,A){const T=C(S(A),x(E));if(T===In)throw new Error("invalid private or public key received");return m(T)}function y(E){return w(E,g)}function v(E,A,T){const O=f(E*(A-T));return A=f(A-O),T=f(T+O),{x_2:A,x_3:T}}function C(E,A){Xe("u",E,In,t),Xe("scalar",A,d,p);const T=A,O=E;let L=Or,M=In,D=E,U=Or,P=In;for(let F=BigInt(a-1);F>=In;F--){const I=T>>F&Or;P^=I,{x_2:L,x_3:D}=v(P,L,D),{x_2:M,x_3:U}=v(P,M,U),P=I;const b=L+M,_=f(b*b),R=L-M,N=f(R*R),$=_-N,q=D+U,W=D-U,H=f(W*b),j=f(q*R),se=H+j,re=H-j;D=f(se*se),U=f(O*f(re*re)),L=f(_*N),M=f($*(_+f(u*$)))}({x_2:L,x_3:D}=v(P,L,D)),{x_2:M,x_3:U}=v(P,M,U);const k=i(M);return f(L*k)}return{scalarMult:w,scalarMultBase:y,getSharedSecret:(E,A)=>w(E,A),getPublicKey:E=>y(E),utils:{randomPrivateKey:()=>e.randomBytes(c)},GuBytes:g.slice()}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Vn=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Wl=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const Lw=BigInt(1),zl=BigInt(2),Dw=BigInt(3),Mw=BigInt(5),Ow=BigInt(8);function Uh(r){const e=BigInt(10),t=BigInt(20),n=BigInt(40),s=BigInt(80),i=Vn,a=r*r%i*r%i,c=he(a,zl,i)*a%i,l=he(c,Lw,i)*r%i,u=he(l,Mw,i)*l%i,d=he(u,e,i)*u%i,h=he(d,t,i)*d%i,p=he(h,n,i)*h%i,f=he(p,s,i)*p%i,g=he(f,s,i)*p%i,m=he(g,e,i)*u%i;return{pow_p_5_8:he(m,zl,i)*r%i,b2:a}}function $h(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function Fw(r,e){const t=Vn,n=ue(e*e*e,t),s=ue(n*n*e,t),i=Uh(r*s).pow_p_5_8;let o=ue(r*n*i,t);const a=ue(e*o*o,t),c=o,l=ue(o*Wl,t),u=a===r,d=a===ue(-r,t),h=a===ue(-r*Wl,t);return u&&(o=c),(d||h)&&(o=l),bw(o,t)&&(o=ue(-o,t)),{isValid:u||d,value:o}}const Kl=hs(Vn,void 0,!0),Nw={a:Kl.create(BigInt(-1)),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Kl,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Ow,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:uw,randomBytes:no,adjustScalarBytes:$h,uvRatio:Fw},wi=Pw(Nw),Ps=Rw({P:Vn,type:"x25519",powPminus2:r=>{const e=Vn,{pow_p_5_8:t,b2:n}=Uh(r);return ue(he(t,Dw,e)*n,e)},adjustScalarBytes:$h,randomBytes:no});class Hl extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}}class Bw extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}}const xr={get(r=globalThis){const e=r.crypto;if(e?.subtle==null)throw new Bw("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return e}},qh=32,_c=64,ka=32;let Kr;const Wh=(async()=>{try{return await xr.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function Uw(){const r=wi.utils.randomPrivateKey(),e=wi.getPublicKey(r);return{privateKey:Vw(r,e),publicKey:e}}async function $w(r,e){let t;r.length===_c?t=r.subarray(0,32):t=r;const n={crv:"Ed25519",kty:"OKP",x:G(r.subarray(32),"base64url"),d:G(t,"base64url"),ext:!0,key_ops:["sign"]},s=await xr.get().subtle.importKey("jwk",n,{name:"Ed25519"},!0,["sign"]),i=await xr.get().subtle.sign({name:"Ed25519"},s,e instanceof Uint8Array?e:e.subarray());return new Uint8Array(i,0,i.byteLength)}function qw(r,e){const t=r.subarray(0,ka);return wi.sign(e instanceof Uint8Array?e:e.subarray(),t)}async function Ww(r,e){return Kr==null&&(Kr=await Wh),Kr?$w(r,e):qw(r,e)}async function zw(r,e,t){if(r.buffer instanceof ArrayBuffer){const n=await xr.get().subtle.importKey("raw",r.buffer,{name:"Ed25519"},!1,["verify"]);return await xr.get().subtle.verify({name:"Ed25519"},n,e,t instanceof Uint8Array?t:t.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function Kw(r,e,t){return wi.verify(e,t instanceof Uint8Array?t:t.subarray(),r)}async function Hw(r,e,t){return Kr==null&&(Kr=await Wh),Kr?zw(r,e,t):Kw(r,e,t)}function Vw(r,e){const t=new Uint8Array(_c);for(let n=0;n<ka;n++)t[n]=r[n],t[ka+n]=e[n];return t}function xc(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class zh{type="Ed25519";raw;constructor(e){this.raw=Ac(e,qh)}toMultihash(){return as.digest(kt(this))}toCID(){return le.createV1(114,this.toMultihash())}toString(){return be.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:ke(this.raw,e.raw)}verify(e,t,n){n?.signal?.throwIfAborted();const s=Hw(this.raw,t,e);return xc(s)?s.then(i=>(n?.signal?.throwIfAborted(),i)):s}}class Gw{type="Ed25519";raw;publicKey;constructor(e,t){this.raw=Ac(e,_c),this.publicKey=new zh(t)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:ke(this.raw,e.raw)}sign(e,t){t?.signal?.throwIfAborted();const n=Ww(this.raw,e);return xc(n)?n.then(s=>(t?.signal?.throwIfAborted(),s)):(t?.signal?.throwIfAborted(),n)}}function Kh(r){return r=Ac(r,qh),new zh(r)}async function jw(){const{privateKey:r,publicKey:e}=Uw();return new Gw(r,e)}function Ac(r,e){if(r=Uint8Array.from(r??[]),r.length!==e)throw new K(`Key must be a Uint8Array of length ${e}, got ${r.length}`);return r}const Yw=Math.pow(2,7),Xw=Math.pow(2,14),Qw=Math.pow(2,21),Cc=Math.pow(2,28),Ic=Math.pow(2,35),Tc=Math.pow(2,42),Pc=Math.pow(2,49),ie=128,Me=127;function Ie(r){if(r<Yw)return 1;if(r<Xw)return 2;if(r<Qw)return 3;if(r<Cc)return 4;if(r<Ic)return 5;if(r<Tc)return 6;if(r<Pc)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Hh(r,e,t=0){switch(Ie(r)){case 8:e[t++]=r&255|ie,r/=128;case 7:e[t++]=r&255|ie,r/=128;case 6:e[t++]=r&255|ie,r/=128;case 5:e[t++]=r&255|ie,r/=128;case 4:e[t++]=r&255|ie,r>>>=7;case 3:e[t++]=r&255|ie,r>>>=7;case 2:e[t++]=r&255|ie,r>>>=7;case 1:{e[t++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return e}function Zw(r,e,t=0){switch(Ie(r)){case 8:e.set(t++,r&255|ie),r/=128;case 7:e.set(t++,r&255|ie),r/=128;case 6:e.set(t++,r&255|ie),r/=128;case 5:e.set(t++,r&255|ie),r/=128;case 4:e.set(t++,r&255|ie),r>>>=7;case 3:e.set(t++,r&255|ie),r>>>=7;case 2:e.set(t++,r&255|ie),r>>>=7;case 1:{e.set(t++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return e}function Vh(r,e){let t=r[e],n=0;if(n+=t&Me,t<ie||(t=r[e+1],n+=(t&Me)<<7,t<ie)||(t=r[e+2],n+=(t&Me)<<14,t<ie)||(t=r[e+3],n+=(t&Me)<<21,t<ie)||(t=r[e+4],n+=(t&Me)*Cc,t<ie)||(t=r[e+5],n+=(t&Me)*Ic,t<ie)||(t=r[e+6],n+=(t&Me)*Tc,t<ie)||(t=r[e+7],n+=(t&Me)*Pc,t<ie))return n;throw new RangeError("Could not decode varint")}function Jw(r,e){let t=r.get(e),n=0;if(n+=t&Me,t<ie||(t=r.get(e+1),n+=(t&Me)<<7,t<ie)||(t=r.get(e+2),n+=(t&Me)<<14,t<ie)||(t=r.get(e+3),n+=(t&Me)<<21,t<ie)||(t=r.get(e+4),n+=(t&Me)*Cc,t<ie)||(t=r.get(e+5),n+=(t&Me)*Ic,t<ie)||(t=r.get(e+6),n+=(t&Me)*Tc,t<ie)||(t=r.get(e+7),n+=(t&Me)*Pc,t<ie))return n;throw new RangeError("Could not decode varint")}function bt(r,e,t=0){return e==null&&(e=St(Ie(r))),e instanceof Uint8Array?Hh(r,e,t):Zw(r,e,t)}function kr(r,e=0){return r instanceof Uint8Array?Vh(r,e):Jw(r,e)}const kc=new Float32Array([-0]),zt=new Uint8Array(kc.buffer);function eb(r,e,t){kc[0]=r,e[t]=zt[0],e[t+1]=zt[1],e[t+2]=zt[2],e[t+3]=zt[3]}function tb(r,e){return zt[0]=r[e],zt[1]=r[e+1],zt[2]=r[e+2],zt[3]=r[e+3],kc[0]}const Rc=new Float64Array([-0]),Oe=new Uint8Array(Rc.buffer);function rb(r,e,t){Rc[0]=r,e[t]=Oe[0],e[t+1]=Oe[1],e[t+2]=Oe[2],e[t+3]=Oe[3],e[t+4]=Oe[4],e[t+5]=Oe[5],e[t+6]=Oe[6],e[t+7]=Oe[7]}function nb(r,e){return Oe[0]=r[e],Oe[1]=r[e+1],Oe[2]=r[e+2],Oe[3]=r[e+3],Oe[4]=r[e+4],Oe[5]=r[e+5],Oe[6]=r[e+6],Oe[7]=r[e+7],Rc[0]}const sb=BigInt(Number.MAX_SAFE_INTEGER),ib=BigInt(Number.MIN_SAFE_INTEGER);class Fe{lo;hi;constructor(e,t){this.lo=e|0,this.hi=t|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(t+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(BigInt(t)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?t===0?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:n<128?9:10}static fromBigInt(e){if(e===0n)return br;if(e<sb&&e>ib)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let n=e>>32n,s=e-(n<<32n);return t&&(n=~n|0n,s=~s|0n,++s>Vl&&(s=0n,++n>Vl&&(n=0n))),new Fe(Number(s),Number(n))}static fromNumber(e){if(e===0)return br;const t=e<0;t&&(e=-e);let n=e>>>0,s=(e-n)/4294967296>>>0;return t&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new Fe(n,s)}static from(e){return typeof e=="number"?Fe.fromNumber(e):typeof e=="bigint"?Fe.fromBigInt(e):typeof e=="string"?Fe.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new Fe(e.low>>>0,e.high>>>0):br}}const br=new Fe(0,0);br.toBigInt=function(){return 0n};br.zzEncode=br.zzDecode=function(){return this};br.length=function(){return 1};const Vl=4294967296n;function ob(r){let e=0,t=0;for(let n=0;n<r.length;++n)t=r.charCodeAt(n),t<128?e+=1:t<2048?e+=2:(t&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,e+=4):e+=3;return e}function ab(r,e,t){if(t-e<1)return"";let s;const i=[];let o=0,a;for(;e<t;)a=r[e++],a<128?i[o++]=a:a>191&&a<224?i[o++]=(a&31)<<6|r[e++]&63:a>239&&a<365?(a=((a&7)<<18|(r[e++]&63)<<12|(r[e++]&63)<<6|r[e++]&63)-65536,i[o++]=55296+(a>>10),i[o++]=56320+(a&1023)):i[o++]=(a&15)<<12|(r[e++]&63)<<6|r[e++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function Gh(r,e,t){const n=t;let s,i;for(let o=0;o<r.length;++o)s=r.charCodeAt(o),s<128?e[t++]=s:s<2048?(e[t++]=s>>6|192,e[t++]=s&63|128):(s&64512)===55296&&((i=r.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,e[t++]=s>>18|240,e[t++]=s>>12&63|128,e[t++]=s>>6&63|128,e[t++]=s&63|128):(e[t++]=s>>12|224,e[t++]=s>>6&63|128,e[t++]=s&63|128);return t-n}function it(r,e){return RangeError(`index out of range: ${r.pos} + ${e??1} > ${r.len}`)}function ks(r,e){return(r[e-4]|r[e-3]<<8|r[e-2]<<16|r[e-1]<<24)>>>0}class cb{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(e){this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,it(this,10);return e}int32(){return this.uint32()|0}sint32(){const e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw it(this,4);return ks(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw it(this,4);return ks(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw it(this,4);const e=tb(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw it(this,4);const e=nb(this.buf,this.pos);return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,n=this.pos+e;if(n>this.len)throw it(this,e);return this.pos+=e,t===n?new Uint8Array(0):this.buf.subarray(t,n)}string(){const e=this.bytes();return ab(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw it(this,e);this.pos+=e}else do if(this.pos>=this.len)throw it(this);while((this.buf[this.pos++]&128)!==0);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new Fe(0,0);let t=0;if(this.len-this.pos>4){for(;t<4;++t)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw it(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,e}if(this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw it(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw it(this,8);const e=ks(this.buf,this.pos+=4),t=ks(this.buf,this.pos+=4);return new Fe(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=Vh(this.buf,this.pos);return this.pos+=Ie(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function lb(r){return new cb(r instanceof Uint8Array?r:r.subarray())}function me(r,e,t){const n=lb(r);return e.decode(n,void 0,t)}function ub(r){let n,s=8192;return function(o){if(o<1||o>4096)return St(o);s+o>8192&&(n=St(8192),s=0);const a=n.subarray(s,s+=o);return(s&7)!==0&&(s=(s|7)+1),a}}class Rn{fn;len;next;val;constructor(e,t,n){this.fn=e,this.len=t,this.next=void 0,this.val=n}}function Lo(){}class db{head;tail;len;next;constructor(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}}const hb=ub();function fb(r){return globalThis.Buffer!=null?St(r):hb(r)}class Ra{len;head;tail;states;constructor(){this.len=0,this.head=new Rn(Lo,0,0),this.tail=this.head,this.states=null}_push(e,t,n){return this.tail=this.tail.next=new Rn(e,t,n),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new gb((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(Rs,10,Fe.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=Fe.fromBigInt(e);return this._push(Rs,t.length(),t)}uint64Number(e){return this._push(Hh,Ie(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=Fe.fromBigInt(e).zzEncode();return this._push(Rs,t.length(),t)}sint64Number(e){const t=Fe.fromNumber(e).zzEncode();return this._push(Rs,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(Do,1,e?1:0)}fixed32(e){return this._push(Tn,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=Fe.fromBigInt(e);return this._push(Tn,4,t.lo)._push(Tn,4,t.hi)}fixed64Number(e){const t=Fe.fromNumber(e);return this._push(Tn,4,t.lo)._push(Tn,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(eb,4,e)}double(e){return this._push(rb,8,e)}bytes(e){const t=e.length>>>0;return t===0?this._push(Do,1,0):this.uint32(t)._push(mb,t,e)}string(e){const t=ob(e);return t!==0?this.uint32(t)._push(Gh,t,e):this._push(Do,1,0)}fork(){return this.states=new db(this),this.head=this.tail=new Rn(Lo,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Rn(Lo,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=e.next,this.tail=t,this.len+=n),this}finish(){let e=this.head.next;const t=fb(this.len);let n=0;for(;e!=null;)e.fn(e.val,t,n),n+=e.len,e=e.next;return t}}function Do(r,e,t){e[t]=r&255}function pb(r,e,t){for(;r>127;)e[t++]=r&127|128,r>>>=7;e[t]=r}class gb extends Rn{next;constructor(e,t){super(pb,e,t),this.next=void 0}}function Rs(r,e,t){for(;r.hi!==0;)e[t++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)e[t++]=r.lo&127|128,r.lo=r.lo>>>7;e[t++]=r.lo}function Tn(r,e,t){e[t]=r&255,e[t+1]=r>>>8&255,e[t+2]=r>>>16&255,e[t+3]=r>>>24}function mb(r,e,t){e.set(r,t)}globalThis.Buffer!=null&&(Ra.prototype.bytes=function(r){const e=r.length>>>0;return this.uint32(e),e>0&&this._push(yb,e,r),this},Ra.prototype.string=function(r){const e=globalThis.Buffer.byteLength(r);return this.uint32(e),e>0&&this._push(wb,e,r),this});function yb(r,e,t){e.set(r,t)}function wb(r,e,t){r.length<40?Gh(r,e,t):e.utf8Write!=null?e.utf8Write(r,t):e.set(z(r),t)}function bb(){return new Ra}function ye(r,e){const t=bb();return e.encode(r,t,{lengthDelimited:!1}),t.finish()}var bi;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(bi||(bi={}));function jh(r,e,t,n){return{name:r,type:e,encode:t,decode:n}}function bn(r){function e(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}const t=function(i,o){const a=e(i);o.int32(a)},n=function(i){const o=i.int32();return e(o)};return jh("enum",bi.VARINT,t,n)}function we(r,e){return jh("message",bi.LENGTH_DELIMITED,r,e)}class Lt extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"}class Gl extends Error{code="ERR_MAX_SIZE";name="MaxSizeError"}var Te;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1",r.ECDSA="ECDSA"})(Te||(Te={}));var La;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1",r[r.ECDSA=3]="ECDSA"})(La||(La={}));(function(r){r.codec=()=>bn(La)})(Te||(Te={}));var en;(function(r){let e;r.codec=()=>(e==null&&(e=we((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),Te.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.Type=Te.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ye(t,r.codec()),r.decode=(t,n)=>me(t,r.codec(),n)})(en||(en={}));var jl;(function(r){let e;r.codec=()=>(e==null&&(e=we((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),Te.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.Type=Te.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ye(t,r.codec()),r.decode=(t,n)=>me(t,r.codec(),n)})(jl||(jl={}));function Lc(r){if(isNaN(r)||r<=0)throw new K("random bytes length must be a Number bigger than 0");return no(r)}const ei=Ah;class vb{type="RSA";jwk;_raw;_multihash;constructor(e,t){this.jwk=e,this._multihash=t}get raw(){return this._raw==null&&(this._raw=Ab(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return le.createV1(114,this._multihash)}toString(){return be.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:ke(this.raw,e.raw)}verify(e,t,n){return Tb(this.jwk,t,e,n)}}const Sb=18,Eb=1062,_b=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function xb(r){const e=ro(r[1],{offset:0});return{kty:"RSA",n:G(e[0],"base64url"),e:G(e[1],"base64url")}}function Ab(r){if(r.n==null||r.e==null)throw new K("JWK was missing components");return Bn([_b,bh(Bn([Ca(z(r.n,"base64url")),Ca(z(r.e,"base64url"))]))]).subarray()}function Cb(r,e){if(r.byteLength>=Eb)throw new eh("Key size is too large");const t=ro(r,{offset:0});return Ib(t,r,e)}function Ib(r,e,t){const n=xb(r);if(t==null){const s=ei(en.encode({Type:Te.RSA,Data:e}));t=zn(Sb,s)}return new vb(n,t)}async function Tb(r,e,t,n){const s=await xr.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);n?.signal?.throwIfAborted();const i=await xr.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},s,e,t instanceof Uint8Array?t:t.subarray());return n?.signal?.throwIfAborted(),i}class Yh extends Sh{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,yc(e);const n=Kn(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(n.length>s?e.create().update(n).digest():n);for(let o=0;o<i.length;o++)i[o]^=54;this.iHash.update(i),this.oHash=e.create();for(let o=0;o<i.length;o++)i[o]^=106;this.oHash.update(i),_r(i)}update(e){return gi(this),this.iHash.update(e),this}digestInto(e){gi(this),ls(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=i,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const io=(r,e,t)=>new Yh(r,e).update(t).digest();io.create=(r,e)=>new Yh(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Yl(r){r.lowS!==void 0&&jt("lowS",r.lowS),r.prehash!==void 0&&jt("prehash",r.prehash)}function Pb(r){const e=Ec(r);wn(e,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:t,Fp:n,a:s}=e;if(t){if(!n.eql(s,n.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...e})}class kb extends Error{constructor(e=""){super(e)}}const Ct={Err:kb,_tlv:{encode:(r,e)=>{const{Err:t}=Ct;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const n=e.length/2,s=Is(n);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const i=n>127?Is(s.length/2|128):"";return Is(r)+i+s+e},decode(r,e){const{Err:t}=Ct;let n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");const s=e[n++],i=!!(s&128);let o=0;if(!i)o=s;else{const c=s&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const l=e.subarray(n,n+c);if(l.length!==c)throw new t("tlv.decode: length bytes not complete");if(l[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const u of l)o=o<<8|u;if(n+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(n,n+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+o)}}},_int:{encode(r){const{Err:e}=Ct;if(r<It)throw new e("integer: negative integers are not allowed");let t=Is(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(r){const{Err:e}=Ct;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return yr(r)}},toSig(r){const{Err:e,_int:t,_tlv:n}=Ct,s=fe("signature",r),{v:i,l:o}=n.decode(48,s);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,i),{v:l,l:u}=n.decode(2,c);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(l)}},hexFromSig(r){const{_tlv:e,_int:t}=Ct,n=e.encode(2,t.encode(r.r)),s=e.encode(2,t.encode(r.s)),i=n+s;return e.encode(48,i)}};function Mo(r,e){return Zr(ds(r,e))}const It=BigInt(0),Ee=BigInt(1);BigInt(2);const Oo=BigInt(3),Rb=BigInt(4);function Lb(r){const e=Pb(r),{Fp:t}=e,n=hs(e.n,e.nBitLength),s=e.toBytes||((w,y,v)=>{const C=y.toAffine();return Jr(Uint8Array.from([4]),t.toBytes(C.x),t.toBytes(C.y))}),i=e.fromBytes||(w=>{const y=w.subarray(1),v=t.fromBytes(y.subarray(0,t.BYTES)),C=t.fromBytes(y.subarray(t.BYTES,2*t.BYTES));return{x:v,y:C}});function o(w){const{a:y,b:v}=e,C=t.sqr(w),E=t.mul(C,w);return t.add(t.add(E,t.mul(w,y)),v)}function a(w,y){const v=t.sqr(y),C=o(w);return t.eql(v,C)}if(!a(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const c=t.mul(t.pow(e.a,Oo),Rb),l=t.mul(t.sqr(e.b),BigInt(27));if(t.is0(t.add(c,l)))throw new Error("bad curve params: a or b");function u(w){return vc(w,Ee,e.n)}function d(w){const{allowedPrivateKeyLengths:y,nByteLength:v,wrapPrivateKey:C,n:E}=e;if(y&&typeof w!="bigint"){if(us(w)&&(w=Zr(w)),typeof w!="string"||!y.includes(w.length))throw new Error("invalid private key");w=w.padStart(v*2,"0")}let A;try{A=typeof w=="bigint"?w:yr(fe("private key",w,v))}catch{throw new Error("invalid private key, expected hex or "+v+" bytes, got "+typeof w)}return C&&(A=ue(A,E)),Xe("private key",A,Ee,E),A}function h(w){if(!(w instanceof g))throw new Error("ProjectivePoint expected")}const p=yi((w,y)=>{const{px:v,py:C,pz:E}=w;if(t.eql(E,t.ONE))return{x:v,y:C};const A=w.is0();y==null&&(y=A?t.ONE:t.inv(E));const T=t.mul(v,y),O=t.mul(C,y),L=t.mul(E,y);if(A)return{x:t.ZERO,y:t.ZERO};if(!t.eql(L,t.ONE))throw new Error("invZ was invalid");return{x:T,y:O}}),f=yi(w=>{if(w.is0()){if(e.allowInfinityPoint&&!t.is0(w.py))return;throw new Error("bad point: ZERO")}const{x:y,y:v}=w.toAffine();if(!t.isValid(y)||!t.isValid(v))throw new Error("bad point: x or y not FE");if(!a(y,v))throw new Error("bad point: equation left != right");if(!w.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(y,v,C){if(y==null||!t.isValid(y))throw new Error("x required");if(v==null||!t.isValid(v)||t.is0(v))throw new Error("y required");if(C==null||!t.isValid(C))throw new Error("z required");this.px=y,this.py=v,this.pz=C,Object.freeze(this)}static fromAffine(y){const{x:v,y:C}=y||{};if(!y||!t.isValid(v)||!t.isValid(C))throw new Error("invalid affine point");if(y instanceof g)throw new Error("projective point not allowed");const E=A=>t.eql(A,t.ZERO);return E(v)&&E(C)?g.ZERO:new g(v,C,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(y){const v=Sc(t,y.map(C=>C.pz));return y.map((C,E)=>C.toAffine(v[E])).map(g.fromAffine)}static fromHex(y){const v=g.fromAffine(i(fe("pointHex",y)));return v.assertValidity(),v}static fromPrivateKey(y){return g.BASE.multiply(d(y))}static msm(y,v){return Bh(g,n,y,v)}_setWindowSize(y){x.setWindowSize(this,y)}assertValidity(){f(this)}hasEvenY(){const{y}=this.toAffine();if(t.isOdd)return!t.isOdd(y);throw new Error("Field doesn't support isOdd")}equals(y){h(y);const{px:v,py:C,pz:E}=this,{px:A,py:T,pz:O}=y,L=t.eql(t.mul(v,O),t.mul(A,E)),M=t.eql(t.mul(C,O),t.mul(T,E));return L&&M}negate(){return new g(this.px,t.neg(this.py),this.pz)}double(){const{a:y,b:v}=e,C=t.mul(v,Oo),{px:E,py:A,pz:T}=this;let O=t.ZERO,L=t.ZERO,M=t.ZERO,D=t.mul(E,E),U=t.mul(A,A),P=t.mul(T,T),k=t.mul(E,A);return k=t.add(k,k),M=t.mul(E,T),M=t.add(M,M),O=t.mul(y,M),L=t.mul(C,P),L=t.add(O,L),O=t.sub(U,L),L=t.add(U,L),L=t.mul(O,L),O=t.mul(k,O),M=t.mul(C,M),P=t.mul(y,P),k=t.sub(D,P),k=t.mul(y,k),k=t.add(k,M),M=t.add(D,D),D=t.add(M,D),D=t.add(D,P),D=t.mul(D,k),L=t.add(L,D),P=t.mul(A,T),P=t.add(P,P),D=t.mul(P,k),O=t.sub(O,D),M=t.mul(P,U),M=t.add(M,M),M=t.add(M,M),new g(O,L,M)}add(y){h(y);const{px:v,py:C,pz:E}=this,{px:A,py:T,pz:O}=y;let L=t.ZERO,M=t.ZERO,D=t.ZERO;const U=e.a,P=t.mul(e.b,Oo);let k=t.mul(v,A),F=t.mul(C,T),I=t.mul(E,O),b=t.add(v,C),_=t.add(A,T);b=t.mul(b,_),_=t.add(k,F),b=t.sub(b,_),_=t.add(v,E);let R=t.add(A,O);return _=t.mul(_,R),R=t.add(k,I),_=t.sub(_,R),R=t.add(C,E),L=t.add(T,O),R=t.mul(R,L),L=t.add(F,I),R=t.sub(R,L),D=t.mul(U,_),L=t.mul(P,I),D=t.add(L,D),L=t.sub(F,D),D=t.add(F,D),M=t.mul(L,D),F=t.add(k,k),F=t.add(F,k),I=t.mul(U,I),_=t.mul(P,_),F=t.add(F,I),I=t.sub(k,I),I=t.mul(U,I),_=t.add(_,I),k=t.mul(F,_),M=t.add(M,k),k=t.mul(R,_),L=t.mul(b,L),L=t.sub(L,k),k=t.mul(b,F),D=t.mul(R,D),D=t.add(D,k),new g(L,M,D)}subtract(y){return this.add(y.negate())}is0(){return this.equals(g.ZERO)}wNAF(y){return x.wNAFCached(this,y,g.normalizeZ)}multiplyUnsafe(y){const{endo:v,n:C}=e;Xe("scalar",y,It,C);const E=g.ZERO;if(y===It)return E;if(this.is0()||y===Ee)return this;if(!v||x.hasPrecomputes(this))return x.wNAFCachedUnsafe(this,y,g.normalizeZ);let{k1neg:A,k1:T,k2neg:O,k2:L}=v.splitScalar(y),M=E,D=E,U=this;for(;T>It||L>It;)T&Ee&&(M=M.add(U)),L&Ee&&(D=D.add(U)),U=U.double(),T>>=Ee,L>>=Ee;return A&&(M=M.negate()),O&&(D=D.negate()),D=new g(t.mul(D.px,v.beta),D.py,D.pz),M.add(D)}multiply(y){const{endo:v,n:C}=e;Xe("scalar",y,Ee,C);let E,A;if(v){const{k1neg:T,k1:O,k2neg:L,k2:M}=v.splitScalar(y);let{p:D,f:U}=this.wNAF(O),{p:P,f:k}=this.wNAF(M);D=x.constTimeNegate(T,D),P=x.constTimeNegate(L,P),P=new g(t.mul(P.px,v.beta),P.py,P.pz),E=D.add(P),A=U.add(k)}else{const{p:T,f:O}=this.wNAF(y);E=T,A=O}return g.normalizeZ([E,A])[0]}multiplyAndAddUnsafe(y,v,C){const E=g.BASE,A=(O,L)=>L===It||L===Ee||!O.equals(E)?O.multiplyUnsafe(L):O.multiply(L),T=A(this,v).add(A(y,C));return T.is0()?void 0:T}toAffine(y){return p(this,y)}isTorsionFree(){const{h:y,isTorsionFree:v}=e;if(y===Ee)return!0;if(v)return v(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:y,clearCofactor:v}=e;return y===Ee?this:v?v(g,this):this.multiplyUnsafe(e.h)}toRawBytes(y=!0){return jt("isCompressed",y),this.assertValidity(),s(g,this,y)}toHex(y=!0){return jt("isCompressed",y),Zr(this.toRawBytes(y))}}g.BASE=new g(e.Gx,e.Gy,t.ONE),g.ZERO=new g(t.ZERO,t.ONE,t.ZERO);const{endo:m,nBitLength:S}=e,x=Nh(g,m?Math.ceil(S/2):S);return{CURVE:e,ProjectivePoint:g,normPrivateKeyToScalar:d,weierstrassEquation:o,isWithinCurveOrder:u}}function Db(r){const e=Ec(r);return wn(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Mb(r){const e=Db(r),{Fp:t,n,nByteLength:s,nBitLength:i}=e,o=t.BYTES+1,a=2*t.BYTES+1;function c(P){return ue(P,n)}function l(P){return Ta(P,n)}const{ProjectivePoint:u,normPrivateKeyToScalar:d,weierstrassEquation:h,isWithinCurveOrder:p}=Lb({...e,toBytes(P,k,F){const I=k.toAffine(),b=t.toBytes(I.x),_=Jr;return jt("isCompressed",F),F?_(Uint8Array.from([k.hasEvenY()?2:3]),b):_(Uint8Array.from([4]),b,t.toBytes(I.y))},fromBytes(P){const k=P.length,F=P[0],I=P.subarray(1);if(k===o&&(F===2||F===3)){const b=yr(I);if(!vc(b,Ee,t.ORDER))throw new Error("Point is not on curve");const _=h(b);let R;try{R=t.sqrt(_)}catch(q){const W=q instanceof Error?": "+q.message:"";throw new Error("Point is not on curve"+W)}const N=(R&Ee)===Ee;return(F&1)===1!==N&&(R=t.neg(R)),{x:b,y:R}}else if(k===a&&F===4){const b=t.fromBytes(I.subarray(0,t.BYTES)),_=t.fromBytes(I.subarray(t.BYTES,2*t.BYTES));return{x:b,y:_}}else{const b=o,_=a;throw new Error("invalid Point, expected length of "+b+", or uncompressed "+_+", got "+k)}}});function f(P){const k=n>>Ee;return P>k}function g(P){return f(P)?c(-P):P}const m=(P,k,F)=>yr(P.slice(k,F));class S{constructor(k,F,I){Xe("r",k,Ee,n),Xe("s",F,Ee,n),this.r=k,this.s=F,I!=null&&(this.recovery=I),Object.freeze(this)}static fromCompact(k){const F=s;return k=fe("compactSignature",k,F*2),new S(m(k,0,F),m(k,F,2*F))}static fromDER(k){const{r:F,s:I}=Ct.toSig(fe("DER",k));return new S(F,I)}assertValidity(){}addRecoveryBit(k){return new S(this.r,this.s,k)}recoverPublicKey(k){const{r:F,s:I,recovery:b}=this,_=E(fe("msgHash",k));if(b==null||![0,1,2,3].includes(b))throw new Error("recovery id invalid");const R=b===2||b===3?F+e.n:F;if(R>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const N=(b&1)===0?"02":"03",$=u.fromHex(N+Mo(R,t.BYTES)),q=l(R),W=c(-_*q),H=c(I*q),j=u.BASE.multiplyAndAddUnsafe($,W,H);if(!j)throw new Error("point at infinify");return j.assertValidity(),j}hasHighS(){return f(this.s)}normalizeS(){return this.hasHighS()?new S(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return mi(this.toDERHex())}toDERHex(){return Ct.hexFromSig(this)}toCompactRawBytes(){return mi(this.toCompactHex())}toCompactHex(){const k=s;return Mo(this.r,k)+Mo(this.s,k)}}const x={isValidPrivateKey(P){try{return d(P),!0}catch{return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{const P=Mh(e.n);return _w(e.randomBytes(P),e.n)},precompute(P=8,k=u.BASE){return k._setWindowSize(P),k.multiply(BigInt(3)),k}};function w(P,k=!0){return u.fromPrivateKey(P).toRawBytes(k)}function y(P){if(typeof P=="bigint")return!1;if(P instanceof u)return!0;const F=fe("key",P).length,I=t.BYTES,b=I+1,_=2*I+1;if(!(e.allowedPrivateKeyLengths||s===b))return F===b||F===_}function v(P,k,F=!0){if(y(P)===!0)throw new Error("first arg must be private key");if(y(k)===!1)throw new Error("second arg must be public key");return u.fromHex(k).multiply(d(P)).toRawBytes(F)}const C=e.bits2int||function(P){if(P.length>8192)throw new Error("input is too large");const k=yr(P),F=P.length*8-i;return F>0?k>>BigInt(F):k},E=e.bits2int_modN||function(P){return c(C(P))},A=so(i);function T(P){return Xe("num < 2^"+i,P,It,A),ds(P,s)}function O(P,k,F=L){if(["recovered","canonical"].some(re=>re in F))throw new Error("sign() legacy options not supported");const{hash:I,randomBytes:b}=e;let{lowS:_,prehash:R,extraEntropy:N}=F;_==null&&(_=!0),P=fe("msgHash",P),Yl(F),R&&(P=fe("prehashed msgHash",I(P)));const $=E(P),q=d(k),W=[T(q),T($)];if(N!=null&&N!==!1){const re=N===!0?b(t.BYTES):N;W.push(fe("extraEntropy",re))}const H=Jr(...W),j=$;function se(re){const Ae=C(re);if(!p(Ae))return;const ze=l(Ae),Se=u.BASE.multiply(Ae).toAffine(),Le=c(Se.x);if(Le===It)return;const je=c(ze*c(j+Le*q));if(je===It)return;let st=(Se.x===Le?0:2)|Number(Se.y&Ee),_n=je;return _&&f(je)&&(_n=g(je),st^=1),new S(Le,_n,st)}return{seed:H,k2sig:se}}const L={lowS:e.lowS,prehash:!1},M={lowS:e.lowS,prehash:!1};function D(P,k,F=L){const{seed:I,k2sig:b}=O(P,k,F),_=e;return fw(_.hash.outputLen,_.nByteLength,_.hmac)(I,b)}u.BASE._setWindowSize(8);function U(P,k,F,I=M){const b=P;k=fe("msgHash",k),F=fe("publicKey",F);const{lowS:_,prehash:R,format:N}=I;if(Yl(I),"strict"in I)throw new Error("options.strict was renamed to lowS");if(N!==void 0&&N!=="compact"&&N!=="der")throw new Error("format must be compact or der");const $=typeof b=="string"||us(b),q=!$&&!N&&typeof b=="object"&&b!==null&&typeof b.r=="bigint"&&typeof b.s=="bigint";if(!$&&!q)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let W,H;try{if(q&&(W=new S(b.r,b.s)),$){try{N!=="compact"&&(W=S.fromDER(b))}catch(st){if(!(st instanceof Ct.Err))throw st}!W&&N!=="der"&&(W=S.fromCompact(b))}H=u.fromHex(F)}catch{return!1}if(!W||_&&W.hasHighS())return!1;R&&(k=e.hash(k));const{r:j,s:se}=W,re=E(k),Ae=l(se),ze=c(re*Ae),Se=c(j*Ae),Le=u.BASE.multiplyAndAddUnsafe(H,ze,Se)?.toAffine();return Le?c(Le.x)===j:!1}return{CURVE:e,getPublicKey:w,getSharedSecret:v,sign:D,verify:U,ProjectivePoint:u,Signature:S,utils:x}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ob(r){return{hash:r,hmac:(e,...t)=>io(r,e,Gy(...t)),randomBytes:no}}function Fb(r,e){const t=n=>Mb({...r,...Ob(n)});return{...t(e),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xh=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Xl=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Nb=BigInt(0),Bb=BigInt(1),Da=BigInt(2),Ql=(r,e)=>(r+e/Da)/e;function Ub(r){const e=Xh,t=BigInt(3),n=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),l=r*r*r%e,u=l*l*r%e,d=he(u,t,e)*u%e,h=he(d,t,e)*u%e,p=he(h,Da,e)*l%e,f=he(p,s,e)*p%e,g=he(f,i,e)*f%e,m=he(g,a,e)*g%e,S=he(m,c,e)*m%e,x=he(S,a,e)*g%e,w=he(x,t,e)*u%e,y=he(w,o,e)*f%e,v=he(y,n,e)*l%e,C=he(v,Da,e);if(!Ma.eql(Ma.sqr(C),r))throw new Error("Cannot find square root");return C}const Ma=hs(Xh,void 0,void 0,{sqrt:Ub}),vi=Fb({a:Nb,b:BigInt(7),Fp:Ma,n:Xl,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{const e=Xl,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Bb*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=t,o=BigInt("0x100000000000000000000000000000000"),a=Ql(i*r,e),c=Ql(-n*r,e);let l=ue(r-a*t-c*s,e),u=ue(-a*n-c*i,e);const d=l>o,h=u>o;if(d&&(l=e-l),h&&(u=e-u),l>o||u>o)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:d,k1:l,k2neg:h,k2:u}}}},Ah);function $b(r,e,t,n){const s=mh.digest(t instanceof Uint8Array?t:t.subarray());if(xc(s))return s.then(({digest:i})=>(n?.signal?.throwIfAborted(),vi.verify(e,i,r))).catch(i=>{throw i.name==="AbortError"?i:new Hl(String(i))});try{return n?.signal?.throwIfAborted(),vi.verify(e,s.digest,r)}catch(i){throw new Hl(String(i))}}class qb{type="secp256k1";raw;_key;constructor(e){this._key=zb(e),this.raw=Wb(this._key)}toMultihash(){return as.digest(kt(this))}toCID(){return le.createV1(114,this.toMultihash())}toString(){return be.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:ke(this.raw,e.raw)}verify(e,t,n){return $b(this._key,t,e,n)}}function Qh(r){return new qb(r)}function Wb(r){return vi.ProjectivePoint.fromHex(r).toRawBytes(!0)}function zb(r){try{return vi.ProjectivePoint.fromHex(r),r}catch(e){throw new eh(String(e))}}async function Kb(r,e){return jw()}function Zt(r,e){const{Type:t,Data:n}=en.decode(r),s=n??new Uint8Array;switch(t){case Te.RSA:return Cb(s,e);case Te.Ed25519:return Kh(s);case Te.secp256k1:return Qh(s);case Te.ECDSA:return vh(s);default:throw new fc}}function Hb(r){const{Type:e,Data:t}=en.decode(r.digest),n=t??new Uint8Array;switch(e){case Te.Ed25519:return Kh(n);case Te.secp256k1:return Qh(n);case Te.ECDSA:return vh(n);default:throw new fc}}function kt(r){return en.encode({Type:Te[r.type],Data:r.raw})}const Zh=Symbol.for("nodejs.util.inspect.custom"),Vb=114;class Dc{type;multihash;publicKey;string;constructor(e){this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[lc]=!0;toString(){return this.string==null&&(this.string=be.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return le.createV1(Vb,this.multihash)}toJSON(){return this.toString()}equals(e){if(e==null)return!1;if(e instanceof Uint8Array)return ke(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(e?.toMultihash()?.bytes!=null)return ke(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[Zh](){return`PeerId(${this.toString()})`}}class Jh extends Dc{type="RSA";publicKey;constructor(e){super({...e,type:"RSA"}),this.publicKey=e.publicKey}}class ef extends Dc{type="Ed25519";publicKey;constructor(e){super({...e,type:"Ed25519"}),this.publicKey=e.publicKey}}class tf extends Dc{type="secp256k1";publicKey;constructor(e){super({...e,type:"secp256k1"}),this.publicKey=e.publicKey}}const Gb=2336;class rf{type="url";multihash;publicKey;url;constructor(e){this.url=e.toString(),this.multihash=as.digest(z(this.url))}[Zh](){return`PeerId(${this.url})`}[lc]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return le.createV1(Gb,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=G(e)),e.toString()===this.toString())}}const jb=114,Zl=2336;function dt(r,e){let t;if(r.charAt(0)==="1"||r.charAt(0)==="Q")t=rr(be.decode(`z${r}`));else{if(r.startsWith("k51qzi5uqu5")||r.startsWith("kzwfwjn5ji4")||r.startsWith("k2k4r8")||r.startsWith("bafz"))return ps(le.parse(r));throw new K('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return fs(t)}function Gn(r){if(r.type==="Ed25519")return new ef({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new tf({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new Jh({multihash:r.toCID().multihash,publicKey:r});throw new fc}function Yb(r){return Gn(r.publicKey)}function fs(r){if(Qb(r))return new Jh({multihash:r});if(Xb(r))try{const e=Hb(r);if(e.type==="Ed25519")return new ef({multihash:r,publicKey:e});if(e.type==="secp256k1")return new tf({multihash:r,publicKey:e})}catch{const t=G(r.digest);return new rf(new URL(t))}throw new sm("Supplied PeerID Multihash is invalid")}function ps(r){if(r?.multihash==null||r.version==null||r.version===1&&r.code!==jb&&r.code!==Zl)throw new nm("Supplied PeerID CID is invalid");if(r.code===Zl){const e=G(r.multihash.digest);return new rf(new URL(e))}return fs(r.multihash)}function Xb(r){return r.code===as.code}function Qb(r){return r.code===mh.code}const Zb=8,Mc=1024*1024*4;let Jb=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},nf=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},e0=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"},Jl=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};function sf(r){return r[Symbol.asyncIterator]!=null}function of(r,e){if(r.byteLength>e)throw new nf("Message length too long")}const oo=r=>{const e=Ie(r),t=St(e);return bt(r,t),oo.bytes=e,t};oo.bytes=0;function Si(r,e){e=e??{};const t=e.lengthEncoder??oo,n=e?.maxDataLength??Mc;function*s(i){of(i,n);const o=t(i.byteLength);o instanceof Uint8Array?yield o:yield*o,i instanceof Uint8Array?yield i:yield*i}return sf(r)?async function*(){for await(const i of r)yield*s(i)}():function*(){for(const i of r)yield*s(i)}()}Si.single=(r,e)=>{e=e??{};const t=e.lengthEncoder??oo,n=e?.maxDataLength??Mc;return of(r,n),new J(t(r.byteLength),r)};var lr;(function(r){r[r.LENGTH=0]="LENGTH",r[r.DATA=1]="DATA"})(lr||(lr={}));const Oc=r=>{const e=kr(r);return Oc.bytes=Ie(e),e};Oc.bytes=0;function Ei(r,e){const t=new J;let n=lr.LENGTH,s=-1;const i=e?.lengthDecoder??Oc,o=e?.maxLengthLength??Zb,a=e?.maxDataLength??Mc;function*c(){for(;t.byteLength>0;){if(n===lr.LENGTH)try{if(s=i(t),s<0)throw new Jb("Invalid message length");if(s>a)throw new nf("Message length too long");const l=i.bytes;t.consume(l),e?.onLength!=null&&e.onLength(s),n=lr.DATA}catch(l){if(l instanceof RangeError){if(t.byteLength>o)throw new e0("Message length length too long");break}throw l}if(n===lr.DATA){if(t.byteLength<s)break;const l=t.sublist(0,s);t.consume(s),e?.onData!=null&&e.onData(l),yield l,n=lr.LENGTH}}}return sf(r)?async function*(){for await(const l of r)t.append(l),yield*c();if(t.byteLength>0)throw new Jl("Unexpected end of input")}():function*(){for(const l of r)t.append(l),yield*c();if(t.byteLength>0)throw new Jl("Unexpected end of input")}()}Ei.fromReader=(r,e)=>{let t=1;const n=async function*(){for(;;)try{const{done:i,value:o}=await r.next(t);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{t=1}}();return Ei(n,{...e??{},onLength:i=>{t=i}})};function pe(){const r={};return r.promise=new Promise((e,t)=>{r.resolve=e,r.reject=t}),r}let eu=class extends Error{type;code;constructor(e,t,n){super(e??"The operation was aborted"),this.type="aborted",this.name=n??"AbortError",this.code=t??"ABORT_ERR"}};async function _e(r,e,t){if(e==null)return r;if(e.aborted)return r.catch(()=>{}),Promise.reject(new eu(t?.errorMessage,t?.errorCode,t?.errorName));let n;const s=new eu(t?.errorMessage,t?.errorCode,t?.errorName);try{return await Promise.race([r,new Promise((i,o)=>{n=()=>{o(s)},e.addEventListener("abort",n)})])}finally{n!=null&&e.removeEventListener("abort",n)}}class t0{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=pe(),this.haveNext=pe()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=pe(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=pe(),await _e(this.readNext.promise,t?.signal,t)}}function af(){return new t0}class r0 extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"}function _i(r,e){const t=af();r.sink(t).catch(async o=>{await t.end(o)}),r.sink=async o=>{for await(const a of o)await t.push(a);await t.end()};let n=r.source;r.source[Symbol.iterator]!=null?n=r.source[Symbol.iterator]():r.source[Symbol.asyncIterator]!=null&&(n=r.source[Symbol.asyncIterator]());const s=new J;return{read:async o=>{if(o?.signal?.throwIfAborted(),o?.bytes==null){const{done:c,value:l}=await _e(n.next(),o?.signal);return c===!0?null:l}for(;s.byteLength<o.bytes;){const{value:c,done:l}=await _e(n.next(),o?.signal);if(l===!0)throw new r0("unexpected end of input");s.append(c)}const a=s.sublist(0,o.bytes);return s.consume(o.bytes),a},write:async(o,a)=>{a?.signal?.throwIfAborted(),o instanceof Uint8Array?await t.push(o,a):await t.push(o.subarray(),a)},unwrap:()=>{if(s.byteLength>0){const o=r.source;r.source=async function*(){e?.yieldBytes===!1?yield s:yield*s,yield*o}()}return r}}}class n0 extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"}class s0 extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"}class i0 extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"}function tn(r,e={}){const t=_i(r,e);e.maxDataLength!=null&&e.maxLengthLength==null&&(e.maxLengthLength=Ie(e.maxDataLength));const n=e?.lengthDecoder??kr,s=e?.lengthEncoder??bt;return{read:async o=>{let a=-1;const c=new J;for(;;){c.append(await t.read({...o,bytes:1}));try{a=n(c)}catch(l){if(l instanceof RangeError)continue;throw l}if(a<0)throw new n0("Invalid message length");if(e?.maxLengthLength!=null&&c.byteLength>e.maxLengthLength)throw new i0("message length length too long");if(a>-1)break}if(e?.maxDataLength!=null&&a>e.maxDataLength)throw new s0("message length too long");return t.read({...o,bytes:a})},write:async(o,a)=>{await t.write(new J(s(o.byteLength),o),a)},writeV:async(o,a)=>{const c=new J(...o.flatMap(l=>[s(l.byteLength),l]));await t.write(c,a)},unwrap:()=>t.unwrap()}}function tu(){const r=pe();let e=!1;return{sink:async t=>{if(e)throw new Error("already piped");e=!0,r.resolve(t)},source:async function*(){yield*await r.promise}()}}function o0(){const r=tu(),e=tu();return[{source:r.source,sink:e.sink},{source:e.source,sink:r.sink}]}class ru{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||(e-1&e)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}}class Fo{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new ru(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return e?.byteLength!=null?e.byteLength:1}push(e){if(e?.value!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new ru(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return e?.value!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}let a0=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}};function gs(r={}){return c0(t=>{const n=t.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function c0(r,e){e=e??{};let t=e.onEnd,n=new Fo,s,i,o,a=pe();const c=async()=>{try{return n.isEmpty()?o?{done:!0}:await new Promise((m,S)=>{i=x=>{i=null,n.push(x);try{m(r(n))}catch(w){S(w)}return s}}):r(n)}finally{n.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=pe()})}},l=m=>i!=null?i(m):(n.push(m),s),u=m=>(n=new Fo,i!=null?i({error:m}):(n.push({error:m}),s)),d=m=>{if(o)return s;if(e?.objectMode!==!0&&m?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:m})},h=m=>o?s:(o=!0,m!=null?u(m):l({done:!0})),p=()=>(n=new Fo,h(),{done:!0}),f=m=>(h(m),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:c,return:p,throw:f,push:d,end:h,get readableLength(){return n.size},onEmpty:async m=>{const S=m?.signal;if(S?.throwIfAborted(),n.isEmpty())return;let x,w;S!=null&&(x=new Promise((y,v)=>{w=()=>{v(new a0)},S.addEventListener("abort",w)}));try{await Promise.race([a.promise,x])}finally{w!=null&&S!=null&&S?.removeEventListener("abort",w)}}},t==null)return s;const g=s;return s={[Symbol.asyncIterator](){return this},next(){return g.next()},throw(m){return g.throw(m),t!=null&&(t(m),t=void 0),{done:!0}},return(){return g.return(),t!=null&&(t(),t=void 0),{done:!0}},push:d,end(m){return g.end(m),t!=null&&(t(m),t=void 0),s},get readableLength(){return g.readableLength},onEmpty:m=>g.onEmpty(m)},s}function l0(r){return r[Symbol.asyncIterator]!=null}async function u0(r,e,t){try{await Promise.all(r.map(async n=>{for await(const s of n)await e.push(s,{signal:t}),t.throwIfAborted()})),await e.end(void 0,{signal:t})}catch(n){await e.end(n,{signal:t}).catch(()=>{})}}async function*d0(r){const e=new AbortController,t=af();u0(r,t,e.signal).catch(()=>{});try{yield*t}finally{e.abort()}}function*h0(r){for(const e of r)yield*e}function xi(...r){const e=[];for(const t of r)l0(t)||e.push(t);return e.length===r.length?h0(e):d0(r)}function Fc(r,...e){if(r==null)throw new Error("Empty pipeline");if(No(r)){const n=r;r=()=>n.source}else if(lf(r)||cf(r)){const n=r;r=()=>n}const t=[r,...e];if(t.length>1&&No(t[t.length-1])&&(t[t.length-1]=t[t.length-1].sink),t.length>2)for(let n=1;n<t.length-1;n++)No(t[n])&&(t[n]=p0(t[n]));return f0(...t)}const f0=(...r)=>{let e;for(;r.length>0;)e=r.shift()(e);return e},cf=r=>r?.[Symbol.asyncIterator]!=null,lf=r=>r?.[Symbol.iterator]!=null,No=r=>r==null?!1:r.sink!=null&&r.source!=null,p0=r=>e=>{const t=r.sink(e);if(t?.then!=null){const n=gs({objectMode:!0});t.then(()=>{n.end()},o=>{n.end(o)});let s;const i=r.source;if(cf(i))s=async function*(){yield*i,n.end()};else if(lf(i))s=function*(){yield*i,n.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return xi(n,s())}return r.source},jn=65535,nu=jn-16,ms=!!globalThis.process?.env?.DUMP_SESSION_KEYS;/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function uf(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Oa(r){if(typeof r!="boolean")throw new Error(`boolean expected, not ${r}`)}function Bo(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function He(r,...e){if(!uf(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function su(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function g0(r,e){He(r);const t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function Yt(r){return new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength/4))}function rn(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function m0(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}const y0=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function w0(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}function Fa(r){if(typeof r=="string")r=w0(r);else if(uf(r))r=Na(r);else throw new Error("Uint8Array expected, got "+typeof r);return r}function b0(r,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(r,e)}function v0(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}const S0=(r,e)=>{function t(n,...s){if(He(n),!y0)throw new Error("Non little-endian hardware is not yet supported");if(r.nonceLength!==void 0){const u=s[0];if(!u)throw new Error("nonce / iv required");r.varSizeNonce?He(u):He(u,r.nonceLength)}const i=r.tagLength;i&&s[1]!==void 0&&He(s[1]);const o=e(n,...s),a=(u,d)=>{if(d!==void 0){if(u!==2)throw new Error("cipher output not supported");He(d)}};let c=!1;return{encrypt(u,d){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,He(u),a(o.encrypt.length,d),o.encrypt(u,d)},decrypt(u,d){if(He(u),i&&u.length<i)throw new Error("invalid ciphertext length: smaller than tagLength="+i);return a(o.decrypt.length,d),o.decrypt(u,d)}}}return Object.assign(t,r),t};function iu(r,e,t=!0){if(e===void 0)return new Uint8Array(r);if(e.length!==r)throw new Error("invalid output length, expected "+r+", got: "+e.length);if(t&&!_0(e))throw new Error("invalid output, must be aligned");return e}function ou(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const s=BigInt(32),i=BigInt(4294967295),o=Number(t>>s&i),a=Number(t&i),c=4,l=0;r.setUint32(e+c,o,n),r.setUint32(e+l,a,n)}function E0(r,e,t){Oa(t);const n=new Uint8Array(16),s=m0(n);return ou(s,0,BigInt(e),t),ou(s,8,BigInt(r),t),n}function _0(r){return r.byteOffset%4===0}function Na(r){return Uint8Array.from(r)}const df=r=>Uint8Array.from(r.split("").map(e=>e.charCodeAt(0))),x0=df("expand 16-byte k"),A0=df("expand 32-byte k"),C0=Yt(x0),I0=Yt(A0);function ee(r,e){return r<<e|r>>>32-e}function Ba(r){return r.byteOffset%4===0}const Ls=64,T0=16,hf=2**32-1,au=new Uint32Array;function P0(r,e,t,n,s,i,o,a){const c=s.length,l=new Uint8Array(Ls),u=Yt(l),d=Ba(s)&&Ba(i),h=d?Yt(s):au,p=d?Yt(i):au;for(let f=0;f<c;o++){if(r(e,t,n,u,o,a),o>=hf)throw new Error("arx: counter overflow");const g=Math.min(Ls,c-f);if(d&&g===Ls){const m=f/4;if(f%4!==0)throw new Error("arx: invalid block position");for(let S=0,x;S<T0;S++)x=m+S,p[x]=h[x]^u[S];f+=Ls;continue}for(let m=0,S;m<g;m++)S=f+m,i[S]=s[S]^l[m];f+=g}}function k0(r,e){const{allowShortKeys:t,extendNonceFn:n,counterLength:s,counterRight:i,rounds:o}=b0({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof r!="function")throw new Error("core must be a function");return Bo(s),Bo(o),Oa(i),Oa(t),(a,c,l,u,d=0)=>{He(a),He(c),He(l);const h=l.length;if(u===void 0&&(u=new Uint8Array(h)),He(u),Bo(d),d<0||d>=hf)throw new Error("arx: counter overflow");if(u.length<h)throw new Error(`arx: output (${u.length}) is shorter than data (${h})`);const p=[];let f=a.length,g,m;if(f===32)p.push(g=Na(a)),m=I0;else if(f===16&&t)g=new Uint8Array(32),g.set(a),g.set(a,16),m=C0,p.push(g);else throw new Error(`arx: invalid 32-byte key, got length=${f}`);Ba(c)||p.push(c=Na(c));const S=Yt(g);if(n){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");n(m,S,Yt(c.subarray(0,16)),S),c=c.subarray(16)}const x=16-s;if(x!==c.length)throw new Error(`arx: nonce must be ${x} or 16 bytes`);if(x!==12){const y=new Uint8Array(12);y.set(c,i?0:12-c.length),c=y,p.push(c)}const w=Yt(c);return P0(r,m,S,w,l,u,d,o),rn(...p),u}}const Ce=(r,e)=>r[e++]&255|(r[e++]&255)<<8;class R0{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=Fa(e),He(e,32);const t=Ce(e,0),n=Ce(e,2),s=Ce(e,4),i=Ce(e,6),o=Ce(e,8),a=Ce(e,10),c=Ce(e,12),l=Ce(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|n<<3)&8191,this.r[2]=(n>>>10|s<<6)&7939,this.r[3]=(s>>>7|i<<9)&8191,this.r[4]=(i>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|l<<8)&8191,this.r[9]=l>>>5&127;for(let u=0;u<8;u++)this.pad[u]=Ce(e,16+2*u)}process(e,t,n=!1){const s=n?0:2048,{h:i,r:o}=this,a=o[0],c=o[1],l=o[2],u=o[3],d=o[4],h=o[5],p=o[6],f=o[7],g=o[8],m=o[9],S=Ce(e,t+0),x=Ce(e,t+2),w=Ce(e,t+4),y=Ce(e,t+6),v=Ce(e,t+8),C=Ce(e,t+10),E=Ce(e,t+12),A=Ce(e,t+14);let T=i[0]+(S&8191),O=i[1]+((S>>>13|x<<3)&8191),L=i[2]+((x>>>10|w<<6)&8191),M=i[3]+((w>>>7|y<<9)&8191),D=i[4]+((y>>>4|v<<12)&8191),U=i[5]+(v>>>1&8191),P=i[6]+((v>>>14|C<<2)&8191),k=i[7]+((C>>>11|E<<5)&8191),F=i[8]+((E>>>8|A<<8)&8191),I=i[9]+(A>>>5|s),b=0,_=b+T*a+O*(5*m)+L*(5*g)+M*(5*f)+D*(5*p);b=_>>>13,_&=8191,_+=U*(5*h)+P*(5*d)+k*(5*u)+F*(5*l)+I*(5*c),b+=_>>>13,_&=8191;let R=b+T*c+O*a+L*(5*m)+M*(5*g)+D*(5*f);b=R>>>13,R&=8191,R+=U*(5*p)+P*(5*h)+k*(5*d)+F*(5*u)+I*(5*l),b+=R>>>13,R&=8191;let N=b+T*l+O*c+L*a+M*(5*m)+D*(5*g);b=N>>>13,N&=8191,N+=U*(5*f)+P*(5*p)+k*(5*h)+F*(5*d)+I*(5*u),b+=N>>>13,N&=8191;let $=b+T*u+O*l+L*c+M*a+D*(5*m);b=$>>>13,$&=8191,$+=U*(5*g)+P*(5*f)+k*(5*p)+F*(5*h)+I*(5*d),b+=$>>>13,$&=8191;let q=b+T*d+O*u+L*l+M*c+D*a;b=q>>>13,q&=8191,q+=U*(5*m)+P*(5*g)+k*(5*f)+F*(5*p)+I*(5*h),b+=q>>>13,q&=8191;let W=b+T*h+O*d+L*u+M*l+D*c;b=W>>>13,W&=8191,W+=U*a+P*(5*m)+k*(5*g)+F*(5*f)+I*(5*p),b+=W>>>13,W&=8191;let H=b+T*p+O*h+L*d+M*u+D*l;b=H>>>13,H&=8191,H+=U*c+P*a+k*(5*m)+F*(5*g)+I*(5*f),b+=H>>>13,H&=8191;let j=b+T*f+O*p+L*h+M*d+D*u;b=j>>>13,j&=8191,j+=U*l+P*c+k*a+F*(5*m)+I*(5*g),b+=j>>>13,j&=8191;let se=b+T*g+O*f+L*p+M*h+D*d;b=se>>>13,se&=8191,se+=U*u+P*l+k*c+F*a+I*(5*m),b+=se>>>13,se&=8191;let re=b+T*m+O*g+L*f+M*p+D*h;b=re>>>13,re&=8191,re+=U*d+P*u+k*l+F*c+I*a,b+=re>>>13,re&=8191,b=(b<<2)+b|0,b=b+_|0,_=b&8191,b=b>>>13,R+=b,i[0]=_,i[1]=R,i[2]=N,i[3]=$,i[4]=q,i[5]=W,i[6]=H,i[7]=j,i[8]=se,i[9]=re}finalize(){const{h:e,pad:t}=this,n=new Uint16Array(10);let s=e[1]>>>13;e[1]&=8191;for(let a=2;a<10;a++)e[a]+=s,s=e[a]>>>13,e[a]&=8191;e[0]+=s*5,s=e[0]>>>13,e[0]&=8191,e[1]+=s,s=e[1]>>>13,e[1]&=8191,e[2]+=s,n[0]=e[0]+5,s=n[0]>>>13,n[0]&=8191;for(let a=1;a<10;a++)n[a]=e[a]+s,s=n[a]>>>13,n[a]&=8191;n[9]-=8192;let i=(s^1)-1;for(let a=0;a<10;a++)n[a]&=i;i=~i;for(let a=0;a<10;a++)e[a]=e[a]&i|n[a];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let o=e[0]+t[0];e[0]=o&65535;for(let a=1;a<8;a++)o=(e[a]+t[a]|0)+(o>>>16)|0,e[a]=o&65535;rn(n)}update(e){su(this),e=Fa(e),He(e);const{buffer:t,blockLen:n}=this,s=e.length;for(let i=0;i<s;){const o=Math.min(n-this.pos,s-i);if(o===n){for(;n<=s-i;i+=n)this.process(e,i);continue}t.set(e.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===n&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){rn(this.h,this.r,this.buffer,this.pad)}digestInto(e){su(this),g0(e,this),this.finished=!0;const{buffer:t,h:n}=this;let{pos:s}=this;if(s){for(t[s++]=1;s<16;s++)t[s]=0;this.process(t,0,!0)}this.finalize();let i=0;for(let o=0;o<8;o++)e[i++]=n[o]>>>0,e[i++]=n[o]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}}function L0(r){const e=(n,s)=>r(s).update(Fa(n)).digest(),t=r(new Uint8Array(32));return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=n=>r(n),e}const D0=L0(r=>new R0(r));function M0(r,e,t,n,s,i=20){let o=r[0],a=r[1],c=r[2],l=r[3],u=e[0],d=e[1],h=e[2],p=e[3],f=e[4],g=e[5],m=e[6],S=e[7],x=s,w=t[0],y=t[1],v=t[2],C=o,E=a,A=c,T=l,O=u,L=d,M=h,D=p,U=f,P=g,k=m,F=S,I=x,b=w,_=y,R=v;for(let $=0;$<i;$+=2)C=C+O|0,I=ee(I^C,16),U=U+I|0,O=ee(O^U,12),C=C+O|0,I=ee(I^C,8),U=U+I|0,O=ee(O^U,7),E=E+L|0,b=ee(b^E,16),P=P+b|0,L=ee(L^P,12),E=E+L|0,b=ee(b^E,8),P=P+b|0,L=ee(L^P,7),A=A+M|0,_=ee(_^A,16),k=k+_|0,M=ee(M^k,12),A=A+M|0,_=ee(_^A,8),k=k+_|0,M=ee(M^k,7),T=T+D|0,R=ee(R^T,16),F=F+R|0,D=ee(D^F,12),T=T+D|0,R=ee(R^T,8),F=F+R|0,D=ee(D^F,7),C=C+L|0,R=ee(R^C,16),k=k+R|0,L=ee(L^k,12),C=C+L|0,R=ee(R^C,8),k=k+R|0,L=ee(L^k,7),E=E+M|0,I=ee(I^E,16),F=F+I|0,M=ee(M^F,12),E=E+M|0,I=ee(I^E,8),F=F+I|0,M=ee(M^F,7),A=A+D|0,b=ee(b^A,16),U=U+b|0,D=ee(D^U,12),A=A+D|0,b=ee(b^A,8),U=U+b|0,D=ee(D^U,7),T=T+O|0,_=ee(_^T,16),P=P+_|0,O=ee(O^P,12),T=T+O|0,_=ee(_^T,8),P=P+_|0,O=ee(O^P,7);let N=0;n[N++]=o+C|0,n[N++]=a+E|0,n[N++]=c+A|0,n[N++]=l+T|0,n[N++]=u+O|0,n[N++]=d+L|0,n[N++]=h+M|0,n[N++]=p+D|0,n[N++]=f+U|0,n[N++]=g+P|0,n[N++]=m+k|0,n[N++]=S+F|0,n[N++]=x+I|0,n[N++]=w+b|0,n[N++]=y+_|0,n[N++]=v+R|0}const O0=k0(M0,{counterRight:!1,counterLength:4,allowShortKeys:!1}),F0=new Uint8Array(16),cu=(r,e)=>{r.update(e);const t=e.length%16;t&&r.update(F0.subarray(t))},N0=new Uint8Array(32);function lu(r,e,t,n,s){const i=r(e,t,N0),o=D0.create(i);s&&cu(o,s),cu(o,n);const a=E0(n.length,s?s.length:0,!0);o.update(a);const c=o.digest();return rn(i,a),c}const B0=r=>(e,t,n)=>({encrypt(i,o){const a=i.length;o=iu(a+16,o,!1),o.set(i);const c=o.subarray(0,-16);r(e,t,c,c,1);const l=lu(r,e,t,c,n);return o.set(l,a),rn(l),o},decrypt(i,o){o=iu(i.length-16,o,!1);const a=i.subarray(0,-16),c=i.subarray(-16),l=lu(r,e,t,a,n);if(!v0(c,l))throw new Error("invalid tag");return o.set(i.subarray(0,-16)),r(e,t,o,o,1),rn(l),o}}),uu=S0({blockSize:64,nonceLength:12,tagLength:16},B0(O0));function U0(r,e,t){return yc(r),t===void 0&&(t=new Uint8Array(r.outputLen)),io(r,Kn(t),Kn(e))}const Uo=Uint8Array.from([0]),du=Uint8Array.of();function $0(r,e,t,n=32){yc(r),pi(n);const s=r.outputLen;if(n>255*s)throw new Error("Length should be <= 255*HashLen");const i=Math.ceil(n/s);t===void 0&&(t=du);const o=new Uint8Array(i*s),a=io.create(r,e),c=a._cloneInto(),l=new Uint8Array(a.outputLen);for(let u=0;u<i;u++)Uo[0]=u+1,c.update(u===0?du:l).update(t).update(Uo).digestInto(l),o.set(l,s*u),a._cloneInto(c);return a.destroy(),c.destroy(),_r(l,Uo),o.slice(0,n)}const q0={hashSHA256(r){return ei(r.subarray())},getHKDF(r,e){const t=U0(ei,e,r),s=$0(ei,t,void 0,96),i=s.subarray(0,32),o=s.subarray(32,64),a=s.subarray(64,96);return[i,o,a]},generateX25519KeyPair(){const r=Ps.utils.randomPrivateKey();return{publicKey:Ps.getPublicKey(r),privateKey:r}},generateX25519KeyPairFromSeed(r){return{publicKey:Ps.getPublicKey(r),privateKey:r}},generateX25519SharedKey(r,e){return Ps.getSharedSecret(r.subarray(),e.subarray())},chaCha20Poly1305Encrypt(r,e,t,n){return uu(n,e,t).encrypt(r.subarray())},chaCha20Poly1305Decrypt(r,e,t,n,s){return uu(n,e,t).decrypt(r.subarray(),s)}},W0=q0;function z0(r){return{generateKeypair:r.generateX25519KeyPair,dh:(e,t)=>r.generateX25519SharedKey(e.privateKey,t).subarray(0,32),encrypt:r.chaCha20Poly1305Encrypt,decrypt:r.chaCha20Poly1305Decrypt,hash:r.hashSHA256,hkdf:r.getHKDF}}const Ai=r=>{const e=St(2);return e[0]=r>>8,e[1]=r,e};Ai.bytes=2;const ti=r=>{if(r.length<2)throw RangeError("Could not decode int16BE");if(r instanceof Uint8Array){let e=0;return e+=r[0]<<8,e+=r[1],e}return r.getUint16(0)};ti.bytes=2;function K0(r){return{xxHandshakeSuccesses:r.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:r.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:r.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:r.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:r.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}function ff(r,e){!e.enabled||!ms||(r?(e(`LOCAL_STATIC_PUBLIC_KEY ${G(r.publicKey,"hex")}`),e(`LOCAL_STATIC_PRIVATE_KEY ${G(r.privateKey,"hex")}`)):e("Missing local static keys."))}function pf(r,e){!e.enabled||!ms||(r?(e(`LOCAL_PUBLIC_EPHEMERAL_KEY ${G(r.publicKey,"hex")}`),e(`LOCAL_PRIVATE_EPHEMERAL_KEY ${G(r.privateKey,"hex")}`)):e("Missing local ephemeral keys."))}function H0(r,e){!e.enabled||!ms||e(r?`REMOTE_STATIC_PUBLIC_KEY ${G(r.subarray(),"hex")}`:"Missing remote static public key.")}function gf(r,e){!e.enabled||!ms||e(r?`REMOTE_EPHEMERAL_PUBLIC_KEY ${G(r.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function mf(r,e,t){!t.enabled||!ms||(t(`CIPHER_STATE_1 ${r.n.getUint64()} ${r.k&&G(r.k,"hex")}`),t(`CIPHER_STATE_2 ${e.n.getUint64()} ${e.k&&G(e.k,"hex")}`))}class Un extends Error{code;constructor(e="Invalid crypto exchange"){super(e),this.code=Un.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"}const V0=0,G0=4294967295,j0="Cipherstate has reached maximum n, a new handshake must be performed";class Y0{n;bytes;view;constructor(e=V0){this.n=e,this.bytes=ae(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,e,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>G0)throw new Error(j0)}}const Hr=ae(0);class Ds{k;n;crypto;constructor(e,t=void 0,n=0){this.crypto=e,this.k=t,this.n=new Y0(n)}hasKey(){return!!this.k}encryptWithAd(e,t){if(!this.hasKey())return t;this.n.assertValue();const n=this.crypto.encrypt(t,this.n.getBytes(),e,this.k);return this.n.increment(),n}decryptWithAd(e,t,n){if(!this.hasKey())return t;this.n.assertValue();const s=this.crypto.decrypt(t,this.n.getBytes(),e,this.k,n);return this.n.increment(),s}}class X0{cs;ck;h;crypto;constructor(e,t){this.crypto=e;const n=z(t,"utf-8");this.h=Z0(e,n),this.ck=this.h,this.cs=new Ds(e)}mixKey(e){const[t,n]=this.crypto.hkdf(this.ck,e);this.ck=t,this.cs=new Ds(this.crypto,n)}mixHash(e){this.h=this.crypto.hash(new J(this.h,e))}encryptAndHash(e){const t=this.cs.encryptWithAd(this.h,e);return this.mixHash(t),t}decryptAndHash(e){const t=this.cs.decryptWithAd(this.h,e);return this.mixHash(e),t}split(){const[e,t]=this.crypto.hkdf(this.ck,Hr);return[new Ds(this.crypto,e),new Ds(this.crypto,t)]}}class Q0{ss;s;e;rs;re;initiator;crypto;constructor(e){const{crypto:t,protocolName:n,prologue:s,initiator:i,s:o,e:a,rs:c,re:l}=e;this.crypto=t,this.ss=new X0(t,n),this.ss.mixHash(s),this.initiator=i,this.s=o,this.e=a,this.rs=c,this.re=l}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const e=this.crypto.generateKeypair();return this.ss.mixHash(e.publicKey),this.e=e,e.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(e,t=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(e.byteLength<t+32)throw new Error("message is not long enough");this.re=e.sublist(t,t+32),this.ss.mixHash(this.re)}readS(e,t=0){if(this.rs)throw new Error("remote static public key is already set");const n=32+(this.ss.cs.hasKey()?16:0);if(e.byteLength<t+n)throw new Error("message is not long enough");const s=e.sublist(t,t+n);return this.rs=this.ss.decryptAndHash(s),n}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class yf extends Q0{writeMessageA(e){return new J(this.writeE(),this.ss.encryptAndHash(e))}writeMessageB(e){const t=this.writeE();this.writeEE();const n=this.writeS();return this.writeES(),new J(t,n,this.ss.encryptAndHash(e))}writeMessageC(e){const t=this.writeS();return this.writeSE(),new J(t,this.ss.encryptAndHash(e))}readMessageA(e){try{return this.readE(e),this.ss.decryptAndHash(e.sublist(32))}catch(t){throw new Un(`handshake stage 0 validation fail: ${t.message}`)}}readMessageB(e){try{this.readE(e),this.readEE();const t=this.readS(e,32);return this.readES(),this.ss.decryptAndHash(e.sublist(32+t))}catch(t){throw new Un(`handshake stage 1 validation fail: ${t.message}`)}}readMessageC(e){try{const t=this.readS(e);return this.readSE(),this.ss.decryptAndHash(e.sublist(t))}catch(t){throw new Un(`handshake stage 2 validation fail: ${t.message}`)}}}function Z0(r,e){if(e.length<=32){const t=ae(32);return t.set(e),t}else return r.hash(e)}var Ci;(function(r){let e;r.codec=()=>(e==null&&(e=we((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.webtransportCerthashes!=null)for(const i of t.webtransportCerthashes)n.uint32(10),n.bytes(i);if(t.streamMuxers!=null)for(const i of t.streamMuxers)n.uint32(18),n.string(i);s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={webtransportCerthashes:[],streamMuxers:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(s.limits?.webtransportCerthashes!=null&&i.webtransportCerthashes.length===s.limits.webtransportCerthashes)throw new Lt('Decode error - map field "webtransportCerthashes" had too many elements');i.webtransportCerthashes.push(t.bytes());break}case 2:{if(s.limits?.streamMuxers!=null&&i.streamMuxers.length===s.limits.streamMuxers)throw new Lt('Decode error - map field "streamMuxers" had too many elements');i.streamMuxers.push(t.string());break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ye(t,r.codec()),r.decode=(t,n)=>me(t,r.codec(),n)})(Ci||(Ci={}));var Ii;(function(r){let e;r.codec=()=>(e==null&&(e=we((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.identityKey!=null&&t.identityKey.byteLength>0&&(n.uint32(10),n.bytes(t.identityKey)),t.identitySig!=null&&t.identitySig.byteLength>0&&(n.uint32(18),n.bytes(t.identitySig)),t.extensions!=null&&(n.uint32(34),Ci.codec().encode(t.extensions,n)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={identityKey:ae(0),identitySig:ae(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.identityKey=t.bytes();break}case 2:{i.identitySig=t.bytes();break}case 4:{i.extensions=Ci.codec().decode(t,t.uint32(),{limits:s.limits?.extensions});break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ye(t,r.codec()),r.decode=(t,n)=>me(t,r.codec(),n)})(Ii||(Ii={}));async function wf(r,e,t){const n=await r.sign(vf(e));return Ii.encode({identityKey:kt(r.publicKey),identitySig:n,extensions:t})}async function bf(r,e,t){try{const n=Ii.decode(r),s=Zt(n.identityKey);if(t?.equals(s)===!1)throw new Error(`Payload identity key ${s} does not match expected remote identity key ${t}`);if(!e)throw new Error("Remote static does not exist");const i=vf(e);if(!await s.verify(i,n.identitySig))throw new Error("Invalid payload signature");return n}catch(n){throw new em(n.message)}}function vf(r){const e=z("noise-libp2p-static-key:");return r instanceof Uint8Array?ut([e,r],e.length+r.length):(r.prepend(e),r)}async function J0(r,e){const{log:t,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=r,u=await wf(i,a.publicKey,l),d=new yf({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});ff(d.s,t),t.trace("Stage 0 - Initiator starting to send first message."),await n.write(d.writeMessageA(Hr),e),t.trace("Stage 0 - Initiator finished sending first message."),pf(d.e,t),t.trace("Stage 1 - Initiator waiting to receive first message from responder...");const h=d.readMessageB(await n.read(e));t.trace("Stage 1 - Initiator received the message."),gf(d.re,t),H0(d.rs,t),t.trace("Initiator going to check remote's signature...");const p=await bf(h,d.rs,c);t.trace("All good with the signature!"),t.trace("Stage 2 - Initiator sending third handshake message."),await n.write(d.writeMessageC(u),e),t.trace("Stage 2 - Initiator sent message with signed payload.");const[f,g]=d.ss.split();return mf(f,g,t),{payload:p,encrypt:m=>f.encryptWithAd(Hr,m),decrypt:(m,S)=>g.decryptWithAd(Hr,m,S)}}async function ev(r,e){const{log:t,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=r,u=await wf(i,a.publicKey,l),d=new yf({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});ff(d.s,t),t.trace("Stage 0 - Responder waiting to receive first message."),d.readMessageA(await n.read(e)),t.trace("Stage 0 - Responder received first message."),gf(d.re,t),t.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await n.write(d.writeMessageB(u),e),t.trace("Stage 1 - Responder sent the second handshake message with signed payload."),pf(d.e,t),t.trace("Stage 2 - Responder waiting for third handshake message...");const h=d.readMessageC(await n.read(e));t.trace("Stage 2 - Responder received the message, finished handshake.");const p=await bf(h,d.rs,c),[f,g]=d.ss.split();return mf(f,g,t),{payload:p,encrypt:m=>g.encryptWithAd(Hr,m),decrypt:(m,S)=>f.decryptWithAd(Hr,m,S)}}const hu=16;function tv(r,e){return async function*(t){for await(const n of t)for(let s=0;s<n.length;s+=nu){let i=s+nu;i>n.length&&(i=n.length);let o;n instanceof Uint8Array?o=r.encrypt(n.subarray(s,i)):o=r.encrypt(n.sublist(s,i)),e?.encryptedPackets.increment(),yield new J(Ai(o.byteLength),o)}}}function rv(r,e){return async function*(t){for await(const n of t)for(let s=0;s<n.length;s+=jn){let i=s+jn;if(i>n.length&&(i=n.length),i-hu<s)throw new Error("Invalid chunk");const o=n.sublist(s,i),a=n.subarray(s,i-hu);try{const c=r.decrypt(o,a);e?.decryptedPackets.increment(),yield c}catch(c){throw e?.decryptErrors.increment(),c}}}}class nv{protocol="/noise";crypto;prologue;staticKey;extensions;metrics;components;constructor(e,t={}){const{staticNoiseKey:n,extensions:s,crypto:i,prologueBytes:o}=t,{metrics:a}=e;this.components=e;const c=i??W0;this.crypto=z0(c),this.extensions={webtransportCerthashes:[],...s},this.metrics=a?K0(a):void 0,n?this.staticKey=c.generateX25519KeyPairFromSeed(n):this.staticKey=c.generateX25519KeyPair(),this.prologue=o??ae(0)}[Symbol.toStringTag]="@chainsafe/libp2p-noise";[rt]=["@libp2p/connection-encryption","@chainsafe/libp2p-noise"];async secureOutbound(e,t){const n=tn(e,{lengthEncoder:Ai,lengthDecoder:ti,maxDataLength:jn}),s=await this.performHandshakeInitiator(n,this.components.privateKey,t?.remotePeer?.publicKey,t),i=await this.createSecureConnection(n,s);e.source=i.source,e.sink=i.sink;const o=Zt(s.payload.identityKey);return{conn:e,remoteExtensions:s.payload.extensions,remotePeer:Gn(o),streamMuxer:t?.skipStreamMuxerNegotiation===!0?void 0:this.getStreamMuxer(s.payload.extensions?.streamMuxers)}}getStreamMuxer(e){if(e==null||e.length===0)return;const t=this.components.upgrader.getStreamMuxers();if(t!=null)for(const n of e){const s=t.get(n);if(s!=null)return s}if(e.length)throw new Jd("Early muxer negotiation was requested but the initiator and responder had no common muxers")}async secureInbound(e,t){const n=tn(e,{lengthEncoder:Ai,lengthDecoder:ti,maxDataLength:jn}),s=await this.performHandshakeResponder(n,this.components.privateKey,t?.remotePeer?.publicKey,t),i=await this.createSecureConnection(n,s);e.source=i.source,e.sink=i.sink;const o=Zt(s.payload.identityKey);return{conn:e,remoteExtensions:s.payload.extensions,remotePeer:Gn(o),streamMuxer:t?.skipStreamMuxerNegotiation===!0?void 0:this.getStreamMuxer(s.payload.extensions?.streamMuxers)}}async performHandshakeInitiator(e,t,n,s){let i;const o=s?.skipStreamMuxerNegotiation===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{i=await J0({connection:e,privateKey:t,remoteIdentityKey:n,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:o,webtransportCerthashes:[],...this.extensions}},s),this.metrics?.xxHandshakeSuccesses.increment()}catch(a){throw this.metrics?.xxHandshakeErrors.increment(),a}return i}async performHandshakeResponder(e,t,n,s){let i;const o=s?.skipStreamMuxerNegotiation===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{i=await ev({connection:e,privateKey:t,remoteIdentityKey:n,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:o,webtransportCerthashes:[],...this.extensions}},s),this.metrics?.xxHandshakeSuccesses.increment()}catch(a){throw this.metrics?.xxHandshakeErrors.increment(),a}return i}async createSecureConnection(e,t){const[n,s]=o0(),i=e.unwrap();return await Fc(n,tv(t,this.metrics),i,o=>Ei(o,{lengthDecoder:ti}),rv(t,this.metrics),n),s}}function Sf(r={}){return e=>new nv(e,r)}function Ef(r){if(r!=null){if(typeof r[Symbol.iterator]=="function")return r[Symbol.iterator]();if(typeof r[Symbol.asyncIterator]=="function")return r[Symbol.asyncIterator]();if(typeof r.next=="function")return r}throw new Error("argument is not an iterator or iterable")}class $r extends Error{static name="InvalidFrameError";constructor(e="The frame was invalid"){super(e),this.name="InvalidFrameError"}}class _f extends Error{static name="UnrequestedPingError";constructor(e="Unrequested ping error"){super(e),this.name="UnrequestedPingError"}}class xf extends Error{static name="NotMatchingPingError";constructor(e="Unrequested ping error"){super(e),this.name="NotMatchingPingError"}}class sv extends Error{static name="InvalidStateError";constructor(e="Invalid state"){super(e),this.name="InvalidStateError"}}class iv extends Error{static name="StreamAlreadyExistsError";constructor(e="Strean already exists"){super(e),this.name="StreamAlreadyExistsError"}}class ov extends Error{static name="DecodeInvalidVersionError";constructor(e="Decode invalid version"){super(e),this.name="DecodeInvalidVersionError"}}class av extends Error{static name="BothClientsError";constructor(e="Both clients"){super(e),this.name="BothClientsError"}}class Af extends Error{static name="ReceiveWindowExceededError";constructor(e="Receive window exceeded"){super(e),this.name="ReceiveWindowExceededError"}}const cv=new Set([$r.name,_f.name,xf.name,iv.name,ov.name,av.name,Af.name]),Nc=256*1024,lv=16*1024*1024,uv={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:Nc,maxStreamWindowSize:lv,maxMessageSize:64*1024};function dv(r){if(r.keepAliveInterval<=0)throw new K("keep-alive interval must be positive");if(r.maxInboundStreams<0)throw new K("max inbound streams must be larger or equal 0");if(r.maxOutboundStreams<0)throw new K("max outbound streams must be larger or equal 0");if(r.initialStreamWindowSize<Nc)throw new K("InitialStreamWindowSize must be larger or equal 256 kB");if(r.maxStreamWindowSize<r.initialStreamWindowSize)throw new K("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(r.maxStreamWindowSize>2**32-1)throw new K("MaxStreamWindowSize must be less than equal MAX_UINT32");if(r.maxMessageSize<1024)throw new K("MaxMessageSize must be greater than a kilobyte")}var ve;(function(r){r[r.Data=0]="Data",r[r.WindowUpdate=1]="WindowUpdate",r[r.Ping=2]="Ping",r[r.GoAway=3]="GoAway"})(ve||(ve={}));var ge;(function(r){r[r.SYN=1]="SYN",r[r.ACK=2]="ACK",r[r.FIN=4]="FIN",r[r.RST=8]="RST"})(ge||(ge={}));Object.values(ge).filter(r=>typeof r!="string");const hv=0;var gt;(function(r){r[r.NormalTermination=0]="NormalTermination",r[r.ProtocolError=1]="ProtocolError",r[r.InternalError=2]="InternalError"})(gt||(gt={}));const $n=12,fu=2**24;function fv(r){if(r[0]!==hv)throw new $r("Invalid frame version");return{type:r[1],flag:(r[2]<<8)+r[3],streamID:r[4]*fu+(r[5]<<16)+(r[6]<<8)+r[7],length:r[8]*fu+(r[9]<<16)+(r[10]<<8)+r[11]}}class pv{source;buffer;frameInProgress;constructor(e){this.source=gv(e),this.buffer=new J,this.frameInProgress=!1}async*emitFrames(){for await(const e of this.source)for(this.buffer.append(e);;){const t=this.readHeader();if(t===void 0)break;const{type:n,length:s}=t;n===ve.Data?(this.frameInProgress=!0,yield{header:t,readData:this.readBytes.bind(this,s)}):yield{header:t}}}readHeader(){if(this.frameInProgress)throw new sv("decoding frame already in progress");if(this.buffer.length<$n)return;const e=fv(this.buffer.subarray(0,$n));return this.buffer.consume($n),e}async readBytes(e){if(this.buffer.length<e){for await(const n of this.source)if(this.buffer.append(n),this.buffer.length>=e)break}const t=this.buffer.sublist(0,e);return this.buffer.consume(e),this.frameInProgress=!1,t}}function gv(r){if(r[Symbol.iterator]!==void 0){const e=r[Symbol.iterator]();return e.return=void 0,{[Symbol.iterator](){return e}}}else if(r[Symbol.asyncIterator]!==void 0){const e=r[Symbol.asyncIterator]();return e.return=void 0,{[Symbol.asyncIterator](){return e}}}else throw new Error("a source must be either an iterable or an async iterable")}function pu(r){const e=new Uint8Array($n);return e[1]=r.type,e[2]=r.flag>>>8,e[3]=r.flag,e[4]=r.streamID>>>24,e[5]=r.streamID>>>16,e[6]=r.streamID>>>8,e[7]=r.streamID,e[8]=r.length>>>24,e[9]=r.length>>>16,e[10]=r.length>>>8,e[11]=r.length,e}function mv(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}function yv(r,e){const t=Ef(r).return?.();mv(t)&&t.catch(n=>{e.error("could not cause iterator to return",n)})}const wv=5e3;function $o(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class Bc{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;sendingData;constructor(e){this.sinkController=new AbortController,this.sinkEnd=pe(),this.closed=pe(),this.log=e.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=e.id,this.metadata=e.metadata??{},this.direction=e.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=e.sendCloseWriteTimeout??wv,this.onEnd=e.onEnd,this.onCloseRead=e.onCloseRead,this.onCloseWrite=e.onCloseWrite,this.onReset=e.onReset,this.onAbort=e.onAbort,this.source=this.streamSource=gs({onEnd:t=>{t!=null?this.log.trace("source ended with error",t):this.log.trace("source ended"),this.onSourceEnd(t)}}),this.sink=this.sink.bind(this)}async sink(e){if(this.writeStatus!=="ready")throw new ba(`writable end state is "${this.writeStatus}" not "ready"`);try{this.writeStatus="writing";const t={signal:this.sinkController.signal};if(this.direction==="outbound"){const s=this.sendNewStream(t);$o(s)&&await s}const n=()=>{yv(e,this.log)};try{this.sinkController.signal.addEventListener("abort",n),this.log.trace("sink reading from source");for await(let s of e){s=s instanceof Uint8Array?new J(s):s;const i=this.sendData(s,t);$o(i)&&(this.sendingData=pe(),await i,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",n)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),this.writeStatus==="writing"&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(t){throw this.log.trace("sink ended with error, calling abort with error",t),this.abort(t),t}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(e){this.timeline.closeRead==null&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),this.onCloseRead?.(),this.timeline.closeWrite!=null?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(e){this.timeline.closeWrite==null&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),this.onCloseWrite?.(),this.timeline.closeRead!=null?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(e){this.status==="open"&&(this.log.trace("closing gracefully"),this.status="closing",await _e(Promise.all([this.closeWrite(e),this.closeRead(e),this.closed.promise]),e?.signal),this.status="closed",this.log.trace("closed gracefully"))}async closeRead(e={}){if(this.readStatus==="closing"||this.readStatus==="closed")return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);const t=this.readStatus;this.readStatus="closing",this.status!=="reset"&&this.status!=="aborted"&&this.timeline.closeRead==null&&(this.log.trace("send close read to remote"),await this.sendCloseRead(e)),t==="ready"&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(e={}){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),this.writeStatus==="ready"&&(this.log.trace("sink was never sunk, sink an empty array"),await _e(this.sink([]),e.signal)),this.writeStatus==="writing"&&(this.sendingData!=null&&await _e(this.sendingData.promise,e.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await _e(this.sinkEnd.promise,e.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(e){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;this.log("abort with error",e),this.log("try to send reset to remote");const t=this.sendReset();$o(t)&&t.catch(n=>{this.log.error("error sending reset message",n)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(e),this.onAbort?.(e)}reset(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;const e=new rm("stream reset");this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(e),this.onReset?.()}_closeSinkAndSource(e){this._closeSink(e),this._closeSource(e)}_closeSink(e){this.writeStatus==="writing"&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(e)}_closeSource(e){this.readStatus!=="closing"&&this.readStatus!=="closed"&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(e))}remoteCloseWrite(){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("received remote close write but local source is already closed");return}this.log.trace("remote close write"),this._closeSource()}remoteCloseRead(){if(this.writeStatus==="closing"||this.writeStatus==="closed"){this.log("received remote close read but local sink is already closed");return}this.log.trace("remote close read"),this._closeSink()}destroy(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset"){this.log("received destroy but we are already closed");return}this.log.trace("stream destroyed"),this._closeSinkAndSource()}sourcePush(e){this.streamSource.push(e)}sourceReadableLength(){return this.streamSource.readableLength}}function Cf(r){const[e,t]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>e.next(),push:s=>{n.push(s)},next:()=>n.length>0?{done:!1,value:n.shift()}:e.next(),[t](){return this}}}function bv(r){return r[Symbol.asyncIterator]!=null}function gu(r){return r?.then!=null}function If(r,e){let t=0;if(bv(r))return async function*(){for await(const c of r){const l=e(c,t++);gu(l)&&await l,yield c}}();const n=Cf(r),{value:s,done:i}=n.next();if(i===!0)return function*(){}();if(typeof e(s,t++)?.then=="function")return async function*(){yield s;for await(const c of n){const l=e(c,t++);gu(l)&&await l,yield c}}();const a=e;return function*(){yield s;for(const c of n)a(c,t++),yield c}()}var at;(function(r){r[r.Init=0]="Init",r[r.SYNSent=1]="SYNSent",r[r.SYNReceived=2]="SYNReceived",r[r.Established=3]="Established",r[r.Finished=4]="Finished"})(at||(at={}));class vv extends Bc{name;state;config;_id;sendWindowCapacity;sendWindowCapacityUpdate;recvWindow;recvWindowCapacity;epochStart;getRTT;sendFrame;constructor(e){super({...e,onEnd:t=>{this.state=at.Finished,e.onEnd?.(t)}}),this.config=e.config,this._id=parseInt(e.id,10),this.name=e.name,this.state=e.state,this.sendWindowCapacity=Nc,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=e.getRTT,this.sendFrame=e.sendFrame,this.source=If(this.source,()=>{this.sendWindowUpdate()})}async sendNewStream(){}async sendData(e,t={}){for(e=e.sublist();e.byteLength!==0;){if(this.sendWindowCapacity===0&&(this.log?.trace("wait for send window capacity, status %s",this.status),await this.waitForSendWindowCapacity(t),this.status==="closed"||this.status==="aborted"||this.status==="reset")){this.log?.trace("%s while waiting for send window capacity",this.status);return}const n=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-$n,e.length),s=this.getSendFlags();this.sendFrame({type:ve.Data,flag:s,streamID:this._id,length:n},e.sublist(0,n)),this.sendWindowCapacity-=n,e.consume(n)}}async sendReset(){this.sendFrame({type:ve.WindowUpdate,flag:ge.RST,streamID:this._id,length:0})}async sendCloseWrite(){const e=this.getSendFlags()|ge.FIN;this.sendFrame({type:ve.WindowUpdate,flag:e,streamID:this._id,length:0})}async sendCloseRead(){}async waitForSendWindowCapacity(e={}){if(this.sendWindowCapacity>0)return;let t,n;const s=()=>{this.status==="open"||this.status==="closing"?n(new Er("Stream aborted")):t()};e.signal?.addEventListener("abort",s);try{await new Promise((i,o)=>{this.sendWindowCapacityUpdate=()=>{i()},n=o,t=i})}finally{e.signal?.removeEventListener("abort",s)}}handleWindowUpdate(e){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(e.flag);const t=this.sendWindowCapacity;this.sendWindowCapacity+=e.length,t===0&&e.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(e,t){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(e.flag),this.recvWindowCapacity<e.length)throw new Af("Receive window exceeded");const n=await t();this.recvWindowCapacity-=e.length,this.sourcePush(n)}processFlags(e){(e&ge.ACK)===ge.ACK&&this.state===at.SYNSent&&(this.state=at.Established),(e&ge.FIN)===ge.FIN&&this.remoteCloseWrite(),(e&ge.RST)===ge.RST&&this.reset()}getSendFlags(){switch(this.state){case at.Init:return this.state=at.SYNSent,ge.SYN;case at.SYNReceived:return this.state=at.Established,ge.ACK;default:return 0}}sendWindowUpdate(){const e=this.getSendFlags(),t=Date.now(),n=this.getRTT();if(e===0&&n>-1&&t-this.epochStart<n*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&e===0)return;const s=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=t,this.sendFrame({type:ve.WindowUpdate,flag:e,streamID:this._id,length:s})}}const Tf="/yamux/1.0.0",Sv=500;class Ev{protocol=Tf;_components;_init;constructor(e,t={}){this._components=e,this._init=t}[Symbol.toStringTag]="@chainsafe/libp2p-yamux";[rt]=["@libp2p/stream-multiplexing"];createStreamMuxer(e){return new _v(this._components,{...this._init,...e})}}class _v{protocol=Tf;source;sink;config;log;logger;closeController;nextStreamID;_streams;nextPingID;activePing;rtt;client;localGoAway;remoteGoAway;numInboundStreams;numOutboundStreams;onIncomingStream;onStreamEnd;constructor(e,t){this.client=t.direction==="outbound",this.config={...uv,...t},this.logger=e.logger,this.log=this.logger.forComponent("libp2p:yamux"),dv(this.config),this.closeController=new AbortController,this.closeController.signal,this.onIncomingStream=t.onIncomingStream,this.onStreamEnd=t.onStreamEnd,this._streams=new Map,this.source=gs({onEnd:()=>{this.log?.trace("muxer source ended"),this._streams.forEach(n=>{n.destroy()})}}),this.sink=async n=>{const s=()=>{const a=Ef(n);if(a.return!=null){const c=a.return();xv(c)&&c.catch(l=>{this.log?.("could not cause sink source to return",l)})}};let i,o;try{const a=new pv(n);try{this.closeController.signal.addEventListener("abort",s);for await(const c of a.emitFrames())await this.handleFrame(c.header,c.readData)}finally{this.closeController.signal.removeEventListener("abort",s)}i=gt.NormalTermination}catch(a){cv.has(a.name)?(this.log?.error("protocol error in sink",a),i=gt.ProtocolError):(this.log?.error("internal error in sink",a),i=gt.InternalError),o=a}this.log?.trace("muxer sink ended"),o!=null?this.abort(o,i):await this.close({reason:i})},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(n=>this.log?.error("keepalive error: %s",n)),this.ping().catch(n=>this.log?.error("ping error: %s",n))}get streams(){return Array.from(this._streams.values())}newStream(e){if(this.remoteGoAway!==void 0)throw new xn("Muxer closed remotely");if(this.localGoAway!==void 0)throw new xn("Muxer closed locally");const t=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new ih("max outbound streams exceeded");this.log?.trace("new outgoing stream id=%s",t);const n=this._newStream(t,e,at.Init,"outbound");return this._streams.set(t,n),this.numOutboundStreams++,n.sendWindowUpdate(),n}async ping(){if(this.remoteGoAway!==void 0)throw new xn("Muxer closed remotely");if(this.localGoAway!==void 0)throw new xn("Muxer closed locally");if(this.activePing===void 0){let e=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((s,i)=>{const o=()=>{i(new xn("Muxer closed locally"))};this.closeController.signal.addEventListener("abort",o,{once:!0}),e=()=>{this.closeController.signal.removeEventListener("abort",o),s()}}),resolve:e};const t=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}const n=Date.now();this.rtt=n-t}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}async close(e={}){if(this.closeController.signal.aborted)return;const t=e?.reason??gt.NormalTermination;if(this.log?.trace("muxer close reason=%s",t),e.signal==null){const n=AbortSignal.timeout(Sv);e={...e,signal:n}}try{await Promise.all([...this._streams.values()].map(async n=>n.close(e))),this.sendGoAway(t),this._closeMuxer()}catch(n){this.abort(n)}}abort(e,t){if(!this.closeController.signal.aborted){t=t??gt.InternalError,this.log?.error("muxer abort reason=%s error=%s",t,e);for(const n of this._streams.values())n.abort(e);this.sendGoAway(t),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(e,t,n,s){if(this._streams.get(e)!=null)throw new K("Stream already exists with that id");const i=new vv({id:e.toString(),name:t,state:n,direction:s,sendFrame:this.sendFrame.bind(this),onEnd:()=>{this.closeStream(e),this.onStreamEnd?.(i)},log:this.logger.forComponent(`libp2p:yamux:${s}:${e}`),config:this.config,getRTT:this.getRTT.bind(this)});return i}closeStream(e){this.client===(e%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(e)}async keepAliveLoop(){const e=new Promise((t,n)=>{this.closeController.signal.addEventListener("abort",n,{once:!0})});for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let t;try{await Promise.race([e,new Promise(n=>{t=setTimeout(n,this.config.keepAliveInterval)})]),this.ping().catch(n=>this.log?.error("ping error: %s",n))}catch{clearInterval(t);return}}}async handleFrame(e,t){const{streamID:n,type:s,length:i}=e;if(this.log?.trace("received frame %o",e),n===0)switch(s){case ve.Ping:{this.handlePing(e);return}case ve.GoAway:{this.handleGoAway(i);return}default:throw new $r("Invalid frame type")}else switch(e.type){case ve.Data:case ve.WindowUpdate:{await this.handleStreamMessage(e,t);return}default:throw new $r("Invalid frame type")}}handlePing(e){if(e.flag===ge.SYN)this.log?.trace("received ping request pingId=%s",e.length),this.sendPing(e.length,ge.ACK);else if(e.flag===ge.ACK)this.log?.trace("received ping response pingId=%s",e.length),this.handlePingResponse(e.length);else throw new $r("Invalid frame flag")}handlePingResponse(e){if(this.activePing===void 0)throw new _f("ping not requested");if(this.activePing.id!==e)throw new xf("ping doesn't match our id");this.activePing.resolve()}handleGoAway(e){this.log?.trace("received GoAway reason=%s",gt[e]??"unknown"),this.remoteGoAway=e;for(const t of this._streams.values())t.reset();this._closeMuxer()}async handleStreamMessage(e,t){const{streamID:n,flag:s,type:i}=e;(s&ge.SYN)===ge.SYN&&this.incomingStream(n);const o=this._streams.get(n);if(o===void 0){if(i===ve.Data){if(this.log?.("discarding data for stream id=%s",n),t===void 0)throw new Error("unreachable");await t()}else this.log?.trace("frame for missing stream id=%s",n);return}switch(i){case ve.WindowUpdate:{o.handleWindowUpdate(e);return}case ve.Data:{if(t===void 0)throw new Error("unreachable");await o.handleData(e,t);return}default:throw new Error("unreachable")}}incomingStream(e){if(this.client!==(e%2===0))throw new K("Both endpoints are clients");if(this._streams.has(e))return;if(this.log?.trace("new incoming stream id=%s",e),this.localGoAway!==void 0){this.sendFrame({type:ve.WindowUpdate,flag:ge.RST,streamID:e,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){this.log?.("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:ve.WindowUpdate,flag:ge.RST,streamID:e,length:0});return}const t=this._newStream(e,void 0,at.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(e,t),this.onIncomingStream?.(t)}sendFrame(e,t){if(this.log?.trace("sending frame %o",e),e.type===ve.Data){if(t===void 0)throw new $r("Invalid frame");this.source.push(new J(pu(e),t))}else this.source.push(pu(e))}sendPing(e,t=ge.SYN){t===ge.SYN?this.log?.trace("sending ping request pingId=%s",e):this.log?.trace("sending ping response pingId=%s",e),this.sendFrame({type:ve.Ping,flag:t,streamID:0,length:e})}sendGoAway(e=gt.NormalTermination){this.log?.("sending GoAway reason=%s",gt[e]),this.localGoAway=e,this.sendFrame({type:ve.GoAway,flag:0,streamID:0,length:e})}}function xv(r){return r!=null&&typeof r.then=="function"}function Av(r={}){return e=>new Ev(e,r)}var Ti;(function(r){let e;r.codec=()=>(e==null&&(e=we((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&t.payload.byteLength>0&&(n.uint32(26),n.bytes(t.payload)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={publicKey:ae(0),payloadType:ae(0),payload:ae(0),signature:ae(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=t.bytes();break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ye(t,r.codec()),r.decode=(t,n)=>me(t,r.codec(),n)})(Ti||(Ti={}));class Cv extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}}class vt{static createFromProtobuf=async e=>{const t=Ti.decode(e),n=Zt(t.publicKey);return new vt({publicKey:n,payloadType:t.payloadType,payload:t.payload,signature:t.signature})};static seal=async(e,t)=>{if(t==null)throw new Error("Missing private key");const n=e.domain,s=e.codec,i=e.marshal(),o=mu(n,s,i),a=await t.sign(o.subarray());return new vt({publicKey:t.publicKey,payloadType:s,payload:i,signature:a})};static openAndCertify=async(e,t)=>{const n=await vt.createFromProtobuf(e);if(!await n.validate(t))throw new Cv("Envelope signature is not valid for the given domain");return n};publicKey;payloadType;payload;signature;marshaled;constructor(e){const{publicKey:t,payloadType:n,payload:s,signature:i}=e;this.publicKey=t,this.payloadType=n,this.payload=s,this.signature=i}marshal(){return this.marshaled==null&&(this.marshaled=Ti.encode({publicKey:kt(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return e==null?!1:ke(this.marshal(),e.marshal())}async validate(e){const t=mu(e,this.payloadType,this.payload);return this.publicKey.verify(t.subarray(),this.signature)}}const mu=(r,e,t)=>{const n=z(r),s=bt(n.byteLength),i=bt(e.length),o=bt(t.length);return new J(s,n,i,e,o,t)};function Iv(r,e){const t=(n,s)=>n.toString().localeCompare(s.toString());return r.length!==e.length?!1:(e.sort(t),r.sort(t).every((n,s)=>e[s].equals(n)))}class Tv{index=0;input="";new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,n=e();return n===void 0&&(this.index=t),n}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{const t=this.readChar();if(t===e)return t})}readSeparator(e,t,n){return this.readAtomically(()=>{if(!(t>0&&this.readGivenChar(e)===void 0))return n()})}readNumber(e,t,n,s){return this.readAtomically(()=>{let i=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",l=2**(8*s)-1;for(;;){const u=this.readAtomically(()=>{const d=this.readChar();if(d===void 0)return;const h=Number.parseInt(d,e);if(!Number.isNaN(h))return h});if(u===void 0)break;if(i*=e,i+=u,i>l||(o+=1,t!==void 0&&o>t))return}if(o!==0)return!n&&c&&o>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const n=this.readSeparator(".",t,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;e[t]=n}return e})}readIPv6Addr(){const e=t=>{for(let n=0;n<t.length/2;n++){const s=n*2;if(n<t.length-3){const o=this.readSeparator(":",n,()=>this.readIPv4Addr());if(o!==void 0)return t[s]=o[0],t[s+1]=o[1],t[s+2]=o[2],t[s+3]=o[3],[s+4,!0]}const i=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(i===void 0)return[s,!1];t[s]=i>>8,t[s+1]=i&255}return[t.length,!1]};return this.readAtomically(()=>{const t=new Uint8Array(16),[n,s]=e(t);if(n===16)return t;if(s||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const i=new Uint8Array(14),o=16-(n+2),[a]=e(i.subarray(0,o));return t.set(i.subarray(0,a),16-a),t})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const Pf=45,Pv=15,nn=new Tv;function kf(r){if(!(r.length>Pv))return nn.new(r).parseWith(()=>nn.readIPv4Addr())}function Rf(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>Pf))return nn.new(r).parseWith(()=>nn.readIPv6Addr())}function Pi(r,e=!1){if(r.includes("%")&&(r=r.split("%")[0]),r.length>Pf)return;const t=nn.new(r).parseWith(()=>nn.readIPAddr());if(t)return e&&t.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,t[0],t[1],t[2],t[3]]):t}function kv(r,e,t){let n=0;for(const s of r)if(!(n<e)){if(n>t)break;if(s!==255)return!1;n++}return!0}function Rv(r,e,t,n){let s=0;for(const i of r)if(!(s<t)){if(s>n)break;if(i!==e[s])return!1;s++}return!0}function Lv(r){switch(r.length){case Yn:return r.join(".");case Xn:{const e=[];for(let t=0;t<r.length;t++)t%2===0&&e.push(r[t].toString(16).padStart(2,"0")+r[t+1].toString(16).padStart(2,"0"));return e.join(":")}default:throw new Error("Invalid ip length")}}function Dv(r){let e=0;for(let[t,n]of r.entries()){if(n===255){e+=8;continue}for(;(n&128)!=0;)e++,n=n<<1;if((n&128)!=0)return-1;for(let s=t+1;s<r.length;s++)if(r[s]!=0)return-1;break}return e}function Mv(r){let e="0x";for(const t of r)e+=(t>>4).toString(16)+(t&15).toString(16);return e}const Yn=4,Xn=16,Ov=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function Lf(r,e){e.length===Xn&&r.length===Yn&&kv(e,0,11)&&(e=e.slice(12)),e.length===Yn&&r.length===Xn&&Rv(r,Ov,0,11)&&(r=r.slice(12));const t=r.length;if(t!=e.length)throw new Error("Failed to mask ip");const n=new Uint8Array(t);for(let s=0;s<t;s++)n[s]=r[s]&e[s];return n}function Fv(r,e){if(typeof e=="string"&&(e=Pi(e)),e==null)throw new Error("Invalid ip");if(e.length!==r.network.length)return!1;for(let t=0;t<e.length;t++)if((r.network[t]&r.mask[t])!==(e[t]&r.mask[t]))return!1;return!0}function Nv(r){const[e,t]=r.split("/");if(!e||!t)throw new Error("Failed to parse given CIDR: "+r);let n=Yn,s=kf(e);if(s==null&&(n=Xn,s=Rf(e),s==null))throw new Error("Failed to parse given CIDR: "+r);const i=parseInt(t,10);if(Number.isNaN(i)||String(i).length!==t.length||i<0||i>n*8)throw new Error("Failed to parse given CIDR: "+r);const o=Df(i,8*n);return{network:Lf(s,o),mask:o}}function Df(r,e){if(e!==8*Yn&&e!==8*Xn)throw new Error("Invalid CIDR mask");if(r<0||r>e)throw new Error("Invalid CIDR mask");const t=e/8,n=new Uint8Array(t);for(let s=0;s<t;s++){if(r>=8){n[s]=255,r-=8;continue}n[s]=255-(255>>r),r=0}return n}class Mf{constructor(e,t){if(t==null)({network:this.network,mask:this.mask}=Nv(e));else{const n=Pi(e);if(n==null)throw new Error("Failed to parse network");t=String(t);const s=parseInt(t,10);if(Number.isNaN(s)||String(s).length!==t.length||s<0||s>n.length*8){const i=Pi(t);if(i==null)throw new Error("Failed to parse mask");this.mask=i}else this.mask=Df(s,8*n.length);this.network=Lf(n,this.mask)}}contains(e){return Fv({network:this.network,mask:this.mask},e)}toString(){const e=Dv(this.mask),t=e!==-1?String(e):Mv(this.mask);return Lv(this.network)+"/"+t}}function Bv(r,e){return new Mf(r).contains(e)}function sn(r){return!!kf(r)}function Uc(r){return!!Rf(r)}function Of(r){return!!Pi(r)}const yu=sn,Uv=Uc,Ff=function(r){let e=0;if(r=r.toString().trim(),yu(r)){const t=new Uint8Array(e+4);return r.split(/\./g).forEach(n=>{t[e++]=parseInt(n,10)&255}),t}if(Uv(r)){const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const i=yu(t[n]);let o;i&&(o=Ff(t[n]),t[n]=G(o.slice(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,G(o.slice(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const i=[n,1];for(n=9-t.length;n>0;n--)i.push("0");t.splice.apply(t,i)}const s=new Uint8Array(e+16);for(n=0;n<t.length;n++){const i=parseInt(t[n],16);s[e++]=i>>8&255,s[e++]=i&255}return s}throw new Error("invalid ip address")},$v=function(r,e=0,t){e=~~e,t=t??r.length-e;const n=new DataView(r.buffer);if(t===4){const s=[];for(let i=0;i<t;i++)s.push(r[e+i]);return s.join(".")}if(t===16){const s=[];for(let i=0;i<t;i+=2)s.push(n.getUint16(e+i).toString(16));return s.join(":").replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}return""},Ye=-1,Qn={},Ua={},qv=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,Ye,"ip6zone"],[43,8,"ipcidr"],[53,Ye,"dns",!0],[54,Ye,"dns4",!0],[55,Ye,"dns6",!0],[56,Ye,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,Ye,"unix",!1,!0],[421,Ye,"ipfs"],[421,Ye,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,Ye,"garlic64"],[448,0,"tls"],[449,Ye,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,Ye,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[481,Ye,"http-path"],[777,Ye,"memory"]];qv.forEach(r=>{const e=Wv(...r);Ua[e.code]=e,Qn[e.name]=e});function Wv(r,e,t,n,s){return{code:r,size:e,name:t,resolvable:!!n,path:!!s}}function V(r){if(typeof r=="number"){if(Ua[r]!=null)return Ua[r];throw new Error(`no protocol with code: ${r}`)}else if(typeof r=="string"){if(Qn[r]!=null)return Qn[r];throw new Error(`no protocol with name: ${r}`)}throw new Error(`invalid protocol id type: ${typeof r}`)}const zv=V("ip4"),Kv=V("ip6"),Hv=V("ipcidr");function Nf(r,e){switch(V(r).code){case 4:case 41:return jv(e);case 42:return zo(e);case 43:return G(e,"base10");case 6:case 273:case 33:case 132:return Bf(e).toString();case 53:case 54:case 55:case 56:case 400:case 449:case 777:return zo(e);case 421:return Zv(e);case 444:return vu(e);case 445:return vu(e);case 466:return Qv(e);case 481:return globalThis.encodeURIComponent(zo(e));default:return G(e,"base16")}}function wu(r,e){switch(V(r).code){case 4:return bu(e);case 41:return bu(e);case 42:return Wo(e);case 43:return z(e,"base10");case 6:case 273:case 33:case 132:return $c(parseInt(e,10));case 53:case 54:case 55:case 56:case 400:case 449:case 777:return Wo(e);case 421:return Yv(e);case 444:return Jv(e);case 445:return eS(e);case 466:return Xv(e);case 481:return Wo(globalThis.decodeURIComponent(e));default:return z(e,"base16")}}function Vv(r){let e,t;if(r.stringTuples().forEach(([n,s])=>{(n===zv.code||n===Kv.code)&&(t=s),n===Hv.code&&(e=s)}),e==null||t==null)throw new Error("Invalid multiaddr");return new Mf(t,e)}const qo=Object.values(fi).map(r=>r.decoder),Gv=function(){let r=qo[0].or(qo[1]);return qo.slice(2).forEach(e=>r=r.or(e)),r}();function bu(r){if(!Of(r))throw new Error("invalid ip address");return Ff(r)}function jv(r){const e=$v(r,0,r.length);if(e==null)throw new Error("ipBuff is required");if(!Of(e))throw new Error("invalid ip address");return e}function $c(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,r),new Uint8Array(e)}function Bf(r){return new DataView(r.buffer).getUint16(r.byteOffset)}function Wo(r){const e=z(r),t=Uint8Array.from(bt(e.length));return ut([t,e],t.length+e.length)}function zo(r){const e=kr(r);if(r=r.slice(Ie(e)),r.length!==e)throw new Error("inconsistent lengths");return G(r)}function Yv(r){let e;r[0]==="Q"||r[0]==="1"?e=rr(be.decode(`z${r}`)).bytes:e=le.parse(r).multihash.bytes;const t=Uint8Array.from(bt(e.length));return ut([t,e],t.length+e.length)}function Xv(r){const e=Gv.decode(r),t=Uint8Array.from(bt(e.length));return ut([t,e],t.length+e.length)}function Qv(r){const e=kr(r),t=r.slice(Ie(e));if(t.length!==e)throw new Error("inconsistent lengths");return"u"+G(t,"base64url")}function Zv(r){const e=kr(r),t=r.slice(Ie(e));if(t.length!==e)throw new Error("inconsistent lengths");return G(t,"base58btc")}function Jv(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=Pt.decode("b"+e[0]),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=$c(n);return ut([t,s],t.length+s.length)}function eS(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=Pt.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=$c(n);return ut([t,s],t.length+s.length)}function vu(r){const e=r.slice(0,r.length-2),t=r.slice(r.length-2),n=G(e,"base32"),s=Bf(t);return`${n}:${s}`}function tS(r){r=$a(r);const e=[],t=[];let n=null;const s=r.split("/").slice(1);if(s.length===1&&s[0]==="")return{bytes:new Uint8Array,string:"/",tuples:[],stringTuples:[],path:null};for(let i=0;i<s.length;i++){const o=s[i],a=V(o);if(a.size===0){e.push([a.code]),t.push([a.code]);continue}if(i++,i>=s.length)throw new qf("invalid address: "+r);if(a.path===!0){n=$a(s.slice(i).join("/")),e.push([a.code,wu(a.code,n)]),t.push([a.code,n]);break}const c=wu(a.code,s[i]);e.push([a.code,c]),t.push([a.code,Nf(a.code,c)])}return{string:Uf(t),bytes:$f(e),tuples:e,stringTuples:t,path:n}}function Su(r){const e=[],t=[];let n=null,s=0;for(;s<r.length;){const i=kr(r,s),o=Ie(i),a=V(i),c=rS(a,r.slice(s+o));if(c===0){e.push([i]),t.push([i]),s+=o;continue}const l=r.slice(s+o,s+o+c);if(s+=c+o,s>r.length)throw new qf("Invalid address Uint8Array: "+G(r,"base16"));e.push([i,l]);const u=Nf(i,l);if(t.push([i,u]),a.path===!0){n=u;break}}return{bytes:Uint8Array.from(r),string:Uf(t),tuples:e,stringTuples:t,path:n}}function Uf(r){const e=[];return r.map(t=>{const n=V(t[0]);return e.push(n.name),t.length>1&&t[1]!=null&&e.push(t[1]),null}),$a(e.join("/"))}function $f(r){return ut(r.map(e=>{const t=V(e[0]);let n=Uint8Array.from(bt(t.code));return e.length>1&&e[1]!=null&&(n=ut([n,e[1]])),n}))}function rS(r,e){if(r.size>0)return r.size/8;if(r.size===0)return 0;{const t=kr(e instanceof Uint8Array?e:Uint8Array.from(e));return t+Ie(t)}}function $a(r){return"/"+r.trim().split("/").filter(e=>e).join("/")}class qf extends Error{static name="ParseError";name="ParseError";constructor(e){super(`Error parsing address: ${e}`)}}const nS=Symbol.for("nodejs.util.inspect.custom"),Wf=Symbol.for("@multiformats/js-multiaddr/multiaddr"),sS=[V("dns").code,V("dns4").code,V("dns6").code,V("dnsaddr").code];class iS extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}}class qr{bytes;#e;#t;#r;#a;[Wf]=!0;constructor(e){e==null&&(e="");let t;if(e instanceof Uint8Array)t=Su(e);else if(typeof e=="string"){if(e.length>0&&e.charAt(0)!=="/")throw new Error(`multiaddr "${e}" must start with a "/"`);t=tS(e)}else if(ao(e))t=Su(e.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr");this.bytes=t.bytes,this.#e=t.string,this.#t=t.tuples,this.#r=t.stringTuples,this.#a=t.path}toString(){return this.#e}toJSON(){return this.toString()}toOptions(){let e,t,n,s,i="";const o=V("tcp"),a=V("udp"),c=V("ip4"),l=V("ip6"),u=V("dns6"),d=V("ip6zone");for(const[p,f]of this.stringTuples())p===d.code&&(i=`%${f??""}`),sS.includes(p)&&(t=o.name==="tcp"?"tcp":"udp",s=443,n=`${f??""}${i}`,e=p===u.code?6:4),(p===o.code||p===a.code)&&(t=V(p).name==="tcp"?"tcp":"udp",s=parseInt(f??"")),(p===c.code||p===l.code)&&(t=V(p).name==="tcp"?"tcp":"udp",n=`${f??""}${i}`,e=p===l.code?6:4);if(e==null||t==null||n==null||s==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:n,transport:t,port:s}}protos(){return this.#t.map(([e])=>Object.assign({},V(e)))}protoCodes(){return this.#t.map(([e])=>e)}protoNames(){return this.#t.map(([e])=>V(e).name)}tuples(){return this.#t.map(([e,t])=>t==null?[e]:[e,t])}stringTuples(){return this.#r.map(([e,t])=>t==null?[e]:[e,t])}encapsulate(e){return e=new qr(e),new qr(this.toString()+e.toString())}decapsulate(e){const t=e.toString(),n=this.toString(),s=n.lastIndexOf(t);if(s<0)throw new Error(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new qr(n.slice(0,s))}decapsulateCode(e){const t=this.tuples();for(let n=t.length-1;n>=0;n--)if(t[n][0]===e)return new qr($f(t.slice(0,n)));return this}getPeerId(){try{let e=[];this.stringTuples().forEach(([n,s])=>{n===Qn.p2p.code&&e.push([n,s]),n===Qn["p2p-circuit"].code&&(e=[])});const t=e.pop();if(t?.[1]!=null){const n=t[1];return n[0]==="Q"||n[0]==="1"?G(be.decode(`z${n}`),"base58btc"):G(le.parse(n).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){return this.#a}equals(e){return ke(this.bytes,e.bytes)}async resolve(e){const t=this.protos().find(i=>i.resolvable);if(t==null)return[this];const n=qc.get(t.name);if(n==null)throw new iS(`no available resolver for ${t.name}`);return(await n(this,e)).map(i=>Y(i))}nodeAddress(){const e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(e){const t=(e??this).protos();return!(t.length!==2||t[0].code!==4&&t[0].code!==41||t[1].code!==6&&t[1].code!==273)}[nS](){return`Multiaddr(${this.#e})`}}const qc=new Map;function ao(r){return!!r?.[Wf]}function Y(r){return new qr(r)}const oS="libp2p-peer-record",aS=Uint8Array.from([3,1]);var ki;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=we((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.multiaddr!=null&&s.multiaddr.byteLength>0&&(i.uint32(10),i.bytes(s.multiaddr)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={multiaddr:ae(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.multiaddr=s.bytes();break}default:{s.skipType(l&7);break}}}return a})),n),t.encode=s=>ye(s,t.codec()),t.decode=(s,i)=>me(s,t.codec(),i)})(r.AddressInfo||(r.AddressInfo={}));let e;r.codec=()=>(e==null&&(e=we((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.peerId!=null&&t.peerId.byteLength>0&&(n.uint32(10),n.bytes(t.peerId)),t.seq!=null&&t.seq!==0n&&(n.uint32(16),n.uint64(t.seq)),t.addresses!=null)for(const i of t.addresses)n.uint32(26),r.AddressInfo.codec().encode(i,n);s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={peerId:ae(0),seq:0n,addresses:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.peerId=t.bytes();break}case 2:{i.seq=t.uint64();break}case 3:{if(s.limits?.addresses!=null&&i.addresses.length===s.limits.addresses)throw new Lt('Decode error - map field "addresses" had too many elements');i.addresses.push(r.AddressInfo.codec().decode(t,t.uint32(),{limits:s.limits?.addresses$}));break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ye(t,r.codec()),r.decode=(t,n)=>me(t,r.codec(),n)})(ki||(ki={}));class Ze{static createFromProtobuf=e=>{const t=ki.decode(e),n=fs(rr(t.peerId)),s=(t.addresses??[]).map(o=>Y(o.multiaddr)),i=t.seq;return new Ze({peerId:n,multiaddrs:s,seqNumber:i})};static DOMAIN=oS;static CODEC=aS;peerId;multiaddrs;seqNumber;domain=Ze.DOMAIN;codec=Ze.CODEC;marshaled;constructor(e){const{peerId:t,multiaddrs:n,seqNumber:s}=e;this.peerId=t,this.multiaddrs=n??[],this.seqNumber=s??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=ki.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(e=>({multiaddr:e.bytes}))})),this.marshaled}equals(e){return!(!(e instanceof Ze)||!this.peerId.equals(e.peerId)||this.seqNumber!==e.seqNumber||!Iv(this.multiaddrs,e.multiaddrs))}}function Dt(r,e){const t=tn(r,e),n={read:async(s,i)=>{const o=await t.read(i);return s.decode(o)},write:async(s,i,o)=>{await t.write(i.encode(s),o)},writeV:async(s,i,o)=>{await t.writeV(s.map(a=>i.encode(a)),o)},pb:s=>({read:async i=>n.read(s,i),write:async(i,o)=>n.write(i,s,o),writeV:async(i,o)=>n.writeV(i,s,o),unwrap:()=>n}),unwrap:()=>t.unwrap()};return n}const cS=290,lS=1,zf=2e3,uS=100,Ms=`${uc}-circuit-relay`;BigInt(1<<17);const Ri="/libp2p/circuit/relay/0.2.0/hop",Eu="/libp2p/circuit/relay/0.2.0/stop",_u=300,dS=4096,hS=.001;var on;(function(r){(function(n){n.RESERVE="RESERVE",n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let e;(function(n){n[n.RESERVE=0]="RESERVE",n[n.CONNECT=1]="CONNECT",n[n.STATUS=2]="STATUS"})(e||(e={})),function(n){n.codec=()=>bn(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=we((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.peer!=null&&(s.uint32(18),an.codec().encode(n.peer,s)),n.reservation!=null&&(s.uint32(26),Li.codec().encode(n.reservation,s)),n.limit!=null&&(s.uint32(34),cn.codec().encode(n.limit,s)),n.status!=null&&(s.uint32(40),qe.codec().encode(n.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=an.codec().decode(n,n.uint32(),{limits:i.limits?.peer});break}case 3:{o.reservation=Li.codec().decode(n,n.uint32(),{limits:i.limits?.reservation});break}case 4:{o.limit=cn.codec().decode(n,n.uint32(),{limits:i.limits?.limit});break}case 5:{o.status=qe.codec().decode(n);break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>ye(n,r.codec()),r.decode=(n,s)=>me(n,r.codec(),s)})(on||(on={}));var At;(function(r){(function(n){n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let e;(function(n){n[n.CONNECT=0]="CONNECT",n[n.STATUS=1]="STATUS"})(e||(e={})),function(n){n.codec=()=>bn(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=we((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.peer!=null&&(s.uint32(18),an.codec().encode(n.peer,s)),n.limit!=null&&(s.uint32(26),cn.codec().encode(n.limit,s)),n.status!=null&&(s.uint32(32),qe.codec().encode(n.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=an.codec().decode(n,n.uint32(),{limits:i.limits?.peer});break}case 3:{o.limit=cn.codec().decode(n,n.uint32(),{limits:i.limits?.limit});break}case 4:{o.status=qe.codec().decode(n);break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>ye(n,r.codec()),r.decode=(n,s)=>me(n,r.codec(),s)})(At||(At={}));var an;(function(r){let e;r.codec=()=>(e==null&&(e=we((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.id!=null&&t.id.byteLength>0&&(n.uint32(10),n.bytes(t.id)),t.addrs!=null)for(const i of t.addrs)n.uint32(18),n.bytes(i);s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={id:ae(0),addrs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.id=t.bytes();break}case 2:{if(s.limits?.addrs!=null&&i.addrs.length===s.limits.addrs)throw new Lt('Decode error - map field "addrs" had too many elements');i.addrs.push(t.bytes());break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ye(t,r.codec()),r.decode=(t,n)=>me(t,r.codec(),n)})(an||(an={}));var Li;(function(r){let e;r.codec=()=>(e==null&&(e=we((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.expire!=null&&t.expire!==0n&&(n.uint32(8),n.uint64(t.expire)),t.addrs!=null)for(const i of t.addrs)n.uint32(18),n.bytes(i);t.voucher!=null&&(n.uint32(26),Mi.codec().encode(t.voucher,n)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={expire:0n,addrs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.expire=t.uint64();break}case 2:{if(s.limits?.addrs!=null&&i.addrs.length===s.limits.addrs)throw new Lt('Decode error - map field "addrs" had too many elements');i.addrs.push(t.bytes());break}case 3:{i.voucher=Mi.codec().decode(t,t.uint32(),{limits:s.limits?.voucher});break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ye(t,r.codec()),r.decode=(t,n)=>me(t,r.codec(),n)})(Li||(Li={}));var cn;(function(r){let e;r.codec=()=>(e==null&&(e=we((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.duration!=null&&(n.uint32(8),n.uint32(t.duration)),t.data!=null&&(n.uint32(16),n.uint64(t.data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.duration=t.uint32();break}case 2:{i.data=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ye(t,r.codec()),r.decode=(t,n)=>me(t,r.codec(),n)})(cn||(cn={}));var qe;(function(r){r.UNUSED="UNUSED",r.OK="OK",r.RESERVATION_REFUSED="RESERVATION_REFUSED",r.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",r.PERMISSION_DENIED="PERMISSION_DENIED",r.CONNECTION_FAILED="CONNECTION_FAILED",r.NO_RESERVATION="NO_RESERVATION",r.MALFORMED_MESSAGE="MALFORMED_MESSAGE",r.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(qe||(qe={}));var qa;(function(r){r[r.UNUSED=0]="UNUSED",r[r.OK=100]="OK",r[r.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",r[r.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",r[r.PERMISSION_DENIED=202]="PERMISSION_DENIED",r[r.CONNECTION_FAILED=203]="CONNECTION_FAILED",r[r.NO_RESERVATION=204]="NO_RESERVATION",r[r.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",r[r.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(qa||(qa={}));(function(r){r.codec=()=>bn(qa)})(qe||(qe={}));var Di;(function(r){let e;r.codec=()=>(e==null&&(e=we((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.relay!=null&&t.relay.byteLength>0&&(n.uint32(10),n.bytes(t.relay)),t.peer!=null&&t.peer.byteLength>0&&(n.uint32(18),n.bytes(t.peer)),t.expiration!=null&&t.expiration!==0n&&(n.uint32(24),n.uint64(t.expiration)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={relay:ae(0),peer:ae(0),expiration:0n},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.relay=t.bytes();break}case 2:{i.peer=t.bytes();break}case 3:{i.expiration=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ye(t,r.codec()),r.decode=(t,n)=>me(t,r.codec(),n)})(Di||(Di={}));var Mi;(function(r){let e;r.codec=()=>(e==null&&(e=we((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&(n.uint32(26),Di.codec().encode(t.payload,n)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={publicKey:ae(0),payloadType:ae(0),signature:ae(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=Di.codec().decode(t,t.uint32(),{limits:s.limits?.payload});break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ye(t,r.codec()),r.decode=(t,n)=>me(t,r.codec(),n)})(Mi||(Mi={}));const fS=r=>r.toString().split("/").slice(1),ys=r=>({match:e=>e.length<1?!1:r(e[0])?e.slice(1):!1,pattern:"fn"}),X=r=>({match:e=>ys(t=>t===r).match(e),pattern:r}),vn=()=>({match:r=>ys(e=>typeof e=="string").match(r),pattern:"{string}"}),Zn=()=>({match:r=>ys(e=>!isNaN(parseInt(e))).match(r),pattern:"{number}"}),ce=()=>({match:r=>{if(r.length<2||r[0]!=="p2p"&&r[0]!=="ipfs")return!1;if(r[1].startsWith("Q")||r[1].startsWith("1"))try{be.decode(`z${r[1]}`)}catch{return!1}else return!1;return r.slice(2)},pattern:"/p2p/{peerid}"}),Oi=()=>({match:r=>{if(r.length<2||r[0]!=="certhash")return!1;try{gh.decode(r[1])}catch{return!1}return r.slice(2)},pattern:"/certhash/{certhash}"}),oe=r=>({match:e=>{const t=r.match(e);return t===!1?e:t},pattern:`optional(${r.pattern})`}),We=(...r)=>({match:e=>{let t;for(const n of r){const s=n.match(e);s!==!1&&(t==null||s.length<t.length)&&(t=s)}return t??!1},pattern:`or(${r.map(e=>e.pattern).join(", ")})`}),Q=(...r)=>({match:e=>{for(const t of r){const n=t.match(e);if(n===!1)return!1;e=n}return e},pattern:`and(${r.map(e=>e.pattern).join(", ")})`});function de(...r){function e(s){let i=fS(s);for(const o of r){const a=o.match(i);if(a===!1)return!1;i=a}return i}function t(s){return e(s)!==!1}function n(s){const i=e(s);return i===!1?!1:i.length===0}return{matchers:r,matches:t,exactMatch:n}}const pS=ce(),gS=de(pS),co=Q(X("dns4"),vn()),lo=Q(X("dns6"),vn()),uo=Q(X("dnsaddr"),vn()),Wc=Q(X("dns"),vn());de(co,oe(ce()));de(lo,oe(ce()));de(uo,oe(ce()));de(We(Wc,uo,co,lo),oe(ce()));const Kf=Q(X("ip4"),ys(sn)),Hf=Q(X("ip6"),ys(Uc)),zc=We(Kf,Hf),Rt=We(zc,Wc,co,lo,uo),mS=de(We(zc,Q(We(Wc,uo,co,lo),oe(ce())))),xu=de(Kf),Au=de(Hf);de(zc);const Kc=Q(Rt,X("tcp"),Zn()),ws=Q(Rt,X("udp"),Zn()),Fi=de(Q(Kc,oe(ce())));de(ws);const Hc=Q(ws,X("quic"),oe(ce())),ho=Q(ws,X("quic-v1"),oe(ce())),yS=We(Hc,ho);de(Hc);const wS=de(ho),Wa=We(Rt,Kc,ws,Hc,ho),Vf=We(Q(Wa,X("ws"),oe(ce()))),Jn=de(Vf),Gf=We(Q(Wa,X("wss"),oe(ce())),Q(Wa,X("tls"),oe(Q(X("sni"),vn())),X("ws"),oe(ce()))),Ni=de(Gf),jf=Q(ws,X("webrtc-direct"),oe(Oi()),oe(Oi()),oe(ce())),Cu=de(jf),Yf=Q(ho,X("webtransport"),oe(Oi()),oe(Oi()),oe(ce())),Bi=de(Yf),Ui=We(Vf,Gf,Q(Kc,oe(ce())),Q(yS,oe(ce())),Q(Rt,oe(ce())),jf,Yf,ce()),Xf=de(Ui),bS=Q(Ui,X("p2p-circuit"),ce()),es=de(bS),vS=We(Q(Ui,X("p2p-circuit"),X("webrtc"),oe(ce())),Q(Ui,X("webrtc"),oe(ce())),Q(X("webrtc"),oe(ce()))),za=de(vS),SS=We(Q(Rt,X("tcp"),Zn(),X("http"),oe(ce())),Q(Rt,X("http"),oe(ce())));de(SS);const ES=We(Q(Rt,X("tcp"),We(Q(X("443"),X("http")),Q(Zn(),X("https")),Q(Zn(),X("tls"),X("http"))),oe(ce())),Q(Rt,X("tls"),X("http"),oe(ce())),Q(Rt,X("https"),oe(ce())));de(ES);const _S=We(Q(X("memory"),vn(),oe(ce())));de(_S);function Jt(r){const e=new globalThis.AbortController;function t(){e.abort();for(const i of r)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}for(const i of r){if(i?.aborted===!0){t();break}i?.addEventListener!=null&&i.addEventListener("abort",t)}function n(){for(const i of r)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}const s=e.signal;return s.clear=n,s}class Iu extends Error{static name="HadEnoughRelaysError";name="HadEnoughRelaysError"}class xS extends Error{static name="DoubleRelayError";name="DoubleRelayError"}class AS extends Error{static name="RelayQueueFullError";name="RelayQueueFullError"}function Tu(r){const e=r*BigInt(1e3),t=new Date().getTime();return Number(e-BigInt(t))}class Pu{expires;bytes;constructor(e){e?.duration!=null&&e?.duration!==0&&(this.expires=Date.now()+e.duration*1e3),this.bytes=e?.data,this.bytes===0n&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(e){this.bytes!=null&&(this.bytes-=BigInt(e.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(this.expires==null&&this.bytes==null)return;const e={};if(this.bytes!=null){const t=this;Object.defineProperty(e,"bytes",{get(){return t.bytes}})}if(this.expires!=null){const t=this;Object.defineProperty(e,"seconds",{get(){return Math.round(((t.expires??0)-Date.now())/1e3)}})}return e}}const Qf=de(Q(Xf.matchers[0],X("p2p-circuit"))),Zf=de(X("p2p-circuit"));function qn(r,e){const t={[Symbol.iterator]:()=>t,next:()=>{const n=r.next(),s=n.value;return n.done===!0||s==null?{done:!0,value:void 0}:{done:!1,value:e(s)}}};return t}function Ko(r){const e=rr(be.decode(`z${r}`));return fs(e)}class fo{map;constructor(e){if(this.map=new Map,e!=null)for(const[t,n]of e.entries())this.map.set(t.toString(),{key:t,value:n})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return qn(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach((t,n)=>{e(t.value,t.key,this)})}get(e){return this.map.get(e.toString())?.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return qn(this.map.values(),e=>e.key)}values(){return qn(this.map.values(),e=>e.value)}get size(){return this.map.size}}class Vr{set;constructor(e){if(this.set=new Set,e!=null)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return qn(this.set.entries(),e=>{const t=Ko(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const n=Ko(t);e(n,n,this)})}has(e){return this.set.has(e.toString())}values(){return qn(this.set.values(),e=>Ko(e))}intersection(e){const t=new Vr;for(const n of e)this.has(n)&&t.add(n);return t}difference(e){const t=new Vr;for(const n of this)e.has(n)||t.add(n);return t}union(e){const t=new Vr;for(const n of e)t.add(n);for(const n of this)t.add(n);return t}}const Vc={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},Jf={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},ep=new globalThis.TextEncoder;function CS(r,e){const t=Vc[e];let n=Jf[e];for(let s=0;s<r.length;s++)n^=BigInt(r[s]),n=BigInt.asUintN(e,n*t);return n}function IS(r,e,t){if(t.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const n=Vc[e];let s=Jf[e],i=r;for(;i.length>0;){const o=ep.encodeInto(i,t);i=i.slice(o.read);for(let a=0;a<o.written;a++)s^=BigInt(t[a]),s=BigInt.asUintN(e,s*n)}return s}function TS(r,{size:e=32,utf8Buffer:t}={}){if(!Vc[e])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof r=="string"){if(t)return IS(r,e,t);r=ep.encode(r)}return CS(r,e)}const Gc={hash:r=>Number(TS(r,{size:32})),hashV:(r,e)=>PS(Gc.hash(r,e))};function PS(r){let e=r.toString(16);return e.length%2===1&&(e=`0${e}`),z(e,"base16")}const tp=64;class pr{fp;h;seed;constructor(e,t,n,s=2){if(s>tp)throw new TypeError("Invalid Fingerprint Size");const i=t.hashV(e,n),o=ae(s);for(let a=0;a<o.length;a++)o[a]=i[a];o.length===0&&(o[0]=7),this.fp=o,this.h=t,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return e?.fp instanceof Uint8Array?ke(this.fp,e.fp):!1}}function $i(r,e){return Math.floor(Math.random()*(e-r))+r}class Os{contents;constructor(e){this.contents=new Array(e).fill(null)}has(e){if(!(e instanceof pr))throw new TypeError("Invalid Fingerprint");return this.contents.some(t=>e.equals(t))}add(e){if(!(e instanceof pr))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(this.contents[t]==null)return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof pr))throw new TypeError("Invalid Fingerprint");const t=$i(0,this.contents.length-1),n=this.contents[t];return this.contents[t]=e,n}remove(e){if(!(e instanceof pr))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex(n=>e.equals(n));return t>-1?(this.contents[t]=null,!0):!1}}const kS=500;class ku{bucketSize;filterSize;fingerprintSize;buckets;count;hash;seed;constructor(e){this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??Gc,this.seed=e.seed??$i(0,Math.pow(2,10))}add(e){typeof e=="string"&&(e=z(e));const t=new pr(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=(n^t.hash())%this.filterSize;if(this.buckets[n]==null&&(this.buckets[n]=new Os(this.bucketSize)),this.buckets[s]==null&&(this.buckets[s]=new Os(this.bucketSize)),this.buckets[n].add(t)||this.buckets[s].add(t))return this.count++,!0;const i=[n,s];let o=i[$i(0,i.length-1)];this.buckets[o]==null&&(this.buckets[o]=new Os(this.bucketSize));for(let a=0;a<kS;a++){const c=this.buckets[o].swap(t);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new Os(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(e){typeof e=="string"&&(e=z(e));const t=new pr(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=this.buckets[n]?.has(t)??!1;if(s)return s;const i=(n^t.hash())%this.filterSize;return this.buckets[i]?.has(t)??!1}remove(e){typeof e=="string"&&(e=z(e));const t=new pr(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=this.buckets[n]?.remove(t)??!1;if(s)return this.count--,s;const i=(n^t.hash())%this.filterSize,o=this.buckets[i]?.remove(t)??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const RS={1:.5,2:.84,4:.95,8:.98};function LS(r=.001){return r>.002?2:r>1e-5?4:8}function DS(r,e=.001){const t=LS(e),n=RS[t],s=Math.round(r/n),i=Math.min(Math.ceil(Math.log2(1/e)+Math.log2(2*t)),tp);return{filterSize:s,bucketSize:t,fingerprintSize:i}}class MS{filterSize;bucketSize;fingerprintSize;scale;filterSeries;hash;seed;constructor(e){this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??Gc,this.seed=e.seed??$i(0,Math.pow(2,10)),this.filterSeries=[new ku({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if(typeof e=="string"&&(e=z(e)),this.has(e))return!0;let t=this.filterSeries.find(n=>n.reliable);if(t==null){const n=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new ku({filterSize:n,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){typeof e=="string"&&(e=z(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){typeof e=="string"&&(e=z(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce((e,t)=>e+t.count,0)}}function ts(r,e=.001,t){return new MS({...DS(r,e)})}class OS{filter;constructor(e,t){this.filter=ts(e,t)}has(e){return this.filter.has(e.toMultihash().bytes)}add(e){this.filter.add(e.toMultihash().bytes)}remove(e){this.filter.remove?.(e.toMultihash().bytes)}}function FS(r,e=.001){return new OS(r,e)}function Ru(r){const{stream:e,remoteAddr:t,logger:n,onDataRead:s,onDataWrite:i}=r,o=n.forComponent("libp2p:stream:converter");let a=!1,c=!1;const l=e.close.bind(e);e.close=async f=>{await l(f),p(!0)};const u=e.abort.bind(e);e.abort=f=>{u(f),p(!0)};const d=e.sink.bind(e);e.sink=async f=>{try{await d(Fc(f,g=>If(g,m=>i?.(m))))}catch(g){g.type!=="aborted"&&o.error("%s error in sink",t,g)}finally{c=!0,p()}};const h={log:o,sink:e.sink,source:async function*(){try{for await(const f of e.source)s?.(f),yield f}finally{a=!0,p()}}(),remoteAddr:t,timeline:{open:Date.now(),close:void 0},close:e.close,abort:e.abort};function p(f){f===!0&&(a=!0,c=!0),a&&c&&h.timeline.close==null&&(h.timeline.close=Date.now())}return h}class te extends Event{type;detail;constructor(e,t){super(e),this.type=e,this.detail=t}}let NS=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.name="AbortError",this.code=t??"ABORT_ERR"}};async function Gr(r,e,t,n){const s=new NS(n?.errorMessage,n?.errorCode);return t?.aborted===!0?Promise.reject(s):new Promise((i,o)=>{function a(){t?.removeEventListener("abort",u),r.removeEventListener(e,c),n?.errorEvent!=null&&r.removeEventListener(n.errorEvent,l)}const c=d=>{try{if(n?.filter?.(d)===!1)return}catch(h){a(),o(h);return}a(),i(d)},l=d=>{a(),o(d.detail)},u=()=>{a(),o(s)};t?.addEventListener("abort",u),r.addEventListener(e,c),n?.errorEvent!=null&&r.addEventListener(n.errorEvent,l)})}function Ka(r,e){let t;const n=function(){const s=function(){t=void 0,r()};clearTimeout(t),t=setTimeout(s,e)};return n.start=()=>{},n.stop=()=>{clearTimeout(t)},n}class BS extends Error{remainingPoints;msBeforeNext;consumedPoints;isFirstInDuration;constructor(e="Rate limit exceeded",t){super(e),this.name="RateLimitError",this.remainingPoints=t.remainingPoints,this.msBeforeNext=t.msBeforeNext,this.consumedPoints=t.consumedPoints,this.isFirstInDuration=t.isFirstInDuration}}class US extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}class $S{deferred;signal;constructor(e){this.signal=e,this.deferred=pe(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new Er)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}}function qS(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class WS{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=qS(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,n)=>t&&n.signal?.aborted===!0,!0)&&(this.controller.abort(new Er),this.cleanup())}async join(e={}){const t=new $S(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await _e(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}}class rp extends Qt{concurrency;maxSize;queue;pending;sort;constructor(e={}){super(),this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,e.metricName!=null&&e.metrics?.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})}),this.sort=e.sort,this.queue=[],this.emitEmpty=Ka(this.emitEmpty.bind(this),1),this.emitIdle=Ka(this.emitIdle.bind(this),1)}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if(t.status==="queued"){e=t;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new US;const n=new WS(e,t);return this.enqueue(n),this.safeDispatchEvent("add"),this.tryToStartAnother(),n.join(t).then(s=>(this.safeDispatchEvent("completed",{detail:s}),this.safeDispatchEvent("success",{detail:{job:n,result:s}}),s)).catch(s=>{if(n.status==="queued"){for(let i=0;i<this.queue.length;i++)if(this.queue[i]===n){this.queue.splice(i,1);break}}throw this.safeDispatchEvent("error",{detail:s}),this.safeDispatchEvent("failure",{detail:{job:n,error:s}}),s})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new Er)}),this.clear()}async onEmpty(e){this.size!==0&&await Gr(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await Gr(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await Gr(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=gs({objectMode:!0}),n=c=>{c!=null?this.abort():this.clear(),t.end(c)},s=c=>{c.detail!=null&&t.push(c.detail)},i=c=>{n(c.detail)},o=()=>{n()},a=()=>{n(new Er("Queue aborted"))};this.addEventListener("completed",s),this.addEventListener("error",i),this.addEventListener("idle",o),e?.signal?.addEventListener("abort",a);try{yield*t}finally{this.removeEventListener("completed",s),this.removeEventListener("error",i),this.removeEventListener("idle",o),e?.signal?.removeEventListener("abort",a),n()}}}class jc extends rp{has(e){return this.find(e)!=null}find(e){return this.queue.find(t=>e.equals(t.options.peerId))}}class zS extends Qt{peerStore;registrar;connectionManager;randomWalk;started;running;topologyId;log;discoveryController;filter;queue;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.started=!1,this.running=!1,this.peerStore=e.peerStore,this.registrar=e.registrar,this.connectionManager=e.connectionManager,this.randomWalk=e.randomWalk,this.filter=t.filter,this.discoveryController=new AbortController,this.discoveryController.signal}isStarted(){return this.started}async start(){this.topologyId=await this.registrar.register(Ri,{filter:this.filter,onConnect:e=>{this.log.trace("discovered relay %p queue (length: %d, active %d)",e,this.queue?.size,this.queue?.running),this.safeDispatchEvent("relay:discover",{detail:e})}}),this.started=!0}stop(){this.topologyId!=null&&this.registrar.unregister(this.topologyId),this.discoveryController?.abort(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,this.discoveryController.signal,Promise.resolve().then(async()=>{this.log("searching peer store for relays");const e=await this.peerStore.all({filters:[n=>n.protocols.includes(Ri)],orders:[()=>Math.random()<.5?1:-1,(n,s)=>{const i=Lu(n),o=Lu(s);return i>o?-1:o>i?1:0}]});for(const n of e)this.log.trace("found relay peer %p in peer store",n.id),this.safeDispatchEvent("relay:discover",{detail:n.id});this.log("found %d relay peers in peer store",e.length);const t=this.queue=new jc({concurrency:5});this.log("start random walk");for await(const n of this.randomWalk.walk({signal:this.discoveryController.signal})){if(this.log.trace("found random peer %p",n.id),t.has(n.id)){this.log.trace("random peer %p was already in queue",n.id);continue}if(this.connectionManager.getConnections(n.id)?.length>0){this.log.trace("random peer %p was already connected",n.id);continue}if(!await this.connectionManager.isDialable(n.multiaddrs)){this.log.trace("random peer %p was not dialable",n.id,n.multiaddrs.map(s=>s.toString()));continue}t.queued>10&&(this.log.trace("wait for space in queue for %p",n.id),await t.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",n.id,t.size,t.running),t.add(async()=>{const s=Jt([this.discoveryController.signal,AbortSignal.timeout(5e3)]);try{await this.connectionManager.openConnection(n.id,{signal:s})}finally{s.clear()}},{peerId:n.id,signal:this.discoveryController.signal}).catch(s=>{this.log.error("error opening connection to random peer %p",n.id,s)})}this.log("stop random walk"),await t.onIdle()}).catch(e=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network",e)}))}stopDiscovery(){this.log("stop discovery"),this.running=!1,this.discoveryController?.abort()}}function Lu(r){const e=r.metadata.get("last-dial-success");return e==null?0:new Date(G(e)).getTime()}class KS extends Qt{connectionManager;addressManager;reservationStore;listeningAddrs;log;listenTimeout;reservationId;relay;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.connectionManager=e.connectionManager,this.addressManager=e.addressManager,this.reservationStore=e.reservationStore,this.listeningAddrs=[],this.listenTimeout=t.listenTimeout??zf,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}_onRemoveRelayPeer=e=>{this.log("relay removed %p our relay %p",e.detail.relay,this.relay,this.relay?.equals(e.detail.relay)),this.relay?.equals(e.detail.relay)===!0&&(this.log("relay peer removed %p",e.detail.relay),this.listeningAddrs.forEach(t=>{this.addressManager.removeObservedAddr(t)}),this.listeningAddrs=[],this.safeDispatchEvent("listening"))};_onAddRelayPeer=e=>{const{details:t}=e.detail;t.type!=="configured"&&t.id===this.reservationId&&this.addedRelay(e.detail)};async listen(e){if(Zf.exactMatch(e))this.log("searching for circuit relay servers"),this.reservationId=this.reservationStore.reserveRelay();else if(Qf.exactMatch(e)){this.log("listen on specific relay server %a",e);const t=AbortSignal.timeout(this.listenTimeout),n=e.decapsulate("/p2p-circuit"),s=await this.connectionManager.openConnection(n,{signal:t});if(!this.reservationStore.hasReservation(s.remotePeer)){this.log("making reservation on peer %p",s.remotePeer);const i=await this.reservationStore.addRelay(s.remotePeer,"configured");this.addedRelay(i)}}else throw new Sa(`Could not listen on p2p-circuit address "${e}"`)}getAddrs(){return[...this.listeningAddrs.values()].flat()}updateAnnounceAddrs(){}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask(()=>{this.safeDispatchEvent("close")})}addedRelay(e){this.log("relay peer added %p",e.relay),this.relay=e.relay,this.listeningAddrs=e.details.reservation.addrs.map(t=>Y(t).encapsulate("/p2p-circuit")),this.listeningAddrs.forEach(t=>{this.addressManager.confirmObservedAddr(t,{type:"transport"})}),queueMicrotask(()=>{this.safeDispatchEvent("listening")})}}function HS(r){return new KS(r)}const VS="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";let GS=(r=21)=>{let e="",t=crypto.getRandomValues(new Uint8Array(r|=0));for(;r--;)e+=VS[t[r]&63];return e};const jS=60*1e3*10,YS=60*1e3*5,XS=30*1e3;class QS extends Qt{peerId;connectionManager;peerStore;events;reserveQueue;reservations;pendingReservations;maxReservationQueueLength;reservationCompletionTimeout;started;log;relayFilter;constructor(e,t){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.reservations=new fo,this.pendingReservations=[],this.maxReservationQueueLength=t?.maxReservationQueueLength??uS,this.reservationCompletionTimeout=t?.reservationCompletionTimeout??zf,this.started=!1,this.relayFilter=ts(100),this.reserveQueue=new jc({concurrency:t?.reservationConcurrency??lS,metricName:"libp2p_relay_reservation_queue",metrics:e.metrics}),this.events.addEventListener("connection:close",n=>{[...this.reservations.values()].find(i=>i.connection===n.detail.id)!=null&&this.#t(n.detail.remotePeer).catch(i=>{this.log("could not remove relay %p - %e",n.detail,i)})})}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>t.tags.has(Ms)]});this.log("removing tag from %d old relays",e.length),await Promise.all(e.map(async t=>{await this.peerStore.merge(t.id,{tags:{[Ms]:void 0}})})),this.log("redialing %d old relays",e.length),await Promise.all(e.map(async t=>this.addRelay(t.id,"discovered"))),this.#r()}).catch(e=>{this.log.error(e)})}stop(){this.reserveQueue.clear(),this.reservations.forEach(({timeout:e})=>{clearTimeout(e)}),this.reservations.clear(),this.started=!1}reserveRelay(){const e=GS();return this.pendingReservations.push(e),this.#r(),e}async addRelay(e,t){if(this.peerId.equals(e))throw this.log.trace("not trying to use self as relay"),new Sa("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new AS("The reservation queue is full");const n=this.reserveQueue.find(e);if(n!=null)return this.log.trace("potential relay peer %p is already in the reservation queue",e),n.join();if(this.relayFilter.has(e.toMultihash().bytes))throw new Sa("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",e),this.reserveQueue.add(async()=>{const s=Date.now();try{const i=this.reservations.get(e);if(i!=null){const f=this.connectionManager.getConnections(e);let g=!1;if(f.length===0&&this.log("already have relay reservation with %p but we are no longer connected",e),f.map(m=>m.id).includes(i.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",e),g=!0),g&&Tu(i.reservation.expire)>jS)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",e),{relay:e,details:i};await this.#t(e)}if(t==="discovered"&&this.pendingReservations.length===0)throw new Iu("Not making reservation on discovered relay because we do not need any more relays");const o=AbortSignal.timeout(this.reservationCompletionTimeout);const a=await this.connectionManager.openConnection(e,{signal:o});if(es.matches(a.remoteAddr))throw new xS("not creating reservation over relayed connection");const c=await this.#e(a,{signal:o}),l=Tu(c.expire);this.log("created reservation on relay peer %p, expiry date is %s",e,new Date(Date.now()+l).toString());const u=Math.min(Math.max(l-YS,XS),Math.pow(2,31)-1),d=setTimeout(()=>{this.log("refresh reservation to relay %p",e),this.addRelay(e,t).catch(async f=>{this.log.error("could not refresh reservation to relay %p - %e",e,f),await this.#t(e)}).catch(f=>{this.log.error("could not remove expired reservation to relay %p - %e",e,f)})},u);let h;if(t==="discovered"){const f=this.pendingReservations.pop();if(f==null)throw new Iu("Made reservation on relay but did not need any more discovered relays");h={timeout:d,reservation:c,type:t,connection:a.id,id:f}}else h={timeout:d,reservation:c,type:t,connection:a.id};this.reservations.set(e,h),await this.peerStore.merge(e,{tags:{[Ms]:{value:1,ttl:l}}}),this.#r();const p={relay:e,details:h};return this.safeDispatchEvent("relay:created-reservation",{detail:p}),p}catch(i){throw t==="discovered"&&i.name==="HadEnoughRelaysError"||this.log.error("could not reserve slot on %p after %dms - %e",e,Date.now()-s,i),(i.name==="DialError"||i.name==="UnsupportedProtocolError")&&this.relayFilter.add(e.toMultihash().bytes),this.#t(e).catch(o=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",e,o)}),i}},{peerId:e})}hasReservation(e){return this.reservations.has(e)}getReservation(e){return this.reservations.get(e)?.reservation}reservationCount(e){return e==null?this.reservations.size:[...this.reservations.values()].reduce((t,n)=>(n.type===e&&t++,t),0)}cancelReservations(){[...this.reservations.values()].forEach(e=>{clearTimeout(e.timeout)}),this.reservations.clear()}async#e(e,t){t.signal?.throwIfAborted(),this.log("requesting reservation from %p",e.remotePeer);const n=await e.newStream(Ri,t),i=Dt(n).pb(on);this.log.trace("send RESERVE to %p",e.remotePeer),await i.write({type:on.Type.RESERVE},t);let o;try{this.log.trace("reading response from %p",e.remotePeer),o=await i.read(t)}catch(c){throw n.abort(c),c}finally{n.status!=="closed"&&await n.close(t)}if(this.log.trace("read response %o",o),o.status===qe.OK&&o.reservation!=null){const c=new Set;c.add(e.remoteAddr.toString());for(const l of o.reservation.addrs){let u=Y(l);u.getPeerId()==null&&(u=u.encapsulate(`/p2p/${e.remotePeer}`)),u=Y(u.toString().replace(`/p2p/${e.remotePeer}/p2p/${e.remotePeer}`,`/p2p/${e.remotePeer}`)),c.add(u.toString())}return o.reservation.addrs=[...c].map(l=>Y(l).bytes),o.reservation}const a=`reservation failed with status ${o.status??"undefined"}`;throw this.log.error(a),new Error(a)}async#t(e){const t=this.reservations.get(e);t!=null&&(this.log("removing relay reservation with %p from local store",e),clearTimeout(t.timeout),this.reservations.delete(e),t.type==="discovered"&&this.pendingReservations.push(t.id),await this.peerStore.merge(e,{tags:{[Ms]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:e,details:t}}),this.#r())}#r(){if(this.pendingReservations.length===0){this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),this.safeDispatchEvent("relay:found-enough-relays");return}this.relayFilter=ts(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")}}const ZS=r=>{if(r.peer==null)return!1;try{r.peer.addrs.forEach(Y)}catch{return!1}return!0},Du={maxInboundStopStreams:_u,maxOutboundStopStreams:_u};class JS{discovery;registrar;peerStore;connectionManager;transportManager;peerId;upgrader;addressManager;connectionGater;reservationStore;logger;maxInboundStopStreams;maxOutboundStopStreams;started;log;shutdownController;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:circuit-relay:transport"),this.registrar=e.registrar,this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.transportManager=e.transportManager,this.logger=e.logger,this.peerId=e.peerId,this.upgrader=e.upgrader,this.addressManager=e.addressManager,this.connectionGater=e.connectionGater,this.maxInboundStopStreams=t.maxInboundStopStreams??Du.maxInboundStopStreams,this.maxOutboundStopStreams=t.maxOutboundStopStreams??Du.maxOutboundStopStreams,this.shutdownController=new AbortController,this.discovery=new zS(e,{filter:t.discoveryFilter??FS(dS,hS)}),this.discovery.addEventListener("relay:discover",n=>{this.reservationStore.addRelay(n.detail,"discovered").catch(s=>{s.name!=="HadEnoughRelaysError"&&s.name!=="RelayQueueFullError"&&this.log.error("could not add discovered relay %p",n.detail,s)})}),this.reservationStore=new QS(e,t),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{this.discovery?.startDiscovery()}),this.reservationStore.addEventListener("relay:found-enough-relays",()=>{this.discovery?.stopDiscovery()}),this.started=!1}[Symbol.toStringTag]="@libp2p/circuit-relay-v2-transport";[rt]=["@libp2p/transport","@libp2p/circuit-relay-v2-transport"];get[li](){return this.discovery!=null?["@libp2p/identify"]:[]}[Zi]=!0;isStarted(){return this.started}async start(){this.shutdownController=new AbortController,this.shutdownController.signal,await this.registrar.handle(Eu,e=>{const t=this.upgrader.createInboundAbortSignal(this.shutdownController.signal);this.onStop(e,t).catch(n=>{this.log.error("error while handling STOP protocol",n),e.stream.abort(n)}).finally(()=>{t.clear()})},{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await oh(this.discovery,this.reservationStore),this.started=!0}async stop(){this.shutdownController.abort(),await ah(this.discovery,this.reservationStore),await this.registrar.unhandle(Eu),this.started=!1}async dial(e,t){if(e.protoCodes().filter(p=>p===cS).length!==1){const p="Invalid circuit relay address";throw this.log.error(p,e),new Nn(p)}const n=e.toString().split("/p2p-circuit"),s=Y(n[0]),i=Y(n[n.length-1]),o=s.getPeerId(),a=i.getPeerId();if(o==null||a==null){const p=`ircuit relay dial to ${e.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${p}`),new Nn(`C${p}`)}const c=dt(o),l=dt(a);let d=this.connectionManager.getConnections(c)[0];d==null?(await this.peerStore.merge(c,{multiaddrs:[s]}),t.onProgress?.(new te("circuit-relay:open-connection")),d=await this.connectionManager.openConnection(c,t)):t.onProgress?.(new te("circuit-relay:reuse-connection"));let h;try{t.onProgress?.(new te("circuit-relay:open-hop-stream")),h=await d.newStream(Ri,t);const p=Dt(h),f=p.pb(on);t.onProgress?.(new te("circuit-relay:write-connect-message")),await f.write({type:on.Type.CONNECT,peer:{id:l.toMultihash().bytes,addrs:[Y(i).bytes]}},t),t.onProgress?.(new te("circuit-relay:read-connect-response"));const g=await f.read(t);if(g.status!==qe.OK)throw new mt(`failed to connect via relay with status ${g?.status?.toString()??"undefined"}`);const m=new Pu(g.limit),S=Ru({stream:p.unwrap(),remoteAddr:e,localAddr:s.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),logger:this.logger,onDataRead:m.onData,onDataWrite:m.onData});return this.log("new outbound relayed connection %a",S.remoteAddr),await this.upgrader.upgradeOutbound(S,{...t,limits:m.getLimits()})}catch(p){throw this.log.error("circuit relay dial to destination %p via relay %p failed",l,c,p),h?.abort(p),p}}createListener(e){return HS({peerId:this.peerId,connectionManager:this.connectionManager,addressManager:this.addressManager,reservationStore:this.reservationStore,logger:this.logger})}listenFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>Qf.exactMatch(t)||Zf.exactMatch(t))}dialFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>es.exactMatch(t))}async onStop({connection:e,stream:t},n){if(!this.reservationStore.hasReservation(e.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.transportManager.listen([e.remoteAddr.encapsulate("/p2p-circuit")])}catch(u){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on",u)}const s=Dt(t).pb(At),i=await s.read({signal:n});if(this.log("new circuit relay v2 stop stream from %p with type %s",e.remotePeer,i.type),i?.type===void 0){this.log.error("type was missing from circuit v2 stop protocol request from %s",e.remotePeer),await s.write({type:At.Type.STATUS,status:qe.MALFORMED_MESSAGE},{signal:n}),await t.close();return}if(i.type!==At.Type.CONNECT){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await s.write({type:At.Type.STATUS,status:qe.UNEXPECTED_MESSAGE},{signal:n}),await t.close();return}if(!ZS(i)){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await s.write({type:At.Type.STATUS,status:qe.MALFORMED_MESSAGE},{signal:n}),await t.close({signal:n});return}const o=fs(rr(i.peer.id));if(await this.connectionGater.denyInboundRelayedConnection?.(e.remotePeer,o)===!0){this.log.error("connection gater denied inbound relayed connection from %p",e.remotePeer),await s.write({type:At.Type.STATUS,status:qe.PERMISSION_DENIED},{signal:n}),await t.close({signal:n});return}this.log.trace("sending success response to %p",e.remotePeer),await s.write({type:At.Type.STATUS,status:qe.OK},{signal:n});const a=new Pu(i.limit),c=e.remoteAddr.encapsulate(`/p2p-circuit/p2p/${o.toString()}`);this.addressManager.getAddresses()[0];const l=Ru({stream:s.unwrap().unwrap(),remoteAddr:c,logger:this.logger,onDataRead:a.onData,onDataWrite:a.onData});this.log("new inbound relayed connection %a",l.remoteAddr),await this.upgrader.upgradeInbound(l,{limits:a.getLimits(),signal:n}),this.log("%s connection %a upgraded","inbound",l.remoteAddr)}}function eE(r={}){return e=>new JS(e,r)}function tE(r){return r[Symbol.asyncIterator]!=null}function Ha(r){if(tE(r))return(async()=>{for await(const e of r);})();for(const e of r);}const Fs=globalThis.CustomEvent??Event;async function*np(r,e={}){let t=e.concurrency??1/0;t<1&&(t=1/0);const n=e.ordered??!1,s=new EventTarget,i=[];let o=pe(),a=pe(),c=!1,l,u=!1;s.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const f of r){if(i.length===t&&(o=pe(),await o.promise),u)break;const g={done:!1};i.push(g),f().then(m=>{g.done=!0,g.ok=!0,g.value=m,s.dispatchEvent(new Fs("task-complete"))},m=>{g.done=!0,g.err=m,s.dispatchEvent(new Fs("task-complete"))})}c=!0,s.dispatchEvent(new Fs("task-complete"))}catch(f){l=f,s.dispatchEvent(new Fs("task-complete"))}});function d(){return n?i[0]?.done:!!i.find(f=>f.done)}function*h(){for(;i.length>0&&i[0].done;){const f=i[0];if(i.shift(),f.ok)yield f.value;else throw u=!0,o.resolve(),f.err;o.resolve()}}function*p(){for(;d();)for(let f=0;f<i.length;f++)if(i[f].done){const g=i[f];if(i.splice(f,1),f--,g.ok)yield g.value;else throw u=!0,o.resolve(),g.err;o.resolve()}}for(;;){if(d()||(a=pe(),await a.promise),l!=null||(n?yield*h():yield*p(),l!=null))throw l;if(c&&i.length===0)break}}const rE="0.1.0",nE="id",sE="id/push",iE="1.0.0",oE="1.0.0",aE=1024*8,cE=32;var ln;(function(r){let e;r.codec=()=>(e==null&&(e=we((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.protocolVersion!=null&&(n.uint32(42),n.string(t.protocolVersion)),t.agentVersion!=null&&(n.uint32(50),n.string(t.agentVersion)),t.publicKey!=null&&(n.uint32(10),n.bytes(t.publicKey)),t.listenAddrs!=null)for(const i of t.listenAddrs)n.uint32(18),n.bytes(i);if(t.observedAddr!=null&&(n.uint32(34),n.bytes(t.observedAddr)),t.protocols!=null)for(const i of t.protocols)n.uint32(26),n.string(i);t.signedPeerRecord!=null&&(n.uint32(66),n.bytes(t.signedPeerRecord)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={listenAddrs:[],protocols:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 5:{i.protocolVersion=t.string();break}case 6:{i.agentVersion=t.string();break}case 1:{i.publicKey=t.bytes();break}case 2:{if(s.limits?.listenAddrs!=null&&i.listenAddrs.length===s.limits.listenAddrs)throw new Lt('Decode error - map field "listenAddrs" had too many elements');i.listenAddrs.push(t.bytes());break}case 4:{i.observedAddr=t.bytes();break}case 3:{if(s.limits?.protocols!=null&&i.protocols.length===s.limits.protocols)throw new Lt('Decode error - map field "protocols" had too many elements');i.protocols.push(t.string());break}case 8:{i.signedPeerRecord=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ye(t,r.codec()),r.decode=(t,n)=>me(t,r.codec(),n)})(ln||(ln={}));const et={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:aE,runOnConnectionOpen:!0,runOnSelfUpdate:!0,runOnLimitedConnection:!0,concurrency:cE};function lE(r){if(r!=null&&r.length>0)try{return Y(r)}catch{}}function uE(r,e){return e??r.userAgent}async function sp(r,e,t,n,s){if(t("received identify from %p",n.remotePeer),s==null)throw new mt("message was null or undefined");const i={};if(s.listenAddrs.length>0&&(i.addresses=s.listenAddrs.map(c=>({isCertified:!1,multiaddr:Y(c)}))),s.protocols.length>0&&(i.protocols=s.protocols),s.publicKey!=null){const c=Zt(s.publicKey);if(!Gn(c).equals(n.remotePeer))throw new mt("public key did not match remote PeerId");i.publicKey=c}let o;if(s.signedPeerRecord!=null){t.trace("received signedPeerRecord from %p",n.remotePeer);let c=s.signedPeerRecord;const l=await vt.openAndCertify(c,Ze.DOMAIN);let u=Ze.createFromProtobuf(l.payload);const d=ps(l.publicKey.toCID());if(!u.peerId.equals(d))throw new mt("signing key does not match PeerId in the PeerRecord");if(!n.remotePeer.equals(u.peerId))throw new mt("signing key does not match remote PeerId");let h;try{h=await r.get(u.peerId)}catch(p){if(p.name!=="NotFoundError")throw p}if(h!=null&&(i.metadata=h.metadata,h.peerRecordEnvelope!=null)){const p=await vt.createFromProtobuf(h.peerRecordEnvelope),f=Ze.createFromProtobuf(p.payload);f.seqNumber>=u.seqNumber&&(t("sequence number was lower or equal to existing sequence number - stored: %d received: %d",f.seqNumber,u.seqNumber),u=f,c=h.peerRecordEnvelope)}i.peerRecordEnvelope=c,i.addresses=u.multiaddrs.map(p=>({isCertified:!0,multiaddr:p})),o={seq:u.seqNumber,addresses:u.multiaddrs}}else t("%p did not send a signed peer record",n.remotePeer);if(t.trace("patching %p with",n.remotePeer,i),await r.patch(n.remotePeer,i),s.agentVersion!=null||s.protocolVersion!=null){const c={};s.agentVersion!=null&&(c.AgentVersion=z(s.agentVersion)),s.protocolVersion!=null&&(c.ProtocolVersion=z(s.protocolVersion)),t.trace("merging %p metadata",n.remotePeer,c),await r.merge(n.remotePeer,{metadata:c})}const a={peerId:n.remotePeer,protocolVersion:s.protocolVersion,agentVersion:s.agentVersion,publicKey:s.publicKey,listenAddrs:s.listenAddrs.map(c=>Y(c)),observedAddr:s.observedAddr==null?void 0:Y(s.observedAddr),protocols:s.protocols,signedPeerRecord:o,connection:n};return e.safeDispatchEvent("peer:identify",{detail:a}),a}class ip{host;protocol;started;timeout;peerId;privateKey;peerStore;registrar;addressManager;maxInboundStreams;maxOutboundStreams;maxMessageSize;maxObservedAddresses;events;runOnLimitedConnection;log;constructor(e,t){this.protocol=t.protocol,this.started=!1,this.peerId=e.peerId,this.privateKey=e.privateKey,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.events=e.events,this.log=t.log,this.timeout=t.timeout??et.timeout,this.maxInboundStreams=t.maxInboundStreams??et.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??et.maxOutboundStreams,this.maxMessageSize=t.maxMessageSize??et.maxMessageSize,this.maxObservedAddresses=t.maxObservedAddresses??et.maxObservedAddresses,this.runOnLimitedConnection=t.runOnLimitedConnection??et.runOnLimitedConnection,this.host={protocolVersion:`${t.protocolPrefix??et.protocolPrefix}/${rE}`,agentVersion:uE(e.nodeInfo,t.agentVersion)}}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:z(this.host.agentVersion),ProtocolVersion:z(this.host.protocolVersion)}}),await this.registrar.handle(this.protocol,e=>{this.handleProtocol(e).catch(t=>{this.log.error(t)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.registrar.unhandle(this.protocol),this.started=!1}}class dE extends ip{connectionManager;concurrency;constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??et.protocolPrefix}/${sE}/${oE}`,log:e.logger.forComponent("libp2p:identify-push")}),this.connectionManager=e.connectionManager,this.concurrency=t.concurrency??et.concurrency,(t.runOnSelfUpdate??et.runOnSelfUpdate)&&e.events.addEventListener("self:peer:update",n=>{this.push().catch(s=>{this.log.error(s)})})}[rt]=["@libp2p/identify-push"];async push(){if(!this.isStarted())return;const e=this.addressManager.getAddresses().map(u=>u.decapsulateCode(V("p2p").code)),t=new Ze({peerId:this.peerId,multiaddrs:e}),n=await vt.seal(t,this.privateKey),s=this.registrar.getProtocols(),i=await this.peerStore.get(this.peerId),o=G(i.metadata.get("AgentVersion")??z(this.host.agentVersion)),a=G(i.metadata.get("ProtocolVersion")??z(this.host.protocolVersion)),c=this;async function*l(){for(const u of c.connectionManager.getConnections())(await c.peerStore.get(u.remotePeer)).protocols.includes(c.protocol)&&(yield async()=>{let h;const p=AbortSignal.timeout(c.timeout);try{h=await u.newStream(c.protocol,{signal:p,runOnLimitedConnection:c.runOnLimitedConnection}),await Dt(h,{maxDataLength:c.maxMessageSize}).pb(ln).write({listenAddrs:e.map(g=>g.bytes),signedPeerRecord:n.marshal(),protocols:s,agentVersion:o,protocolVersion:a},{signal:p}),await h.close({signal:p})}catch(f){c.log.error("could not push identify update to peer",f),h?.abort(f)}})}await Ha(np(l(),{concurrency:this.concurrency}))}async handleProtocol(e){const{connection:t,stream:n}=e;try{if(this.peerId.equals(t.remotePeer))throw new Error("received push from ourselves?");const s={signal:AbortSignal.timeout(this.timeout)},o=await Dt(n,{maxDataLength:this.maxMessageSize}).pb(ln).read(s);await n.close(s),await sp(this.peerStore,this.events,this.log,t,o)}catch(s){this.log.error("received invalid message",s),n.abort(s);return}this.log.trace("handled push from %p",t.remotePeer)}}const hE=41;function fE(r){try{const[[e,t]]=r.stringTuples();if(t==null)return!1;if(e===hE)return Bv("2000::/3",t)}catch{}return!1}function bs(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var Fr={},Mu;function pE(){return Mu||(Mu=1,function(){var r,e,t,n,s,i,o,a;a=function(c){var l,u,d,h;return l=(c&255<<24)>>>24,u=(c&255<<16)>>>16,d=(c&65280)>>>8,h=c&255,[l,u,d,h].join(".")},o=function(c){var l,u,d,h,p,f;for(l=[],d=h=0;h<=3&&c.length!==0;d=++h){if(d>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}f=e(c),p=f[0],u=f[1],c=c.substring(u),l.push(p)}if(c.length!==0)throw new Error("Invalid IP");switch(l.length){case 1:if(l[0]>4294967295)throw new Error("Invalid IP");return l[0]>>>0;case 2:if(l[0]>255||l[1]>16777215)throw new Error("Invalid IP");return(l[0]<<24|l[1])>>>0;case 3:if(l[0]>255||l[1]>255||l[2]>65535)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2])>>>0;case 4:if(l[0]>255||l[1]>255||l[2]>255||l[3]>255)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2]<<8|l[3])>>>0;default:throw new Error("Invalid IP")}},t=function(c){return c.charCodeAt(0)},n=t("0"),i=t("a"),s=t("A"),e=function(c){var l,u,d,h,p;for(h=0,l=10,u="9",d=0,c.length>1&&c[d]==="0"&&(c[d+1]==="x"||c[d+1]==="X"?(d+=2,l=16):"0"<=c[d+1]&&c[d+1]<="9"&&(d++,l=8,u="7")),p=d;d<c.length;){if("0"<=c[d]&&c[d]<=u)h=h*l+(t(c[d])-n)>>>0;else if(l===16)if("a"<=c[d]&&c[d]<="f")h=h*l+(10+t(c[d])-i)>>>0;else if("A"<=c[d]&&c[d]<="F")h=h*l+(10+t(c[d])-s)>>>0;else break;else break;if(h>4294967295)throw new Error("too large");d++}if(d===p)throw new Error("empty octet");return[h,d]},r=function(){function c(l,u){var d,h,p;if(typeof l!="string")throw new Error("Missing `net' parameter");if(u||(p=l.split("/",2),l=p[0],u=p[1]),u||(u=32),typeof u=="string"&&u.indexOf(".")>-1){try{this.maskLong=o(u)}catch{throw new Error("Invalid mask: "+u)}for(d=h=32;h>=0;d=--h)if(this.maskLong===4294967295<<32-d>>>0){this.bitmask=d;break}}else if(u||u===0)this.bitmask=parseInt(u,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(l)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+l)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+u);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(l){return typeof l=="string"&&(l.indexOf("/")>0||l.split(".").length!==4)&&(l=new c(l)),l instanceof c?this.contains(l.base)&&this.contains(l.broadcast||l.last):(o(l)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(l){return l==null&&(l=1),new c(a(this.netLong+this.size*l),this.mask)},c.prototype.forEach=function(l){var u,d,h;for(h=o(this.first),d=o(this.last),u=0;h<=d;)l(a(h),h,u),u++,h++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),Fr.ip2long=o,Fr.long2ip=a,Fr.Netmask=r}.call(Fr)),Fr}var gE=pE();const mE=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],yE=mE.map(r=>new gE.Netmask(r));function Yc(r){for(const e of yE)if(e.contains(r))return!0;return!1}function wE(r){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(r)}function bE(r){const e=r.split(":");if(e.length<2)return!1;const t=e[e.length-1].padStart(4,"0"),n=e[e.length-2].padStart(4,"0"),s=`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(t.substring(0,2),16)}.${parseInt(t.substring(2),16)}`;return Yc(s)}function vE(r){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)}function SE(r){const e=r.split(":"),t=e[e.length-1];return Yc(t)}function EE(r){return/^::$/.test(r)||/^::1$/.test(r)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(r)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(r)||/^ff([0-9a-fA-F]{2,2}):/i.test(r)}function po(r){return sn(r)?Yc(r):wE(r)?bE(r):vE(r)?SE(r):Uc(r)?EE(r):void 0}const _E=4,xE=41;function op(r){try{const[[e]]=r.stringTuples();return e===_E||e===xE}catch{}return!1}function rs(r){try{if(!op(r))return!1;const[[,e]]=r.stringTuples();return e==null?!1:po(e)??!1}catch{}return!0}const AE=41;class CE extends ip{constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??et.protocolPrefix}/${nE}/${iE}`,log:e.logger.forComponent("libp2p:identify")}),(t.runOnConnectionOpen??et.runOnConnectionOpen)&&e.events.addEventListener("connection:open",n=>{const s=n.detail;this.identify(s).catch(i=>{i.name!==dc.name&&this.log.error("error during identify trigged by connection:open",i)})})}[rt]=["@libp2p/identify"];async _identify(e,t={}){let n;if(t.signal==null){const s=AbortSignal.timeout(this.timeout);t={...t,signal:s}}try{n=await e.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const i=await Dt(n,{maxDataLength:this.maxMessageSize}).pb(ln).read(t);return await n.close(t),i}catch(s){throw n?.abort(s),s}}async identify(e,t={}){const n=await this._identify(e,t),{publicKey:s,protocols:i,observedAddr:o}=n;if(s==null)throw new mt("public key was missing from identify message");const a=Zt(s),c=ps(a.toCID());if(!e.remotePeer.equals(c))throw new mt("identified peer does not match the expected peer");if(this.peerId.equals(c))throw new mt("identified peer is our own peer id?");return this.maybeAddObservedAddress(o),this.log("identify completed for peer %p and protocols %o",c,i),sp(this.peerStore,this.events,this.log,e,n)}maybeAddObservedAddress(e){const t=lE(e);if(t==null)return;if(this.log.trace("our observed address was %a",t),rs(t)){this.log.trace("our observed address was private");return}if(t.stringTuples()[0][0]===AE&&!fE(t)){this.log.trace("our observed address was IPv6 but not a global unicast address");return}Fi.exactMatch(t)||(this.log.trace("storing the observed address"),this.addressManager.addObservedAddr(t))}async handleProtocol(e){const{connection:t,stream:n}=e,s=AbortSignal.timeout(this.timeout);try{const i=await this.peerStore.get(this.peerId),o=this.addressManager.getAddresses().map(u=>u.decapsulateCode(V("p2p").code));let a=i.peerRecordEnvelope;if(o.length>0&&a==null){const u=new Ze({peerId:this.peerId,multiaddrs:o});a=(await vt.seal(u,this.privateKey)).marshal().subarray()}let c=t.remoteAddr.bytes;mS.matches(t.remoteAddr)||(c=void 0),await Dt(n).pb(ln).write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:kt(this.privateKey.publicKey),listenAddrs:o.map(u=>u.bytes),signedPeerRecord:a,observedAddr:c,protocols:i.protocols},{signal:s}),await n.close({signal:s})}catch(i){this.log.error("could not respond to identify request",i),n.abort(i)}}}function IE(r={}){return e=>new CE(e,r)}function TE(r={}){return e=>new dE(e,r)}const Ho=32,PE="1.0.0",kE="ping",RE="ipfs",LE=1e4,DE=2,ME=1;class OE{protocol;components;started;timeout;maxInboundStreams;maxOutboundStreams;runOnLimitedConnection;log;constructor(e,t={}){this.components=e,this.log=e.logger.forComponent("libp2p:ping"),this.started=!1,this.protocol=`/${t.protocolPrefix??RE}/${kE}/${PE}`,this.timeout=t.timeout??LE,this.maxInboundStreams=t.maxInboundStreams??DE,this.maxOutboundStreams=t.maxOutboundStreams??ME,this.runOnLimitedConnection=t.runOnLimitedConnection??!0,this.handleMessage=this.handleMessage.bind(this)}[Symbol.toStringTag]="@libp2p/ping";[rt]=["@libp2p/ping"];async start(){await this.components.registrar.handle(this.protocol,this.handleMessage,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(e){this.log("incoming ping from %p",e.connection.remotePeer);const{stream:t}=e,n=Date.now(),s=_i(t);let i=!1;Promise.resolve().then(async()=>{for(;;){const o=AbortSignal.timeout(this.timeout);o.addEventListener("abort",()=>{t?.abort(new hc("ping timeout"))});const a=await s.read({bytes:Ho,signal:o});await s.write(a,{signal:o}),i=!0}}).catch(o=>{i&&o.name==="UnexpectedEOFError"&&t.readStatus!=="ready"||(this.log.error("incoming ping from %p failed with error - %e",e.connection.remotePeer,o),t?.abort(o))}).finally(()=>{const o=Date.now()-n;this.log("incoming ping from %p complete in %dms",e.connection.remotePeer,o);const a=AbortSignal.timeout(this.timeout);t.close({signal:a}).catch(c=>{this.log.error("error closing ping stream from %p - %e",e.connection.remotePeer,c),t?.abort(c)})})}async ping(e,t={}){this.log("pinging %p",e);const n=Date.now(),s=Lc(Ho),i=await this.components.connectionManager.openConnection(e,t);let o;if(t.signal==null){const a=AbortSignal.timeout(this.timeout);t={...t,signal:a}}try{o=await i.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const a=_i(o),[,c]=await Promise.all([a.write(s,t),a.read({...t,bytes:Ho})]),l=Date.now()-n;if(!ke(s,c.subarray()))throw new im(`Received wrong ping ack after ${l}ms`);return this.log("ping %p complete in %dms",i.remotePeer,l),l}catch(a){throw this.log.error("error while pinging %p",i.remotePeer,a),o?.abort(a),a}finally{o!=null&&await o.close(t)}}}function FE(r={}){return e=>new OE(e,r)}var Ke;(function(r){(function(n){n.FIN="FIN",n.STOP_SENDING="STOP_SENDING",n.RESET="RESET",n.FIN_ACK="FIN_ACK"})(r.Flag||(r.Flag={}));let e;(function(n){n[n.FIN=0]="FIN",n[n.STOP_SENDING=1]="STOP_SENDING",n[n.RESET=2]="RESET",n[n.FIN_ACK=3]="FIN_ACK"})(e||(e={})),function(n){n.codec=()=>bn(e)}(r.Flag||(r.Flag={}));let t;r.codec=()=>(t==null&&(t=we((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.flag!=null&&(s.uint32(8),r.Flag.codec().encode(n.flag,s)),n.message!=null&&(s.uint32(18),s.bytes(n.message)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.flag=r.Flag.codec().decode(n);break}case 2:{o.message=n.bytes();break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>ye(n,r.codec()),r.decode=(n,s)=>me(n,r.codec(),s)})(Ke||(Ke={}));const NE=["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478","stun:stun.cloudflare.com:3478","stun:stun.services.mozilla.com:3478"];Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");const BE=2*1024*1024,UE=30*1e3,ap=16*1024;function $E(r=ap){const e=Ie(r-Ie(r)),t=1+Ie(Object.keys(Ke.Flag).length-1),n=1,s=r-e-t-n,i=Ie(s);return e+t+n+i}const qE=$E(),WE=5e3,zE=5e3,KE=3e4,cp="/webrtc",Va="/webrtc-signaling/0.0.1";var Ou=function(r,e,t){if(t||arguments.length===2)for(var n=0,s=e.length,i;n<s;n++)(i||!(n in e))&&(i||(i=Array.prototype.slice.call(e,0,n)),i[n]=e[n]);return r.concat(i||Array.prototype.slice.call(e))},HE=function(){function r(e,t,n){this.name=e,this.version=t,this.os=n,this.type="browser"}return r}(),VE=function(){function r(e){this.version=e,this.type="node",this.name="node",this.os=process.platform}return r}(),GE=function(){function r(e,t,n,s){this.name=e,this.version=t,this.os=n,this.bot=s,this.type="bot-device"}return r}(),jE=function(){function r(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return r}(),YE=function(){function r(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return r}(),XE=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,QE=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,Fu=3,ZE=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",XE]],Nu=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function JE(r){return typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new YE:typeof navigator<"u"?t_(navigator.userAgent):n_()}function e_(r){return r!==""&&ZE.reduce(function(e,t){var n=t[0],s=t[1];if(e)return e;var i=s.exec(r);return!!i&&[n,i]},!1)}function t_(r){var e=e_(r);if(!e)return null;var t=e[0],n=e[1];if(t==="searchbot")return new jE;var s=n[1]&&n[1].split(".").join("_").split("_").slice(0,3);s?s.length<Fu&&(s=Ou(Ou([],s,!0),s_(Fu-s.length),!0)):s=[];var i=s.join("."),o=r_(r),a=QE.exec(r);return a&&a[1]?new GE(t,i,o,a[1]):new HE(t,i,o)}function r_(r){for(var e=0,t=Nu.length;e<t;e++){var n=Nu[e],s=n[0],i=n[1],o=i.exec(r);if(o)return s}return null}function n_(){var r=typeof process<"u"&&process.version;return r?new VE(process.version.slice(1)):null}function s_(r){for(var e=[],t=0;t<r;t++)e.push("0");return e}class lp extends Error{constructor(e){super(e),this.name="TimeoutError"}}let i_=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}};const Bu=r=>globalThis.DOMException===void 0?new i_(r):new DOMException(r),Uu=r=>{const e=r.reason===void 0?Bu("This operation was aborted."):r.reason;return e instanceof Error?e:Bu(e)};function Xc(r,e){const{milliseconds:t,fallback:n,message:s,customTimers:i={setTimeout,clearTimeout}}=e;let o,a;const l=new Promise((u,d)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(e.signal){const{signal:p}=e;p.aborted&&d(Uu(p)),a=()=>{d(Uu(p))},p.addEventListener("abort",a,{once:!0})}if(t===Number.POSITIVE_INFINITY){r.then(u,d);return}const h=new lp;o=i.setTimeout.call(void 0,()=>{if(n){try{u(n())}catch(p){d(p)}return}typeof r.cancel=="function"&&r.cancel(),s===!1?u():s instanceof Error?d(s):(h.message=s??`Promise timed out after ${t} milliseconds`,d(h))},t),(async()=>{try{u(await r)}catch(p){d(p)}})()}).finally(()=>{l.clear(),a&&e.signal&&e.signal.removeEventListener("abort",a)});return l.clear=()=>{i.clearTimeout.call(void 0,o),o=void 0},l}const $u=JE(),up=$u!=null&&$u.name==="firefox",dp=async function*(){},hp=async r=>{};function o_(r,e,t=KE,n){r.readyState==="open"&&Promise.resolve().then(async()=>{if(r.bufferedAmount>0){n.log("%s drain channel with %d buffered bytes",e,r.bufferedAmount);const s=pe();let i=!1;r.bufferedAmountLowThreshold=0;const o=()=>{i||(n.log("%s drain channel closed before drain",e),s.resolve())};r.addEventListener("close",o,{once:!0}),r.addEventListener("bufferedamountlow",()=>{i=!0,r.removeEventListener("close",o),s.resolve()}),await Xc(s.promise,{milliseconds:t})}}).then(async()=>{r.readyState==="open"&&r.close()}).catch(s=>{n.log.error("error closing outbound stream",s)})}async function qu(r){return r=r??{},typeof r=="function"&&(r=await r()),r.iceServers=r.iceServers??NE.map(e=>({urls:[e]})),r}class Wu{log;peerConnection;remoteAddr;timeline;metrics;source=dp();sink=hp;constructor(e,t){this.log=e.logger.forComponent("libp2p:webrtc:maconn"),this.remoteAddr=t.remoteAddr,this.timeline=t.timeline,this.peerConnection=t.peerConnection;const n=this.peerConnection,s=n.connectionState;this.peerConnection.onconnectionstatechange=()=>{this.log.trace("peer connection state change",n.connectionState,"initial state",s),(n.connectionState==="disconnected"||n.connectionState==="failed"||n.connectionState==="closed")&&(this.timeline.close=Date.now())}}async close(e){this.log.trace("closing connection"),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({close:!0})}abort(e){this.log.error("closing connection due to error",e),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({abort:!0})}}class a_ extends Bc{channel;incomingData;maxBufferedAmount;bufferedAmountLowEventTimeout;maxMessageSize;receiveFinAck;finAckTimeout;openTimeout;closeController;constructor(e){const t=e.onEnd;switch(e.onEnd=s=>{this.log.trace('readable and writeable ends closed with status "%s"',this.status),Promise.resolve(async()=>{if(!(this.timeline.abort!=null||this.timeline.reset!==null))try{await Xc(this.receiveFinAck.promise,{milliseconds:this.finAckTimeout})}catch(i){this.log.error("error receiving FIN_ACK",i)}}).then(()=>{this.incomingData.end(),t?.(s)}).catch(i=>{this.log.error("error ending stream",i)}).finally(()=>{this.channel.close()})},super(e),this.channel=e.channel,this.channel.binaryType="arraybuffer",this.incomingData=gs(),this.bufferedAmountLowEventTimeout=e.bufferedAmountLowEventTimeout??UE,this.maxBufferedAmount=e.maxBufferedAmount??BE,this.maxMessageSize=(e.maxMessageSize??ap)-qE,this.receiveFinAck=pe(),this.finAckTimeout=e.closeTimeout??WE,this.openTimeout=e.openTimeout??zE,this.closeController=new AbortController,this.channel.readyState){case"open":this.timeline.open=new Date().getTime();break;case"closed":case"closing":(this.timeline.close===void 0||this.timeline.close===0)&&(this.timeline.close=Date.now());break;case"connecting":break;default:throw this.log.error("unknown datachannel state %s",this.channel.readyState),new ba("Unknown datachannel state")}this.channel.onopen=s=>{this.timeline.open=new Date().getTime()},this.channel.onclose=s=>{this.log.trace("received onclose event"),this.closeController.abort(),this.receiveFinAck.resolve(),this.close().catch(i=>{this.log.error("error closing stream after channel closed",i)})},this.channel.onerror=s=>{this.log.trace("received onerror event"),this.closeController.abort();const i=s.error;this.abort(i)},this.channel.onmessage=async s=>{const{data:i}=s;i===null||i.byteLength===0||this.incomingData.push(new Uint8Array(i,0,i.byteLength))};const n=this;Promise.resolve().then(async()=>{for await(const s of Ei(this.incomingData)){const i=n.processIncomingProtobuf(s);i!=null&&n.sourcePush(new J(i))}}).catch(s=>{this.log.error("error processing incoming data channel messages",s)})}sendNewStream(){}async _sendMessage(e,t=!0){if(this.channel.readyState==="closed"||this.channel.readyState==="closing")throw new ba(`Invalid datachannel state - ${this.channel.readyState}`);if(this.channel.readyState!=="open"){const n=AbortSignal.timeout(this.openTimeout),s=Jt([this.closeController.signal,n]);try{this.log('channel state is "%s" and not "open", waiting for "open" event before sending data',this.channel.readyState),await Gr(this.channel,"open",s)}finally{s.clear()}this.log('channel state is now "%s", sending data',this.channel.readyState)}if(t&&this.channel.bufferedAmount>this.maxBufferedAmount){const n=AbortSignal.timeout(this.bufferedAmountLowEventTimeout),s=Jt([this.closeController.signal,n]);try{this.log('channel buffer is %d, wait for "bufferedamountlow" event',this.channel.bufferedAmount),await Gr(this.channel,"bufferedamountlow",s)}catch(i){throw n.aborted?new hc(`Timed out waiting for DataChannel buffer to clear after ${this.bufferedAmountLowEventTimeout}ms`):i}finally{s.clear()}}try{this.log.trace('sending message, channel state "%s"',this.channel.readyState),this.channel.send(e.subarray())}catch(n){this.log.error("error while sending message",n)}}async sendData(e){const t=e.byteLength;for(e=e.sublist();e.byteLength>0;){const n=Math.min(e.byteLength,this.maxMessageSize),s=e.subarray(0,n),i=Ke.encode({message:s}),o=Si.single(i);this.log.trace("sending %d/%d bytes on channel",s.byteLength,t),await this._sendMessage(o),e.consume(n)}this.log.trace('finished sending data, channel state "%s"',this.channel.readyState)}async sendReset(){try{await this._sendFlag(Ke.Flag.RESET)}catch(e){this.log.error("failed to send reset - %e",e)}finally{this.channel.close()}}async sendCloseWrite(e){if(this.channel.readyState!=="open"){this.receiveFinAck.resolve();return}if(await this._sendFlag(Ke.Flag.FIN)){this.log.trace("awaiting FIN_ACK");try{await _e(this.receiveFinAck.promise,e?.signal,{errorMessage:"sending close-write was aborted before FIN_ACK was received",errorName:"FinAckNotReceivedError"})}catch(n){this.log.error("failed to await FIN_ACK",n)}}else this.log.trace("sending FIN failed, not awaiting FIN_ACK");this.receiveFinAck.resolve()}async sendCloseRead(){this.channel.readyState==="open"&&await this._sendFlag(Ke.Flag.STOP_SENDING)}processIncomingProtobuf(e){const t=Ke.decode(e);if(t.flag!==void 0&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',t.flag,this.writeStatus,this.readStatus),t.flag===Ke.Flag.FIN&&(this.remoteCloseWrite(),this.log.trace("sending FIN_ACK"),this._sendFlag(Ke.Flag.FIN_ACK).catch(n=>{this.log.error("error sending FIN_ACK immediately",n)})),t.flag===Ke.Flag.RESET&&this.reset(),t.flag===Ke.Flag.STOP_SENDING&&this.remoteCloseRead(),t.flag===Ke.Flag.FIN_ACK&&(this.log.trace("received FIN_ACK"),this.receiveFinAck.resolve())),this.readStatus==="ready")return t.message}async _sendFlag(e){if(this.channel.readyState!=="open")return this.log.trace('not sending flag %s because channel is "%s" and not "open"',e.toString(),this.channel.readyState),!1;this.log.trace("sending flag %s",e.toString());const t=Ke.encode({flag:e}),n=Si.single(t);try{return await this._sendMessage(n,!1),!0}catch(s){this.log.error("could not send flag %s - %e",e.toString(),s)}return!1}}function Ga(r){const{channel:e,direction:t,handshake:n}=r;return new a_({id:`${e.id}`,log:r.logger.forComponent(`libp2p:webrtc:stream:${n===!0?"handshake":t}:${e.id}`),...r})}class fp{protocol;peerConnection;bufferedStreams=[];metrics;dataChannelOptions;components;log;constructor(e,t){this.components=e,this.peerConnection=t.peerConnection,this.metrics=t.metrics,this.protocol=t.protocol??cp,this.dataChannelOptions=t.dataChannelOptions??{},this.log=e.logger.forComponent("libp2p:webrtc:muxerfactory"),this.peerConnection.ondatachannel=({channel:n})=>{if(this.log.trace('incoming early datachannel with channel id %d and label "%s"',n.id),n.label==="init"){this.log.trace("closing early init channel"),n.close();return}const s={},i=Ga({channel:n,direction:"inbound",onEnd:o=>{s.onEnd(o)},logger:e.logger,...this.dataChannelOptions});s.stream=i,s.channel=n,s.onEnd=()=>{this.bufferedStreams=this.bufferedStreams.filter(o=>o.stream.id!==i.id)},this.bufferedStreams.push(s)}}createStreamMuxer(e){return new c_(this.components,{...e,peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,streams:this.bufferedStreams,protocol:this.protocol})}}class c_{init;streams;protocol;log;peerConnection;dataChannelOptions;metrics;logger;constructor(e,t){this.init=t,this.log=e.logger.forComponent("libp2p:webrtc:muxer"),this.logger=e.logger,this.streams=t.streams.map(n=>n.stream),this.peerConnection=t.peerConnection,this.protocol=t.protocol??cp,this.metrics=t.metrics,this.dataChannelOptions=t.dataChannelOptions??{},this.peerConnection.ondatachannel=({channel:n})=>{if(this.log.trace("incoming datachannel with channel id %d",n.id),n.label==="init"){this.log.trace("closing init channel"),n.close();return}const s=n.id,i=Ga({channel:n,direction:"inbound",onEnd:()=>{this.#e(i,n),this.log("incoming channel %s ended",s)},logger:this.logger,...this.dataChannelOptions});this.streams.push(i),this.metrics?.increment({incoming_stream:!0}),t?.onIncomingStream?.(i)},this.init.streams.length>0&&queueMicrotask(()=>{this.init.streams.forEach(n=>{n.onEnd=()=>{this.log("incoming early channel %s ended with state %s",n.channel.id,n.channel.readyState),this.#e(n.stream,n.channel)},this.metrics?.increment({incoming_stream:!0}),this.init?.onIncomingStream?.(n.stream)})})}#e(e,t){this.log.trace("stream %s %s %s onEnd",e.direction,e.id,e.protocol),o_(t,`${e.direction} ${e.id} ${e.protocol}`,this.dataChannelOptions.drainTimeout,{log:this.log}),this.streams=this.streams.filter(n=>n.id!==e.id),this.metrics?.increment({stream_end:!0}),this.init?.onStreamEnd?.(e)}async close(e){try{await Promise.all(this.streams.map(async t=>t.close(e)))}catch(t){this.abort(t)}}abort(e){for(const t of this.streams)t.abort(e)}source=dp();sink=hp;newStream(){const e=this.peerConnection.createDataChannel(""),t=e.id;this.log.trace("opened outgoing datachannel with channel id %s",t);const n=Ga({channel:e,direction:"outbound",onEnd:()=>{this.#e(n,e),this.log("outgoing channel %s ended",t)},logger:this.logger,...this.dataChannelOptions});return this.streams.push(n),this.metrics?.increment({outgoing_stream:!0}),n}}const pp=globalThis.RTCPeerConnection,gp=globalThis.RTCSessionDescription,l_=globalThis.RTCIceCandidate;class u_ extends Error{constructor(e){super(`WebRTC transport error: ${e}`),this.name="WebRTCTransportError"}}class Kt extends u_{constructor(e="SDP handshake failed"){super(e),this.name="SDPHandshakeFailedError"}}var lt;(function(r){(function(n){n.SDP_OFFER="SDP_OFFER",n.SDP_ANSWER="SDP_ANSWER",n.ICE_CANDIDATE="ICE_CANDIDATE"})(r.Type||(r.Type={}));let e;(function(n){n[n.SDP_OFFER=0]="SDP_OFFER",n[n.SDP_ANSWER=1]="SDP_ANSWER",n[n.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(e||(e={})),function(n){n.codec=()=>bn(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=we((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.data!=null&&(s.uint32(18),s.string(n.data)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.data=n.string();break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>ye(n,r.codec()),r.decode=(n,s)=>me(n,r.codec(),s)})(lt||(lt={}));const mp=async(r,e,t)=>{try{const n=pe();for(d_(r,n);;){const s=await Promise.race([n.promise,e.read({signal:t.signal}).catch(()=>{})]);if(s==null){t.signal?.throwIfAborted();break}if(s.type!==lt.Type.ICE_CANDIDATE)throw new mt("ICE candidate message expected");const i=JSON.parse(s.data??"null");if(i===""||i===null){t.onProgress?.(new te("webrtc:end-of-ice-candidates")),t.log.trace("end-of-candidates received");continue}const o=new l_(i);t.log.trace("%s received new ICE candidate %o",t.direction,i);try{t.onProgress?.(new te("webrtc:add-ice-candidate",o.candidate)),await r.addIceCandidate(o)}catch(a){t.log.error("%s bad candidate received",t.direction,i,a)}}}catch(n){if(t.log.error("%s error parsing ICE candidate",t.direction,n),t.signal?.aborted===!0&&Qc(r)!=="connected")throw n}};function Qc(r){return up?r.iceConnectionState:r.connectionState}function d_(r,e){r[up?"oniceconnectionstatechange":"onconnectionstatechange"]=t=>{switch(Qc(r)){case"connected":e.resolve();break;case"failed":case"disconnected":case"closed":e.reject(new rh("RTCPeerConnection was closed"));break}}}async function h_({rtcConfiguration:r,dataChannel:e,signal:t,metrics:n,multiaddr:s,connectionManager:i,transportManager:o,log:a,logger:c,onProgress:l}){const{baseAddr:u}=g_(s);n?.dialerEvents.increment({open:!0}),a.trace("dialing base address: %a",u);const d=u.getPeerId();if(d==null)throw new K("Relay peer was missing");const h=i.getConnections(dt(d));let p,f=!1;h.length===0?(l?.(new te("webrtc:dial-relay")),p=await o.dial(u,{signal:t,onProgress:l}),f=!0):(l?.(new te("webrtc:reuse-relay-connection")),p=h[0]);try{l?.(new te("webrtc:open-signaling-stream"));const g=await p.newStream(Va,{signal:t,runOnLimitedConnection:!0}),m=Dt(g).pb(lt),S=new pp(r),x=new fp({logger:c},{peerConnection:S,dataChannelOptions:e});try{const w=S.createDataChannel("init");S.onicecandidate=({candidate:E})=>{const A=JSON.stringify(E?.toJSON()??null);a.trace("initiator sending ICE candidate %o",E),m.write({type:lt.Type.ICE_CANDIDATE,data:A},{signal:t}).catch(T=>{a.error("error sending ICE candidate",T)})},S.onicecandidateerror=E=>{a.error("initiator ICE candidate error",E)};const y=await S.createOffer().catch(E=>{throw a.error("could not execute createOffer",E),new Kt("Failed to set createOffer")});a.trace("initiator send SDP offer %s",y.sdp),l?.(new te("webrtc:send-sdp-offer")),await m.write({type:lt.Type.SDP_OFFER,data:y.sdp},{signal:t}),await S.setLocalDescription(y).catch(E=>{throw a.error("could not execute setLocalDescription",E),new Kt("Failed to set localDescription")}),l?.(new te("webrtc:read-sdp-answer")),a.trace("initiator read SDP answer");const v=await m.read({signal:t});if(v.type!==lt.Type.SDP_ANSWER)throw new Kt("Remote should send an SDP answer");a.trace("initiator received SDP answer %s",v.data);const C=new gp({type:"answer",sdp:v.data});return await S.setRemoteDescription(C).catch(E=>{throw a.error("could not execute setRemoteDescription",E),new Kt("Failed to set remoteDescription")}),a.trace("initiator read candidates until connected"),l?.(new te("webrtc:read-ice-candidates")),await mp(S,m,{direction:"initiator",signal:t,log:a,onProgress:l}),a.trace("initiator connected, closing init channel"),w.close(),l?.(new te("webrtc:close-signaling-stream")),a.trace("closing signaling channel"),await g.close({signal:t}),a.trace("initiator connected to remote address %s",s),{remoteAddress:s,peerConnection:S,muxerFactory:x}}catch(w){throw a.error("outgoing signaling error",w),S.close(),g.abort(w),w}finally{S.onicecandidate=null,S.onicecandidateerror=null}}finally{if(f)try{await p.close({signal:t})}catch(g){p.abort(g)}}}const zu=de(Xf.matchers[0],X("p2p-circuit"));class Zc extends Qt{transportManager;shutdownController;events;constructor(e,t){super(),this.transportManager=e.transportManager,this.events=e.events,this.shutdownController=t.shutdownController,this.onTransportListening=this.onTransportListening.bind(this)}async listen(){this.events.addEventListener("transport:listening",this.onTransportListening)}onTransportListening(e){e.detail.getAddrs().filter(n=>zu.exactMatch(n)).map(n=>n.encapsulate("/webrtc")).length>0&&this.safeDispatchEvent("listening")}getAddrs(){return this.transportManager.getListeners().filter(e=>!(e instanceof Zc)).map(e=>e.getAddrs().filter(t=>zu.exactMatch(t)).map(t=>t.encapsulate("/webrtc"))).flat()}updateAnnounceAddrs(){}async close(){this.events.removeEventListener("transport:listening",this.onTransportListening),this.shutdownController.abort(),queueMicrotask(()=>{this.safeDispatchEvent("close")})}}async function f_({peerConnection:r,stream:e,signal:t,connection:n,log:s}){s.trace("new inbound signaling stream");const i=Dt(e).pb(lt);try{r.onicecandidate=({candidate:u})=>{const d=JSON.stringify(u?.toJSON()??null);s.trace("recipient sending ICE candidate %s",d),i.write({type:lt.Type.ICE_CANDIDATE,data:d},{signal:t}).catch(h=>{s.error("error sending ICE candidate",h)})},s.trace("recipient read SDP offer");const a=await i.read({signal:t});if(a.type!==lt.Type.SDP_OFFER)throw new Kt(`expected message type SDP_OFFER, received: ${a.type??"undefined"} `);s.trace("recipient received SDP offer %s",a.data);const c=new gp({type:"offer",sdp:a.data});await r.setRemoteDescription(c).catch(u=>{throw s.error("could not execute setRemoteDescription",u),new Kt("Failed to set remoteDescription")});const l=await r.createAnswer().catch(u=>{throw s.error("could not execute createAnswer",u),new Kt("Failed to create answer")});s.trace("recipient send SDP answer %s",l.sdp),await i.write({type:lt.Type.SDP_ANSWER,data:l.sdp},{signal:t}),await r.setLocalDescription(l).catch(u=>{throw s.error("could not execute setLocalDescription",u),new Kt("Failed to set localDescription")}),s.trace("recipient read candidates until connected"),await mp(r,i,{direction:"recipient",signal:t,log:s})}catch(a){if(Qc(r)!=="connected")throw s.error("error while handling signaling stream from peer %a",n.remoteAddr,a),r.close(),a;s("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",n.remoteAddr,a)}const o=Y(`/webrtc/p2p/${n.remoteAddr.getPeerId()}`);return s.trace("recipient connected to remote address %s",o),{remoteAddress:o}}class p_{components;init;log;_started=!1;metrics;shutdownController;constructor(e,t={}){this.components=e,this.init=t,this.log=e.logger.forComponent("libp2p:webrtc"),this.shutdownController=new AbortController,this.shutdownController.signal,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}[Zi]=!0;[Symbol.toStringTag]="@libp2p/webrtc";[rt]=["@libp2p/transport"];[li]=["@libp2p/identify","@libp2p/circuit-relay-v2-transport"];isStarted(){return this._started}async start(){await this.components.registrar.handle(Va,e=>{const t=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);this._onProtocol(e,t).catch(n=>{this.log.error("failed to handle incoming connect from %p",e.connection.remotePeer,n)}).finally(()=>{t.clear()})},{runOnLimitedConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(Va),this._started=!1}createListener(e){return new Zc(this.components,{shutdownController:this.shutdownController})}listenFilter(e){return e.filter(za.exactMatch)}dialFilter(e){return this.listenFilter(e)}async dial(e,t){this.log.trace("dialing address: %a",e);const{remoteAddress:n,peerConnection:s,muxerFactory:i}=await h_({rtcConfiguration:await qu(this.init.rtcConfiguration),dataChannel:this.init.dataChannel,multiaddr:e,dataChannelOptions:this.init.dataChannel,signal:t.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager,log:this.log,logger:this.components.logger,onProgress:t.onProgress}),o=new Wu(this.components,{peerConnection:s,timeline:{open:Date.now()},remoteAddr:n,metrics:this.metrics?.dialerEvents}),a=await t.upgrader.upgradeOutbound(o,{skipProtection:!0,skipEncryption:!0,muxerFactory:i,onProgress:t.onProgress,signal:t.signal});return this._closeOnShutdown(s,o),a}async _onProtocol({connection:e,stream:t},n){const s=new pp(await qu(this.init.rtcConfiguration)),i=new fp(this.components,{peerConnection:s,dataChannelOptions:this.init.dataChannel});try{const{remoteAddress:o}=await f_({peerConnection:s,connection:e,stream:t,signal:n,log:this.log});await t.close({signal:n});const a=new Wu(this.components,{peerConnection:s,timeline:{open:new Date().getTime()},remoteAddr:o,metrics:this.metrics?.listenerEvents});await this.components.upgrader.upgradeInbound(a,{skipEncryption:!0,skipProtection:!0,muxerFactory:i,signal:n}),this._closeOnShutdown(s,a)}catch(o){throw this.log.error("incoming signaling error",o),s.close(),t.abort(o),o}}_closeOnShutdown(e,t){const n=()=>{t.close().catch(s=>{this.log.error("could not close WebRTCMultiaddrConnection",s)})};this.shutdownController.signal.addEventListener("abort",n),e.addEventListener("close",()=>{this.shutdownController.signal.removeEventListener("abort",n)})}}function g_(r){const e=r.toString().split("/webrtc/");if(e.length!==2)throw new K("webrtc protocol was not present in multiaddr");if(!e[0].includes("/p2p-circuit"))throw new K("p2p-circuit protocol was not present in multiaddr");let t=Y(e[0]);const s=Y("/"+e[1]).getPeerId();if(s==null)throw new K("destination peer id was missing");const i=t.protos().pop();if(i===void 0)throw new K("invalid multiaddr");return i.name!=="p2p"&&(t=t.encapsulate(`/p2p/${s}`)),{baseAddr:t,peerId:dt(s)}}const xt="/",yp=new TextEncoder().encode(xt),Ns=yp[0];class $e{_buf;constructor(e,t){if(typeof e=="string")this._buf=z(e);else if(e instanceof Uint8Array)this._buf=e;else throw new Error("Invalid key, should be String of Uint8Array");if(t==null&&(t=!0),t&&this.clean(),this._buf.byteLength===0||this._buf[0]!==Ns)throw new Error("Invalid key")}toString(e="utf8"){return G(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new $e(e.join(xt))}static random(){return new $e(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||typeof e=="string"?new $e(e):typeof e.uint8Array=="function"?new $e(e.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=yp),this._buf[0]!==Ns){const e=new Uint8Array(this._buf.byteLength+1);e.fill(Ns,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===Ns;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),n=e.list();for(let s=0;s<t.length;s++){if(n.length<s+1)return!1;const i=t[s],o=n[s];if(i<o)return!0;if(i>o)return!1}return t.length<n.length}reverse(){return $e.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(xt).slice(1)}type(){return m_(this.baseNamespace())}name(){return y_(this.baseNamespace())}instance(e){return new $e(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(xt)||(e+=xt),e+=this.type(),new $e(e)}parent(){const e=this.list();return e.length===1?new $e(xt):new $e(e.slice(0,-1).join(xt))}child(e){return this.toString()===xt?e:e.toString()===xt?this:new $e(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()===this.toString()?!1:e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()===this.toString()?!1:this.toString().startsWith(e.toString())}isTopLevel(){return this.list().length===1}concat(...e){return $e.withNamespaces([...this.namespaces(),...w_(e.map(t=>t.namespaces()))])}}function m_(r){const e=r.split(":");return e.length<2?"":e.slice(0,-1).join(":")}function y_(r){const e=r.split(":");return e[e.length-1]}function w_(r){return[].concat(...r)}function b_(r){return e=>new p_(e,r)}const v_=[V("tcp").code,V("dns").code,V("dnsaddr").code,V("dns4").code,V("dns6").code];function Ku(r){return wp("sni",r)?.[1]}function Hu(r){const e=wp("tcp",r)?.[1];return e==null?"":`:${e}`}function wp(r,e){let t;try{t=V(r).code}catch{return}for(const[n,s]of e)if(n===t&&s!=null)return[n,s]}function Vu(r){return r.some(([e,t])=>e===V("tls").code)}function ot(r,e,t){const n=bp[V(r).name];if(n==null)throw new Error(`Can't interpret protocol ${V(r).name}`);const s=n(e,t);return r===V("ip6").code?`[${s}]`:s}const bp={ip4:(r,e)=>r,ip6:(r,e)=>e.length===0?r:`[${r}]`,tcp:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`tcp://${ot(t[0],t[1]??"",e)}:${r}`},udp:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`udp://${ot(t[0],t[1]??"",e)}:${r}`},dnsaddr:(r,e)=>r,dns4:(r,e)=>r,dns6:(r,e)=>r,dns:(r,e)=>r,ipfs:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${ot(t[0],t[1]??"",e)}`},p2p:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${ot(t[0],t[1]??"",e)}`},http:(r,e)=>{const t=Vu(e),n=Ku(e),s=Hu(e);if(t&&n!=null)return`https://${n}${s}`;const i=t?"https://":"http://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=ot(o[0],o[1]??"",e);return a=a.replace("tcp://",""),`${i}${a}`},"http-path":(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");const n=ot(t[0],t[1]??"",e),s=decodeURIComponent(r);return`${n}/${s}`},tls:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return ot(t[0],t[1]??"",e)},sni:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return ot(t[0],t[1]??"",e)},https:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let n=ot(t[0],t[1]??"",e);return n=n.replace("tcp://",""),`https://${n}`},ws:(r,e)=>{const t=Vu(e),n=Ku(e),s=Hu(e);if(t&&n!=null)return`wss://${n}${s}`;const i=t?"wss://":"ws://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=ot(o[0],o[1]??"",e);return a=a.replace("tcp://",""),`${i}${a}`},wss:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let n=ot(t[0],t[1]??"",e);return n=n.replace("tcp://",""),`wss://${n}`}};function S_(r,e){const n=Y(r).stringTuples(),s=n.pop();if(s==null)throw new Error("Unexpected end of multiaddr");const i=V(s[0]),o=bp[i.name];if(o==null)throw new Error(`No interpreter found for ${i.name}`);let a=o(s[1]??"",n);return v_.includes(s[0])&&(a=a.replace(/^.*:\/\//,""),s[1]==="443"?a=`https://${a}`:a=`http://${a}`),(a.startsWith("http://")||a.startsWith("https://")||a.startsWith("ws://")||a.startsWith("wss://"))&&(a=new URL(a).toString(),a.endsWith("/")&&(a=a.substring(0,a.length-1))),a}const E_=async r=>{if(r.readyState>=2)throw new Error("socket closed");r.readyState!==1&&await new Promise((e,t)=>{function n(){r.removeEventListener("open",s),r.removeEventListener("error",i)}function s(){n(),e()}function i(o){n(),t(o.error??new Error(`connect ECONNREFUSED ${r.url}`))}r.addEventListener("open",s),r.addEventListener("error",i)})},__=(r,e)=>(e=e??{},e.closeOnEnd=e.closeOnEnd!==!1,async n=>{for await(const s of n){try{await E_(r)}catch(i){if(i.message==="socket closed")break;throw i}if(r.readyState===r.CLOSING||r.readyState===r.CLOSED)break;r.send(s)}e.closeOnEnd!=null&&r.readyState<=1&&await new Promise((s,i)=>{r.addEventListener("close",o=>{if(o.wasClean||o.code===1006)s();else{const a=Object.assign(new Error("ws error"),{event:o});i(a)}}),setTimeout(()=>{r.close()})})});var Nr={},Pn={},Gu;function x_(){if(Gu)return Pn;Gu=1,Object.defineProperty(Pn,"__esModule",{value:!0});class r{constructor(){this.pullQueue=[],this.pushQueue=[],this.eventHandlers={},this.isPaused=!1,this.isStopped=!1}push(n){if(this.isStopped)return;const s={value:n,done:!1};if(this.pullQueue.length){const i=this.pullQueue.shift();i&&i.resolve(s)}else this.pushQueue.push(Promise.resolve(s)),this.highWaterMark!==void 0&&this.pushQueue.length>=this.highWaterMark&&!this.isPaused&&(this.isPaused=!0,this.eventHandlers.highWater?this.eventHandlers.highWater():console&&console.warn(`EventIterator queue reached ${this.pushQueue.length} items`))}stop(){if(!this.isStopped){this.isStopped=!0,this.remove();for(const n of this.pullQueue)n.resolve({value:void 0,done:!0});this.pullQueue.length=0}}fail(n){if(!this.isStopped)if(this.isStopped=!0,this.remove(),this.pullQueue.length){for(const s of this.pullQueue)s.reject(n);this.pullQueue.length=0}else{const s=Promise.reject(n);s.catch(()=>{}),this.pushQueue.push(s)}}remove(){Promise.resolve().then(()=>{this.removeCallback&&this.removeCallback()})}[Symbol.asyncIterator](){return{next:n=>{const s=this.pushQueue.shift();return s?(this.lowWaterMark!==void 0&&this.pushQueue.length<=this.lowWaterMark&&this.isPaused&&(this.isPaused=!1,this.eventHandlers.lowWater&&this.eventHandlers.lowWater()),s):this.isStopped?Promise.resolve({value:void 0,done:!0}):new Promise((i,o)=>{this.pullQueue.push({resolve:i,reject:o})})},return:()=>(this.isStopped=!0,this.pushQueue.length=0,this.remove(),Promise.resolve({value:void 0,done:!0}))}}}class e{constructor(n,{highWaterMark:s=100,lowWaterMark:i=1}={}){const o=new r;o.highWaterMark=s,o.lowWaterMark=i,o.removeCallback=n({push:a=>o.push(a),stop:()=>o.stop(),fail:a=>o.fail(a),on:(a,c)=>{o.eventHandlers[a]=c}})||(()=>{}),this[Symbol.asyncIterator]=()=>o[Symbol.asyncIterator](),Object.freeze(this)}}return Pn.EventIterator=e,Pn.default=e,Pn}var ju;function A_(){if(ju)return Nr;ju=1,Object.defineProperty(Nr,"__esModule",{value:!0});const r=x_();Nr.EventIterator=r.EventIterator;function e(t,n,s){return new r.EventIterator(({push:i})=>(this.addEventListener(t,i,n),()=>this.removeEventListener(t,i,n)),s)}return Nr.subscribe=e,Nr.default=r.EventIterator,Nr}var C_=A_();function Yu(r){return r instanceof ArrayBuffer||r?.constructor?.name==="ArrayBuffer"&&typeof r?.byteLength=="number"}const I_=r=>{r.binaryType="arraybuffer";const e=async()=>{await new Promise((i,o)=>{if(n){i();return}if(s!=null){o(s);return}const a=u=>{r.removeEventListener("open",c),r.removeEventListener("error",l),u()},c=()=>{a(i)},l=u=>{a(()=>{o(u.error??new Error(`connect ECONNREFUSED ${r.url}`))})};r.addEventListener("open",c),r.addEventListener("error",l)})},t=async function*(){const i=new C_.EventIterator(({push:o,stop:a,fail:c})=>{const l=d=>{let h=null;typeof d.data=="string"&&(h=z(d.data)),Yu(d.data)&&(h=new Uint8Array(d.data)),d.data instanceof Uint8Array&&(h=d.data),h!=null&&o(h)},u=d=>{c(d.error??new Error("Socket error"))};return r.addEventListener("message",l),r.addEventListener("error",u),r.addEventListener("close",a),()=>{r.removeEventListener("message",l),r.removeEventListener("error",u),r.removeEventListener("close",a)}},{highWaterMark:1/0});await e();for await(const o of i)yield Yu(o)?new Uint8Array(o):o}();let n=r.readyState===1,s;return r.addEventListener("open",()=>{n=!0,s=null}),r.addEventListener("close",()=>{n=!1,s=null}),r.addEventListener("error",i=>{n||(s=i.error??new Error(`connect ECONNREFUSED ${r.url}`))}),Object.assign(t,{connected:e})},T_=(r,e)=>{e=e??{};const t=I_(r);let n=e.remoteAddress,s=e.remotePort;if(r.url!=null)try{const o=new URL(r.url);n=o.hostname,s=parseInt(o.port,10)}catch{}if(n==null||s==null)throw new Error("Remote connection did not have address and/or port");return{sink:__(r,e),source:t,connected:async()=>{await t.connected()},close:async()=>{(r.readyState===r.CONNECTING||r.readyState===r.OPEN)&&await new Promise(o=>{r.addEventListener("close",()=>{o()}),r.close()})},destroy:()=>{r.terminate!=null?r.terminate():r.close()},remoteAddress:n,remotePort:s,socket:r}},P_=WebSocket,k_={"http:":"ws:","https:":"wss:"},Xu="ws:",R_=(r,e)=>{if(r.startsWith("//")&&(r=`${e?.protocol??Xu}${r}`),r.startsWith("/")&&e!=null){const n=e.protocol??Xu,s=e.host,i=e.port!=null&&s?.endsWith(`:${e.port}`)!==!0?`:${e.port}`:"";r=`${n}//${s}${i}${r}`}const t=new URL(r);for(const[n,s]of Object.entries(k_))t.protocol===n&&(t.protocol=s);return t};function L_(r,e){const t=typeof window>"u"?void 0:window.location;e=e??{};const n=R_(r,t),s=new P_(n.toString(),e.websocket);return T_(s,e)}function vp(r){return r.filter(e=>Ni.exactMatch(e)||Jn.exactMatch(e))}function D_(){throw new Error("WebSocket Servers can not be created in the browser!")}const M_=500;function O_(r,e,t){const n=t.logger.forComponent("libp2p:websockets:maconn"),s=t.metrics,i=t.metricPrefix??"",o={log:n,async sink(a){try{await r.sink(async function*(){for await(const c of a)c instanceof Uint8Array?yield c:yield c.subarray()}())}catch(c){c.type!=="aborted"&&n.error(c)}},source:r.source,remoteAddr:e,timeline:{open:Date.now()},async close(a={}){const c=Date.now();if(a.signal==null){const u=AbortSignal.timeout(M_);a={...a,signal:u}}const l=()=>{const{host:u,port:d}=o.remoteAddr.toOptions();n("timeout closing stream to %s:%s after %dms, destroying it manually",u,d,Date.now()-c),this.abort(new Er("Socket close timeout"))};a.signal?.addEventListener("abort",l);try{await r.close()}catch(u){n.error("error closing WebSocket gracefully",u),this.abort(u)}finally{a.signal?.removeEventListener("abort",l),o.timeline.close=Date.now()}},abort(a){const{host:c,port:l}=o.remoteAddr.toOptions();n("timeout closing stream to %s:%s due to error",c,l,a),r.destroy(),o.timeline.close=Date.now(),s?.increment({[`${i}error`]:!0})}};return r.socket.addEventListener("close",()=>{s?.increment({[`${i}close`]:!0}),o.timeline.close==null&&(o.timeline.close=Date.now())},{once:!0}),o}class F_{log;init;logger;metrics;components;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:websockets"),this.logger=e.logger,this.components=e,this.init=t,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total",{label:"event",help:"Total count of WebSockets dialer events by type"})})}[Zi]=!0;[Symbol.toStringTag]="@libp2p/websockets";[rt]=["@libp2p/transport"];async dial(e,t){this.log("dialing %s",e),t=t??{};const n=await this._connect(e,t),s=O_(n,e,{logger:this.logger,metrics:this.metrics?.dialerEvents});this.log("new outbound connection %s",s.remoteAddr);const i=await t.upgrader.upgradeOutbound(s,t);return this.log("outbound connection %s upgraded",s.remoteAddr),i}async _connect(e,t){t?.signal?.throwIfAborted();const n=e.toOptions();this.log("dialing %s:%s",n.host,n.port);const s=pe(),i=L_(S_(e),this.init);i.socket.addEventListener("error",()=>{const o=new rh(`Could not connect to ${e.toString()}`);this.log.error("connection error:",o),this.metrics?.dialerEvents.increment({error:!0}),s.reject(o)});try{t.onProgress?.(new te("websockets:open-connection")),await _e(Promise.race([i.connected(),s.promise]),t.signal)}catch(o){throw t.signal?.aborted&&this.metrics?.dialerEvents.increment({abort:!0}),i.close().catch(a=>{this.log.error("error closing raw socket",a)}),o}return this.log("connected %s",e),this.metrics?.dialerEvents.increment({connect:!0}),i}createListener(e){return D_({logger:this.logger,events:this.components.events,metrics:this.components.metrics},{...this.init,...e})}listenFilter(e){return e=Array.isArray(e)?e:[e],this.init?.filter!=null?this.init?.filter(e):vp(e)}dialFilter(e){return this.listenFilter(e)}}function N_(r={}){return e=>new F_(e,r)}const B_=1e3;function U_(r){throw new Error("Not implemented")}class $_ extends Bc{writer;reader;constructor(e){super(e),this.writer=e.bidiStream.writable.getWriter(),this.reader=e.bidiStream.readable.getReader(),Promise.resolve().then(async()=>{for(;;){const t=await this.reader.read();if(t.done){e.log("remote closed write");return}t.value!=null&&this.sourcePush(new J(t.value))}}).catch(t=>{e.log.error("error reading from stream",t),this.abort(t)}).finally(()=>{this.remoteCloseWrite()}),this.writer.closed.then(()=>{e.log("writer closed")}).catch(t=>{e.log("writer close promise rejected",t)}).finally(()=>{this.remoteCloseRead()})}sendNewStream(e){}async sendData(e,t){for(const n of e)this.log("sendData waiting for writer to be ready"),await _e(this.writer.ready,t?.signal),this.writer.write(n).catch(s=>{this.log.error("error sending stream data",s)})}async sendReset(e){this.log("sendReset aborting writer"),await _e(this.writer.abort(),e?.signal),this.log("sendReset aborted writer")}async sendCloseWrite(e){this.log("sendCloseWrite closing writer"),await _e(this.writer.close(),e?.signal),this.log("sendCloseWrite closed writer")}async sendCloseRead(e){this.log("sendCloseRead cancelling reader"),await _e(this.reader.cancel(),e?.signal),this.log("sendCloseRead cancelled reader")}}async function Qu(r,e,t,n,s,i){const o=i.forComponent(`libp2p:webtransport:stream:${t}:${e}`),a=new $_({bidiStream:r,id:e,direction:t,log:o,onEnd:()=>{const c=n.findIndex(l=>l===a);c!==-1&&n.splice(c,1),s?.(a)}});return a}function Sp(){return{source:{[Symbol.asyncIterator](){return{async next(){return new Promise(()=>{})}}}},sink:async r=>new Promise(()=>{})}}function q_(r,e,t,n){let s=0;const i=t.forComponent("libp2p:webtransport:muxer");return{protocol:"webtransport",createStreamMuxer:o=>{typeof o=="function"&&(o={onIncomingStream:o});const a=[];Promise.resolve().then(async()=>{//! TODO unclear how to add backpressure here?
for(;;){const{done:l,value:u}=await e.read();if(l)break;if(a.length>=n.maxInboundStreams)i(`too many inbound streams open - ${a.length}/${n.maxInboundStreams}, closing new incoming stream`),u.writable.close().catch(d=>{i.error(`failed to close inbound stream that crossed our maxInboundStream limit: ${d.message}`)}),u.readable.cancel().catch(d=>{i.error(`failed to close inbound stream that crossed our maxInboundStream limit: ${d.message}`)});else{const d=await Qu(u,String(s++),"inbound",a,o?.onStreamEnd,t);a.push(d),o?.onIncomingStream?.(d)}}}).catch(l=>{i.error("could not create a new stream",l)});const c={protocol:"webtransport",streams:a,newStream:async l=>{i("new outgoing stream",l);const u=await r.createBidirectionalStream(),d=await Qu(u,String(s++),o?.direction??"outbound",a,o?.onStreamEnd,t);return a.push(d),d},close:async()=>{i("closing webtransport muxer gracefully");try{r.close()}catch(l){c.abort(l)}},abort:l=>{i("closing webtransport muxer with err:",l);try{r.close()}catch(u){i.error("webtransport session threw error during close",u)}},...Sp()};return c}}}function W_(r,e){return e.filter(n=>!!r.find(s=>ke(n,s))).length===e.length}const z_=Object.values(fi).map(r=>r.decoder).reduce((r,e)=>r.or(e));function K_(r){return rr(z_.decode(r))}function Zu(r){if(!Bi.matches(r))throw new Ji("Invalid multiaddr, was not a WebTransport address");const e=r.stringTuples(),t=e.filter(([o,a])=>o===V("certhash").code).map(([o,a])=>K_(a??"")),n=e.filter(([o,a])=>o===V("p2p").code).map(([o,a])=>dt(a??""))[0],s=r.toOptions();let i=s.host;return s.family===6&&i?.includes(":")&&(i=`[${i}]`),{url:`https://${i}:${s.port}`,certhashes:t,remotePeer:n}}const H_=globalThis.WebTransport;class V_{log;components;config;metrics;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:webtransport"),this.components=e,this.config={...t,maxInboundStreams:t.maxInboundStreams??B_,certificates:t.certificates??[]},e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webtransport_dialer_events_total",{label:"event",help:"Total count of WebTransport dialer events by type"})})}[Symbol.toStringTag]="@libp2p/webtransport";[Zi]=!0;[rt]=["@libp2p/transport"];async dial(e,t){t.signal.throwIfAborted(),this.log("dialing %s",e),t=t??{};const{url:n,certhashes:s,remotePeer:i}=Zu(e);let o,a,c=()=>{},l=!1,u=!1,d=!1;try{this.metrics?.dialerEvents.increment({pending:!0});const h=new H_(`${n}/.well-known/libp2p-webtransport?type=noise`,{serverCertificateHashes:s.map(p=>({algorithm:"sha-256",value:p.digest}))});if(c=p=>{if(!l)try{this.metrics?.dialerEvents.increment({[p]:!0}),h.close()}catch(f){this.log.error("error closing wt session",f)}finally{a!=null&&(a.timeline.close=Date.now()),l=!0}},o=()=>{c(u?"noise_timeout":"ready_timeout")},t.signal.addEventListener("abort",o,{once:!0}),this.log("wait for session to be ready"),t.onProgress?.(new te("webtransport:wait-for-session")),await Promise.race([h.closed,h.ready]),this.log("session became ready"),u=!0,this.metrics?.dialerEvents.increment({ready:!0}),h.closed.catch(p=>{this.log.error("error on remote wt session close",p)}).finally(()=>{c("remote_close")}),d=await _e(this.authenticateWebTransport({wt:h,remotePeer:i,certhashes:s,...t}),t.signal),!d)throw new Jd("Failed to authenticate webtransport");return this.metrics?.dialerEvents.increment({open:!0}),a={close:async()=>{this.log("closing webtransport"),c("close")},abort:p=>{this.log("aborting webtransport due to passed err",p),c("abort")},remoteAddr:e,timeline:{open:Date.now()},log:this.components.logger.forComponent("libp2p:webtransport:maconn"),...Sp()},await t.upgrader.upgradeOutbound(a,{...t,skipEncryption:!0,muxerFactory:q_(h,h.incomingBidirectionalStreams.getReader(),this.components.logger,this.config),skipProtection:!0})}catch(h){throw this.log.error("caught wt session err",h),c(d?"upgrade_error":u?"noise_error":"ready_error"),h}finally{o!=null&&t.signal?.removeEventListener("abort",o)}}async authenticateWebTransport({wt:e,remotePeer:t,certhashes:n,onProgress:s,signal:i}){i?.throwIfAborted(),s?.(new te("webtransport:open-authentication-stream"));const o=await e.createBidirectionalStream(),a=o.writable.getWriter(),c=o.readable.getReader(),l={source:async function*(){for(;;){const h=await c.read();if(h.value!=null&&(yield h.value),h.done)break}}(),sink:async h=>{for await(const p of h){await _e(a.ready,i);const f=p instanceof Uint8Array?p:p.subarray();a.write(f).catch(g=>{this.log.error("could not write chunk during authentication of WebTransport stream",g)})}}},u=Sf()(this.components);s?.(new te("webtransport:secure-outbound-connection"));const{remoteExtensions:d}=await u.secureOutbound(l,{signal:i,remotePeer:t,skipStreamMuxerNegotiation:!0});if(s?.(new te("webtransport:close-authentication-stream")),a.close().catch(h=>{this.log.error(`Failed to close authentication stream writer: ${h.message}`)}),c.cancel().catch(h=>{this.log.error(`Failed to close authentication stream reader: ${h.message}`)}),!W_(d?.webtransportCerthashes??[],n.map(h=>h.bytes)))throw new K("Our certhashes are not a subset of the remote's reported certhashes");return!0}createListener(e){return U_(this.components,{...e,certificates:this.config.certificates,maxInboundStreams:this.config.maxInboundStreams})}listenFilter(){return[]}dialFilter(e){return globalThis.WebTransport==null?[]:e.filter(t=>{if(!Bi.exactMatch(t))return!1;const{url:n,certhashes:s}=Zu(t);return n!=null&&s.length>0})}}function G_(r={}){return e=>new V_(e,r)}function qi(r){if(typeof r!="object"||r===null)return!1;const e=Object.getPrototypeOf(r);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in r)&&!(Symbol.iterator in r)}const{hasOwnProperty:Ep}=Object.prototype,{propertyIsEnumerable:j_}=Object,un=(r,e,t)=>{Object.defineProperty(r,e,{value:t,writable:!0,enumerable:!0,configurable:!0})},Y_=void 0,Ju={concatArrays:!1,ignoreUndefined:!1},go=r=>{const e=[];for(const t in r)Ep.call(r,t)&&e.push(t);if(Object.getOwnPropertySymbols){const t=Object.getOwnPropertySymbols(r);for(const n of t)j_.call(r,n)&&e.push(n)}return e};function Sn(r){return Array.isArray(r)?X_(r):qi(r)?Q_(r):r}function X_(r){const e=r.slice(0,0);return go(r).forEach(t=>{un(e,t,Sn(r[t]))}),e}function Q_(r){const e=Object.getPrototypeOf(r)===null?Object.create(null):{};return go(r).forEach(t=>{un(e,t,Sn(r[t]))}),e}const _p=(r,e,t,n)=>(t.forEach(s=>{typeof e[s]>"u"&&n.ignoreUndefined||(s in r&&r[s]!==Object.getPrototypeOf(r)?un(r,s,ja(r[s],e[s],n)):un(r,s,Sn(e[s])))}),r),Z_=(r,e,t)=>{let n=r.slice(0,0),s=0;return[r,e].forEach(i=>{const o=[];for(let a=0;a<i.length;a++)Ep.call(i,a)&&(o.push(String(a)),i===r?un(n,s++,i[a]):un(n,s++,Sn(i[a])));n=_p(n,i,go(i).filter(a=>!o.includes(a)),t)}),n};function ja(r,e,t){return t.concatArrays&&Array.isArray(r)&&Array.isArray(e)?Z_(r,e,t):!qi(e)||!qi(r)?Sn(e):_p(r,e,go(e),t)}function xp(...r){const e=ja(Sn(Ju),this!==Y_&&this||{},Ju);let t={_:{}};for(const n of r)if(n!==void 0){if(!qi(n))throw new TypeError("`"+n+"` is not an Option Object");t=ja(t,{_:n},e)}return t._}var Vo={exports:{}},ed;function J_(){return ed||(ed=1,function(r){var e=Object.prototype.hasOwnProperty,t="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(t=!1));function s(c,l,u){this.fn=c,this.context=l,this.once=u||!1}function i(c,l,u,d,h){if(typeof u!="function")throw new TypeError("The listener must be a function");var p=new s(u,d||c,h),f=t?t+l:l;return c._events[f]?c._events[f].fn?c._events[f]=[c._events[f],p]:c._events[f].push(p):(c._events[f]=p,c._eventsCount++),c}function o(c,l){--c._eventsCount===0?c._events=new n:delete c._events[l]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var l=[],u,d;if(this._eventsCount===0)return l;for(d in u=this._events)e.call(u,d)&&l.push(t?d.slice(1):d);return Object.getOwnPropertySymbols?l.concat(Object.getOwnPropertySymbols(u)):l},a.prototype.listeners=function(l){var u=t?t+l:l,d=this._events[u];if(!d)return[];if(d.fn)return[d.fn];for(var h=0,p=d.length,f=new Array(p);h<p;h++)f[h]=d[h].fn;return f},a.prototype.listenerCount=function(l){var u=t?t+l:l,d=this._events[u];return d?d.fn?1:d.length:0},a.prototype.emit=function(l,u,d,h,p,f){var g=t?t+l:l;if(!this._events[g])return!1;var m=this._events[g],S=arguments.length,x,w;if(m.fn){switch(m.once&&this.removeListener(l,m.fn,void 0,!0),S){case 1:return m.fn.call(m.context),!0;case 2:return m.fn.call(m.context,u),!0;case 3:return m.fn.call(m.context,u,d),!0;case 4:return m.fn.call(m.context,u,d,h),!0;case 5:return m.fn.call(m.context,u,d,h,p),!0;case 6:return m.fn.call(m.context,u,d,h,p,f),!0}for(w=1,x=new Array(S-1);w<S;w++)x[w-1]=arguments[w];m.fn.apply(m.context,x)}else{var y=m.length,v;for(w=0;w<y;w++)switch(m[w].once&&this.removeListener(l,m[w].fn,void 0,!0),S){case 1:m[w].fn.call(m[w].context);break;case 2:m[w].fn.call(m[w].context,u);break;case 3:m[w].fn.call(m[w].context,u,d);break;case 4:m[w].fn.call(m[w].context,u,d,h);break;default:if(!x)for(v=1,x=new Array(S-1);v<S;v++)x[v-1]=arguments[v];m[w].fn.apply(m[w].context,x)}}return!0},a.prototype.on=function(l,u,d){return i(this,l,u,d,!1)},a.prototype.once=function(l,u,d){return i(this,l,u,d,!0)},a.prototype.removeListener=function(l,u,d,h){var p=t?t+l:l;if(!this._events[p])return this;if(!u)return o(this,p),this;var f=this._events[p];if(f.fn)f.fn===u&&(!h||f.once)&&(!d||f.context===d)&&o(this,p);else{for(var g=0,m=[],S=f.length;g<S;g++)(f[g].fn!==u||h&&!f[g].once||d&&f[g].context!==d)&&m.push(f[g]);m.length?this._events[p]=m.length===1?m[0]:m:o(this,p)}return this},a.prototype.removeAllListeners=function(l){var u;return l?(u=t?t+l:l,this._events[u]&&o(this,u)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,r.exports=a}(Vo)),Vo.exports}var e1=J_();const t1=bs(e1);function r1(r,e,t){let n=0,s=r.length;for(;s>0;){const i=Math.trunc(s/2);let o=n+i;t(r[o],e)<=0?(n=++o,s-=i+1):s=i}return n}let n1=class{#e=[];enqueue(e,t){t={priority:0,...t};const n={priority:t.priority,id:t.id,run:e};if(this.size===0||this.#e[this.size-1].priority>=t.priority){this.#e.push(n);return}const s=r1(this.#e,n,(i,o)=>o.priority-i.priority);this.#e.splice(s,0,n)}setPriority(e,t){const n=this.#e.findIndex(i=>i.id===e);if(n===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[s]=this.#e.splice(n,1);this.enqueue(s.run,{priority:t,id:e})}dequeue(){return this.#e.shift()?.run}filter(e){return this.#e.filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return this.#e.length}};class Ya extends t1{#e;#t;#r=0;#a;#c;#p=0;#s;#l;#n;#g;#i=0;#u;#o;#m;#b=1n;timeout;constructor(e){if(super(),e={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:n1,...e},!(typeof e.intervalCap=="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString()??""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString()??""}\` (${typeof e.interval})`);this.#e=e.carryoverConcurrencyCount,this.#t=e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0,this.#a=e.intervalCap,this.#c=e.interval,this.#n=new e.queueClass,this.#g=e.queueClass,this.concurrency=e.concurrency,this.timeout=e.timeout,this.#m=e.throwOnTimeout===!0,this.#o=e.autoStart===!1}get#v(){return this.#t||this.#r<this.#a}get#S(){return this.#i<this.#u}#E(){this.#i--,this.#d(),this.emit("next")}#_(){this.#w(),this.#y(),this.#l=void 0}get#x(){const e=Date.now();if(this.#s===void 0){const t=this.#p-e;if(t<0)this.#r=this.#e?this.#i:0;else return this.#l===void 0&&(this.#l=setTimeout(()=>{this.#_()},t)),!0}return!1}#d(){if(this.#n.size===0)return this.#s&&clearInterval(this.#s),this.#s=void 0,this.emit("empty"),this.#i===0&&this.emit("idle"),!1;if(!this.#o){const e=!this.#x;if(this.#v&&this.#S){const t=this.#n.dequeue();return t?(this.emit("active"),t(),e&&this.#y(),!0):!1}}return!1}#y(){this.#t||this.#s!==void 0||(this.#s=setInterval(()=>{this.#w()},this.#c),this.#p=Date.now()+this.#c)}#w(){this.#r===0&&this.#i===0&&this.#s&&(clearInterval(this.#s),this.#s=void 0),this.#r=this.#e?this.#i:0,this.#h()}#h(){for(;this.#d(););}get concurrency(){return this.#u}set concurrency(e){if(!(typeof e=="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);this.#u=e,this.#h()}async#A(e){return new Promise((t,n)=>{e.addEventListener("abort",()=>{n(e.reason)},{once:!0})})}setPriority(e,t){this.#n.setPriority(e,t)}async add(e,t={}){return t.id??=(this.#b++).toString(),t={timeout:this.timeout,throwOnTimeout:this.#m,...t},new Promise((n,s)=>{this.#n.enqueue(async()=>{this.#i++,this.#r++;try{t.signal?.throwIfAborted();let i=e({signal:t.signal});t.timeout&&(i=Xc(Promise.resolve(i),{milliseconds:t.timeout})),t.signal&&(i=Promise.race([i,this.#A(t.signal)]));const o=await i;n(o),this.emit("completed",o)}catch(i){if(i instanceof lp&&!t.throwOnTimeout){n();return}s(i),this.emit("error",i)}finally{this.#E()}},t),this.emit("add"),this.#d()})}async addAll(e,t){return Promise.all(e.map(async n=>this.add(n,t)))}start(){return this.#o?(this.#o=!1,this.#h(),this):this}pause(){this.#o=!0}clear(){this.#n=new this.#g}async onEmpty(){this.#n.size!==0&&await this.#f("empty")}async onSizeLessThan(e){this.#n.size<e||await this.#f("next",()=>this.#n.size<e)}async onIdle(){this.#i===0&&this.#n.size===0||await this.#f("idle")}async#f(e,t){return new Promise(n=>{const s=()=>{t&&!t()||(this.off(e,s),n())};this.on(e,s)})}get size(){return this.#n.size}sizeBy(e){return this.#n.filter(e).length}get pending(){return this.#i}get isPaused(){return this.#o}}function Ap(r){const e=[er.A];return r==null?e:Array.isArray(r)?r.length===0?e:r:[r]}const Cp=60;function Ip(r){return{Status:r.Status??0,TC:r.TC??r.flag_tc??!1,RD:r.RD??r.flag_rd??!1,RA:r.RA??r.flag_ra??!1,AD:r.AD??r.flag_ad??!1,CD:r.CD??r.flag_cd??!1,Question:(r.Question??r.questions??[]).map(e=>({name:e.name,type:er[e.type]})),Answer:(r.Answer??r.answers??[]).map(e=>({name:e.name,type:er[e.type],TTL:e.TTL??e.ttl??Cp,data:e.data instanceof Uint8Array?G(e.data):e.data}))}}const s1=4;function td(r,e={}){const t=new Ya({concurrency:e.queryConcurrency??s1});return async(n,s={})=>{const i=new URLSearchParams;i.set("name",n),Ap(s.types).forEach(a=>{i.append("type",er[a])}),s.onProgress?.(new te("dns:query",{detail:n}));const o=await t.add(async()=>{const a=await fetch(`${r}?${i}`,{headers:{accept:"application/dns-json"},signal:s?.signal});if(a.status!==200)throw new Error(`Unexpected HTTP status: ${a.status} - ${a.statusText}`);const c=Ip(await a.json());return s.onProgress?.(new te("dns:response",{detail:c})),c},{signal:s.signal});if(o==null)throw new Error("No DNS response received");return o}}function i1(){return[td("https://cloudflare-dns.com/dns-query"),td("https://dns.google/resolve")]}var Go,rd;function o1(){return rd||(rd=1,Go=function(r){if(!r)throw Error("hashlru must have a max value, of type number, greater than 0");var e=0,t=Object.create(null),n=Object.create(null);function s(i,o){t[i]=o,e++,e>=r&&(e=0,n=t,t=Object.create(null))}return{has:function(i){return t[i]!==void 0||n[i]!==void 0},remove:function(i){t[i]!==void 0&&(t[i]=void 0),n[i]!==void 0&&(n[i]=void 0)},get:function(i){var o=t[i];if(o!==void 0)return o;if((o=n[i])!==void 0)return s(i,o),o},set:function(i,o){t[i]!==void 0?t[i]=o:s(i,o)},clear:function(){t=Object.create(null),n=Object.create(null)}}}),Go}var a1=o1();const c1=bs(a1);class l1{lru;constructor(e){this.lru=c1(e)}get(e,t){let n=!0;const s=[];for(const i of t){const o=this.getAnswers(e,i);if(o.length===0){n=!1;break}s.push(...o)}if(n)return Ip({answers:s})}getAnswers(e,t){const n=`${e.toLowerCase()}-${t}`,s=this.lru.get(n);if(s!=null){const i=s.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:er[a.type]}));return i.length===0&&this.lru.remove(n),i}return[]}add(e,t){const n=`${e.toLowerCase()}-${t.type}`,s=this.lru.get(n)??[];s.push({expires:Date.now()+(t.TTL??Cp)*1e3,value:t}),this.lru.set(n,s)}remove(e,t){const n=`${e.toLowerCase()}-${t}`;this.lru.remove(n)}clear(){this.lru.clear()}}function u1(r){return new l1(r)}const d1=1e3;class h1{resolvers;cache;constructor(e){this.resolvers={},this.cache=u1(e.cacheSize??d1),Object.entries(e.resolvers??{}).forEach(([t,n])=>{Array.isArray(n)||(n=[n]),t.endsWith(".")||(t=`${t}.`),this.resolvers[t]=n}),this.resolvers["."]==null&&(this.resolvers["."]=i1())}async query(e,t={}){const n=Ap(t.types),s=t.cached!==!1?this.cache.get(e,n):void 0;if(s!=null)return t.onProgress?.(new te("dns:cache",{detail:s})),s;const i=`${e.split(".").pop()}.`,o=(this.resolvers[i]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const c of o){if(t.signal?.aborted===!0)break;try{const l=await c(e,{...t,types:n});for(const u of l.Answer)this.cache.add(e,u);return l}catch(l){a.push(l),t.onProgress?.(new te("dns:error",{detail:l}))}}throw a.length===1?a[0]:new AggregateError(a,`DNS lookup of ${e} ${n} failed`)}}var er;(function(r){r[r.A=1]="A",r[r.CNAME=5]="CNAME",r[r.TXT=16]="TXT",r[r.AAAA=28]="AAAA"})(er||(er={}));function f1(r={}){return new h1(r)}const p1=32,{code:g1}=V("dnsaddr");class m1 extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}const Tp=async function(e,t={}){const n=t.maxRecursiveDepth??p1;if(n===0)throw new m1("Max recursive depth reached");const[,s]=e.stringTuples().find(([l])=>l===g1)??[],o=await(t?.dns??f1()).query(`_dnsaddr.${s}`,{signal:t?.signal,types:[er.TXT]}),a=e.getPeerId(),c=[];for(const l of o.Answer){const u=l.data.replace(/["']/g,"").trim().split("=")[1];if(u==null||a!=null&&!u.includes(a))continue;const d=Y(u);if(u.startsWith("/dnsaddr")){const h=await d.resolve({...t,maxRecursiveDepth:n-1});c.push(...h.map(p=>p.toString()))}else c.push(d.toString())}return c},y1={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter:r=>r},connectionManager:{resolvers:{dnsaddr:Tp}},transportManager:{faultTolerance:Wn.FATAL_ALL}};async function w1(r){const e=xp(y1,r);if(e.connectionProtector===null&&globalThis.process?.env?.LIBP2P_FORCE_PNET!=null)throw new K("Private network is enforced, but no protector was provided");return e}const dn=1e3,hn=dn*60,fn=hn*60,Ar=fn*24,b1=Ar*7,v1=Ar*365.25;function Pp(r,e){try{if(typeof r=="string"&&r.length>0)return S1(r);if(typeof r=="number"&&isFinite(r))return e?.long?_1(r):E1(r);throw new Error("Value is not a string or number.")}catch(t){const n=x1(t)?`${t.message}. value=${JSON.stringify(r)}`:"An unknown error has occured.";throw new Error(n)}}function S1(r){if(r=String(r),r.length>100)throw new Error("Value exceeds the maximum length of 100 characters.");const e=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(r);if(!e)return NaN;const t=parseFloat(e[1]),n=(e[2]||"ms").toLowerCase();switch(n){case"years":case"year":case"yrs":case"yr":case"y":return t*v1;case"weeks":case"week":case"w":return t*b1;case"days":case"day":case"d":return t*Ar;case"hours":case"hour":case"hrs":case"hr":case"h":return t*fn;case"minutes":case"minute":case"mins":case"min":case"m":return t*hn;case"seconds":case"second":case"secs":case"sec":case"s":return t*dn;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:throw new Error(`The unit ${n} was matched, but no matching case exists.`)}}function E1(r){const e=Math.abs(r);return e>=Ar?`${Math.round(r/Ar)}d`:e>=fn?`${Math.round(r/fn)}h`:e>=hn?`${Math.round(r/hn)}m`:e>=dn?`${Math.round(r/dn)}s`:`${r}ms`}function _1(r){const e=Math.abs(r);return e>=Ar?Bs(r,e,Ar,"day"):e>=fn?Bs(r,e,fn,"hour"):e>=hn?Bs(r,e,hn,"minute"):e>=dn?Bs(r,e,dn,"second"):`${r} ms`}function Bs(r,e,t,n){const s=e>=t*1.5;return`${Math.round(r/t)} ${n}${s?"s":""}`}function x1(r){return typeof r=="object"&&r!==null&&"message"in r}function A1(r){t.debug=t,t.default=t,t.coerce=c,t.disable=i,t.enable=s,t.enabled=o,t.humanize=Pp,t.destroy=l,Object.keys(r).forEach(u=>{t[u]=r[u]}),t.names=[],t.skips=[],t.formatters={};function e(u){let d=0;for(let h=0;h<u.length;h++)d=(d<<5)-d+u.charCodeAt(h),d|=0;return t.colors[Math.abs(d)%t.colors.length]}t.selectColor=e;function t(u){let d,h=null,p,f;function g(...m){if(!g.enabled)return;const S=g,x=Number(new Date),w=x-(d||x);S.diff=w,S.prev=d,S.curr=x,d=x,m[0]=t.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");let y=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,(C,E)=>{if(C==="%%")return"%";y++;const A=t.formatters[E];if(typeof A=="function"){const T=m[y];C=A.call(S,T),m.splice(y,1),y--}return C}),t.formatArgs.call(S,m),(S.log||t.log).apply(S,m)}return g.namespace=u,g.useColors=t.useColors(),g.color=t.selectColor(u),g.extend=n,g.destroy=t.destroy,Object.defineProperty(g,"enabled",{enumerable:!0,configurable:!1,get:()=>h!==null?h:(p!==t.namespaces&&(p=t.namespaces,f=t.enabled(u)),f),set:m=>{h=m}}),typeof t.init=="function"&&t.init(g),g}function n(u,d){const h=t(this.namespace+(typeof d>"u"?":":d)+u);return h.log=this.log,h}function s(u){t.save(u),t.namespaces=u,t.names=[],t.skips=[];let d;const h=(typeof u=="string"?u:"").split(/[\s,]+/),p=h.length;for(d=0;d<p;d++)h[d]&&(u=h[d].replace(/\*/g,".*?"),u[0]==="-"?t.skips.push(new RegExp("^"+u.substr(1)+"$")):t.names.push(new RegExp("^"+u+"$")))}function i(){const u=[...t.names.map(a),...t.skips.map(a).map(d=>"-"+d)].join(",");return t.enable(""),u}function o(u){if(u[u.length-1]==="*")return!0;let d,h;for(d=0,h=t.skips.length;d<h;d++)if(t.skips[d].test(u))return!1;for(d=0,h=t.names.length;d<h;d++)if(t.names[d].test(u))return!0;return!1}function a(u){return u.toString().substring(2,u.toString().length-2).replace(/\.\*\?$/,"*")}function c(u){return u instanceof Error?u.stack??u.message:u}function l(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.setupFormatters(t.formatters),t.enable(t.load()),t}var C1={};const Wi=D1(),I1=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function T1(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/)!=null?!1:typeof document<"u"&&document.documentElement?.style?.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/)!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/)}function P1(r){if(r[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+r[0]+(this.useColors?"%c ":" ")+"+"+Pp(this.diff),!this.useColors)return;const e="color: "+this.color;r.splice(1,0,e,"color: inherit");let t=0,n=0;r[0].replace(/%[a-zA-Z%]/g,s=>{s!=="%%"&&(t++,s==="%c"&&(n=t))}),r.splice(n,0,e)}const k1=console.debug??console.log??(()=>{});function R1(r){try{r?Wi?.setItem("debug",r):Wi?.removeItem("debug")}catch{}}function L1(){let r;try{r=Wi?.getItem("debug")}catch{}return!r&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(r=C1.DEBUG),r}function D1(){try{return localStorage}catch{}}function M1(r){r.j=function(e){try{return JSON.stringify(e)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}}const Qe=A1({formatArgs:P1,save:R1,load:L1,useColors:T1,setupFormatters:M1,colors:I1,storage:Wi,log:k1});Qe.formatters.b=r=>r==null?"undefined":be.baseEncode(r);Qe.formatters.t=r=>r==null?"undefined":Pt.baseEncode(r);Qe.formatters.m=r=>r==null?"undefined":ph.baseEncode(r);Qe.formatters.p=r=>r==null?"undefined":r.toString();Qe.formatters.c=r=>r==null?"undefined":r.toString();Qe.formatters.k=r=>r==null?"undefined":r.toString();Qe.formatters.a=r=>r==null?"undefined":r.toString();Qe.formatters.e=r=>r==null?"undefined":nd(r.stack)??nd(r.message)??r.toString();function O1(r){const e=()=>{};return e.enabled=!1,e.color="",e.diff=0,e.log=()=>{},e.namespace=r,e.destroy=()=>!0,e.extend=()=>e,e}function kp(){return{forComponent(r){return F1(r)}}}function F1(r){let e=O1(`${r}:trace`);return Qe.enabled(`${r}:trace`)&&Qe.names.map(t=>t.toString()).find(t=>t.includes(":trace"))!=null&&(e=Qe(`${r}:trace`)),Object.assign(Qe(r),{error:Qe(`${r}:error`),trace:e})}function nd(r){if(r!=null&&(r=r.trim(),r.length!==0))return r}function N1(r){return r[Symbol.asyncIterator]!=null}function Xa(r){if(N1(r))return(async()=>{const t=[];for await(const n of r)t.push(n);return t})();const e=[];for(const t of r)e.push(t);return e}let Rp=class extends Error{static name="AbortError";name="AbortError";constructor(e="The operation was aborted",...t){super(e,...t)}};const Xt={},Cr=r=>{r.addEventListener("message",e=>{Cr.dispatchEvent("message",r,e)}),r.port!=null&&r.port.addEventListener("message",e=>{Cr.dispatchEvent("message",r,e)})};Cr.addEventListener=(r,e)=>{Xt[r]==null&&(Xt[r]=[]),Xt[r].push(e)};Cr.removeEventListener=(r,e)=>{Xt[r]!=null&&(Xt[r]=Xt[r].filter(t=>t===e))};Cr.dispatchEvent=function(r,e,t){Xt[r]!=null&&Xt[r].forEach(n=>n(e,t))};const sd="lock:worker:request-read",id="lock:worker:abort-read-request",od="lock:worker:release-read",ad="lock:master:grant-read",cd="lock:worker:request-write",ld="lock:worker:abort-write-request",ud="lock:worker:release-write",dd="lock:master:grant-write",B1=(r=10)=>Math.random().toString().substring(2,r+2),hd=(r,e,t,n,s,i,o)=>(a,c)=>{if(c.data==null)return;const l={type:c.data.type,name:c.data.name,identifier:c.data.identifier};c.data.type===n&&r.dispatchEvent(new MessageEvent(e,{data:{name:l.name,handler:async()=>{a.postMessage({type:o,name:l.name,identifier:l.identifier}),await new Promise(u=>{const d=h=>{if(h?.data==null)return;const p={type:h.data.type,name:h.data.name,identifier:h.data.identifier};p.type===i&&p.identifier===l.identifier&&(a.removeEventListener("message",d),u())};a.addEventListener("message",d)})}}})),l.type===s&&(a.postMessage({type:s,name:l.name,identifier:l.identifier}),r.dispatchEvent(new MessageEvent(t,{data:{name:l.name}})))},fd=(r,e,t,n,s)=>async i=>{i?.signal?.throwIfAborted();const o=B1();return globalThis.postMessage({type:e,identifier:o,name:r}),new Promise((a,c)=>{const l=()=>{process.send?.({type:t,identifier:o,name:r}),c(new Rp)};i?.signal?.addEventListener("abort",l,{once:!0});const u=d=>{if(d?.data==null)return;const h={type:d.data.type,identifier:d.data.identifier};h.type===n&&h.identifier===o&&(globalThis.removeEventListener("message",u),i?.signal?.removeEventListener("abort",l),a(()=>{globalThis.postMessage({type:s,identifier:o,name:r})}))};globalThis.addEventListener("message",u)})},U1={singleProcess:!1},$1=r=>{if(r=Object.assign({},U1,r),!!globalThis.document||r.singleProcess){const t=new EventTarget;return Cr.addEventListener("message",hd(t,"requestReadLock","abortReadLockRequest",sd,id,od,ad)),Cr.addEventListener("message",hd(t,"requestWriteLock","abortWriteLockRequest",cd,ld,ud,dd)),t}return{isWorker:!0,readLock:t=>fd(t,sd,id,ad,od),writeLock:t=>fd(t,cd,ld,dd,ud)}},ir={};let Je;async function jo(r,e){let t,n;const s=new Promise((o,a)=>{t=o,n=a}),i=()=>{n(new Rp)};return e?.signal?.addEventListener("abort",i,{once:!0}),r.add(async()=>{await new Promise(o=>{t(()=>{e?.signal?.removeEventListener("abort",i),o()})})},{signal:e?.signal}).catch(o=>{n(o)}),s}const q1=(r,e)=>{if(Je.isWorker===!0)return{readLock:Je.readLock(r,e),writeLock:Je.writeLock(r,e)};const t=new Ya({concurrency:1});let n;return{async readLock(s){if(n!=null)return jo(n,s);n=new Ya({concurrency:e.concurrency,autoStart:!1});const i=n,o=jo(n,s);return t.add(async()=>{i.start(),await i.onIdle().then(()=>{n===i&&(n=null)})}),o},async writeLock(s){return n=null,jo(t,s)}}},W1={name:"lock",concurrency:1/0,singleProcess:!1};function z1(r){const e=Object.assign({},W1,r);return Je==null&&(Je=$1(e),Je.isWorker!==!0&&(Je.addEventListener("requestReadLock",t=>{const n=t.data.name;if(ir[n]==null)return;const s=new AbortController,i=o=>{o.data.name===n&&s.abort()};Je.addEventListener("abortReadLockRequest",i),ir[n].readLock({signal:s.signal}).then(async o=>t.data.handler().finally(()=>{o()})).finally(()=>{Je.removeEventListener("abortReadLockRequest",i)})}),Je.addEventListener("requestWriteLock",async t=>{const n=t.data.name;if(ir[n]==null)return;const s=new AbortController,i=o=>{o.data.name===n&&s.abort()};Je.addEventListener("abortWriteLockRequest",i),ir[t.data.name].writeLock({signal:s.signal}).then(async o=>t.data.handler().finally(()=>{o()})).finally(()=>{Je.removeEventListener("abortWriteLockRequest",i)})}))),ir[e.name]==null&&(ir[e.name]=q1(e.name,e)),ir[e.name]}const K1=36e5,H1=216e5;var gr;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=we((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&s.value.byteLength>0&&(i.uint32(18),i.bytes(s.value)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:"",value:ae(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.key=s.string();break}case 2:{a.value=s.bytes();break}default:{s.skipType(l&7);break}}}return a})),n),t.encode=s=>ye(s,t.codec()),t.decode=(s,i)=>me(s,t.codec(),i)})(r.Peer$metadataEntry||(r.Peer$metadataEntry={})),function(t){let n;t.codec=()=>(n==null&&(n=we((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&(i.uint32(18),Ki.codec().encode(s.value,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:""},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.key=s.string();break}case 2:{a.value=Ki.codec().decode(s,s.uint32(),{limits:o.limits?.value});break}default:{s.skipType(l&7);break}}}return a})),n),t.encode=s=>ye(s,t.codec()),t.decode=(s,i)=>me(s,t.codec(),i)}(r.Peer$tagsEntry||(r.Peer$tagsEntry={}));let e;r.codec=()=>(e==null&&(e=we((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.addresses!=null)for(const i of t.addresses)n.uint32(10),zi.codec().encode(i,n);if(t.protocols!=null)for(const i of t.protocols)n.uint32(18),n.string(i);if(t.publicKey!=null&&(n.uint32(34),n.bytes(t.publicKey)),t.peerRecordEnvelope!=null&&(n.uint32(42),n.bytes(t.peerRecordEnvelope)),t.metadata!=null&&t.metadata.size!==0)for(const[i,o]of t.metadata.entries())n.uint32(50),r.Peer$metadataEntry.codec().encode({key:i,value:o},n);if(t.tags!=null&&t.tags.size!==0)for(const[i,o]of t.tags.entries())n.uint32(58),r.Peer$tagsEntry.codec().encode({key:i,value:o},n);t.updated!=null&&(n.uint32(64),n.uint64Number(t.updated)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(s.limits?.addresses!=null&&i.addresses.length===s.limits.addresses)throw new Lt('Decode error - map field "addresses" had too many elements');i.addresses.push(zi.codec().decode(t,t.uint32(),{limits:s.limits?.addresses$}));break}case 2:{if(s.limits?.protocols!=null&&i.protocols.length===s.limits.protocols)throw new Lt('Decode error - map field "protocols" had too many elements');i.protocols.push(t.string());break}case 4:{i.publicKey=t.bytes();break}case 5:{i.peerRecordEnvelope=t.bytes();break}case 6:{if(s.limits?.metadata!=null&&i.metadata.size===s.limits.metadata)throw new Gl('Decode error - map field "metadata" had too many elements');const c=r.Peer$metadataEntry.codec().decode(t,t.uint32());i.metadata.set(c.key,c.value);break}case 7:{if(s.limits?.tags!=null&&i.tags.size===s.limits.tags)throw new Gl('Decode error - map field "tags" had too many elements');const c=r.Peer$tagsEntry.codec().decode(t,t.uint32(),{limits:{value:s.limits?.tags$value}});i.tags.set(c.key,c.value);break}case 8:{i.updated=t.uint64Number();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ye(t,r.codec()),r.decode=(t,n)=>me(t,r.codec(),n)})(gr||(gr={}));var zi;(function(r){let e;r.codec=()=>(e==null&&(e=we((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.multiaddr!=null&&t.multiaddr.byteLength>0&&(n.uint32(10),n.bytes(t.multiaddr)),t.isCertified!=null&&(n.uint32(16),n.bool(t.isCertified)),t.observed!=null&&(n.uint32(24),n.uint64Number(t.observed)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={multiaddr:ae(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.multiaddr=t.bytes();break}case 2:{i.isCertified=t.bool();break}case 3:{i.observed=t.uint64Number();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ye(t,r.codec()),r.decode=(t,n)=>me(t,r.codec(),n)})(zi||(zi={}));var Ki;(function(r){let e;r.codec=()=>(e==null&&(e=we((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.value!=null&&t.value!==0&&(n.uint32(8),n.uint32(t.value)),t.expiry!=null&&(n.uint32(16),n.uint64(t.expiry)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={value:0},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.value=t.uint32();break}case 2:{i.expiry=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ye(t,r.codec()),r.decode=(t,n)=>me(t,r.codec(),n)})(Ki||(Ki={}));function V1(r,e){if(r.publicKey!=null||e.publicKey==null)return r;let t;if(r.type==="RSA"){const s=be.decode(`z${r}`);t=rr(s)}const n=Zt(e.publicKey,t);return Gn(n)}function Qa(r,e,t){const n=gr.decode(e);return Za(r,n,t)}function Za(r,e,t){const n=new Map,s=BigInt(Date.now());for(const[i,o]of e.tags.entries())o.expiry!=null&&o.expiry<s||n.set(i,o);return{...e,id:V1(r,e),addresses:e.addresses.filter(({observed:i})=>i!=null&&i>Date.now()-t).map(({multiaddr:i,isCertified:o})=>({multiaddr:Y(i),isCertified:o??!1})),metadata:e.metadata,peerRecordEnvelope:e.peerRecordEnvelope??void 0,tags:n}}function G1(r,e){return j1(r.addresses,e.addresses)&&Y1(r.protocols,e.protocols)&&X1(r.publicKey,e.publicKey)&&Q1(r.peerRecordEnvelope,e.peerRecordEnvelope)&&Z1(r.metadata,e.metadata)&&J1(r.tags,e.tags)}function j1(r,e){return Dp(r,e,(t,n)=>!(t.isCertified!==n.isCertified||!ke(t.multiaddr,n.multiaddr)))}function Y1(r,e){return Dp(r,e,(t,n)=>t===n)}function X1(r,e){return Lp(r,e)}function Q1(r,e){return Lp(r,e)}function Z1(r,e){return Mp(r,e,(t,n)=>ke(t,n))}function J1(r,e){return Mp(r,e,(t,n)=>t.value===n.value&&t.expiry===n.expiry)}function Lp(r,e){return r==null&&e==null?!0:r!=null&&e!=null?ke(r,e):!1}function Dp(r,e,t){if(r.length!==e.length)return!1;for(let n=0;n<r.length;n++)if(!t(r[n],e[n]))return!1;return!0}function Mp(r,e,t){if(r.size!==e.size)return!1;for(const[n,s]of r.entries()){const i=e.get(n);if(i==null||!t(s,i))return!1}return!0}const Op="/peers/";function Us(r){if(!Zd(r)||r.type==null)throw new K("Invalid PeerId");const e=r.toCID().toString();return new $e(`${Op}${e}`)}async function ex(r,e,t,n){const s=new Map;for(const i of t){if(i==null)continue;if(i.multiaddr instanceof Uint8Array&&(i.multiaddr=Y(i.multiaddr)),!ao(i.multiaddr))throw new K("Multiaddr was invalid");if(!await e(r,i.multiaddr))continue;const o=i.isCertified??!1,a=i.multiaddr.toString(),c=s.get(a);c!=null?i.isCertified=c.isCertified||o:s.set(a,{multiaddr:i.multiaddr,isCertified:o})}return[...s.values()].sort((i,o)=>i.multiaddr.toString().localeCompare(o.multiaddr.toString())).map(({isCertified:i,multiaddr:o})=>{const a=o.getPeerId();return r.equals(a)&&(o=o.decapsulate(Y(`/p2p/${r}`))),{isCertified:i,multiaddr:o.bytes}})}async function Yo(r,e,t,n){if(e==null)throw new K("Invalid PeerData");if(e.publicKey!=null&&r.publicKey!=null&&!e.publicKey.equals(r.publicKey))throw new K("publicKey bytes do not match peer id publicKey bytes");const s=n.existingPeer?.peer;if(s!=null&&!r.equals(s.id))throw new K("peer id did not match existing peer id");let i=s?.addresses??[],o=new Set(s?.protocols??[]),a=s?.metadata??new Map,c=s?.tags??new Map,l=s?.peerRecordEnvelope;if(t==="patch"){if((e.multiaddrs!=null||e.addresses!=null)&&(i=[],e.multiaddrs!=null&&i.push(...e.multiaddrs.map(h=>({isCertified:!1,multiaddr:h}))),e.addresses!=null&&i.push(...e.addresses)),e.protocols!=null&&(o=new Set(e.protocols)),e.metadata!=null){const h=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);a=$s(h,{validate:pd})}if(e.tags!=null){const h=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags);c=$s(h,{validate:gd,map:md})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}if(t==="merge"){if(e.multiaddrs!=null&&i.push(...e.multiaddrs.map(h=>({isCertified:!1,multiaddr:h}))),e.addresses!=null&&i.push(...e.addresses),e.protocols!=null&&(o=new Set([...o,...e.protocols])),e.metadata!=null){const h=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);for(const[p,f]of h)f==null?a.delete(p):a.set(p,f);a=$s([...a.entries()],{validate:pd})}if(e.tags!=null){const h=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags),p=new Map(c);for(const[f,g]of h)g==null?p.delete(f):p.set(f,g);c=$s([...p.entries()],{validate:gd,map:md})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}let u;s?.id.publicKey!=null?u=kt(s.id.publicKey):e.publicKey!=null?u=kt(e.publicKey):r.publicKey!=null&&(u=kt(r.publicKey));const d={addresses:await ex(r,n.addressFilter??(async()=>!0),i,n.existingPeer?.peerPB.addresses),protocols:[...o.values()].sort((h,p)=>h.localeCompare(p)),metadata:a,tags:c,publicKey:u,peerRecordEnvelope:l};return d.addresses.forEach(h=>{h.observed=n.existingPeer?.peerPB.addresses?.find(p=>ke(p.multiaddr,p.multiaddr))?.observed??Date.now()}),r.type!=="RSA"&&delete d.publicKey,d}function $s(r,e){const t=new Map;for(const[n,s]of r)s!=null&&e.validate(n,s);for(const[n,s]of r.sort(([i],[o])=>i.localeCompare(o)))s!=null&&t.set(n,e.map?.(n,s)??s);return t}function pd(r,e){if(typeof r!="string")throw new K("Metadata key must be a string");if(!(e instanceof Uint8Array))throw new K("Metadata value must be a Uint8Array")}function gd(r,e){if(typeof r!="string")throw new K("Tag name must be a string");if(e.value!=null){if(parseInt(`${e.value}`,10)!==e.value)throw new K("Tag value must be an integer");if(e.value<0||e.value>100)throw new K("Tag value must be between 0-100")}if(e.ttl!=null){if(parseInt(`${e.ttl}`,10)!==e.ttl)throw new K("Tag ttl must be an integer");if(e.ttl<0)throw new K("Tag ttl must be between greater than 0")}}function md(r,e){let t;return e.expiry!=null&&(t=e.expiry),e.ttl!=null&&(t=BigInt(Date.now()+Number(e.ttl))),{value:e.value??0,expiry:t}}function Fp(r){const e=r.toString().split("/")[2],t=le.parse(e,Pt);return ps(t)}function Xo(r,e,t){const n=Fp(r);return Qa(n,e,t)}function tx(r,e){return{prefix:Op,filters:(r.filters??[]).map(t=>({key:n,value:s})=>t(Xo(n,s,e))),orders:(r.orders??[]).map(t=>(n,s)=>t(Xo(n.key,n.value,e),Xo(s.key,s.value,e)))}}class rx{peerId;datastore;lock;addressFilter;log;maxAddressAge;maxPeerAge;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.lock=z1({name:"peer-store",singleProcess:!0}),this.maxAddressAge=t.maxAddressAge??K1,this.maxPeerAge=t.maxPeerAge??H1}async has(e){try{return await this.load(e),!0}catch(t){if(t.name!=="NotFoundError")throw t}return!1}async delete(e){this.peerId.equals(e)||await this.datastore.delete(Us(e))}async load(e){const t=Us(e),n=await this.datastore.get(t),s=gr.decode(n);if(this.#r(e,s))throw await this.datastore.delete(t),new va;return Za(e,s,this.peerId.equals(e)?1/0:this.maxAddressAge)}async save(e,t){const n=await this.#e(e),s=await Yo(e,t,"patch",{addressFilter:this.addressFilter});return this.#t(e,s,n)}async patch(e,t){const n=await this.#e(e),s=await Yo(e,t,"patch",{addressFilter:this.addressFilter,existingPeer:n});return this.#t(e,s,n)}async merge(e,t){const n=await this.#e(e),s=await Yo(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:n});return this.#t(e,s,n)}async*all(e){for await(const{key:t,value:n}of this.datastore.query(tx(e??{},this.maxAddressAge))){const s=Fp(t);if(s.equals(this.peerId))continue;const i=gr.decode(n);if(this.#r(s,i)){await this.datastore.delete(t);continue}yield Za(s,i,this.peerId.equals(s)?1/0:this.maxAddressAge)}}async#e(e){try{const t=Us(e),n=await this.datastore.get(t),s=gr.decode(n);if(this.#r(e,s))throw await this.datastore.delete(t),new va;return{peerPB:s,peer:Qa(e,n,this.maxAddressAge)}}catch(t){t.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",t)}}async#t(e,t,n){t.updated=Date.now();const s=gr.encode(t);return await this.datastore.put(Us(e),s),{peer:Qa(e,s,this.maxAddressAge),previous:n?.peer,updated:n==null||!G1(t,n.peerPB)}}#r(e,t){if(t.updated==null)return!0;if(this.peerId.equals(e))return!1;const n=t.updated<Date.now()-this.maxPeerAge,s=Date.now()-this.maxAddressAge,i=t.addresses.filter(o=>o.observed!=null&&o.observed>s);return n&&i.length===0}}class nx{store;events;peerId;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new rx(e,t)}[Symbol.toStringTag]="@libp2p/peer-store";async forEach(e,t){this.log.trace("forEach await read lock");const n=await this.store.lock.readLock();this.log.trace("forEach got read lock");try{for await(const s of this.store.all(t))e(s)}finally{this.log.trace("forEach release read lock"),n()}}async all(e){this.log.trace("all await read lock");const t=await this.store.lock.readLock();this.log.trace("all got read lock");try{return await Xa(this.store.all(e))}finally{this.log.trace("all release read lock"),t()}}async delete(e){this.log.trace("delete await write lock");const t=await this.store.lock.writeLock();this.log.trace("delete got write lock");try{await this.store.delete(e)}finally{this.log.trace("delete release write lock"),t()}}async has(e){this.log.trace("has await read lock");const t=await this.store.lock.readLock();this.log.trace("has got read lock");try{return await this.store.has(e)}finally{this.log.trace("has release read lock"),t()}}async get(e){this.log.trace("get await read lock");const t=await this.store.lock.readLock();this.log.trace("get got read lock");try{return await this.store.load(e)}finally{this.log.trace("get release read lock"),t()}}async getInfo(e){const t=await this.get(e);return{id:t.id,multiaddrs:t.addresses.map(({multiaddr:n})=>n)}}async save(e,t){this.log.trace("save await write lock");const n=await this.store.lock.writeLock();this.log.trace("save got write lock");try{const s=await this.store.save(e,t);return this.#e(e,s),s.peer}finally{this.log.trace("save release write lock"),n()}}async patch(e,t){this.log.trace("patch await write lock");const n=await this.store.lock.writeLock();this.log.trace("patch got write lock");try{const s=await this.store.patch(e,t);return this.#e(e,s),s.peer}finally{this.log.trace("patch release write lock"),n()}}async merge(e,t){this.log.trace("merge await write lock");const n=await this.store.lock.writeLock();this.log.trace("merge got write lock");try{const s=await this.store.merge(e,t);return this.#e(e,s),s.peer}finally{this.log.trace("merge release write lock"),n()}}async consumePeerRecord(e,t){const n=await vt.openAndCertify(e,Ze.DOMAIN),s=ps(n.publicKey.toCID());if(t?.equals(s)===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",t,s),!1;const i=Ze.createFromProtobuf(n.payload);let o;try{o=await this.get(s)}catch(a){if(a.name!=="NotFoundError")throw a}if(o?.peerRecordEnvelope!=null){const a=await vt.createFromProtobuf(o.peerRecordEnvelope),c=Ze.createFromProtobuf(a.payload);if(c.seqNumber>=i.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",c.seqNumber,i.seqNumber),!1}return await this.patch(i.peerId,{peerRecordEnvelope:e,addresses:i.multiaddrs.map(a=>({isCertified:!0,multiaddr:a}))}),!0}#e(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))}}function sx(r,e={}){return new nx(r,e)}class Hi extends Error{static name="NotFoundError";static code="ERR_NOT_FOUND";name=Hi.name;code=Hi.code;constructor(e="Not Found"){super(e)}}function ix(r){return r[Symbol.asyncIterator]!=null}function Br(r,e){let t=0;if(ix(r))return async function*(){for await(const c of r)await e(c,t++)&&(yield c)}();const n=Cf(r),{value:s,done:i}=n.next();if(i===!0)return function*(){}();const o=e(s,t++);if(typeof o.then=="function")return async function*(){await o&&(yield s);for await(const c of n)await e(c,t++)&&(yield c)}();const a=e;return function*(){o===!0&&(yield s);for(const c of n)a(c,t++)&&(yield c)}()}function ox(r){return r[Symbol.asyncIterator]!=null}function yd(r,e){return ox(r)?async function*(){yield*(await Xa(r)).sort(e)}():function*(){yield*Xa(r).sort(e)}()}function ax(r){return r[Symbol.asyncIterator]!=null}function wd(r,e){return ax(r)?async function*(){let t=0;if(!(e<1)){for await(const n of r)if(yield n,t++,t===e)return}}():function*(){let t=0;if(!(e<1)){for(const n of r)if(yield n,t++,t===e)return}}()}class cx{put(e,t,n){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:n,value:s}of e)await this.put(n,s,t),yield n}async*getMany(e,t={}){for await(const n of e)yield{key:n,value:await this.get(n,t)}}async*deleteMany(e,t={}){for await(const n of e)await this.delete(n,t),yield n}batch(){let e=[],t=[];return{put(n,s){e.push({key:n,value:s})},delete(n){t.push(n)},commit:async n=>{await Ha(this.putMany(e,n)),e=[],await Ha(this.deleteMany(t,n)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let n=this._all(e,t);if(e.prefix!=null){const s=e.prefix;n=Br(n,i=>i.key.toString().startsWith(s))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((s,i)=>Br(s,i),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((s,i)=>yd(s,i),n)),e.offset!=null){let s=0;const i=e.offset;n=Br(n,()=>s++>=i)}return e.limit!=null&&(n=wd(n,e.limit)),n}queryKeys(e,t){let n=this._allKeys(e,t);if(e.prefix!=null){const s=e.prefix;n=Br(n,i=>i.toString().startsWith(s))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((s,i)=>Br(s,i),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((s,i)=>yd(s,i),n)),e.offset!=null){const s=e.offset;let i=0;n=Br(n,()=>i++>=s)}return e.limit!=null&&(n=wd(n,e.limit)),n}}class lx extends cx{data;constructor(){super(),this.data=new Map}put(e,t,n){return n?.signal?.throwIfAborted(),this.data.set(e.toString(),t),e}get(e,t){t?.signal?.throwIfAborted();const n=this.data.get(e.toString());if(n==null)throw new Hi;return n}has(e,t){return t?.signal?.throwIfAborted(),this.data.has(e.toString())}delete(e,t){t?.signal?.throwIfAborted(),this.data.delete(e.toString())}*_all(e,t){t?.signal?.throwIfAborted();for(const[n,s]of this.data.entries())yield{key:new $e(n),value:s},t?.signal?.throwIfAborted()}*_allKeys(e,t){t?.signal?.throwIfAborted();for(const n of this.data.keys())yield new $e(n),t?.signal?.throwIfAborted()}}const bd=864e13,ux=448,Qo=449,dx=53,hx=54,fx=55,px=56;class gx{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=new Map}has(e){const t=this.findHost(e);for(const n of this.mappings.values())if(n.domain===t)return!0;return!1}add(e,t){t.forEach(n=>{this.log("add DNS mapping %s to %s",n,e);const s=po(n)===!0;this.mappings.set(n,{domain:e,verified:s,expires:s?bd-Date.now():0,lastVerified:s?bd-Date.now():void 0})})}remove(e){const t=this.findHost(e);let n=!1;for(const[s,i]of this.mappings.entries())i.domain===t&&(this.log("removing %s to %s DNS mapping %e",s,i.domain,new Error("where")),this.mappings.delete(s),n=n||i.verified);return n}getAll(e){const t=[];for(let n=0;n<e.length;n++){const i=e[n].multiaddr.stringTuples(),o=i[0][1];if(o!=null)for(const[a,c]of this.mappings.entries()){if(o!==a)continue;this.maybeAddSNITuple(i,c.domain)&&(e.splice(n,1),n--,t.push({multiaddr:Y(`/${i.map(u=>[V(u[0]).name,u[1]].join("/")).join("/")}`),verified:c.verified,type:"dns-mapping",expires:c.expires,lastVerified:c.lastVerified}))}}return t}maybeAddSNITuple(e,t){for(let n=0;n<e.length;n++)if(e[n][0]===ux&&e[n+1]?.[0]!==Qo)return e.splice(n+1,0,[Qo,t]),!0;return!1}confirm(e,t){const n=this.findHost(e);let s=!1;for(const[i,o]of this.mappings.entries())o.domain===n&&(this.log("marking %s to %s DNS mapping as verified",i,o.domain),s=o.verified,o.verified=!0,o.expires=Date.now()+t,o.lastVerified=Date.now());return s}unconfirm(e,t){const n=this.findHost(e);let s=!1;for(const[i,o]of this.mappings.entries())o.domain===n&&(this.log("removing verification of %s to %s DNS mapping",i,o.domain),s=s||o.verified,o.verified=!1,o.expires=Date.now()+t);return s}findHost(e){for(const t of e.stringTuples())if(t[0]===Qo||t[0]===dx||t[0]===hx||t[0]===fx||t[0]===px)return t[1]}}const Zo=4,Jo=41,ea=6,mx=273;class yx{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=new Map}has(e){const t=e.stringTuples();for(const n of this.mappings.values())for(const s of n)if(s.externalIp===t[0][1])return!0;return!1}add(e,t,n,s=t,i="tcp"){const o=`${e}-${t}-${i}`,a=this.mappings.get(o)??[],c={internalIp:e,internalPort:t,externalIp:n,externalPort:s,externalFamily:sn(n)?4:6,protocol:i,verified:!1,expires:0};a.push(c),this.mappings.set(o,a)}remove(e){const t=e.stringTuples(),n=t[0][1]??"",s=t[1][0]===ea?"tcp":"udp",i=parseInt(t[1][1]??"0");let o=!1;for(const[a,c]of this.mappings.entries()){for(let l=0;l<c.length;l++){const u=c[l];u.externalIp===n&&u.externalPort===i&&u.protocol===s&&(this.log("removing %s:%s to %s:%s %s IP mapping",u.externalIp,u.externalPort,n,i,s),o=o||u.verified,c.splice(l,1),l--)}c.length===0&&this.mappings.delete(a)}return o}getAll(e){const t=[];for(const{multiaddr:n}of e){const s=n.stringTuples();let i;if((s[0][0]===Zo||s[0][0]===Jo)&&s[1][0]===ea?i=`${s[0][1]}-${s[1][1]}-tcp`:(s[0][0]===Zo||s[0][0]===Jo)&&s[1][0]===mx&&(i=`${s[0][1]}-${s[1][1]}-udp`),i==null)continue;const o=this.mappings.get(i);if(o!=null)for(const a of o)s[0][0]=a.externalFamily===4?Zo:Jo,s[0][1]=a.externalIp,s[1][1]=`${a.externalPort}`,t.push({multiaddr:Y(`/${s.map(c=>[V(c[0]).name,c[1]].join("/")).join("/")}`),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return t}confirm(e,t){const s=e.stringTuples()[0][1];let i=!1;for(const o of this.mappings.values())for(const a of o)a.externalIp===s&&(this.log("marking %s to %s IP mapping as verified",a.internalIp,a.externalIp),i=a.verified,a.verified=!0,a.expires=Date.now()+t,a.lastVerified=Date.now());return i}unconfirm(e,t){const n=e.stringTuples(),s=n[0][1]??"",i=n[1][0]===ea?"tcp":"udp",o=parseInt(n[1][1]??"0");let a=!1;for(const c of this.mappings.values())for(let l=0;l<c.length;l++){const u=c[l];u.externalIp===s&&u.externalPort===o&&u.protocol===i&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",u.externalIp,u.externalPort,s,o,i),a=a||u.verified,u.verified=!1,u.expires=Date.now()+t)}return a}}const wx=4,bx=41;function vx(r){try{const[[e,t]]=r.stringTuples();if(t==null)return!1;if(e===wx)return t.startsWith("169.254.");if(e===bx)return t.toLowerCase().startsWith("fe80")}catch{}return!1}const Sx={maxObservedAddresses:10};class Ex{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=new Map,this.maxObservedAddresses=t.maxObservedAddresses??Sx.maxObservedAddresses}has(e){return this.addresses.has(e.toString())}removePrefixed(e){for(const t of this.addresses.keys())t.toString().startsWith(e)&&this.addresses.delete(t)}add(e){this.addresses.size!==this.maxObservedAddresses&&(rs(e)||vx(e)||(this.log("adding observed address %a",e),this.addresses.set(e.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([e,t])=>({multiaddr:Y(e),verified:t.verified,type:"observed",expires:t.expires,lastVerified:t.lastVerified}))}remove(e){const t=this.addresses.get(e.toString())?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(e.toString()),t}confirm(e,t){const n=e.toString(),s=this.addresses.get(n)??{verified:!1,expires:Date.now()+t,lastVerified:Date.now()},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.log("marking observed address %a as verified",n),this.addresses.set(n,s),i}}const _x=4,xx=41,Ax=53,Cx=54,Ix=55,Tx=56,Px=[_x,xx,Ax,Cx,Ix,Tx];function vd(r){try{const[[e]]=r.stringTuples();return Px.includes(e)}catch{}return!1}const kx={maxObservedAddresses:10};class Rx{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=new Map,this.maxObservedAddresses=t.maxObservedAddresses??kx.maxObservedAddresses}get(e,t){if(rs(e))return{multiaddr:e,verified:!0,type:"transport",expires:Date.now()+t,lastVerified:Date.now()};const n=this.toKey(e);let s=this.addresses.get(n);return s==null&&(s={verified:!vd(e),expires:0},this.addresses.set(n,s)),{multiaddr:e,verified:s.verified,type:"transport",expires:s.expires,lastVerified:s.lastVerified}}has(e){const t=this.toKey(e);return this.addresses.has(t)}remove(e){const t=this.toKey(e),n=this.addresses.get(t)?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(t),n}confirm(e,t){const n=this.toKey(e),s=this.addresses.get(n)??{verified:!1,expires:0,lastVerified:0},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.addresses.set(n,s),i}unconfirm(e,t){const n=this.toKey(e),s=this.addresses.get(n)??{verified:!1,expires:0},i=s.verified;return s.verified=!1,s.expires=Date.now()+t,this.addresses.set(n,s),i}toKey(e){if(vd(e)){const t=e.toOptions();return`${t.host}-${t.port}-${t.transport}`}return e.toString()}}const Sd=6e4,Ed={addressVerificationTTL:Sd*10,addressVerificationRetry:Sd*5},Lx=r=>r;function ta(r,e){const t=r.getPeerId();return t!=null&&dt(t).equals(e)&&(r=r.decapsulate(Y(`/p2p/${e.toString()}`))),r}class Dx{log;components;listen;announce;appendAnnounce;announceFilter;observed;dnsMappings;ipMappings;transportAddresses;observedAddressFilter;addressVerificationTTL;addressVerificationRetry;constructor(e,t={}){const{listen:n=[],announce:s=[],appendAnnounce:i=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=n.map(o=>o.toString()),this.announce=new Set(s.map(o=>o.toString())),this.appendAnnounce=new Set(i.map(o=>o.toString())),this.observed=new Ex(e,t),this.dnsMappings=new gx(e,t),this.ipMappings=new yx(e,t),this.transportAddresses=new Rx(e,t),this.announceFilter=t.announceFilter??Lx,this.observedAddressFilter=ts(1024),this.addressVerificationTTL=t.addressVerificationTTL??Ed.addressVerificationTTL,this.addressVerificationRetry=t.addressVerificationRetry??Ed.addressVerificationRetry,this._updatePeerStoreAddresses=Ka(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),e.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}[Symbol.toStringTag]="@libp2p/address-manager";_updatePeerStoreAddresses(){const e=this.getAddresses().map(t=>t.getPeerId()===this.components.peerId.toString()?t.decapsulate(`/p2p/${this.components.peerId.toString()}`):t);this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch(t=>{this.log.error("error updating addresses",t)})}getListenAddrs(){return Array.from(this.listen).map(e=>Y(e))}getAnnounceAddrs(){return Array.from(this.announce).map(e=>Y(e))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(e=>Y(e))}getObservedAddrs(){return this.observed.getAll().map(e=>e.multiaddr)}addObservedAddr(e){const t=e.stringTuples(),n=`${t[0][1]}:${t[1][1]}`;this.observedAddressFilter.has(n)||(this.observedAddressFilter.add(n),e=ta(e,this.components.peerId),!this.ipMappings.has(e)&&(this.dnsMappings.has(e)||this.observed.add(e)))}confirmObservedAddr(e,t){e=ta(e,this.components.peerId);let n=!0;(t?.type==="transport"||this.transportAddresses.has(e))&&!this.transportAddresses.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="dns-mapping"||this.dnsMappings.has(e))&&!this.dnsMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="ip-mapping"||this.ipMappings.has(e))&&!this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="observed"||this.observed.has(e))&&(this.maybeUpgradeToIPMapping(e)?(this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL),n=!1):!this.observed.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1)),n||this._updatePeerStoreAddresses()}removeObservedAddr(e,t){e=ta(e,this.components.peerId),this.observed.has(e)&&this.observed.remove(e),this.transportAddresses.has(e)&&this.transportAddresses.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.dnsMappings.has(e)&&this.dnsMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.ipMappings.has(e)&&this.ipMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry)}getAddresses(){const e=new Set,t=this.getAddressesWithMetadata().filter(n=>{if(!n.verified)return!1;const s=n.multiaddr.toString();return e.has(s)?!1:(e.add(s),!0)}).map(n=>n.multiaddr);return this.announceFilter(t.map(n=>{const s=Y(n);return s.protos().pop()?.path===!0||s.getPeerId()===this.components.peerId.toString()?s:s.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const e=this.getAnnounceAddrs();if(e.length>0)return this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(e)}),e.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let t=[];t=t.concat(this.components.transportManager.getAddrs().map(s=>this.transportAddresses.get(s,this.addressVerificationTTL)));const n=this.getAppendAnnounceAddrs();return n.length>0&&(this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(n)}),t=t.concat(n.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),t=t.concat(this.observed.getAll()),t=t.concat(this.ipMappings.getAll(t)),t=t.concat(this.dnsMappings.getAll(t)),t}addDNSMapping(e,t){this.dnsMappings.add(e,t)}removeDNSMapping(e){this.dnsMappings.remove(Y(`/dns/${e}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(e,t,n,s=t,i="tcp"){this.ipMappings.add(e,t,n,s,i),this.observed.removePrefixed(`/ip${sn(n)?4:6}/${n}/${i}/${s}`)}removePublicAddressMapping(e,t,n,s=t,i="tcp"){this.ipMappings.remove(Y(`/ip${sn(n)?4:6}/${n}/${i}/${s}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(e){if(this.ipMappings.has(e))return!1;const t=e.toOptions();if(t.family===6||t.host==="127.0.0.1"||po(t.host)===!0)return!1;const n=this.components.transportManager.getListeners(),s=[i=>Jn.exactMatch(i)||Ni.exactMatch(i),i=>Fi.exactMatch(i),i=>wS.exactMatch(i)];for(const i of s){if(!i(e))continue;const o=n.filter(l=>l.getAddrs().filter(u=>u.toOptions().family===4&&i(u)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(l=>l.toOptions().host!=="127.0.0.1").pop();if(a==null)continue;const c=a.toOptions();return this.observed.remove(e),this.ipMappings.add(c.host,c.port,t.host,t.port,t.transport),!0}return!1}}var _d;(function(r){r.NOT_STARTED_YET="The libp2p node is not started yet",r.NOT_FOUND="Not found"})(_d||(_d={}));class Mx extends Error{constructor(e="Missing service"){super(e),this.name="MissingServiceError"}}class Ox extends Error{constructor(e="Unmet service dependencies"){super(e),this.name="UnmetServiceDependenciesError"}}class ra extends Error{constructor(e="No content routers available"){super(e),this.name="NoContentRoutersError"}}class xd extends Error{constructor(e="No peer routers available"){super(e),this.name="NoPeerRoutersError"}}class Fx extends Error{constructor(e="Should not try to find self"){super(e),this.name="QueriedForSelfError"}}class Nx extends Error{constructor(e="Unhandled protocol error"){super(e),this.name="UnhandledProtocolError"}}class Bx extends Error{constructor(e="Duplicate protocol handler error"){super(e),this.name="DuplicateProtocolHandlerError"}}class Ad extends Error{constructor(e="Dial denied error"){super(e),this.name="DialDeniedError"}}class Ux extends Error{constructor(e="No transport was configured to listen on this address"){super(e),this.name="UnsupportedListenAddressError"}}class $x extends Error{constructor(e="Configured listen addresses could not be listened on"){super(e),this.name="UnsupportedListenAddressesError"}}class qx extends Error{constructor(e="No valid addresses"){super(e),this.name="NoValidAddressesError"}}class Wx extends Error{constructor(e="Connection intercepted"){super(e),this.name="ConnectionInterceptedError"}}class zx extends Error{constructor(e="Connection denied"){super(e),this.name="ConnectionDeniedError"}}class qs extends Error{constructor(e="Stream is not multiplexed"){super(e),this.name="MuxerUnavailableError"}}class Ws extends Error{constructor(e="Encryption failed"){super(e),this.name="EncryptionFailedError"}}class Kx extends Error{constructor(e="Transport unavailable"){super(e),this.name="TransportUnavailableError"}}class Hx{components={};_started=!1;constructor(e={}){this.components={};for(const[t,n]of Object.entries(e))this.components[t]=n;this.components.logger==null&&(this.components.logger=kp())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter(t=>pc(t)).map(async t=>{await t[e]?.()}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const Vx=["metrics","connectionProtector","dns"],Gx=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function jx(r={}){const e=new Hx(r);return new Proxy(e,{get(n,s,i){if(typeof s=="string"&&!Gx.includes(s)){const o=e.components[s];if(o==null&&!Vx.includes(s))throw new Mx(`${s} not set`);return o}return Reflect.get(n,s,i)},set(n,s,i){return typeof s=="string"?e.components[s]=i:Reflect.set(n,s,i),!0}})}function Yx(r){const e={};for(const t of Object.values(r.components))for(const n of Xx(t))e[n]=!0;for(const t of Object.values(r.components))for(const n of Qx(t))if(e[n]!==!0)throw new Ox(`Service "${Zx(t)}" required capability "${n}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function Xx(r){return Array.isArray(r?.[rt])?r[rt]:[]}function Qx(r){return Array.isArray(r?.[li])?r[li]:[]}function Zx(r){return r?.[Symbol.toStringTag]??r?.toString()??"unknown"}const Jx=4,e2=41;function t2(r={}){return{denyDialPeer:async()=>!1,denyDialMultiaddr:async e=>{if(Jn.matches(e))return!1;const t=e.stringTuples();return t[0][0]===Jx||t[0][0]===e2?!!po(`${t[0][1]}`):!1},denyInboundConnection:async()=>!1,denyOutboundConnection:async()=>!1,denyInboundEncryptedConnection:async()=>!1,denyOutboundEncryptedConnection:async()=>!1,denyInboundUpgradedConnection:async()=>!1,denyOutboundUpgradedConnection:async()=>!1,filterMultiaddrForPeer:async()=>!0,...r}}const Cd=()=>{const r=new Error("Delay aborted");return r.name="AbortError",r},r2=new WeakMap;function n2({clearTimeout:r,setTimeout:e}={}){return(t,{value:n,signal:s}={})=>{if(s?.aborted)return Promise.reject(Cd());let i,o,a;const c=r??clearTimeout,l=()=>{c(i),a(Cd())},u=()=>{s&&s.removeEventListener("abort",l)},d=new Promise((h,p)=>{o=()=>{u(),h(n)},a=p,i=(e??setTimeout)(o,t)});return s&&s.addEventListener("abort",l,{once:!0}),r2.set(d,()=>{c(i),i=null,o()}),d}}const s2=n2();class i2{memoryStorage;points;duration;blockDuration;execEvenly;execEvenlyMinDelayMs;keyPrefix;constructor(e={}){this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.execEvenly=e.execEvenly??!1,this.execEvenlyMinDelayMs=e.execEvenlyMinDelayMs??this.duration*1e3/this.points,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new o2}async consume(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n);let o=this.memoryStorage.incrby(s,t,i);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+t&&(o=this.memoryStorage.set(s,o.consumedPoints,this.blockDuration)),new BS("Rate limit exceeded",o);if(this.execEvenly&&o.msBeforeNext>0&&!o.isFirstInDuration){let a=Math.ceil(o.msBeforeNext/(o.remainingPoints+2));a<this.execEvenlyMinDelayMs&&(a=o.consumedPoints*this.execEvenlyMinDelayMs),await s2(a)}return o}penalty(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,-t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(e,t){const n=t*1e3,s=this.points+1;return this.memoryStorage.set(this.getKey(e),s,t),{remainingPoints:0,msBeforeNext:n===0?-1:n,consumedPoints:s,isFirstInDuration:!1}}set(e,t,n=0){const s=(n>=0?n:this.duration)*1e3;return this.memoryStorage.set(this.getKey(e),t,n),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return t!=null&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return e?.customDuration!=null&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class o2{storage;constructor(){this.storage=new Map}incrby(e,t,n){const s=this.storage.get(e);if(s!=null){const i=s.expiresAt!=null?s.expiresAt.getTime()-new Date().getTime():-1;return s.expiresAt==null||i>0?(s.value+=t,{remainingPoints:0,msBeforeNext:i,consumedPoints:s.value,isFirstInDuration:!1}):this.set(e,t,n)}return this.set(e,t,n)}set(e,t,n){const s=n*1e3,i=this.storage.get(e);i!=null&&clearTimeout(i.timeoutId);const o={value:t,expiresAt:s>0?new Date(Date.now()+s):void 0};return this.storage.set(e,o),s>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(e)},s),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:o.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(t!=null)return{remainingPoints:0,msBeforeNext:t.expiresAt!=null?t.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}delete(e){const t=this.storage.get(e);return t!=null?(t.timeoutId!=null&&clearTimeout(t.timeoutId),this.storage.delete(e),!0):!1}}function Np(r){if(Zd(r))return{peerId:r,multiaddrs:[]};let e=Array.isArray(r)?r:[r],t;if(e.length>0){const n=e[0].getPeerId();t=n==null?void 0:dt(n),e.forEach(s=>{if(!ao(s))throw new Ji("Invalid multiaddr");const i=s.getPeerId();if(i==null){if(t!=null)throw new K("Multiaddrs must all have the same peer id or have no peer id")}else{const o=dt(i);if(t?.equals(o)!==!0)throw new K("Multiaddrs must all have the same peer id or have no peer id")}})}return e=e.filter(n=>!gS.exactMatch(n)),{peerId:t,multiaddrs:e}}const a2=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function c2(r,e){const t=r?.streams?.map(s=>s.protocol)??[],n=e?.closableProtocols??a2;if(!(t.filter(s=>s!=null&&!n.includes(s)).length>0))try{await r?.close(e)}catch(s){r?.abort(s)}}const Bp=1e4,l2=1e4,Id=1e4,Up=25,u2=5,d2=10,h2=5,f2="last-dial-failure",p2="last-dial-success",$p=500,qp=100,Wp=50;async function g2(r,e){let t=!1;for(const s of qc.keys())if(t=r.protoNames().includes(s),t)break;if(!t)return[r];const n=await r.resolve(e);return e.log("resolved %s to",r,n.map(s=>s.toString())),n}function Ja(r){try{let e;if(typeof r=="string"?e=Y(r):e=r,!e.protoNames().includes("ipcidr")){const n=e.protoNames().includes("ip6")?"/ipcidr/128":"/ipcidr/32";e=e.encapsulate(n)}return Vv(e)}catch{throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${r}`)}}const m2={maxConnections:qp};class y2{maxConnections;connectionManager;peerStore;allow;events;log;constructor(e,t={}){this.maxConnections=t.maxConnections??m2.maxConnections,this.allow=(t.allow??[]).map(n=>Ja(n)),this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(e=>{this.log.error("error while pruning connections %e",e)})}async _maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length;if(this.log("checking max connections limit %d/%d",t,this.maxConnections),t<=this.maxConnections)return;const n=new fo;for(const a of e){const c=a.remotePeer;if(!n.has(c)){n.set(c,0);try{const l=await this.peerStore.get(c);n.set(c,[...l.tags.values()].reduce((u,d)=>u+d.value,0))}catch(l){l.name!=="NotFoundError"&&this.log.error("error loading peer tags",l)}}}const s=this.sortConnections(e,n),i=Math.max(t-this.maxConnections,0),o=[];for(const a of s)if(this.log("too many connections open - closing a connection to %p",a.remotePeer),this.allow.some(l=>l.contains(a.remoteAddr.nodeAddress().address))||o.push(a),o.length===i)break;await Promise.all(o.map(async a=>{await c2(a,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:o})}sortConnections(e,t){return e.sort((n,s)=>{const i=n.timeline.open,o=s.timeline.open;return i<o?1:i>o?-1:0}).sort((n,s)=>n.direction==="outbound"&&s.direction==="inbound"?1:n.direction==="inbound"&&s.direction==="outbound"?-1:0).sort((n,s)=>n.streams.length>s.streams.length?1:n.streams.length<s.streams.length?-1:0).sort((n,s)=>{const i=t.get(n.remotePeer)??0,o=t.get(s.remotePeer)??0;return i>o?1:i<o?-1:0})}}class w2 extends rp{constructor(e={}){super({...e,sort:(t,n)=>t.options.priority>n.options.priority?-1:t.options.priority<n.options.priority?1:0})}}function b2(r){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(r)||/^::1$/.test(r)}function Td(r){if(!op(r))return!1;const{address:e}=r.nodeAddress();return b2(e)}function v2(r,e){const t=Fi.exactMatch(r.multiaddr),n=Fi.exactMatch(e.multiaddr);if(t&&!n)return-1;if(!t&&n)return 1;const s=Ni.exactMatch(r.multiaddr),i=Ni.exactMatch(e.multiaddr);if(s&&!i)return-1;if(!s&&i)return 1;const o=Jn.exactMatch(r.multiaddr),a=Jn.exactMatch(e.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=za.exactMatch(r.multiaddr),l=za.exactMatch(e.multiaddr);if(c&&!l)return-1;if(!c&&l)return 1;const u=Cu.exactMatch(r.multiaddr),d=Cu.exactMatch(e.multiaddr);if(u&&!d)return-1;if(!u&&d)return 1;const h=Bi.exactMatch(r.multiaddr),p=Bi.exactMatch(e.multiaddr);return h&&!p?-1:!h&&p?1:0}function S2(r,e){const t=Td(r.multiaddr),n=Td(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function E2(r,e){const t=rs(r.multiaddr),n=rs(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function _2(r,e){return r.isCertified&&!e.isCertified?-1:!r.isCertified&&e.isCertified?1:0}function x2(r,e){const t=es.exactMatch(r.multiaddr),n=es.exactMatch(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function A2(r){return r.sort(v2).sort(_2).sort(x2).sort(E2).sort(S2)}const zs={maxParallelDials:Wp,maxDialQueueLength:$p,maxPeerAddrsToDial:Up,dialTimeout:Bp};class C2{queue;components;addressSorter;maxPeerAddrsToDial;maxDialQueueLength;dialTimeout;shutDownController;connections;log;constructor(e,t={}){this.addressSorter=t.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??zs.maxPeerAddrsToDial,this.maxDialQueueLength=t.maxDialQueueLength??zs.maxDialQueueLength,this.dialTimeout=t.dialTimeout??zs.dialTimeout,this.connections=t.connections??new fo,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.shutDownController=new AbortController,this.shutDownController.signal;for(const[n,s]of Object.entries(t.resolvers??{}))qc.set(n,s);this.queue=new w2({concurrency:t.maxParallelDials??zs.maxParallelDials,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("error",n=>{n.detail?.name!==Er.name&&this.log.error("error in dial queue - %e",n.detail)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){const{peerId:n,multiaddrs:s}=Np(e),i=Array.from(this.connections.values()).flat().find(a=>t.force===!0?!1:a.remotePeer.equals(n)?!0:s.find(c=>c.equals(a.remoteAddr)));if(i?.status==="open")return this.log("already connected to %a",i.remoteAddr),t.onProgress?.(new te("dial-queue:already-connected")),i;const o=this.queue.queue.find(a=>{if(n?.equals(a.options.peerId)===!0)return!0;const c=a.options.multiaddrs;if(c==null)return!1;for(const l of s)if(c.has(l.toString()))return!0;return!1});if(o!=null){this.log("joining existing dial target for %p",n);for(const a of s)o.options.multiaddrs.add(a.toString());return t.onProgress?.(new te("dial-queue:already-in-dial-queue")),o.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new Nn("Dial queue is full");return this.log("creating dial target for %p",n,s.map(a=>a.toString())),t.onProgress?.(new te("dial-queue:add-to-dial-queue")),this.queue.add(async a=>{a.onProgress?.(new te("dial-queue:start-dial"));const c=Jt([this.shutDownController.signal,a.signal]);try{return await this.dialPeer(a,c)}finally{c.clear()}},{peerId:n,priority:t.priority??zp,multiaddrs:new Set(s.map(a=>a.toString())),signal:t.signal??AbortSignal.timeout(this.dialTimeout),onProgress:t.onProgress})}async dialPeer(e,t){const n=e.peerId,s=e.multiaddrs,i=new Set;let o=e.multiaddrs.size===0,a=0,c=0;const l=[];for(this.log("starting dial to %p",n);o||s.size>0;){c++,o=!1;const u=[],d=new Set(e.multiaddrs);s.clear(),this.log("calculating addrs to dial %p from %s",n,[...d]);const h=await this.calculateMultiaddrs(n,d,{...e,signal:t});for(const p of h){if(i.has(p.multiaddr.toString())){this.log.trace("skipping previously failed multiaddr %a while dialing %p",p.multiaddr,n);continue}u.push(p)}this.log("%s dial to %p with %s",c===1?"starting":"continuing",n,u.map(p=>p.multiaddr.toString())),e?.onProgress?.(new te("dial-queue:calculated-addresses",u));for(const p of u){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,e.peerId),new Nn("Peer had more than maxPeerAddrsToDial");a++;try{const f=await this.components.transportManager.dial(p.multiaddr,{...e,signal:t});this.log("dial to %a succeeded",p.multiaddr);try{await this.components.peerStore.merge(f.remotePeer,{multiaddrs:[f.remoteAddr],metadata:{[p2]:z(Date.now().toString())}})}catch(g){this.log.error("could not update last dial failure key for %p",n,g)}return f}catch(f){if(this.log.error("dial failed to %a",p.multiaddr,f),i.add(p.multiaddr.toString()),n!=null)try{await this.components.peerStore.merge(n,{metadata:{[f2]:z(Date.now().toString())}})}catch(g){this.log.error("could not update last dial failure key for %p",n,g)}if(t.aborted)throw new hc(f.message);l.push(f)}}}throw l.length===1?l[0]:new AggregateError(l,"All multiaddr dials failed")}async calculateMultiaddrs(e,t=new Set,n={}){const s=[...t].map(d=>({multiaddr:Y(d),isCertified:!1}));if(e!=null){if(this.components.peerId.equals(e))throw new Nn("Tried to dial self");if(await this.components.connectionGater.denyDialPeer?.(e)===!0)throw new Ad("The dial request is blocked by gater.allowDialPeer");if(s.length===0){this.log("loading multiaddrs for %p",e);try{const d=await this.components.peerStore.get(e);s.push(...d.addresses),this.log("loaded multiaddrs for %p",e,s.map(({multiaddr:h})=>h.toString()))}catch(d){if(d.name!=="NotFoundError")throw d}}if(s.length===0){this.log("looking up multiaddrs for %p in the peer routing",e);try{const d=await this.components.peerRouting.findPeer(e,n);this.log("found multiaddrs for %p in the peer routing",e,s.map(({multiaddr:h})=>h.toString())),s.push(...d.multiaddrs.map(h=>({multiaddr:h,isCertified:!1})))}catch(d){d.name==="NoPeerRoutersError"?this.log("no peer routers configured",e):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",e,d)}}}let i=(await Promise.all(s.map(async d=>{const h=await g2(d.multiaddr,{dns:this.components.dns,...n,log:this.log});return h.length===1&&h[0].equals(d.multiaddr)?d:h.map(p=>({multiaddr:p,isCertified:!1}))}))).flat();if(e!=null){const d=`/p2p/${e.toString()}`;i=i.map(h=>h.multiaddr.protos().pop()?.path===!0?h:h.multiaddr.getPeerId()==null?{multiaddr:h.multiaddr.encapsulate(d),isCertified:h.isCertified}:h)}const o=i.filter(d=>{if(this.components.transportManager.dialTransportForMultiaddr(d.multiaddr)==null)return!1;const h=d.multiaddr.getPeerId();return e!=null&&h!=null?e.equals(h):!0}),a=new Map;for(const d of o){const h=d.multiaddr.toString(),p=a.get(h);if(p!=null){p.isCertified=p.isCertified||d.isCertified||!1;continue}a.set(h,d)}const c=[...a.values()];if(c.length===0)throw new qx("The dial request has no valid addresses");const l=[];for(const d of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(d.multiaddr)||l.push(d);const u=this.addressSorter==null?A2(l):l.sort(this.addressSorter);if(u.length===0)throw new Ad("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",e??"unknown peer",i.map(({multiaddr:d})=>d.toString())),this.log.trace("addresses for %p after filtering",e??"unknown peer",u.map(({multiaddr:d})=>d.toString())),u}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const n=await this.calculateMultiaddrs(void 0,new Set(e.map(s=>s.toString())),t);return t.runOnLimitedConnection===!1?n.find(s=>!es.matches(s.multiaddr))!=null:!0}catch(n){this.log.trace("error calculating if multiaddr(s) were dialable",n)}return!1}}var na={},sa,Pd;function I2(){if(Pd)return sa;Pd=1;function r(e,t){typeof t=="boolean"&&(t={forever:t}),this._originalTimeouts=JSON.parse(JSON.stringify(e)),this._timeouts=e,this._options=t||{},this._maxRetryTime=t&&t.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}return sa=r,r.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},r.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},r.prototype.retry=function(e){if(this._timeout&&clearTimeout(this._timeout),!e)return!1;var t=new Date().getTime();if(e&&t-this._operationStart>=this._maxRetryTime)return this._errors.push(e),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(e);var n=this._timeouts.shift();if(n===void 0)if(this._cachedTimeouts)this._errors.splice(0,this._errors.length-1),n=this._cachedTimeouts.slice(-1);else return!1;var s=this;return this._timer=setTimeout(function(){s._attempts++,s._operationTimeoutCb&&(s._timeout=setTimeout(function(){s._operationTimeoutCb(s._attempts)},s._operationTimeout),s._options.unref&&s._timeout.unref()),s._fn(s._attempts)},n),this._options.unref&&this._timer.unref(),!0},r.prototype.attempt=function(e,t){this._fn=e,t&&(t.timeout&&(this._operationTimeout=t.timeout),t.cb&&(this._operationTimeoutCb=t.cb));var n=this;this._operationTimeoutCb&&(this._timeout=setTimeout(function(){n._operationTimeoutCb()},n._operationTimeout)),this._operationStart=new Date().getTime(),this._fn(this._attempts)},r.prototype.try=function(e){console.log("Using RetryOperation.try() is deprecated"),this.attempt(e)},r.prototype.start=function(e){console.log("Using RetryOperation.start() is deprecated"),this.attempt(e)},r.prototype.start=r.prototype.try,r.prototype.errors=function(){return this._errors},r.prototype.attempts=function(){return this._attempts},r.prototype.mainError=function(){if(this._errors.length===0)return null;for(var e={},t=null,n=0,s=0;s<this._errors.length;s++){var i=this._errors[s],o=i.message,a=(e[o]||0)+1;e[o]=a,a>=n&&(t=i,n=a)}return t},sa}var kd;function T2(){return kd||(kd=1,function(r){var e=I2();r.operation=function(t){var n=r.timeouts(t);return new e(n,{forever:t&&(t.forever||t.retries===1/0),unref:t&&t.unref,maxRetryTime:t&&t.maxRetryTime})},r.timeouts=function(t){if(t instanceof Array)return[].concat(t);var n={retries:10,factor:2,minTimeout:1*1e3,maxTimeout:1/0,randomize:!1};for(var s in t)n[s]=t[s];if(n.minTimeout>n.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var i=[],o=0;o<n.retries;o++)i.push(this.createTimeout(o,n));return t&&t.forever&&!i.length&&i.push(this.createTimeout(o,n)),i.sort(function(a,c){return a-c}),i},r.createTimeout=function(t,n){var s=n.randomize?Math.random()+1:1,i=Math.round(s*Math.max(n.minTimeout,1)*Math.pow(n.factor,t));return i=Math.min(i,n.maxTimeout),i},r.wrap=function(t,n,s){if(n instanceof Array&&(s=n,n=null),!s){s=[];for(var i in t)typeof t[i]=="function"&&s.push(i)}for(var o=0;o<s.length;o++){var a=s[o],c=t[a];t[a]=function(u){var d=r.operation(n),h=Array.prototype.slice.call(arguments,1),p=h.pop();h.push(function(f){d.retry(f)||(f&&(arguments[0]=d.mainError()),p.apply(this,arguments))}),d.attempt(function(){u.apply(t,h)})}.bind(t,c),t[a].options=n}}}(na)),na}var ia,Rd;function P2(){return Rd||(Rd=1,ia=T2()),ia}var k2=P2();const R2=bs(k2),L2=Object.prototype.toString,D2=r=>L2.call(r)==="[object Error]",M2=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Load failed","Network request failed","fetch failed","terminated"]);function O2(r){return r&&D2(r)&&r.name==="TypeError"&&typeof r.message=="string"?r.message==="Load failed"?r.stack===void 0:M2.has(r.message):!1}class F2 extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,{message:e}=e):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}const Ld=(r,e,t)=>{const n=t.retries-(e-1);return r.attemptNumber=e,r.retriesLeft=n,r};async function N2(r,e){return new Promise((t,n)=>{e={...e},e.onFailedAttempt??=()=>{},e.shouldRetry??=()=>!0,e.retries??=10;const s=R2.operation(e),i=()=>{s.stop(),n(e.signal?.reason)};e.signal&&!e.signal.aborted&&e.signal.addEventListener("abort",i,{once:!0});const o=()=>{e.signal?.removeEventListener("abort",i),s.stop()};s.attempt(async a=>{try{const c=await r(a);o(),t(c)}catch(c){try{if(!(c instanceof Error))throw new TypeError(`Non-error was thrown: "${c}". You should only throw errors.`);if(c instanceof F2)throw c.originalError;if(c instanceof TypeError&&!O2(c))throw c;if(Ld(c,a,e),await e.shouldRetry(c)||(s.stop(),n(c)),await e.onFailedAttempt(c),!s.retry(c))throw s.mainError()}catch(l){Ld(l,a,e),o(),n(l)}}})})}class B2{log;queue;started;peerStore;retries;retryInterval;backoffFactor;connectionManager;events;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.queue=new jc({concurrency:t.maxParallelReconnects??h2,metricName:"libp2p_reconnect_queue",metrics:e.metrics}),this.started=!1,this.retries=t.retries??5,this.backoffFactor=t.backoffFactor,this.retryInterval=t.retryInterval,this.events=e.events,e.events.addEventListener("peer:disconnect",n=>{this.maybeReconnect(n.detail).catch(s=>{this.log.error("failed to maybe reconnect to %p - %e",n.detail,s)})})}async maybeReconnect(e){if(!this.started)return;const t=await this.peerStore.get(e);Dd(t)&&(this.queue.has(e)||this.queue.add(async n=>{await N2(async s=>{if(this.started)try{await this.connectionManager.openConnection(e,{signal:n?.signal})}catch(i){throw this.log("reconnecting to %p attempt %d of %d failed - %e",e,s,this.retries,i),i}},{signal:n?.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:e}).catch(async n=>{this.log.error("failed to reconnect to %p - %e",e,n);const s={};[...t.tags.keys()].forEach(i=>{i.startsWith(uc)&&(s[i]=void 0)}),await this.peerStore.merge(e,{tags:s}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:e})}).catch(async n=>{this.log.error("failed to remove keep-alive tag from %p - %e",e,n)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>Dd(t)]});await Promise.all(e.map(async t=>{await this.connectionManager.openConnection(t.id).catch(n=>{this.log.error(n)})}))}).catch(e=>{this.log.error(e)})}stop(){this.started=!1,this.queue.abort()}}function Dd(r){for(const e of r.tags.keys())if(e.startsWith(uc))return!0;return!1}const zp=50,oa={maxConnections:qp,inboundConnectionThreshold:u2,maxIncomingPendingConnections:d2};class U2{started;connections;allow;deny;maxIncomingPendingConnections;incomingPendingConnections;outboundPendingConnections;maxConnections;dialQueue;reconnectQueue;connectionPruner;inboundConnectionRateLimiter;peerStore;metrics;events;log;peerId;constructor(e,t={}){if(this.maxConnections=t.maxConnections??oa.maxConnections,this.maxConnections<1)throw new K("Connection Manager maxConnections must be greater than 0");this.connections=new fo,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(t.allow??[]).map(n=>Ja(n)),this.deny=(t.deny??[]).map(n=>Ja(n)),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??oa.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new i2({points:t.inboundConnectionThreshold??oa.inboundConnectionThreshold,duration:1}),this.connectionPruner=new y2({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{maxConnections:this.maxConnections,allow:t.allow?.map(n=>Y(n))}),this.dialQueue=new C2(e,{addressSorter:t.addressSorter,maxParallelDials:t.maxParallelDials??Wp,maxDialQueueLength:t.maxDialQueueLength??$p,maxPeerAddrsToDial:t.maxPeerAddrsToDial??Up,dialTimeout:t.dialTimeout??Bp,resolvers:t.resolvers??{dnsaddr:Tp},connections:this.connections}),this.reconnectQueue=new B2({events:e.events,peerStore:e.peerStore,logger:e.logger,connectionManager:this},{retries:t.reconnectRetries,retryInterval:t.reconnectRetryInterval,backoffFactor:t.reconnectBackoffFactor,maxParallelReconnects:t.maxParallelReconnects})}[Symbol.toStringTag]="@libp2p/connection-manager";async start(){this.metrics?.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const e={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const t of this.connections.values())for(const n of t)e[n.direction]++;return e}}),this.metrics?.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const e={};for(const t of this.connections.values())for(const n of t)for(const s of n.streams){const i=`${s.direction} ${s.protocol??"unnegotiated"}`;e[i]=(e[i]??0)+1}return e}}),this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const e={};for(const n of this.connections.values())for(const s of n){const i={};for(const o of s.streams){const a=`${o.direction} ${o.protocol??"unnegotiated"}`;i[a]=(i[a]??0)+1}for(const[o,a]of Object.entries(i))e[o]=e[o]??[],e[o].push(a)}const t={};for(let[n,s]of Object.entries(e)){s=s.sort((o,a)=>o-a);const i=Math.floor(s.length*.9);t[n]=s[i]}return t}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await oh(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await ah(this.reconnectQueue,this.dialQueue,this.connectionPruner);const e=[];for(const t of this.connections.values())for(const n of t)e.push((async()=>{try{await n.close()}catch(s){this.log.error(s)}})());this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}onConnect(e){this._onConnect(e).catch(t=>{this.log.error(t)})}async _onConnect(e){const{detail:t}=e;if(!this.started){await t.close();return}if(t.status!=="open")return;const n=t.remotePeer,s=!this.connections.has(n),i=this.connections.get(n)??[];i.push(t),this.connections.set(n,i),n.publicKey!=null&&n.type==="RSA"&&await this.peerStore.patch(n,{publicKey:n.publicKey}),s&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e,n=t.remotePeer,i=(this.connections.get(n)??[]).filter(o=>o.id!==t.id);this.connections.set(n,i),i.length===0&&(this.log("onDisconnect remove all connections for peer %p",n),this.connections.delete(n),this.events.safeDispatchEvent("peer:disconnect",{detail:t.remotePeer}))}getConnections(e){if(e!=null)return this.connections.get(e)??[];let t=[];for(const n of this.connections.values())t=t.concat(n);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){if(!this.started)throw new ci("Not started");this.outboundPendingConnections++;try{t.signal?.throwIfAborted();const{peerId:n}=Np(e);if(this.peerId.equals(n))throw new nh("Can not dial self");if(n!=null&&t.force!==!0){this.log("dial %p",n);const a=this.getConnections(n).find(c=>c.limits==null);if(a!=null)return this.log("had an existing non-limited connection to %p",n),t.onProgress?.(new te("dial-queue:already-connected")),a}const s=await this.dialQueue.dial(e,{...t,priority:t.priority??zp});if(s.status!=="open")throw new th("Remote closed connection during opening");let i=this.connections.get(s.remotePeer);i==null&&(i=[],this.connections.set(s.remotePeer,i));let o=!1;for(const a of i)if(a.id===s.id&&(o=!0),t.force!==!0&&a.id!==s.id&&a.remoteAddr.equals(s.remoteAddr))return s.abort(new Ji("Duplicate multiaddr connection")),a;return o||i.push(s),s}finally{this.outboundPendingConnections--}}async closeConnections(e,t={}){const n=this.connections.get(e)??[];await Promise.all(n.map(async s=>{try{await s.close(t)}catch(i){s.abort(i)}}))}async acceptIncomingConnection(e){if(this.deny.some(s=>s.contains(e.remoteAddr.nodeAddress().address)))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some(s=>s.contains(e.remoteAddr.nodeAddress().address)))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(e.remoteAddr.isThinWaistAddress()){const s=e.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(s,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,s),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map(n=>Y(n))}))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}class aa{movingAverage;variance;deviation;forecast;timeSpan;previousTime;constructor(e){this.timeSpan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timeSpan)}push(e,t=Date.now()){if(this.previousTime!=null){const n=this.alpha(t,this.previousTime),s=e-this.movingAverage,i=n*s;this.movingAverage=n*e+(1-n)*this.movingAverage,this.variance=(1-n)*(this.variance+s*i),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+n*s}else this.movingAverage=e;this.previousTime=t}}const $2=1.2,q2=2,W2=5e3,z2=6e4,K2=5e3;class H2{success;failure;next;metric;timeoutMultiplier;failureMultiplier;minTimeout;maxTimeout;constructor(e={}){const t=e.interval??K2;this.success=new aa(t),this.failure=new aa(t),this.next=new aa(t),this.failureMultiplier=e.failureMultiplier??q2,this.timeoutMultiplier=e.timeoutMultiplier??$2,this.minTimeout=e.minTimeout??W2,this.maxTimeout=e.maxTimeout??z2,e.metricName!=null&&(this.metric=e.metrics?.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){let t=Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier));t<this.minTimeout&&(t=this.minTimeout),t>this.maxTimeout&&(t=this.maxTimeout);const n=AbortSignal.timeout(t),s=Jt([e.signal,n]);return s.start=Date.now(),s.timeout=t,s}cleanUp(e){const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),this.metric?.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),this.metric?.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}const V2=1e4,G2="1.0.0",j2="ping",Y2="ipfs",Md=32,X2=!0;class Q2{protocol;components;log;heartbeatInterval;pingIntervalMs;abortController;timeout;abortConnectionOnPingFailure;constructor(e,t={}){this.components=e,this.protocol=`/${t.protocolPrefix??Y2}/${j2}/${G2}`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??V2,this.abortConnectionOnPingFailure=t.abortConnectionOnPingFailure??X2,this.timeout=new H2({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}[Symbol.toStringTag]="@libp2p/connection-monitor";[rt]=["@libp2p/connection-monitor"];start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(e=>{Promise.resolve().then(async()=>{let t=Date.now();try{const n=this.timeout.getTimeoutSignal({signal:this.abortController?.signal}),s=await e.newStream(this.protocol,{signal:n,runOnLimitedConnection:!0}),i=_i(s);t=Date.now(),await Promise.all([i.write(Lc(Md),{signal:n}),i.read({bytes:Md,signal:n})]),e.rtt=Date.now()-t,await i.unwrap().close({signal:n})}catch(n){if(n.name!=="UnsupportedProtocolError")throw n;e.rtt=(Date.now()-t)/2}}).catch(t=>{this.log.error("error during heartbeat",t),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),e.abort(t)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){this.abortController?.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}class Z2{routers;started;components;constructor(e,t){this.routers=t.routers??[],this.started=!1,this.components=e,this.findProviders=e.metrics?.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,cid:n.toString()}),getAttributesFromYieldedValue:(n,s)=>({...s,providers:[...Array.isArray(s.providers)?s.providers:[],n.id.toString()]})})??this.findProviders,this.provide=e.metrics?.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,cid:n.toString()})})??this.provide,this.cancelReprovide=e.metrics?.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,cid:n.toString()})})??this.cancelReprovide,this.put=e.metrics?.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([n])=>({key:G(n,"base36")})})??this.put,this.get=e.metrics?.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([n])=>({key:G(n,"base36")})})??this.get}[Symbol.toStringTag]="@libp2p/content-routing";isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(this.routers.length===0)throw new ra("No content routers available");const n=this,s=new Vr;for await(const i of xi(...n.routers.filter(o=>o.findProviders instanceof Function).map(o=>o.findProviders(e,t))))i!=null&&(i.multiaddrs.length>0&&await this.components.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),!s.has(i.id)&&(s.add(i.id),yield i))}async provide(e,t={}){if(this.routers.length===0)throw new ra("No content routers available");await Promise.all(this.routers.filter(n=>n.provide instanceof Function).map(async n=>{await n.provide(e,t)}))}async cancelReprovide(e,t={}){if(this.routers.length===0)throw new ra("No content routers available");await Promise.all(this.routers.filter(n=>n.cancelReprovide instanceof Function).map(async n=>{await n.cancelReprovide(e,t)}))}async put(e,t,n){if(!this.isStarted())throw new ci;await Promise.all(this.routers.filter(s=>s.put instanceof Function).map(async s=>{await s.put(e,t,n)}))}async get(e,t){if(!this.isStarted())throw new ci;return Promise.any(this.routers.filter(n=>n.get instanceof Function).map(async n=>n.get(e,t)))}}class J2{log;peerId;peerStore;routers;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[],this.findPeer=e.metrics?.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,peer:n.toString()})})??this.findPeer,this.getClosestPeers=e.metrics?.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,key:G(n,"base36")}),getAttributesFromYieldedValue:(n,s)=>({...s,peers:[...Array.isArray(s.peers)?s.peers:[],n.id.toString()]})})??this.getClosestPeers}[Symbol.toStringTag]="@libp2p/peer-routing";async findPeer(e,t){if(this.routers.length===0)throw new xd("No peer routers available");if(e.toString()===this.peerId.toString())throw new Fx("Should not try to find self");const n=this,s=xi(...this.routers.filter(i=>i.findPeer instanceof Function).map(i=>async function*(){try{yield await i.findPeer(e,t)}catch(o){n.log.error(o)}}()));for await(const i of s)if(i!=null)return i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),i;throw new va}async*getClosestPeers(e,t={}){if(this.routers.length===0)throw new xd("No peer routers available");const n=this,s=ts(1024);for await(const i of np(async function*(){const o=xi(...n.routers.filter(a=>a.getClosestPeers instanceof Function).map(a=>a.getClosestPeers(e,t)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await n.findPeer(a.id,{...t,useCache:!1})}catch(c){n.log.error("could not find peer multiaddrs",c);return}return a}}()))i!=null&&(i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),!s.has(i.id.toMultihash().bytes)&&(s.add(i.id.toMultihash().bytes),yield i))}}class eA extends Qt{peerRouting;log;walking;walkers;shutdownController;walkController;needNext;constructor(e){super(),this.log=e.logger.forComponent("libp2p:random-walk"),this.peerRouting=e.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}[Symbol.toStringTag]="@libp2p/random-walk";start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(e){this.walking||this.startWalk(),this.walkers++;const t=Jt([this.shutdownController.signal,e?.signal]);try{for(;;)this.needNext?.resolve(),this.needNext=pe(),yield(await Gr(this,"walk:peer",t,{errorEvent:"walk:error"})).detail}finally{t.clear(),this.walkers--,this.walkers===0&&(this.walkController?.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const e=Jt([this.walkController.signal,this.shutdownController.signal]),t=Date.now();let n=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const s=Lc(32);let i=Date.now();for await(const o of this.peerRouting.getClosestPeers(s,{signal:e}))e.aborted&&this.log("aborting walk"),e.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",o.id,Date.now()-i,this.walkers),n++,this.safeDispatchEvent("walk:peer",{detail:o}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await _e(this.needNext.promise,e)),i=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",s,this.walkers,n)}catch(s){this.log.error("random walk errored",s),this.safeDispatchEvent("walk:error",{detail:s})}this.log("no walkers left, ended walk")}).catch(s=>{this.log.error("random walk errored",s)}).finally(()=>{this.log("finished walk, found %d peers after %dms",n,Date.now()-t),this.walking=!1})}}const Kp=32,Hp=64;class tA{log;topologies;handlers;components;constructor(e){this.log=e.logger.forComponent("libp2p:registrar"),this.topologies=new Map,this.handlers=new Map,this.components=e,this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}[Symbol.toStringTag]="@libp2p/registrar";getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(t==null)throw new Nx(`No handler registered for protocol ${e}`);return t}getTopologies(e){const t=this.topologies.get(e);return t==null?[]:[...t.values()]}async handle(e,t,n){if(this.handlers.has(e)&&n?.force!==!0)throw new Bx(`Handler already registered for protocol ${e}`);const s=xp.bind({ignoreUndefined:!0})({maxInboundStreams:Kp,maxOutboundStreams:Hp},n);this.handlers.set(e,{handler:t,options:s}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]})}async unhandle(e){(Array.isArray(e)?e:[e]).forEach(n=>{this.handlers.delete(n)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()})}async register(e,t){if(t==null)throw new K("invalid topology");const n=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let s=this.topologies.get(e);return s==null&&(s=new Map,this.topologies.set(e,s)),s.set(n,t),n}unregister(e){for(const[t,n]of this.topologies.entries())n.has(e)&&(n.delete(e),n.size===0&&this.topologies.delete(t))}_onDisconnect(e){const t=e.detail;this.components.peerStore.get(t).then(n=>{for(const s of n.protocols){const i=this.topologies.get(s);if(i!=null)for(const o of i.values())o.filter?.has(t)!==!1&&(o.filter?.remove(t),o.onDisconnect?.(t))}}).catch(n=>{n.name!=="NotFoundError"&&this.log.error("could not inform topologies of disconnecting peer %p",t,n)})}_onPeerUpdate(e){const{peer:t,previous:n}=e.detail,s=(n?.protocols??[]).filter(i=>!t.protocols.includes(i));for(const i of s){const o=this.topologies.get(i);if(o!=null)for(const a of o.values())a.filter?.has(t.id)!==!1&&(a.filter?.remove(t.id),a.onDisconnect?.(t.id))}}_onPeerIdentify(e){const t=e.detail.protocols,n=e.detail.connection,s=e.detail.peerId;for(const i of t){const o=this.topologies.get(i);if(o!=null)for(const a of o.values())n.limits!=null&&a.notifyOnLimitedConnection!==!0||a.filter?.has(s)!==!0&&(a.filter?.add(s),a.onConnect?.(s,n))}}}class rA extends Map{metric;constructor(e){super();const{name:t,metrics:n}=e;this.metric=n.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function nA(r){const{name:e,metrics:t}=r;let n;return t!=null?n=new rA({name:e,metrics:t}):n=new Map,n}class sA{log;components;transports;listeners;faultTolerance;started;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=new Map,this.listeners=nA({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??Wn.FATAL_ALL}[Symbol.toStringTag]="@libp2p/transport-manager";add(e){const t=e[Symbol.toStringTag];if(t==null)throw new K("Transport must have a valid tag");if(this.transports.has(t))throw new K(`There is already a transport with the tag ${t}`);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,n]of this.listeners)for(this.log("closing listeners for %s",t);n.length>0;){const s=n.pop();s!=null&&e.push(s.close())}await Promise.all(e),this.log("all listeners closed");for(const t of this.listeners.keys())this.listeners.set(t,[]);this.started=!1}async dial(e,t){const n=this.dialTransportForMultiaddr(e);if(n==null)throw new Kx(`No transport available for address ${String(e)}`);return t?.onProgress?.(new te("transport-manager:selected-transport",n[Symbol.toStringTag])),n.dial(e,{...t,upgrader:this.components.upgrader})}getAddrs(){let e=[];for(const t of this.listeners.values())for(const n of t)e=[...e,...n.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values())if(t.dialFilter([e]).length>0)return t}listenTransportForMultiaddr(e){for(const t of this.transports.values())if(t.listenFilter([e]).length>0)return t}async listen(e){if(!this.isStarted())throw new ci("Not started");if(e==null||e.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const t={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};e.forEach(i=>{t.errors.set(i.toString(),new Ux)});const n=[];for(const[i,o]of this.transports.entries()){const a=o.listenFilter(e);for(const c of a){this.log("creating listener for %s on %a",i,c);const l=o.createListener({upgrader:this.components.upgrader});let u=this.listeners.get(i)??[];u==null&&(u=[],this.listeners.set(i,u)),u.push(l),l.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:l})}),l.addEventListener("close",()=>{const d=u.findIndex(h=>h===l);u.splice(d,1),this.components.events.safeDispatchEvent("transport:close",{detail:l})}),xu.matches(c)?t.ipv4.attempts++:Au.matches(c)&&t.ipv6.attempts++,n.push(l.listen(c).then(()=>{t.errors.delete(c.toString()),xu.matches(c)&&t.ipv4.success++,Au.matches(c)&&t.ipv6.success++},d=>{throw this.log.error("transport %s could not listen on address %a - %e",i,c,d),t.errors.set(c.toString(),d),d}))}}const s=await Promise.allSettled(n);if(!(s.length>0&&s.every(i=>i.status==="fulfilled"))){if(this.ipv6Unsupported(t)){this.log("all IPv4 addresses succeed but all IPv6 failed");return}if(this.faultTolerance===Wn.NO_FATAL){this.log("failed to listen on any address but fault tolerance allows this");return}throw new $x(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...t.errors.entries()].map(([i,o])=>`
  ${i}: ${`${o.stack??o}`.split(`
`).join(`
  `)}
`).join("")}`)}}ipv6Unsupported(e){if(e.ipv4.attempts===0||e.ipv6.attempts===0)return!1;const t=e.ipv4.attempts===e.ipv4.success,n=e.ipv6.success===0;return t&&n}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const n=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const s=t.pop();s!=null&&n.push(s.close())}await Promise.all(n),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}const Ve="/multistream/1.0.0",Jc=1024,iA=z(`
`);async function Ln(r,e,t){await r.write(e,t)}async function oA(r,e,t){await r.writeV(e,t)}async function aA(r,e){const t=await r.read(e);if(t.byteLength===0||t.get(t.byteLength-1)!==iA[0])throw e.log.error("Invalid mss message - missing newline",t),new mt("Missing newline");return t.sublist(0,-1)}async function jr(r,e){const t=await aA(r,e);return G(t.subarray())}async function ca(r,e,t){if(e=Array.isArray(e)?[...e]:[e],e.length===1&&t.negotiateFully===!1)return cA(r,e[0],t);const n=tn(r,{...t,maxDataLength:Jc}),s=e.shift();if(s==null)throw new Error("At least one protocol must be specified");t.log.trace('select: write ["%s", "%s"]',Ve,s);const i=z(`${Ve}
`),o=z(`${s}
`);await oA(n,[i,o],t),t.log.trace("select: reading multistream-select header");let a=await jr(n,t);if(t.log.trace('select: read "%s"',a),a===Ve&&(t.log.trace("select: reading protocol response"),a=await jr(n,t),t.log.trace('select: read "%s"',a)),a===s)return{stream:n.unwrap(),protocol:s};for(const c of e){t.log.trace('select: write "%s"',c),await Ln(n,z(`${c}
`),t),t.log.trace("select: reading protocol response");const l=await jr(n,t);if(t.log.trace('select: read "%s" for "%s"',l,c),l===c)return{stream:n.unwrap(),protocol:c}}throw new dc("protocol selection failed")}function cA(r,e,t){const n=r.sink.bind(r),s=r.source;let i=!1,o=!1;const a=pe();let c=!1,l=!1;const u=pe();let d=!1,h=!1;const p=pe(),f=tn({sink:n,source:s},{...t,maxDataLength:Jc});r.sink=async x=>{const{sink:w}=f.unwrap();await w(async function*(){let y=!1;for await(const v of x){if(l&&await u.promise,c)yield v;else{l=!0,t.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink',Ve,e,v.byteLength);const C=`${e}
`;yield new J(Uint8Array.from([19]),z(`${Ve}
`),bt(C.length),z(C),v).subarray(),t.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink',Ve,e,v.byteLength),c=!0,l=!1,u.resolve(),g().catch(E=>{t.log.error("could not finish optimistic protocol negotiation of %s",e,E)})}y=!0}y||await g()}())};async function g(){if(o){t.log.trace("optimistic: already negotiating %s stream",e),await a.promise;return}o=!0;try{c||(t.log.trace("optimistic: doing send protocol for %s stream",e),await m()),d||(t.log.trace("optimistic: doing read protocol for %s stream",e),await S())}finally{o=!1,i=!0,a.resolve()}}async function m(){if(l){await u.promise;return}l=!0;try{t.log.trace('optimistic: write ["%s", "%s", data] in source',Ve,e),await f.writeV([z(`${Ve}
`),z(`${e}
`)]),t.log.trace('optimistic: wrote ["%s", "%s", data] in source',Ve,e)}finally{c=!0,l=!1,u.resolve()}}async function S(){if(h){await p.promise;return}h=!0;try{t.log.trace("optimistic: reading multistream select header");let x=await jr(f,t);if(t.log.trace('optimistic: read multistream select header "%s"',x),x===Ve&&(x=await jr(f,t)),t.log.trace('optimistic: read protocol "%s", expecting "%s"',x,e),x!==e)throw new dc("protocol selection failed")}finally{d=!0,h=!1,p.resolve()}}if(r.source=async function*(){await g(),t.log.trace('optimistic: reading data from "%s" stream',e),yield*f.unwrap().source}(),r.closeRead!=null){const x=r.closeRead.bind(r);r.closeRead=async w=>{i||await g().catch(y=>{t.log.error("could not negotiate protocol before close read",y)}),await x(w)}}if(r.closeWrite!=null){const x=r.closeWrite.bind(r);r.closeWrite=async w=>{i||await g().catch(y=>{t.log.error("could not negotiate protocol before close write",y)}),await x(w)}}if(r.close!=null){const x=r.close.bind(r);r.close=async w=>{const y=[];l&&y.push(u.promise),h&&y.push(p.promise),y.length>0?await _e(Promise.all(y),w?.signal):(i=!0,o=!1,a.resolve()),await x(w)}}return{stream:r,protocol:e}}async function la(r,e,t){e=Array.isArray(e)?e:[e],t.log.trace("handle: available protocols %s",e);const n=tn(r,{...t,maxDataLength:Jc,maxLengthLength:2});for(;;){t.log.trace("handle: reading incoming string");const s=await jr(n,t);if(t.log.trace('handle: read "%s"',s),s===Ve){t.log.trace('handle: respond with "%s" for "%s"',Ve,s),await Ln(n,z(`${Ve}
`),t),t.log.trace('handle: responded with "%s" for "%s"',Ve,s);continue}if(e.includes(s))return t.log.trace('handle: respond with "%s" for "%s"',s,s),await Ln(n,z(`${s}
`),t),t.log.trace('handle: responded with "%s" for "%s"',s,s),{stream:n.unwrap(),protocol:s};if(s==="ls"){const i=new J(...e.map(o=>Si.single(z(`${o}
`))),z(`
`));t.log.trace('handle: respond with "%s" for %s',e,s),await Ln(n,i,t),t.log.trace('handle: responded with "%s" for %s',e,s);continue}t.log.trace('handle: respond with "na" for "%s"',s),await Ln(n,z(`na
`),t),t.log('handle: responded with "na" for "%s"',s)}}const lA=500;class uA{id;remoteAddr;remotePeer;direction;timeline;multiplexer;encryption;status;limits;log;tags;_newStream;_close;_abort;_getStreams;constructor(e){const{remoteAddr:t,remotePeer:n,newStream:s,close:i,abort:o,getStreams:a}=e;this.id=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`,this.remoteAddr=t,this.remotePeer=n,this.direction=e.direction,this.status="open",this.timeline=e.timeline,this.multiplexer=e.multiplexer,this.encryption=e.encryption,this.limits=e.limits,this.log=e.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`),this.remoteAddr.getPeerId()==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),this._newStream=s,this._close=i,this._abort=o,this._getStreams=a,this.tags=[]}[Symbol.toStringTag]="Connection";[Jg]=!0;get streams(){return this._getStreams()}async newStream(e,t){if(this.status==="closing")throw new tm("the connection is being closed");if(this.status==="closed")throw new th("the connection is closed");if(Array.isArray(e)||(e=[e]),this.limits!=null&&t?.runOnLimitedConnection!==!0)throw new sh("Cannot open protocol stream on limited connection");const n=await this._newStream(e,t);return n.direction="outbound",n}async close(e={}){if(!(this.status==="closed"||this.status==="closing")){if(this.log("closing connection to %a",this.remoteAddr),this.status="closing",e.signal==null){const t=AbortSignal.timeout(lA);e={...e,signal:t}}try{this.log.trace("closing underlying transport"),await this._close(e),this.log.trace("updating timeline with close time"),this.status="closed",this.timeline.close=Date.now()}catch(t){this.log.error("error encountered during graceful close of connection to %a",this.remoteAddr,t),this.abort(t)}}}abort(e){this.status!=="closed"&&(this.log.error("aborting connection to %a due to error",this.remoteAddr,e),this.status="closing",this._abort(e),this.status="closed",this.timeline.close=Date.now())}}function dA(r){return new uA(r)}function hA(r,e){try{const{options:t}=e.getHandler(r);return t.maxInboundStreams}catch(t){if(t.name!=="UnhandledProtocolError")throw t}return Kp}function fA(r,e,t={}){try{const{options:n}=e.getHandler(r);if(n.maxOutboundStreams!=null)return n.maxOutboundStreams}catch(n){if(n.name!=="UnhandledProtocolError")throw n}return t.maxOutboundStreams??Hp}function Od(r,e,t){let n=0;return t.streams.forEach(s=>{s.direction===e&&s.protocol===r&&n++}),n}class pA{components;connectionEncrypters;streamMuxers;inboundUpgradeTimeout;inboundStreamProtocolNegotiationTimeout;outboundStreamProtocolNegotiationTimeout;events;metrics;constructor(e,t){this.components=e,this.connectionEncrypters=new Map,t.connectionEncrypters.forEach(n=>{this.connectionEncrypters.set(n.protocol,n)}),this.streamMuxers=new Map,t.streamMuxers.forEach(n=>{this.streamMuxers.set(n.protocol,n)}),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??l2,this.inboundStreamProtocolNegotiationTimeout=t.inboundStreamProtocolNegotiationTimeout??Id,this.outboundStreamProtocolNegotiationTimeout=t.outboundStreamProtocolNegotiationTimeout??Id,this.events=e.events,this.metrics={dials:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total")}}[Symbol.toStringTag]="@libp2p/upgrader";async shouldBlockConnection(e,...t){const n=this.components.connectionGater[e];if(n==null)return;if(await n.apply(this.components.connectionGater,t)===!0)throw new Wx(`The multiaddr connection is blocked by gater.${e}`)}createInboundAbortSignal(e){return Jt([AbortSignal.timeout(this.inboundUpgradeTimeout),e])}async upgradeInbound(e,t){let n=!1;const s=this.createInboundAbortSignal(t.signal);try{if(this.metrics.dials?.increment({inbound:!0}),n=await this.components.connectionManager.acceptIncomingConnection(e),!n)throw new zx("Connection denied");await this.shouldBlockConnection("denyInboundConnection",e),await this._performUpgrade(e,"inbound",{...t,signal:s})}catch(i){throw this.metrics.errors?.increment({inbound:!0}),i}finally{s.clear(),n&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t){try{this.metrics.dials?.increment({outbound:!0});const n=e.remoteAddr.getPeerId();let s;n!=null&&(s=dt(n),await this.shouldBlockConnection("denyOutboundConnection",s,e));let i="outbound";return t.initiator===!1&&(i="inbound"),await this._performUpgrade(e,i,t)}catch(n){throw this.metrics.errors?.increment({outbound:!0}),n}}async _performUpgrade(e,t,n){let s,i,o,a,c;this.components.metrics?.trackMultiaddrConnection(e),e.log.trace("starting the %s connection upgrade",t);let l=e;if(n?.skipProtection!==!0){const u=this.components.connectionProtector;u!=null&&(e.log("protecting the %s connection",t),l=await u.protect(e,n))}try{if(s=l,n?.skipEncryption!==!0){n?.onProgress?.(new te(`upgrader:encrypt-${t}-connection`)),{conn:s,remotePeer:i,protocol:c,streamMuxer:a}=await(t==="inbound"?this._encryptInbound(l,n):this._encryptOutbound(l,n));const u={...l,...s};await this.shouldBlockConnection(t==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",i,u)}else{const u=e.remoteAddr.getPeerId();if(u==null)throw new Ji(`${t} connection that skipped encryption must have a peer id`);const d=dt(u);c="native",i=d}if(i.equals(this.components.peerId)){const u=new nh("Can not dial self");throw e.abort(u),u}if(o=s,n?.muxerFactory!=null)a=n.muxerFactory;else if(a==null&&this.streamMuxers.size>0){n?.onProgress?.(new te(`upgrader:multiplex-${t}-connection`));const u=await(t==="inbound"?this._multiplexInbound({...l,...s},this.streamMuxers,n):this._multiplexOutbound({...l,...s},this.streamMuxers,n));a=u.muxerFactory,o=u.stream}}catch(u){throw e.log.error("failed to upgrade inbound connection %s %a - %e",t==="inbound"?"from":"to",e.remoteAddr,u),u}return await this.shouldBlockConnection(t==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",i,e),e.log("successfully upgraded %s connection",t),this._createConnection({cryptoProtocol:c,direction:t,maConn:e,upgradedConn:o,muxerFactory:a,remotePeer:i,limits:n?.limits})}_createConnection(e){const{cryptoProtocol:t,direction:n,maConn:s,upgradedConn:i,remotePeer:o,muxerFactory:a,limits:c}=e;let l,u,d;a!=null&&(l=a.createStreamMuxer({direction:n,onIncomingStream:f=>{d!=null&&Promise.resolve().then(async()=>{const g=this.components.registrar.getProtocols(),m=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout),{stream:S,protocol:x}=await la(f,g,{signal:m,log:f.log,yieldBytes:!1});if(d==null)return;d.log("incoming stream opened on %s",x);const w=hA(x,this.components.registrar);if(Od(x,"inbound",d)===w){const v=new om(`Too many inbound protocol streams for protocol "${x}" - limit ${w}`);throw f.abort(v),v}f.source=S.source,f.sink=S.sink,f.protocol=x,S.closeWrite!=null&&(f.closeWrite=S.closeWrite),S.closeRead!=null&&(f.closeRead=S.closeRead),S.close!=null&&(f.close=S.close),await this.components.peerStore.merge(o,{protocols:[x]}),this.components.metrics?.trackProtocolStream(f,d),this._onStream({connection:d,stream:f,protocol:x})}).catch(async g=>{d.log.error("error handling incoming stream id %s - %e",f.id,g),f.timeline.close==null&&await f.close()})}}),u=async(f,g={})=>{if(l==null)throw new qs("Connection is not multiplexed");d.log.trace("starting new stream for protocols %s",f);const m=await l.newStream();d.log.trace("started new stream %s for protocols %s",m.id,f);try{if(g.signal==null){m.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",f);const v=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);g={...g,signal:v}}m.log.trace("selecting protocol from protocols %s",f);const{stream:S,protocol:x}=await ca(m,f,{...g,log:m.log,yieldBytes:!0});m.log.trace("selected protocol %s",x);const w=fA(x,this.components.registrar,g),y=Od(x,"outbound",d);if(y>=w){const v=new ih(`Too many outbound protocol streams for protocol "${x}" - ${y}/${w}`);throw m.abort(v),v}return await this.components.peerStore.merge(o,{protocols:[x]}),m.source=S.source,m.sink=S.sink,m.protocol=x,S.closeWrite!=null&&(m.closeWrite=S.closeWrite),S.closeRead!=null&&(m.closeRead=S.closeRead),S.close!=null&&(m.close=S.close),this.components.metrics?.trackProtocolStream(m,d),m}catch(S){throw d.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",n==="inbound"?"from":"to",e.maConn.remoteAddr,f,S),m.timeline.close==null&&m.abort(S),S}},Promise.all([l.sink(i.source),i.sink(l.source)]).catch(f=>{d.log.error("error piping data through muxer - %e",f)}));const h=s.timeline;s.timeline=new Proxy(h,{set:(...f)=>(f[1]==="close"&&f[2]!=null&&h.close==null&&(async()=>{try{d.status==="open"&&await d.close()}catch(g){d.log.error("error closing connection after timeline close %e",g)}finally{this.events.safeDispatchEvent("connection:close",{detail:d})}})().catch(g=>{d.log.error("error thrown while dispatching connection:close event %e",g)}),Reflect.set(...f))}),s.timeline.upgraded=Date.now();const p=()=>{throw new qs("Connection is not multiplexed")};return d=dA({remoteAddr:s.remoteAddr,remotePeer:o,status:"open",direction:n,timeline:s.timeline,multiplexer:l?.protocol,encryption:t,limits:c,logger:this.components.logger,newStream:u??p,getStreams:()=>l?.streams??[],close:async f=>{await l?.close(f),await s.close(f)},abort:f=>{s.abort(f),l?.abort(f)}}),this.events.safeDispatchEvent("connection:open",{detail:d}),d.__maConnTimeline=h,d}_onStream(e){const{connection:t,stream:n,protocol:s}=e,{handler:i,options:o}=this.components.registrar.getHandler(s);if(t.limits!=null&&o.runOnLimitedConnection!==!0)throw new sh("Cannot open protocol stream on limited connection");i({connection:t,stream:n})}async _encryptInbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{const{stream:s,protocol:i}=await la(e,n,{...t,log:e.log}),o=this.connectionEncrypters.get(i);if(o==null)throw new Ws(`no crypto module found for ${i}`);return e.log("encrypting inbound connection to %a using %s",e.remoteAddr,i),{...await o.secureInbound(s,t),protocol:i}}catch(s){throw e.log.error("encrypting inbound connection from %a failed",e.remoteAddr,s),new Ws(s.message)}}async _encryptOutbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{e.log.trace("selecting encrypter from %s",n);const{stream:s,protocol:i}=await ca(e,n,{...t,log:e.log,yieldBytes:!0}),o=this.connectionEncrypters.get(i);if(o==null)throw new Ws(`no crypto module found for ${i}`);return e.log("encrypting outbound connection to %a using %s",e.remoteAddr,i),{...await o.secureOutbound(s,t),protocol:i}}catch(s){throw e.log.error("encrypting outbound connection to %a failed",e.remoteAddr,s),new Ws(s.message)}}async _multiplexOutbound(e,t,n){const s=Array.from(t.keys());e.log("outbound selecting muxer %s",s);try{e.log.trace("selecting stream muxer from %s",s);const{stream:i,protocol:o}=await ca(e,s,{...n,log:e.log,yieldBytes:!0});e.log("selected %s as muxer protocol",o);const a=t.get(o);return{stream:i,muxerFactory:a}}catch(i){throw e.log.error("error multiplexing outbound connection",i),new qs(String(i))}}async _multiplexInbound(e,t,n){const s=Array.from(t.keys());e.log("inbound handling muxers %s",s);try{const{stream:i,protocol:o}=await la(e,s,{...n,log:e.log}),a=t.get(o);return{stream:i,muxerFactory:a}}catch(i){throw e.log.error("error multiplexing inbound connection",i),new qs(String(i))}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}const Vp="2.8.8",Gp="js-libp2p";function gA(r,e){return`${r??Gp}/${e??Vp} browser/${globalThis.navigator.userAgent}`}class mA extends Qt{peerId;peerStore;contentRouting;peerRouting;metrics;services;logger;status;components;log;constructor(e){super(),this.status="stopped";const t=new Qt,n=t.dispatchEvent.bind(t);t.dispatchEvent=l=>{const u=n(l),d=this.dispatchEvent(new CustomEvent(l.type,{detail:l.detail}));return u||d},this.peerId=e.peerId,this.logger=e.logger??kp(),this.log=this.logger.forComponent("libp2p"),this.services={};const s=e.nodeInfo?.name??Gp,i=e.nodeInfo?.version??Vp,o=this.components=jx({peerId:e.peerId,privateKey:e.privateKey,nodeInfo:{name:s,version:i,userAgent:e.nodeInfo?.userAgent??gA(s,i)},logger:this.logger,events:t,datastore:e.datastore??new lx,connectionGater:t2(e.connectionGater),dns:e.dns});this.peerStore=this.configureComponent("peerStore",sx(o,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),e.metrics!=null&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),o.events.addEventListener("peer:update",l=>{if(l.detail.previous==null){const u={id:l.detail.peer.id,multiaddrs:l.detail.peer.addresses.map(d=>d.multiaddr)};o.events.safeDispatchEvent("peer:discovery",{detail:u})}}),e.connectionProtector!=null&&this.configureComponent("connectionProtector",e.connectionProtector(o)),this.components.upgrader=new pA(this.components,{connectionEncrypters:(e.connectionEncrypters??[]).map((l,u)=>this.configureComponent(`connection-encryption-${u}`,l(this.components))),streamMuxers:(e.streamMuxers??[]).map((l,u)=>this.configureComponent(`stream-muxers-${u}`,l(this.components))),inboundUpgradeTimeout:e.connectionManager?.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:e.connectionManager?.inboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:e.connectionManager?.outboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout}),this.configureComponent("transportManager",new sA(this.components,e.transportManager)),this.configureComponent("connectionManager",new U2(this.components,e.connectionManager)),e.connectionMonitor?.enabled!==!1&&this.configureComponent("connectionMonitor",new Q2(this.components,e.connectionMonitor)),this.configureComponent("registrar",new tA(this.components)),this.configureComponent("addressManager",new Dx(this.components,e.addresses));const a=(e.peerRouters??[]).map((l,u)=>this.configureComponent(`peer-router-${u}`,l(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new J2(this.components,{routers:a}));const c=(e.contentRouters??[]).map((l,u)=>this.configureComponent(`content-router-${u}`,l(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new Z2(this.components,{routers:c})),this.configureComponent("randomWalk",new eA(this.components)),(e.peerDiscovery??[]).forEach((l,u)=>{this.configureComponent(`peer-discovery-${u}`,l(this.components)).addEventListener("peer",h=>{this.#e(h)})}),e.transports?.forEach((l,u)=>{this.components.transportManager.add(this.configureComponent(`transport-${u}`,l(this.components)))}),e.services!=null)for(const l of Object.keys(e.services)){const u=e.services[l],d=u(this.components);if(d==null){this.log.error("service factory %s returned null or undefined instance",l);continue}this.services[l]=d,this.configureComponent(l,d),d[El]!=null&&(this.log("registering service %s for content routing",l),c.push(d[El])),d[xl]!=null&&(this.log("registering service %s for peer routing",l),a.push(d[xl])),d[_l]!=null&&(this.log("registering service %s for peer discovery",l),d[_l].addEventListener?.("peer",h=>{this.#e(h)}))}Yx(o)}configureComponent(e,t){return t==null&&this.log.error("component %s was null or undefined",e),this.components[e]=t,t}async start(){if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await this.components.beforeStart?.(),await this.components.start(),await this.components.afterStart?.(),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started")}catch(e){throw this.log.error("An error occurred starting libp2p",e),this.status="started",await this.stop(),e}}}async stop(){this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await this.components.beforeStop?.(),await this.components.stop(),await this.components.afterStop?.(),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new Vr;for(const t of this.components.connectionManager.getConnections())e.add(t.remotePeer);return Array.from(e)}async dial(e,t={}){return this.components.connectionManager.openConnection(e,{priority:75,...t})}async dialProtocol(e,t,n={}){if(t==null)throw new K("no protocols were provided to open a stream");if(t=Array.isArray(t)?t:[t],t.length===0)throw new K("no protocols were provided to open a stream");return(await this.dial(e,n)).newStream(t,n)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e,t={}){ao(e)&&(e=dt(e.getPeerId()??"")),await this.components.connectionManager.closeConnections(e,t)}async getPublicKey(e,t={}){if(this.log("getPublicKey %p",e),e.publicKey!=null)return e.publicKey;try{const o=await this.peerStore.get(e);if(o.id.publicKey!=null)return o.id.publicKey}catch(o){if(o.name!=="NotFoundError")throw o}const n=ut([z("/pk/"),e.toMultihash().bytes]),s=await this.contentRouting.get(n,t),i=Zt(s);return await this.peerStore.patch(e,{publicKey:i}),i}async handle(e,t,n){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async s=>{await this.components.registrar.handle(s,t,n)}))}async unhandle(e){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async t=>{await this.components.registrar.unhandle(t)}))}async register(e,t){return this.components.registrar.register(e,t)}unregister(e){this.components.registrar.unregister(e)}async isDialable(e,t={}){return this.components.connectionManager.isDialable(e,t)}#e(e){const{detail:t}=e;if(t.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(t.id,{multiaddrs:t.multiaddrs}).catch(n=>{this.log.error(n)})}}async function yA(r={}){r.privateKey??=await Kb();const e=new mA({...await w1(r),peerId:Yb(r.privateKey)});return r.start!==!1&&await e.start(),e}class wA{mode;connections;activeTransfer;finished;selectedFile;activePeerId;activeStream;transferConnectionId;constructor(){this.mode="idle",this.connections=new Map,this.activeTransfer=!1,this.finished=!1,this.selectedFile=null,this.activePeerId=null,this.activeStream=null,this.transferConnectionId=null}setMode(e){this.mode=e}getMode(){return this.mode}reset(){this.mode="idle",this.connections.clear(),this.activeTransfer=!1,this.finished=!1,this.selectedFile=null,this.activePeerId=null,this.activeStream=null,this.transferConnectionId=null}addConnection(e,t){const n=this.connections.get(e.toString())||new Map;n.set(t.id,t),this.connections.set(e.toString(),n)}removeConnection(e,t){const n=this.connections.get(e);n?.delete(t),n&&this.connections.set(e,n)}removeAllConnectionsWithPeer(e){this.connections.delete(e)}getConnectionsForPeer(e){return this.connections.get(e)}getAllConnections(){return Array.from(this.connections.values())}setActiveTransfer(){this.activeTransfer=!0}clearActiveTransfer(){this.activeTransfer=!1}isTransferActive(){return!!this.activeTransfer}setTransferConnectionId(e){this.transferConnectionId=e}getTransferConnectionId(){return this.transferConnectionId}setSelectedFile(e){this.selectedFile=e}getSelectedFile(){return this.selectedFile}clearSelectedFile(){this.selectedFile=null}setActivePeer(e){this.activePeerId=e}getActivePeer(){return this.activePeerId}setActiveStream(e){this.activeStream=e}getActiveStream(){return this.activeStream}isFinished(){return this.finished||!1}declareFinished(){this.finished=!0}}class bA{node;appState;errorHandler;config;fileTransferHandler;connectionUpgrades;retryAttempts;constructor(e,t,n,s,i){this.node=e,this.appState=t,this.errorHandler=n,this.config=s,this.fileTransferHandler=i,this.connectionUpgrades=new Map,this.retryAttempts=new Map}async onConnectionEstablished(e){const t=e.detail,n=t.remotePeer,s=n.toString(),i=t.remoteAddr.toString();if(console.log(`Connection OPENED with: ${s} on ${i}`),i.includes("/p2p-circuit")&&!i.includes("/webrtc")){const o=t.close.bind(t);let a=!0;t.close=async()=>{if(this.appState.isFinished())return o();if(a){console.log(`Blocking premature close of circuit connection to ${s}`);return}return o()},setTimeout(()=>{a=!1;const c=this.connectionUpgrades.get(s);c&&c.webrtc&&c.webrtc.status==="open"&&console.log("Allowing circuit connection closure - WebRTC established")},3e4)}this.appState.addConnection(n,t),this.connectionUpgrades.has(t.id)||this.connectionUpgrades.set(t.id,{relay:null,webrtc:null,upgrading:!1,stable:!1}),await this.handleConnectionType(t,s,i)}async onConnectionClosed(e){const t=e.detail.remotePeer.toString(),n=e.detail.id;this.connectionUpgrades.delete(n),this.appState.isTransferActive()&&t===this.appState.getActivePeer()&&this.appState.getTransferConnectionId()===n&&!this.appState.isFinished()&&(this.errorHandler.reconnecting(),this.appState.getMode()==="sender"?await this.onSenderConnectionError(e):this.appState.getMode()==="receiver"&&await this.onReceiverConnectionError(t)),this.appState.removeConnection(t,n)}async onReceiverConnectionError(e){const t=new Promise(s=>{const i=o=>{o.detail.remotePeer.toString()===e&&this.appState.isTransferActive()&&(this.node.removeEventListener("connection:open",i),s())};this.node.addEventListener("connection:open",i)}),n=new Promise(s=>{setTimeout(()=>{s()},3e4)});try{await Promise.race([t,n])}catch{}await this.fileTransferHandler.transferComplete(),this.errorHandler.tryAgainError()}async onSenderConnectionError(e){const t=e.detail.remotePeer.toString(),n=2e3;let s=this.retryAttempts.get(t)||0;for(;s<4;){console.log(`Attempting to reconnect to ${t}...`);try{await this.dialPeer(e.detail.remotePeer,{signal:AbortSignal.timeout(5e3)}),this.errorHandler.reconnected();break}catch{s++,this.retryAttempts.set(t,s),await new Promise(o=>setTimeout(o,n*s))}}s>=4&&(this.appState.declareFinished(),await this.node.stop(),this.errorHandler.tryAgainError())}async dialPeer(e,t={}){try{return await this.node.dial(e,t)}catch(n){throw n}}async closePeer(e){const t=this.appState.getConnectionsForPeer(e.toString());if(t)for(const n of t.values())n&&(await n.close(),t.delete(n.id))}async upgradeConnection(e){const t=this.connectionUpgrades.get(e);!t||t.upgrading||(t.upgrading=!0,t.relay&&t.webrtc&&setTimeout(()=>{},5e3))}async waitForWebRTCStream(e,t=3e4){const n=e;return n.channel?n.channel.readyState==="open"?e:new Promise((s,i)=>{const o=setTimeout(()=>{i(new Error("WebRTC stream open timeout"))},t),a=()=>{clearTimeout(o),n.channel.removeEventListener("open",a),n.channel.removeEventListener("error",c),s(e)},c=l=>{clearTimeout(o),n.channel.removeEventListener("open",a),n.channel.removeEventListener("error",c),i(l)};n.channel.addEventListener("open",a),n.channel.addEventListener("error",c)}):e}async handleConnectionType(e,t,n){const s=this.connectionUpgrades.get(e.id);if(!s)return;const i=this.config.getRelayAddress();if(n.includes("/p2p-circuit")&&!n.includes("/webrtc"))s.relay=e,console.log(`Relay connection established for ${t}`);else if(n.includes("/webrtc")){if(s.webrtc=e,this.appState.getMode()==="sender"&&this.appState.getSelectedFile()!=null){const o=Y(n),a=await this.node.dialProtocol(o,this.config.getFileTransferProtocol());this.appState.setTransferConnectionId(e.id),this.appState.setActivePeer(t),this.appState.setActiveStream(await this.waitForWebRTCStream(a)),await this.waitForWebRTCStream(a).then(()=>{this.fileTransferHandler.startFileTransfer()})}console.log(`WebRTC connection established for ${t}`)}else n===i&&(s.relay=e,console.log(`Direct relay connection established for ${t}`))}}/**
 * @license
 * web-streams-polyfill v4.1.0
 * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
 * This code is released under the MIT license.
 * SPDX-License-Identifier: MIT
 */function ns(){}function xe(r){return typeof r=="object"&&r!==null||typeof r=="function"}const jp=ns;function Z(r,e){try{Object.defineProperty(r,"name",{value:e,configurable:!0})}catch{}}const el=Promise,vA=Promise.resolve.bind(el),SA=Promise.prototype.then,EA=Promise.reject.bind(el),_A=vA;function Ne(r){return new el(r)}function ne(r){return Ne(e=>e(r))}function B(r){return EA(r)}function yt(r,e,t){return SA.call(r,e,t)}function ht(r,e,t){yt(yt(r,e,t),void 0,jp)}function ua(r,e){ht(r,e)}function ec(r,e){ht(r,void 0,e)}function vr(r,e,t){return yt(r,e,t)}function vs(r){yt(r,void 0,jp)}let Sr=r=>{if(typeof queueMicrotask=="function")Sr=queueMicrotask;else{const e=ne(void 0);Sr=t=>yt(e,t)}return Sr(r)};function pn(r,e,t){if(typeof r!="function")throw new TypeError("Argument is not a function");return Function.prototype.apply.call(r,e,t)}function En(r,e,t){try{return ne(pn(r,e,t))}catch(n){return B(n)}}class nt{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push(e){const t=this._back;let n=t;t._elements.length===16383&&(n={_elements:[],_next:void 0}),t._elements.push(e),n!==t&&(this._back=n,t._next=n),++this._size}shift(){const e=this._front;let t=e;const n=this._cursor;let s=n+1;const i=e._elements,o=i[n];return s===16384&&(t=e._next,s=0),--this._size,this._cursor=s,e!==t&&(this._front=t),i[n]=void 0,o}forEach(e){let t=this._cursor,n=this._front,s=n._elements;for(;!(t===s.length&&n._next===void 0||t===s.length&&(n=n._next,s=n._elements,t=0,s.length===0));)e(s[t]),++t}peek(){const e=this._front,t=this._cursor;return e._elements[t]}}const Yp=Symbol("[[AbortSteps]]"),Xp=Symbol("[[ErrorSteps]]"),tl=Symbol("[[CancelSteps]]"),rl=Symbol("[[PullSteps]]"),nl=Symbol("[[ReleaseSteps]]");function Qp(r,e){r._ownerReadableStream=e,e._reader=r,e._state==="readable"?tc(r):e._state==="closed"?function(t){tc(t),Jp(t)}(r):Zp(r,e._storedError)}function sl(r,e){return ct(r._ownerReadableStream,e)}function Tt(r){const e=r._ownerReadableStream;e._state==="readable"?il(r,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):function(t,n){Zp(t,n)}(r,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),e._readableStreamController[nl](),e._reader=void 0,r._ownerReadableStream=void 0}function Vi(r){return new TypeError("Cannot "+r+" a stream using a released reader")}function tc(r){r._closedPromise=Ne((e,t)=>{r._closedPromise_resolve=e,r._closedPromise_reject=t})}function Zp(r,e){tc(r),il(r,e)}function il(r,e){r._closedPromise_reject!==void 0&&(vs(r._closedPromise),r._closedPromise_reject(e),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0)}function Jp(r){r._closedPromise_resolve!==void 0&&(r._closedPromise_resolve(void 0),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0)}const Fd=Number.isFinite||function(r){return typeof r=="number"&&isFinite(r)},xA=Math.trunc||function(r){return r<0?Math.ceil(r):Math.floor(r)};function Ht(r,e){if(r!==void 0&&typeof(t=r)!="object"&&typeof t!="function")throw new TypeError(`${e} is not an object.`);var t}function nr(r,e){if(typeof r!="function")throw new TypeError(`${e} is not a function.`)}function eg(r,e){if(!function(t){return typeof t=="object"&&t!==null||typeof t=="function"}(r))throw new TypeError(`${e} is not an object.`)}function Ir(r,e,t){if(r===void 0)throw new TypeError(`Parameter ${e} is required in '${t}'.`)}function Nd(r,e,t){if(r===void 0)throw new TypeError(`${e} is required in '${t}'.`)}function tg(r){return Number(r)}function Bd(r){return r===0?0:r}function ol(r,e){const t=Number.MAX_SAFE_INTEGER;let n=Number(r);if(n=Bd(n),!Fd(n))throw new TypeError(`${e} is not a finite number`);if(n=function(s){return Bd(xA(s))}(n),n<0||n>t)throw new TypeError(`${e} is outside the accepted range of 0 to ${t}, inclusive`);return Fd(n)&&n!==0?n:0}function al(r,e){if(!Bt(r))throw new TypeError(`${e} is not a ReadableStream.`)}function Yr(r){return new ur(r)}function rg(r,e){r._reader._readRequests.push(e)}function cl(r,e,t){const n=r._reader._readRequests.shift();t?n._closeSteps():n._chunkSteps(e)}function mo(r){return r._reader._readRequests.length}function ng(r){const e=r._reader;return e!==void 0&&!!Vt(e)}class ur{constructor(e){if(Ir(e,1,"ReadableStreamDefaultReader"),al(e,"First parameter"),Gt(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");Qp(this,e),this._readRequests=new nt}get closed(){return Vt(this)?this._closedPromise:B(Ks("closed"))}cancel(e=void 0){return Vt(this)?this._ownerReadableStream===void 0?B(Vi("cancel")):sl(this,e):B(Ks("cancel"))}read(){if(!Vt(this))return B(Ks("read"));if(this._ownerReadableStream===void 0)return B(Vi("read from"));let e,t;const n=Ne((s,i)=>{e=s,t=i});return ss(this,{_chunkSteps:s=>e({value:s,done:!1}),_closeSteps:()=>e({value:void 0,done:!0}),_errorSteps:s=>t(s)}),n}releaseLock(){if(!Vt(this))throw Ks("releaseLock");this._ownerReadableStream!==void 0&&function(e){Tt(e);const t=new TypeError("Reader was released");sg(e,t)}(this)}}function Vt(r){return!!xe(r)&&!!Object.prototype.hasOwnProperty.call(r,"_readRequests")&&r instanceof ur}function ss(r,e){const t=r._ownerReadableStream;t._disturbed=!0,t._state==="closed"?e._closeSteps():t._state==="errored"?e._errorSteps(t._storedError):t._readableStreamController[rl](e)}function sg(r,e){const t=r._readRequests;r._readRequests=new nt,t.forEach(n=>{n._errorSteps(e)})}function Ks(r){return new TypeError(`ReadableStreamDefaultReader.prototype.${r} can only be used on a ReadableStreamDefaultReader`)}var da,ha,fa;function Dn(r){return r.slice()}function ig(r,e,t,n,s){new Uint8Array(r).set(new Uint8Array(t,n,s),e)}Object.defineProperties(ur.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),Z(ur.prototype.cancel,"cancel"),Z(ur.prototype.read,"read"),Z(ur.prototype.releaseLock,"releaseLock"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(ur.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0});let Tr=r=>(Tr=typeof r.transfer=="function"?e=>e.transfer():typeof structuredClone=="function"?e=>structuredClone(e,{transfer:[e]}):e=>e,Tr(r)),Pr=r=>(Pr=typeof r.detached=="boolean"?e=>e.detached:e=>e.byteLength===0,Pr(r));function og(r,e,t){if(r.slice)return r.slice(e,t);const n=t-e,s=new ArrayBuffer(n);return ig(s,0,r,e,n),s}function Mn(r,e){const t=r[e];if(t!=null){if(typeof t!="function")throw new TypeError(`${String(e)} is not a function`);return t}}function Ud(r){try{const e=r.done,t=r.value;return yt(_A(t),n=>({done:e,value:n}))}catch(e){return B(e)}}const Ss=(fa=(da=Symbol.asyncIterator)!==null&&da!==void 0?da:(ha=Symbol.for)===null||ha===void 0?void 0:ha.call(Symbol,"Symbol.asyncIterator"))!==null&&fa!==void 0?fa:"@@asyncIterator";function ag(r,e="sync",t){if(t===void 0)if(e==="async"){if((t=Mn(r,Ss))===void 0)return function(s){const i={next(){let o;try{o=cg(s)}catch(a){return B(a)}return Ud(o)},return(o){let a;try{const c=Mn(s.iterator,"return");if(c===void 0)return ne({done:!0,value:o});a=pn(c,s.iterator,[o])}catch(c){return B(c)}return xe(a)?Ud(a):B(new TypeError("The iterator.return() method must return an object"))}};return{iterator:i,nextMethod:i.next,done:!1}}(ag(r,"sync",Mn(r,Symbol.iterator)))}else t=Mn(r,Symbol.iterator);if(t===void 0)throw new TypeError("The object is not iterable");const n=pn(t,r,[]);if(!xe(n))throw new TypeError("The iterator method must return an object");return{iterator:n,nextMethod:n.next,done:!1}}function cg(r){const e=pn(r.nextMethod,r.iterator,[]);if(!xe(e))throw new TypeError("The iterator.next() method must return an object");return e}class lg{constructor(e,t){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=e,this._preventCancel=t}next(){const e=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?vr(this._ongoingPromise,e,e):e(),this._ongoingPromise}return(e){const t=()=>this._returnSteps(e);return this._ongoingPromise=this._ongoingPromise?vr(this._ongoingPromise,t,t):t(),this._ongoingPromise}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:!0});const e=this._reader;let t,n;const s=Ne((i,o)=>{t=i,n=o});return ss(e,{_chunkSteps:i=>{this._ongoingPromise=void 0,Sr(()=>t({value:i,done:!1}))},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,Tt(e),t({value:void 0,done:!0})},_errorSteps:i=>{this._ongoingPromise=void 0,this._isFinished=!0,Tt(e),n(i)}}),s}_returnSteps(e){if(this._isFinished)return Promise.resolve({value:e,done:!0});this._isFinished=!0;const t=this._reader;if(!this._preventCancel){const n=sl(t,e);return Tt(t),vr(n,()=>({value:e,done:!0}))}return Tt(t),ne({value:e,done:!0})}}const ug={next(){return $d(this)?this._asyncIteratorImpl.next():B(qd("next"))},return(r){return $d(this)?this._asyncIteratorImpl.return(r):B(qd("return"))},[Ss](){return this}};function $d(r){if(!xe(r)||!Object.prototype.hasOwnProperty.call(r,"_asyncIteratorImpl"))return!1;try{return r._asyncIteratorImpl instanceof lg}catch{return!1}}function qd(r){return new TypeError(`ReadableStreamAsyncIterator.${r} can only be used on a ReadableSteamAsyncIterator`)}Object.defineProperty(ug,Ss,{enumerable:!1});const dg=Number.isNaN||function(r){return r!=r};function Wd(r){const e=og(r.buffer,r.byteOffset,r.byteOffset+r.byteLength);return new Uint8Array(e)}function rc(r){const e=r._queue.shift();return r._queueTotalSize-=e.size,r._queueTotalSize<0&&(r._queueTotalSize=0),e.value}function ll(r,e,t){if(typeof(n=t)!="number"||dg(n)||n<0||t===1/0)throw new RangeError("Size must be a finite, non-NaN, non-negative number.");var n;r._queue.push({value:e,size:t}),r._queueTotalSize+=t}function sr(r){r._queue=new nt,r._queueTotalSize=0}function hg(r){return r===DataView}class Wr{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!pa(this))throw ga("view");return this._view}respond(e){if(!pa(this))throw ga("respond");if(Ir(e,1,"respond"),e=ol(e,"First parameter"),this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");if(Pr(this._view.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");ii(this._associatedReadableByteStreamController,e)}respondWithNewView(e){if(!pa(this))throw ga("respondWithNewView");if(Ir(e,1,"respondWithNewView"),!ArrayBuffer.isView(e))throw new TypeError("You can only respond with array buffer views");if(this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");if(Pr(e.buffer))throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");oi(this._associatedReadableByteStreamController,e)}}Object.defineProperties(Wr.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),Z(Wr.prototype.respond,"respond"),Z(Wr.prototype.respondWithNewView,"respondWithNewView"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Wr.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});class $t{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!dr(this))throw kn("byobRequest");return sc(this)}get desiredSize(){if(!dr(this))throw kn("desiredSize");return _g(this)}close(){if(!dr(this))throw kn("close");if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const e=this._controlledReadableByteStream._state;if(e!=="readable")throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`);On(this)}enqueue(e){if(!dr(this))throw kn("enqueue");if(Ir(e,1,"enqueue"),!ArrayBuffer.isView(e))throw new TypeError("chunk must be an array buffer view");if(e.byteLength===0)throw new TypeError("chunk must have non-zero byteLength");if(e.buffer.byteLength===0)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw new TypeError("stream is closed or draining");const t=this._controlledReadableByteStream._state;if(t!=="readable")throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be enqueued to`);si(this,e)}error(e=void 0){if(!dr(this))throw kn("error");tt(this,e)}[tl](e){fg(this),sr(this);const t=this._cancelAlgorithm(e);return yo(this),t}[rl](e){const t=this._controlledReadableByteStream;if(this._queueTotalSize>0)return void Eg(this,e);const n=this._autoAllocateChunkSize;if(n!==void 0){let s;try{s=new ArrayBuffer(n)}catch(o){return void e._errorSteps(o)}const i={buffer:s,bufferByteLength:n,byteOffset:0,byteLength:n,bytesFilled:0,minimumFill:1,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(i)}rg(t,e),Rr(this)}[nl](){if(this._pendingPullIntos.length>0){const e=this._pendingPullIntos.peek();e.readerType="none",this._pendingPullIntos=new nt,this._pendingPullIntos.push(e)}}}function dr(r){return!!xe(r)&&!!Object.prototype.hasOwnProperty.call(r,"_controlledReadableByteStream")&&r instanceof $t}function pa(r){return!!xe(r)&&!!Object.prototype.hasOwnProperty.call(r,"_associatedReadableByteStreamController")&&r instanceof Wr}function Rr(r){if(function(t){const n=t._controlledReadableByteStream;return n._state!=="readable"||t._closeRequested||!t._started?!1:!!(ng(n)&&mo(n)>0||dl(n)&&Cg(n)>0||_g(t)>0)}(r)){if(r._pulling)return void(r._pullAgain=!0);r._pulling=!0,ht(r._pullAlgorithm(),()=>(r._pulling=!1,r._pullAgain&&(r._pullAgain=!1,Rr(r)),null),t=>(tt(r,t),null))}}function fg(r){ul(r),r._pendingPullIntos=new nt}function pg(r,e){let t=!1;r._state==="closed"&&(t=!0);const n=gg(e);e.readerType==="default"?cl(r,n,t):function(s,i,o){const a=s._reader,c=a._readIntoRequests.shift();o?c._closeSteps(i):c._chunkSteps(i)}(r,n,t)}function ri(r,e){for(let t=0;t<e.length;++t)pg(r,e[t])}function gg(r){const e=r.bytesFilled,t=r.elementSize;return new r.viewConstructor(r.buffer,r.byteOffset,e/t)}function ni(r,e,t,n){r._queue.push({buffer:e,byteOffset:t,byteLength:n}),r._queueTotalSize+=n}function mg(r,e,t,n){let s;try{s=og(e,t,t+n)}catch(i){throw tt(r,i),i}ni(r,s,0,n)}function yg(r,e){e.bytesFilled>0&&mg(r,e.buffer,e.byteOffset,e.bytesFilled),Xr(r)}function wg(r,e){const t=Math.min(r._queueTotalSize,e.byteLength-e.bytesFilled),n=e.bytesFilled+t;let s=t,i=!1;const o=n-n%e.elementSize;o>=e.minimumFill&&(s=o-e.bytesFilled,i=!0);const a=r._queue;for(;s>0;){const c=a.peek(),l=Math.min(s,c.byteLength),u=e.byteOffset+e.bytesFilled;ig(e.buffer,u,c.buffer,c.byteOffset,l),c.byteLength===l?a.shift():(c.byteOffset+=l,c.byteLength-=l),r._queueTotalSize-=l,bg(r,l,e),s-=l}return i}function bg(r,e,t){t.bytesFilled+=e}function vg(r){r._queueTotalSize===0&&r._closeRequested?(yo(r),Es(r._controlledReadableByteStream)):Rr(r)}function ul(r){r._byobRequest!==null&&(r._byobRequest._associatedReadableByteStreamController=void 0,r._byobRequest._view=null,r._byobRequest=null)}function nc(r){const e=[];for(;r._pendingPullIntos.length>0&&r._queueTotalSize!==0;){const t=r._pendingPullIntos.peek();wg(r,t)&&(Xr(r),e.push(t))}return e}function AA(r,e,t,n){const s=r._controlledReadableByteStream,i=e.constructor,o=function(h){return hg(h)?1:h.BYTES_PER_ELEMENT}(i),{byteOffset:a,byteLength:c}=e,l=t*o;let u;try{u=Tr(e.buffer)}catch(h){return void n._errorSteps(h)}const d={buffer:u,bufferByteLength:u.byteLength,byteOffset:a,byteLength:c,bytesFilled:0,minimumFill:l,elementSize:o,viewConstructor:i,readerType:"byob"};if(r._pendingPullIntos.length>0)return r._pendingPullIntos.push(d),void zd(s,n);if(s._state!=="closed"){if(r._queueTotalSize>0){if(wg(r,d)){const h=gg(d);return vg(r),void n._chunkSteps(h)}if(r._closeRequested){const h=new TypeError("Insufficient bytes to fill elements in the given buffer");return tt(r,h),void n._errorSteps(h)}}r._pendingPullIntos.push(d),zd(s,n),Rr(r)}else{const h=new i(d.buffer,d.byteOffset,0);n._closeSteps(h)}}function Sg(r,e){const t=r._pendingPullIntos.peek();ul(r),r._controlledReadableByteStream._state==="closed"?function(n,s){s.readerType==="none"&&Xr(n);const i=n._controlledReadableByteStream;if(dl(i)){const o=[];for(let a=0;a<Cg(i);++a)o.push(Xr(n));ri(i,o)}}(r,t):function(n,s,i){if(bg(0,s,i),i.readerType==="none"){yg(n,i);const c=nc(n);return void ri(n._controlledReadableByteStream,c)}if(i.bytesFilled<i.minimumFill)return;Xr(n);const o=i.bytesFilled%i.elementSize;if(o>0){const c=i.byteOffset+i.bytesFilled;mg(n,i.buffer,c-o,o)}i.bytesFilled-=o;const a=nc(n);pg(n._controlledReadableByteStream,i),ri(n._controlledReadableByteStream,a)}(r,e,t),Rr(r)}function Xr(r){return r._pendingPullIntos.shift()}function yo(r){r._pullAlgorithm=void 0,r._cancelAlgorithm=void 0}function On(r){const e=r._controlledReadableByteStream;if(!r._closeRequested&&e._state==="readable")if(r._queueTotalSize>0)r._closeRequested=!0;else{if(r._pendingPullIntos.length>0){const t=r._pendingPullIntos.peek();if(t.bytesFilled%t.elementSize!=0){const n=new TypeError("Insufficient bytes to fill elements in the given buffer");throw tt(r,n),n}}yo(r),Es(e)}}function si(r,e){const t=r._controlledReadableByteStream;if(r._closeRequested||t._state!=="readable")return;const{buffer:n,byteOffset:s,byteLength:i}=e;if(Pr(n))throw new TypeError("chunk's buffer is detached and so cannot be enqueued");const o=Tr(n);if(r._pendingPullIntos.length>0){const a=r._pendingPullIntos.peek();if(Pr(a.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");ul(r),a.buffer=Tr(a.buffer),a.readerType==="none"&&yg(r,a)}if(ng(t))(function(a){const c=a._controlledReadableByteStream._reader;for(;c._readRequests.length>0;){if(a._queueTotalSize===0)return;Eg(a,c._readRequests.shift())}})(r),mo(t)===0?ni(r,o,s,i):(r._pendingPullIntos.length>0&&Xr(r),cl(t,new Uint8Array(o,s,i),!1));else if(dl(t)){ni(r,o,s,i);const a=nc(r);ri(r._controlledReadableByteStream,a)}else ni(r,o,s,i);Rr(r)}function tt(r,e){const t=r._controlledReadableByteStream;t._state==="readable"&&(fg(r),sr(r),yo(r),Vg(t,e))}function Eg(r,e){const t=r._queue.shift();r._queueTotalSize-=t.byteLength,vg(r);const n=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);e._chunkSteps(n)}function sc(r){if(r._byobRequest===null&&r._pendingPullIntos.length>0){const e=r._pendingPullIntos.peek(),t=new Uint8Array(e.buffer,e.byteOffset+e.bytesFilled,e.byteLength-e.bytesFilled),n=Object.create(Wr.prototype);(function(s,i,o){s._associatedReadableByteStreamController=i,s._view=o})(n,r,t),r._byobRequest=n}return r._byobRequest}function _g(r){const e=r._controlledReadableByteStream._state;return e==="errored"?null:e==="closed"?0:r._strategyHWM-r._queueTotalSize}function ii(r,e){const t=r._pendingPullIntos.peek();if(r._controlledReadableByteStream._state==="closed"){if(e!==0)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}else{if(e===0)throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");if(t.bytesFilled+e>t.byteLength)throw new RangeError("bytesWritten out of range")}t.buffer=Tr(t.buffer),Sg(r,e)}function oi(r,e){const t=r._pendingPullIntos.peek();if(r._controlledReadableByteStream._state==="closed"){if(e.byteLength!==0)throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream")}else if(e.byteLength===0)throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");if(t.byteOffset+t.bytesFilled!==e.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(t.bufferByteLength!==e.buffer.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");if(t.bytesFilled+e.byteLength>t.byteLength)throw new RangeError("The region specified by view is larger than byobRequest");const n=e.byteLength;t.buffer=Tr(e.buffer),Sg(r,n)}function xg(r,e,t,n,s,i,o){e._controlledReadableByteStream=r,e._pullAgain=!1,e._pulling=!1,e._byobRequest=null,e._queue=e._queueTotalSize=void 0,sr(e),e._closeRequested=!1,e._started=!1,e._strategyHWM=i,e._pullAlgorithm=n,e._cancelAlgorithm=s,e._autoAllocateChunkSize=o,e._pendingPullIntos=new nt,r._readableStreamController=e,ht(ne(t()),()=>(e._started=!0,Rr(e),null),a=>(tt(e,a),null))}function ga(r){return new TypeError(`ReadableStreamBYOBRequest.prototype.${r} can only be used on a ReadableStreamBYOBRequest`)}function kn(r){return new TypeError(`ReadableByteStreamController.prototype.${r} can only be used on a ReadableByteStreamController`)}function CA(r,e){if((r=`${r}`)!="byob")throw new TypeError(`${e} '${r}' is not a valid enumeration value for ReadableStreamReaderMode`);return r}function Ag(r){return new hr(r)}function zd(r,e){r._reader._readIntoRequests.push(e)}function Cg(r){return r._reader._readIntoRequests.length}function dl(r){const e=r._reader;return e!==void 0&&!!mr(e)}Object.defineProperties($t.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),Z($t.prototype.close,"close"),Z($t.prototype.enqueue,"enqueue"),Z($t.prototype.error,"error"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty($t.prototype,Symbol.toStringTag,{value:"ReadableByteStreamController",configurable:!0});class hr{constructor(e){if(Ir(e,1,"ReadableStreamBYOBReader"),al(e,"First parameter"),Gt(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");if(!dr(e._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");Qp(this,e),this._readIntoRequests=new nt}get closed(){return mr(this)?this._closedPromise:B(Hs("closed"))}cancel(e=void 0){return mr(this)?this._ownerReadableStream===void 0?B(Vi("cancel")):sl(this,e):B(Hs("cancel"))}read(e,t={}){if(!mr(this))return B(Hs("read"));if(!ArrayBuffer.isView(e))return B(new TypeError("view must be an array buffer view"));if(e.byteLength===0)return B(new TypeError("view must have non-zero byteLength"));if(e.buffer.byteLength===0)return B(new TypeError("view's buffer must have non-zero byteLength"));if(Pr(e.buffer))return B(new TypeError("view's buffer has been detached"));let n;try{n=function(c,l){var u;return Ht(c,l),{min:ol((u=c?.min)!==null&&u!==void 0?u:1,`${l} has member 'min' that`)}}(t,"options")}catch(c){return B(c)}const s=n.min;if(s===0)return B(new TypeError("options.min must be greater than 0"));if(function(c){return hg(c.constructor)}(e)){if(s>e.byteLength)return B(new RangeError("options.min must be less than or equal to view's byteLength"))}else if(s>e.length)return B(new RangeError("options.min must be less than or equal to view's length"));if(this._ownerReadableStream===void 0)return B(Vi("read from"));let i,o;const a=Ne((c,l)=>{i=c,o=l});return Ig(this,e,s,{_chunkSteps:c=>i({value:c,done:!1}),_closeSteps:c=>i({value:c,done:!0}),_errorSteps:c=>o(c)}),a}releaseLock(){if(!mr(this))throw Hs("releaseLock");this._ownerReadableStream!==void 0&&function(e){Tt(e);const t=new TypeError("Reader was released");Tg(e,t)}(this)}}function mr(r){return!!xe(r)&&!!Object.prototype.hasOwnProperty.call(r,"_readIntoRequests")&&r instanceof hr}function Ig(r,e,t,n){const s=r._ownerReadableStream;s._disturbed=!0,s._state==="errored"?n._errorSteps(s._storedError):AA(s._readableStreamController,e,t,n)}function Tg(r,e){const t=r._readIntoRequests;r._readIntoRequests=new nt,t.forEach(n=>{n._errorSteps(e)})}function Hs(r){return new TypeError(`ReadableStreamBYOBReader.prototype.${r} can only be used on a ReadableStreamBYOBReader`)}function ic(r,e){const{highWaterMark:t}=r;if(t===void 0)return e;if(dg(t)||t<0)throw new RangeError("Invalid highWaterMark");return t}function Pg(r){const{size:e}=r;return e||(()=>1)}function kg(r,e){Ht(r,e);const t=r?.highWaterMark,n=r?.size;return{highWaterMark:t===void 0?void 0:tg(t),size:n===void 0?void 0:IA(n,`${e} has member 'size' that`)}}function IA(r,e){return nr(r,e),t=>tg(r(t))}function TA(r,e,t){return nr(r,t),n=>En(r,e,[n])}function PA(r,e,t){return nr(r,t),()=>En(r,e,[])}function kA(r,e,t){return nr(r,t),n=>pn(r,e,[n])}function RA(r,e,t){return nr(r,t),(n,s)=>En(r,e,[n,s])}function Rg(r,e){if(!zr(r))throw new TypeError(`${e} is not a WritableStream.`)}Object.defineProperties(hr.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),Z(hr.prototype.cancel,"cancel"),Z(hr.prototype.read,"read"),Z(hr.prototype.releaseLock,"releaseLock"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(hr.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});class qt{constructor(e={},t={}){e===void 0?e=null:eg(e,"First parameter");const n=kg(t,"Second parameter"),s=function(o,a){Ht(o,a);const c=o?.abort,l=o?.close,u=o?.start,d=o?.type,h=o?.write;return{abort:c===void 0?void 0:TA(c,o,`${a} has member 'abort' that`),close:l===void 0?void 0:PA(l,o,`${a} has member 'close' that`),start:u===void 0?void 0:kA(u,o,`${a} has member 'start' that`),write:h===void 0?void 0:RA(h,o,`${a} has member 'write' that`),type:d}}(e,"First parameter");if(LA(this),s.type!==void 0)throw new RangeError("Invalid type is specified");const i=Pg(n);(function(o,a,c,l){const u=Object.create(ji.prototype);let d,h,p,f;d=a.start!==void 0?()=>a.start(u):()=>{},h=a.write!==void 0?g=>a.write(g,u):()=>ne(void 0),p=a.close!==void 0?()=>a.close():()=>ne(void 0),f=a.abort!==void 0?g=>a.abort(g):()=>ne(void 0),MA(o,u,d,h,p,f,c,l)})(this,s,ic(n,1),i)}get locked(){if(!zr(this))throw Gs("locked");return Qr(this)}abort(e=void 0){return zr(this)?Qr(this)?B(new TypeError("Cannot abort a stream that already has a writer")):Gi(this,e):B(Gs("abort"))}close(){return zr(this)?Qr(this)?B(new TypeError("Cannot close a stream that already has a writer")):wt(this)?B(new TypeError("Cannot close an already-closing stream")):Dg(this):B(Gs("close"))}getWriter(){if(!zr(this))throw Gs("getWriter");return Lg(this)}}function Lg(r){return new Ut(r)}function LA(r){r._state="writable",r._storedError=void 0,r._writer=void 0,r._writableStreamController=void 0,r._writeRequests=new nt,r._inFlightWriteRequest=void 0,r._closeRequest=void 0,r._inFlightCloseRequest=void 0,r._pendingAbortRequest=void 0,r._backpressure=!1}function zr(r){return!!xe(r)&&!!Object.prototype.hasOwnProperty.call(r,"_writableStreamController")&&r instanceof qt}function Qr(r){return r._writer!==void 0}function Gi(r,e){var t;if(r._state==="closed"||r._state==="errored")return ne(void 0);r._writableStreamController._abortReason=e,(t=r._writableStreamController._abortController)===null||t===void 0||t.abort(e);const n=r._state;if(n==="closed"||n==="errored")return ne(void 0);if(r._pendingAbortRequest!==void 0)return r._pendingAbortRequest._promise;let s=!1;n==="erroring"&&(s=!0,e=void 0);const i=Ne((o,a)=>{r._pendingAbortRequest={_promise:void 0,_resolve:o,_reject:a,_reason:e,_wasAlreadyErroring:s}});return r._pendingAbortRequest._promise=i,s||hl(r,e),i}function Dg(r){const e=r._state;if(e==="closed"||e==="errored")return B(new TypeError(`The stream (in ${e} state) is not in the writable state and cannot be closed`));const t=Ne((i,o)=>{const a={_resolve:i,_reject:o};r._closeRequest=a}),n=r._writer;var s;return n!==void 0&&r._backpressure&&e==="writable"&&yl(n),ll(s=r._writableStreamController,Bg,0),wo(s),t}function oc(r,e){r._state!=="writable"?fl(r):hl(r,e)}function hl(r,e){const t=r._writableStreamController;r._state="erroring",r._storedError=e;const n=r._writer;n!==void 0&&Og(n,e),!function(s){return!(s._inFlightWriteRequest===void 0&&s._inFlightCloseRequest===void 0)}(r)&&t._started&&fl(r)}function fl(r){r._state="errored",r._writableStreamController[Xp]();const e=r._storedError;if(r._writeRequests.forEach(n=>{n._reject(e)}),r._writeRequests=new nt,r._pendingAbortRequest===void 0)return void Vs(r);const t=r._pendingAbortRequest;if(r._pendingAbortRequest=void 0,t._wasAlreadyErroring)return t._reject(e),void Vs(r);ht(r._writableStreamController[Yp](t._reason),()=>(t._resolve(),Vs(r),null),n=>(t._reject(n),Vs(r),null))}function wt(r){return r._closeRequest!==void 0||r._inFlightCloseRequest!==void 0}function Vs(r){r._closeRequest!==void 0&&(r._closeRequest._reject(r._storedError),r._closeRequest=void 0);const e=r._writer;e!==void 0&&ml(e,r._storedError)}function pl(r,e){const t=r._writer;t!==void 0&&e!==r._backpressure&&(e?function(n){bo(n)}(t):yl(t)),r._backpressure=e}Object.defineProperties(qt.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),Z(qt.prototype.abort,"abort"),Z(qt.prototype.close,"close"),Z(qt.prototype.getWriter,"getWriter"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(qt.prototype,Symbol.toStringTag,{value:"WritableStream",configurable:!0});class Ut{constructor(e){if(Ir(e,1,"WritableStreamDefaultWriter"),Rg(e,"First parameter"),Qr(e))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=e,e._writer=this;const t=e._state;if(t==="writable")!wt(e)&&e._backpressure?bo(this):Kd(this),ai(this);else if(t==="erroring")cc(this,e._storedError),ai(this);else if(t==="closed")Kd(this),ai(n=this),Wg(n);else{const s=e._storedError;cc(this,s),qg(this,s)}var n}get closed(){return or(this)?this._closedPromise:B(ar("closed"))}get desiredSize(){if(!or(this))throw ar("desiredSize");if(this._ownerWritableStream===void 0)throw Fn("desiredSize");return function(e){const t=e._ownerWritableStream,n=t._state;return n==="errored"||n==="erroring"?null:n==="closed"?0:Ug(t._writableStreamController)}(this)}get ready(){return or(this)?this._readyPromise:B(ar("ready"))}abort(e=void 0){return or(this)?this._ownerWritableStream===void 0?B(Fn("abort")):function(t,n){return Gi(t._ownerWritableStream,n)}(this,e):B(ar("abort"))}close(){if(!or(this))return B(ar("close"));const e=this._ownerWritableStream;return e===void 0?B(Fn("close")):wt(e)?B(new TypeError("Cannot close an already-closing stream")):Mg(this)}releaseLock(){if(!or(this))throw ar("releaseLock");this._ownerWritableStream!==void 0&&Fg(this)}write(e=void 0){return or(this)?this._ownerWritableStream===void 0?B(Fn("write to")):Ng(this,e):B(ar("write"))}}function or(r){return!!xe(r)&&!!Object.prototype.hasOwnProperty.call(r,"_ownerWritableStream")&&r instanceof Ut}function Mg(r){return Dg(r._ownerWritableStream)}function DA(r,e){r._closedPromiseState==="pending"?ml(r,e):function(t,n){qg(t,n)}(r,e)}function Og(r,e){r._readyPromiseState==="pending"?zg(r,e):function(t,n){cc(t,n)}(r,e)}function Fg(r){const e=r._ownerWritableStream,t=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");Og(r,t),DA(r,t),e._writer=void 0,r._ownerWritableStream=void 0}function Ng(r,e){const t=r._ownerWritableStream,n=t._writableStreamController,s=function(a,c){if(a._strategySizeAlgorithm===void 0)return 1;try{return a._strategySizeAlgorithm(c)}catch(l){return ac(a,l),1}}(n,e);if(t!==r._ownerWritableStream)return B(Fn("write to"));const i=t._state;if(i==="errored")return B(t._storedError);if(wt(t)||i==="closed")return B(new TypeError("The stream is closing or closed and cannot be written to"));if(i==="erroring")return B(t._storedError);const o=function(a){return Ne((c,l)=>{const u={_resolve:c,_reject:l};a._writeRequests.push(u)})}(t);return function(a,c,l){try{ll(a,c,l)}catch(d){return void ac(a,d)}const u=a._controlledWritableStream;!wt(u)&&u._state==="writable"&&pl(u,gl(a)),wo(a)}(n,e,s),o}Object.defineProperties(Ut.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),Z(Ut.prototype.abort,"abort"),Z(Ut.prototype.close,"close"),Z(Ut.prototype.releaseLock,"releaseLock"),Z(Ut.prototype.write,"write"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Ut.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});const Bg={};class ji{constructor(){throw new TypeError("Illegal constructor")}get abortReason(){if(!ma(this))throw ya("abortReason");return this._abortReason}get signal(){if(!ma(this))throw ya("signal");if(this._abortController===void 0)throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");return this._abortController.signal}error(e=void 0){if(!ma(this))throw ya("error");this._controlledWritableStream._state==="writable"&&$g(this,e)}[Yp](e){const t=this._abortAlgorithm(e);return Yi(this),t}[Xp](){sr(this)}}function ma(r){return!!xe(r)&&!!Object.prototype.hasOwnProperty.call(r,"_controlledWritableStream")&&r instanceof ji}function MA(r,e,t,n,s,i,o,a){e._controlledWritableStream=r,r._writableStreamController=e,e._queue=void 0,e._queueTotalSize=void 0,sr(e),e._abortReason=void 0,e._abortController=function(){if(typeof AbortController=="function")return new AbortController}(),e._started=!1,e._strategySizeAlgorithm=a,e._strategyHWM=o,e._writeAlgorithm=n,e._closeAlgorithm=s,e._abortAlgorithm=i;const c=gl(e);pl(r,c),ht(ne(t()),()=>(e._started=!0,wo(e),null),l=>(e._started=!0,oc(r,l),null))}function Yi(r){r._writeAlgorithm=void 0,r._closeAlgorithm=void 0,r._abortAlgorithm=void 0,r._strategySizeAlgorithm=void 0}function Ug(r){return r._strategyHWM-r._queueTotalSize}function wo(r){const e=r._controlledWritableStream;if(!r._started||e._inFlightWriteRequest!==void 0)return;if(e._state==="erroring")return void fl(e);if(r._queue.length===0)return;const t=r._queue.peek().value;t===Bg?function(n){const s=n._controlledWritableStream;(function(o){o._inFlightCloseRequest=o._closeRequest,o._closeRequest=void 0})(s),rc(n);const i=n._closeAlgorithm();Yi(n),ht(i,()=>(function(o){o._inFlightCloseRequest._resolve(void 0),o._inFlightCloseRequest=void 0,o._state==="erroring"&&(o._storedError=void 0,o._pendingAbortRequest!==void 0&&(o._pendingAbortRequest._resolve(),o._pendingAbortRequest=void 0)),o._state="closed";const a=o._writer;a!==void 0&&Wg(a)}(s),null),o=>(function(a,c){a._inFlightCloseRequest._reject(c),a._inFlightCloseRequest=void 0,a._pendingAbortRequest!==void 0&&(a._pendingAbortRequest._reject(c),a._pendingAbortRequest=void 0),oc(a,c)}(s,o),null))}(r):function(n,s){const i=n._controlledWritableStream;(function(a){a._inFlightWriteRequest=a._writeRequests.shift()})(i);const o=n._writeAlgorithm(s);ht(o,()=>{(function(c){c._inFlightWriteRequest._resolve(void 0),c._inFlightWriteRequest=void 0})(i);const a=i._state;if(rc(n),!wt(i)&&a==="writable"){const c=gl(n);pl(i,c)}return wo(n),null},a=>(i._state==="writable"&&Yi(n),function(c,l){c._inFlightWriteRequest._reject(l),c._inFlightWriteRequest=void 0,oc(c,l)}(i,a),null))}(r,t)}function ac(r,e){r._controlledWritableStream._state==="writable"&&$g(r,e)}function gl(r){return Ug(r)<=0}function $g(r,e){const t=r._controlledWritableStream;Yi(r),hl(t,e)}function Gs(r){return new TypeError(`WritableStream.prototype.${r} can only be used on a WritableStream`)}function ya(r){return new TypeError(`WritableStreamDefaultController.prototype.${r} can only be used on a WritableStreamDefaultController`)}function ar(r){return new TypeError(`WritableStreamDefaultWriter.prototype.${r} can only be used on a WritableStreamDefaultWriter`)}function Fn(r){return new TypeError("Cannot "+r+" a stream using a released writer")}function ai(r){r._closedPromise=Ne((e,t)=>{r._closedPromise_resolve=e,r._closedPromise_reject=t,r._closedPromiseState="pending"})}function qg(r,e){ai(r),ml(r,e)}function ml(r,e){r._closedPromise_reject!==void 0&&(vs(r._closedPromise),r._closedPromise_reject(e),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0,r._closedPromiseState="rejected")}function Wg(r){r._closedPromise_resolve!==void 0&&(r._closedPromise_resolve(void 0),r._closedPromise_resolve=void 0,r._closedPromise_reject=void 0,r._closedPromiseState="resolved")}function bo(r){r._readyPromise=Ne((e,t)=>{r._readyPromise_resolve=e,r._readyPromise_reject=t}),r._readyPromiseState="pending"}function cc(r,e){bo(r),zg(r,e)}function Kd(r){bo(r),yl(r)}function zg(r,e){r._readyPromise_reject!==void 0&&(vs(r._readyPromise),r._readyPromise_reject(e),r._readyPromise_resolve=void 0,r._readyPromise_reject=void 0,r._readyPromiseState="rejected")}function yl(r){r._readyPromise_resolve!==void 0&&(r._readyPromise_resolve(void 0),r._readyPromise_resolve=void 0,r._readyPromise_reject=void 0,r._readyPromiseState="fulfilled")}Object.defineProperties(ji.prototype,{abortReason:{enumerable:!0},signal:{enumerable:!0},error:{enumerable:!0}}),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(ji.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});const Hd=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof global<"u"?global:void 0,OA=function(){const r=Hd?.DOMException;return function(e){if(typeof e!="function"&&typeof e!="object"||e.name!=="DOMException")return!1;try{return new e,!0}catch{return!1}}(r)?r:void 0}()||function(){const r=function(e,t){this.message=e||"",this.name=t||"Error",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)};return Z(r,"DOMException"),r.prototype=Object.create(Error.prototype),Object.defineProperty(r.prototype,"constructor",{value:r,writable:!0,configurable:!0}),r}();function Vd(r,e,t,n,s,i){const o=Yr(r),a=Lg(e);r._disturbed=!0;let c=!1,l=ne(void 0);return Ne((u,d)=>{let h;if(i!==void 0){if(h=()=>{const v=i.reason!==void 0?i.reason:new OA("Aborted","AbortError"),C=[];n||C.push(()=>e._state==="writable"?Gi(e,v):ne(void 0)),s||C.push(()=>r._state==="readable"?ct(r,v):ne(void 0)),x(()=>Promise.all(C.map(E=>E())),!0,v)},i.aborted)return void h();i.addEventListener("abort",h)}var p,f,g;if(S(r,o._closedPromise,v=>(n?w(!0,v):x(()=>Gi(e,v),!0,v),null)),S(e,a._closedPromise,v=>(s?w(!0,v):x(()=>ct(r,v),!0,v),null)),p=r,f=o._closedPromise,g=()=>(t?w():x(()=>function(v){const C=v._ownerWritableStream,E=C._state;return wt(C)||E==="closed"?ne(void 0):E==="errored"?B(C._storedError):Mg(v)}(a)),null),p._state==="closed"?g():ua(f,g),wt(e)||e._state==="closed"){const v=new TypeError("the destination writable stream closed before all data could be piped to it");s?w(!0,v):x(()=>ct(r,v),!0,v)}function m(){const v=l;return yt(l,()=>v!==l?m():void 0)}function S(v,C,E){v._state==="errored"?E(v._storedError):ec(C,E)}function x(v,C,E){function A(){return ht(v(),()=>y(C,E),T=>y(!0,T)),null}c||(c=!0,e._state!=="writable"||wt(e)?A():ua(m(),A))}function w(v,C){c||(c=!0,e._state!=="writable"||wt(e)?y(v,C):ua(m(),()=>y(v,C)))}function y(v,C){return Fg(a),Tt(o),i!==void 0&&i.removeEventListener("abort",h),v?d(C):u(void 0),null}vs(Ne((v,C)=>{(function E(A){A?v():yt(c?ne(!0):yt(a._readyPromise,()=>Ne((T,O)=>{ss(o,{_chunkSteps:L=>{l=yt(Ng(a,L),void 0,ns),T(!1)},_closeSteps:()=>T(!0),_errorSteps:O})})),E,C)})(!1)}))})}class Wt{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!js(this))throw Ys("desiredSize");return wl(this)}close(){if(!js(this))throw Ys("close");if(!yn(this))throw new TypeError("The stream is not in a state that permits close");gn(this)}enqueue(e=void 0){if(!js(this))throw Ys("enqueue");if(!yn(this))throw new TypeError("The stream is not in a state that permits enqueue");return mn(this,e)}error(e=void 0){if(!js(this))throw Ys("error");tr(this,e)}[tl](e){sr(this);const t=this._cancelAlgorithm(e);return Xi(this),t}[rl](e){const t=this._controlledReadableStream;if(this._queue.length>0){const n=rc(this);this._closeRequested&&this._queue.length===0?(Xi(this),Es(t)):is(this),e._chunkSteps(n)}else rg(t,e),is(this)}[nl](){}}function js(r){return!!xe(r)&&!!Object.prototype.hasOwnProperty.call(r,"_controlledReadableStream")&&r instanceof Wt}function is(r){if(Kg(r)){if(r._pulling)return void(r._pullAgain=!0);r._pulling=!0,ht(r._pullAlgorithm(),()=>(r._pulling=!1,r._pullAgain&&(r._pullAgain=!1,is(r)),null),e=>(tr(r,e),null))}}function Kg(r){const e=r._controlledReadableStream;return!yn(r)||!r._started?!1:Gt(e)&&mo(e)>0?!0:wl(r)>0}function Xi(r){r._pullAlgorithm=void 0,r._cancelAlgorithm=void 0,r._strategySizeAlgorithm=void 0}function gn(r){if(!yn(r))return;const e=r._controlledReadableStream;r._closeRequested=!0,r._queue.length===0&&(Xi(r),Es(e))}function mn(r,e){if(!yn(r))return;const t=r._controlledReadableStream;if(Gt(t)&&mo(t)>0)cl(t,e,!1);else{let n;try{n=r._strategySizeAlgorithm(e)}catch(s){throw tr(r,s),s}try{ll(r,e,n)}catch(s){throw tr(r,s),s}}is(r)}function tr(r,e){const t=r._controlledReadableStream;t._state==="readable"&&(sr(r),Xi(r),Vg(t,e))}function wl(r){const e=r._controlledReadableStream._state;return e==="errored"?null:e==="closed"?0:r._strategyHWM-r._queueTotalSize}function yn(r){const e=r._controlledReadableStream._state;return!r._closeRequested&&e==="readable"}function Hg(r,e,t,n,s,i,o){e._controlledReadableStream=r,e._queue=void 0,e._queueTotalSize=void 0,sr(e),e._started=!1,e._closeRequested=!1,e._pullAgain=!1,e._pulling=!1,e._strategySizeAlgorithm=o,e._strategyHWM=i,e._pullAlgorithm=n,e._cancelAlgorithm=s,r._readableStreamController=e,ht(ne(t()),()=>(e._started=!0,is(e),null),a=>(tr(e,a),null))}function Ys(r){return new TypeError(`ReadableStreamDefaultController.prototype.${r} can only be used on a ReadableStreamDefaultController`)}function FA(r,e){return dr(r._readableStreamController)?function(t){let n,s,i,o,a,c=Yr(t),l=!1,u=!1,d=!1,h=!1,p=!1;const f=Ne(E=>{a=E});function g(E){ec(E._closedPromise,A=>(E!==c||(tt(i._readableStreamController,A),tt(o._readableStreamController,A),h&&p||a(void 0)),null))}function m(){mr(c)&&(Tt(c),c=Yr(t),g(c)),ss(c,{_chunkSteps:E=>{Sr(()=>{u=!1,d=!1;const A=E;let T=E;if(!h&&!p)try{T=Wd(E)}catch(O){return tt(i._readableStreamController,O),tt(o._readableStreamController,O),void a(ct(t,O))}h||si(i._readableStreamController,A),p||si(o._readableStreamController,T),l=!1,u?x():d&&w()})},_closeSteps:()=>{l=!1,h||On(i._readableStreamController),p||On(o._readableStreamController),i._readableStreamController._pendingPullIntos.length>0&&ii(i._readableStreamController,0),o._readableStreamController._pendingPullIntos.length>0&&ii(o._readableStreamController,0),h&&p||a(void 0)},_errorSteps:()=>{l=!1}})}function S(E,A){Vt(c)&&(Tt(c),c=Ag(t),g(c));const T=A?o:i,O=A?i:o;Ig(c,E,1,{_chunkSteps:L=>{Sr(()=>{u=!1,d=!1;const M=A?p:h;if(A?h:p)M||oi(T._readableStreamController,L);else{let D;try{D=Wd(L)}catch(U){return tt(T._readableStreamController,U),tt(O._readableStreamController,U),void a(ct(t,U))}M||oi(T._readableStreamController,L),si(O._readableStreamController,D)}l=!1,u?x():d&&w()})},_closeSteps:L=>{l=!1;const M=A?p:h,D=A?h:p;M||On(T._readableStreamController),D||On(O._readableStreamController),L!==void 0&&(M||oi(T._readableStreamController,L),!D&&O._readableStreamController._pendingPullIntos.length>0&&ii(O._readableStreamController,0)),M&&D||a(void 0)},_errorSteps:()=>{l=!1}})}function x(){if(l)return u=!0,ne(void 0);l=!0;const E=sc(i._readableStreamController);return E===null?m():S(E._view,!1),ne(void 0)}function w(){if(l)return d=!0,ne(void 0);l=!0;const E=sc(o._readableStreamController);return E===null?m():S(E._view,!0),ne(void 0)}function y(E){if(h=!0,n=E,p){const A=Dn([n,s]),T=ct(t,A);a(T)}return f}function v(E){if(p=!0,s=E,h){const A=Dn([n,s]),T=ct(t,A);a(T)}return f}function C(){}return i=jd(C,x,y),o=jd(C,w,v),g(c),[i,o]}(r):function(t,n){const s=Yr(t);let i,o,a,c,l,u=!1,d=!1,h=!1,p=!1;const f=Ne(w=>{l=w});function g(){return u?(d=!0,ne(void 0)):(u=!0,ss(s,{_chunkSteps:w=>{Sr(()=>{d=!1;const y=w,v=w;h||mn(a._readableStreamController,y),p||mn(c._readableStreamController,v),u=!1,d&&g()})},_closeSteps:()=>{u=!1,h||gn(a._readableStreamController),p||gn(c._readableStreamController),h&&p||l(void 0)},_errorSteps:()=>{u=!1}}),ne(void 0))}function m(w){if(h=!0,i=w,p){const y=Dn([i,o]),v=ct(t,y);l(v)}return f}function S(w){if(p=!0,o=w,h){const y=Dn([i,o]),v=ct(t,y);l(v)}return f}function x(){}return a=Qi(x,g,m),c=Qi(x,g,S),ec(s._closedPromise,w=>(tr(a._readableStreamController,w),tr(c._readableStreamController,w),h&&p||l(void 0),null)),[a,c]}(r)}function NA(r){return xe(e=r)&&e.getReader!==void 0?function(t){let n;function s(){let o;try{o=t.read()}catch(a){return B(a)}return vr(o,a=>{if(!xe(a))throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");if(a.done)gn(n._readableStreamController);else{const c=a.value;mn(n._readableStreamController,c)}})}function i(o){try{return ne(t.cancel(o))}catch(a){return B(a)}}return n=Qi(ns,s,i,0),n}(r.getReader()):function(t){let n;const s=ag(t,"async");function i(){let a;try{a=cg(s)}catch(c){return B(c)}return vr(ne(a),c=>{if(!xe(c))throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");if(c.done)gn(n._readableStreamController);else{const l=c.value;mn(n._readableStreamController,l)}})}function o(a){const c=s.iterator;let l;try{l=Mn(c,"return")}catch(u){return B(u)}return l===void 0?ne(void 0):vr(En(l,c,[a]),u=>{if(!xe(u))throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object")})}return n=Qi(ns,i,o,0),n}(r);var e}function BA(r,e,t){return nr(r,t),n=>En(r,e,[n])}function UA(r,e,t){return nr(r,t),n=>En(r,e,[n])}function $A(r,e,t){return nr(r,t),n=>pn(r,e,[n])}function qA(r,e){if((r=`${r}`)!="bytes")throw new TypeError(`${e} '${r}' is not a valid enumeration value for ReadableStreamType`);return r}function Gd(r,e){Ht(r,e);const t=r?.preventAbort,n=r?.preventCancel,s=r?.preventClose,i=r?.signal;return i!==void 0&&function(o,a){if(!function(c){if(typeof c!="object"||c===null)return!1;try{return typeof c.aborted=="boolean"}catch{return!1}}(o))throw new TypeError(`${a} is not an AbortSignal.`)}(i,`${e} has member 'signal' that`),{preventAbort:!!t,preventCancel:!!n,preventClose:!!s,signal:i}}Object.defineProperties(Wt.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),Z(Wt.prototype.close,"close"),Z(Wt.prototype.enqueue,"enqueue"),Z(Wt.prototype.error,"error"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Wt.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});let Ue=class{constructor(e={},t={}){e===void 0?e=null:eg(e,"First parameter");const n=kg(t,"Second parameter"),s=function(i,o){Ht(i,o);const a=i,c=a?.autoAllocateChunkSize,l=a?.cancel,u=a?.pull,d=a?.start,h=a?.type;return{autoAllocateChunkSize:c===void 0?void 0:ol(c,`${o} has member 'autoAllocateChunkSize' that`),cancel:l===void 0?void 0:BA(l,a,`${o} has member 'cancel' that`),pull:u===void 0?void 0:UA(u,a,`${o} has member 'pull' that`),start:d===void 0?void 0:$A(d,a,`${o} has member 'start' that`),type:h===void 0?void 0:qA(h,`${o} has member 'type' that`)}}(e,"First parameter");if(bl(this),s.type==="bytes"){if(n.size!==void 0)throw new RangeError("The strategy for a byte stream cannot have a size function");(function(i,o,a){const c=Object.create($t.prototype);let l,u,d;l=o.start!==void 0?()=>o.start(c):()=>{},u=o.pull!==void 0?()=>o.pull(c):()=>ne(void 0),d=o.cancel!==void 0?p=>o.cancel(p):()=>ne(void 0);const h=o.autoAllocateChunkSize;if(h===0)throw new TypeError("autoAllocateChunkSize must be greater than 0");xg(i,c,l,u,d,a,h)})(this,s,ic(n,0))}else{const i=Pg(n);(function(o,a,c,l){const u=Object.create(Wt.prototype);let d,h,p;d=a.start!==void 0?()=>a.start(u):()=>{},h=a.pull!==void 0?()=>a.pull(u):()=>ne(void 0),p=a.cancel!==void 0?f=>a.cancel(f):()=>ne(void 0),Hg(o,u,d,h,p,c,l)})(this,s,ic(n,1),i)}}get locked(){if(!Bt(this))throw cr("locked");return Gt(this)}cancel(e=void 0){return Bt(this)?Gt(this)?B(new TypeError("Cannot cancel a stream that already has a reader")):ct(this,e):B(cr("cancel"))}getReader(e=void 0){if(!Bt(this))throw cr("getReader");return function(t,n){Ht(t,n);const s=t?.mode;return{mode:s===void 0?void 0:CA(s,`${n} has member 'mode' that`)}}(e,"First parameter").mode===void 0?Yr(this):Ag(this)}pipeThrough(e,t={}){if(!Bt(this))throw cr("pipeThrough");Ir(e,1,"pipeThrough");const n=function(i,o){Ht(i,o);const a=i?.readable;Nd(a,"readable","ReadableWritablePair"),al(a,`${o} has member 'readable' that`);const c=i?.writable;return Nd(c,"writable","ReadableWritablePair"),Rg(c,`${o} has member 'writable' that`),{readable:a,writable:c}}(e,"First parameter"),s=Gd(t,"Second parameter");if(Gt(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(Qr(n.writable))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");return vs(Vd(this,n.writable,s.preventClose,s.preventAbort,s.preventCancel,s.signal)),n.readable}pipeTo(e,t={}){if(!Bt(this))return B(cr("pipeTo"));if(e===void 0)return B("Parameter 1 is required in 'pipeTo'.");if(!zr(e))return B(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));let n;try{n=Gd(t,"Second parameter")}catch(s){return B(s)}return Gt(this)?B(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):Qr(e)?B(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):Vd(this,e,n.preventClose,n.preventAbort,n.preventCancel,n.signal)}tee(){if(!Bt(this))throw cr("tee");return Dn(FA(this))}values(e=void 0){if(!Bt(this))throw cr("values");return function(t,n){const s=Yr(t),i=new lg(s,n),o=Object.create(ug);return o._asyncIteratorImpl=i,o}(this,function(t,n){return Ht(t,n),{preventCancel:!!t?.preventCancel}}(e,"First parameter").preventCancel)}[Ss](e){return this.values(e)}static from(e){return NA(e)}};function Qi(r,e,t,n=1,s=()=>1){const i=Object.create(Ue.prototype);return bl(i),Hg(i,Object.create(Wt.prototype),r,e,t,n,s),i}function jd(r,e,t){const n=Object.create(Ue.prototype);return bl(n),xg(n,Object.create($t.prototype),r,e,t,0,void 0),n}function bl(r){r._state="readable",r._reader=void 0,r._storedError=void 0,r._disturbed=!1}function Bt(r){return!!xe(r)&&!!Object.prototype.hasOwnProperty.call(r,"_readableStreamController")&&r instanceof Ue}function Gt(r){return r._reader!==void 0}function ct(r,e){if(r._disturbed=!0,r._state==="closed")return ne(void 0);if(r._state==="errored")return B(r._storedError);Es(r);const t=r._reader;if(t!==void 0&&mr(t)){const n=t._readIntoRequests;t._readIntoRequests=new nt,n.forEach(s=>{s._closeSteps(void 0)})}return vr(r._readableStreamController[tl](e),ns)}function Es(r){r._state="closed";const e=r._reader;if(e!==void 0&&(Jp(e),Vt(e))){const t=e._readRequests;e._readRequests=new nt,t.forEach(n=>{n._closeSteps()})}}function Vg(r,e){r._state="errored",r._storedError=e;const t=r._reader;t!==void 0&&(il(t,e),Vt(t)?sg(t,e):Tg(t,e))}function cr(r){return new TypeError(`ReadableStream.prototype.${r} can only be used on a ReadableStream`)}Object.defineProperties(Ue,{from:{enumerable:!0}}),Object.defineProperties(Ue.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),Z(Ue.from,"from"),Z(Ue.prototype.cancel,"cancel"),Z(Ue.prototype.getReader,"getReader"),Z(Ue.prototype.pipeThrough,"pipeThrough"),Z(Ue.prototype.pipeTo,"pipeTo"),Z(Ue.prototype.tee,"tee"),Z(Ue.prototype.values,"values"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Ue.prototype,Symbol.toStringTag,{value:"ReadableStream",configurable:!0}),Object.defineProperty(Ue.prototype,Ss,{value:Ue.prototype.values,writable:!0,configurable:!0});const WA=r=>r.byteLength;Z(WA,"size");const zA=()=>1;Z(zA,"size");function KA(r,e){tr(r._readable._readableStreamController,e),vl(r,e)}function vl(r,e){VA(r._transformStreamController),ac(r._writable._writableStreamController,e),HA(r)}function HA(r){r._backpressure&&Gg(r,!1)}function Gg(r,e){r._backpressureChangePromise!==void 0&&r._backpressureChangePromise_resolve(),r._backpressureChangePromise=Ne(t=>{r._backpressureChangePromise_resolve=t}),r._backpressure=e}class Ur{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!Xs(this))throw Qs("desiredSize");return wl(this._controlledTransformStream._readable._readableStreamController)}enqueue(e=void 0){if(!Xs(this))throw Qs("enqueue");GA(this,e)}error(e=void 0){if(!Xs(this))throw Qs("error");var t;t=e,KA(this._controlledTransformStream,t)}terminate(){if(!Xs(this))throw Qs("terminate");(function(e){const t=e._controlledTransformStream;gn(t._readable._readableStreamController);const n=new TypeError("TransformStream terminated");vl(t,n)})(this)}}function Xs(r){return!!xe(r)&&!!Object.prototype.hasOwnProperty.call(r,"_controlledTransformStream")&&r instanceof Ur}function VA(r){r._transformAlgorithm=void 0,r._flushAlgorithm=void 0,r._cancelAlgorithm=void 0}function GA(r,e){const t=r._controlledTransformStream,n=t._readable._readableStreamController;if(!yn(n))throw new TypeError("Readable side is not in a state that permits enqueue");try{mn(n,e)}catch(i){throw vl(t,i),t._readable._storedError}(function(i){return!Kg(i)})(n)!==t._backpressure&&Gg(t,!0)}function Qs(r){return new TypeError(`TransformStreamDefaultController.prototype.${r} can only be used on a TransformStreamDefaultController`)}Object.defineProperties(Ur.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),Z(Ur.prototype.enqueue,"enqueue"),Z(Ur.prototype.error,"error"),Z(Ur.prototype.terminate,"terminate"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Ur.prototype,Symbol.toStringTag,{value:"TransformStreamDefaultController",configurable:!0});var wa={exports:{}};/*! streamsaver. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */var Yd;function jA(){return Yd||(Yd=1,function(r){((e,t)=>{r.exports=t()})("streamSaver",()=>{const e=typeof window=="object"?window:this;e.HTMLElement||console.warn("streamsaver is meant to run on browsers main thread");let t=null,n=!1;const s=f=>{try{f()}catch{}},i=e.WebStreamsPolyfill||{},o=e.isSecureContext;let a=/constructor/i.test(e.HTMLElement)||!!e.safari||!!e.WebKitPoint;const c=o||"MozAppearance"in document.documentElement.style?"iframe":"navigate",l={createWriteStream:p,WritableStream:e.WritableStream||i.WritableStream,supported:!0,version:{full:"2.0.5",major:2,minor:0,dot:5},mitm:"https://jimmywarting.github.io/StreamSaver.js/mitm.html?version=2.0.0"};function u(f){if(!f)throw new Error("meh");const g=document.createElement("iframe");return g.hidden=!0,g.src=f,g.loaded=!1,g.name="iframe",g.isIframe=!0,g.postMessage=(...m)=>g.contentWindow.postMessage(...m),g.addEventListener("load",()=>{g.loaded=!0},{once:!0}),document.body.appendChild(g),g}function d(f){const g="width=200,height=100",m=document.createDocumentFragment(),S={frame:e.open(f,"popup",g),loaded:!1,isIframe:!1,isPopup:!0,remove(){S.frame.close()},addEventListener(...w){m.addEventListener(...w)},dispatchEvent(...w){m.dispatchEvent(...w)},removeEventListener(...w){m.removeEventListener(...w)},postMessage(...w){S.frame.postMessage(...w)}},x=w=>{w.source===S.frame&&(S.loaded=!0,e.removeEventListener("message",x),S.dispatchEvent(new Event("load")))};return e.addEventListener("message",x),S}try{new Response(new ReadableStream),o&&!("serviceWorker"in navigator)&&(a=!0)}catch{a=!0}s(()=>{const{readable:f}=new TransformStream,g=new MessageChannel;g.port1.postMessage(f,[f]),g.port1.close(),g.port2.close(),n=!0,Object.defineProperty(l,"TransformStream",{configurable:!1,writable:!1,value:TransformStream})});function h(){t||(t=o?u(l.mitm):d(l.mitm))}function p(f,g,m){let S={size:null,pathname:null,writableStrategy:void 0,readableStrategy:void 0},x=0,w=null,y=null,v=null;if(Number.isFinite(g)?([m,g]=[g,m],console.warn("[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream"),S.size=m,S.writableStrategy=g):g&&g.highWaterMark?(console.warn("[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream"),S.size=m,S.writableStrategy=g):S=g||{},!a){h(),y=new MessageChannel,f=encodeURIComponent(f.replace(/\//g,":")).replace(/['()]/g,escape).replace(/\*/g,"%2A");const E={transferringReadable:n,pathname:S.pathname||Math.random().toString().slice(-6)+"/"+f,headers:{"Content-Type":"application/octet-stream; charset=utf-8","Content-Disposition":"attachment; filename*=UTF-8''"+f}};S.size&&(E.headers["Content-Length"]=S.size);const A=[E,"*",[y.port2]];if(n){const T=c==="iframe"?void 0:{transform(L,M){if(!(L instanceof Uint8Array))throw new TypeError("Can only write Uint8Arrays");x+=L.length,M.enqueue(L),w&&(location.href=w,w=null)},flush(){w&&(location.href=w)}};v=new l.TransformStream(T,S.writableStrategy,S.readableStrategy);const O=v.readable;y.port1.postMessage({readableStream:O},[O])}y.port1.onmessage=T=>{T.data.download?c==="navigate"?(t.remove(),t=null,x?location.href=T.data.download:w=T.data.download):(t.isPopup&&(t.remove(),t=null,c==="iframe"&&u(l.mitm)),u(T.data.download)):T.data.abort&&(C=[],y.port1.postMessage("abort"),y.port1.onmessage=null,y.port1.close(),y.port2.close(),y=null)},t.loaded?t.postMessage(...A):t.addEventListener("load",()=>{t.postMessage(...A)},{once:!0})}let C=[];return!a&&v&&v.writable||new l.WritableStream({write(E){if(!(E instanceof Uint8Array))throw new TypeError("Can only write Uint8Arrays");if(a){C.push(E);return}y.port1.postMessage(E),x+=E.length,w&&(location.href=w,w=null)},close(){if(a){const E=new Blob(C,{type:"application/octet-stream; charset=utf-8"}),A=document.createElement("a");A.href=URL.createObjectURL(E),A.download=f,A.click()}else y.port1.postMessage("end")},abort(){C=[],y.port1.postMessage("abort"),y.port1.onmessage=null,y.port1.close(),y.port2.close(),y=null}},S.writableStrategy)}return l})}(wa)),wa.exports}var YA=jA();const Xd=bs(YA);class XA{node;appState;progressTracker;uiManager;errorHandler;protocol;wakeLock=null;transferProgressBytes;receivedFileStream=null;receivedFileWriter=null;fileNameFromHeader;fileSizeFromHeader;fileTypeFromHeader;headerReceived;receivedBytesTotal;constructor(e,t,n,s,i){this.node=e,this.appState=t,this.progressTracker=n,this.uiManager=s,this.errorHandler=i,this.protocol="/fileferry/filetransfer/1.0.0",this.wakeLock=null,this.transferProgressBytes=0,this.receivedFileStream=null,this.receivedFileWriter=null,this.fileNameFromHeader="downloaded_file",this.fileSizeFromHeader=0,this.fileTypeFromHeader="application/octet-stream",this.headerReceived=!1,this.receivedBytesTotal=0,Xd.WritableStream=qt,window.WritableStream=qt}setupFileTransferProtocol(){const e=async({stream:t,connection:n})=>{this.getWakelock(),this.appState.setActivePeer(n.remotePeer.toString()),this.appState.setTransferConnectionId(n.id),this.appState.isTransferActive()?(console.log("Resuming file transfer after reconnection."),this.appState.setActiveStream(t)):(this.appState.setActiveStream(t),this.appState.setActiveTransfer()),await this.handleFileTransfer()};this.node.handle(this.protocol,e)}async startFileTransfer(){try{const e=this.appState.getActiveStream(),t=this.appState.getSelectedFile();if(!e||!t)throw new Error("No active stream or file to start transfer.");this.appState.isTransferActive()?(console.log("Resuming file transfer after reconnection."),await this.sendFileToStream(e,t)):(this.appState.setActiveTransfer(),await this.sendFileToStream(e,t)),this.appState.isFinished()&&await this.transferComplete()}catch{}}async handleFileTransfer(){try{const e=this.appState.getActiveStream();if(!e)throw new Error("No active stream to handle transfer.");await this.receiveFileFromStream(e),this.appState.isFinished()&&await this.transferComplete()}catch{}}async sendFileToStream(e,t,n=16384){try{const s=this.createFileHeader(t),i=new TextEncoder().encode(s+`
`);let o=0;const a=e.channel,c=a.bufferedAmountLowThreshold||1024*64,l=async function*(){yield new J(i),await new Promise(u=>setTimeout(u,1));for(let u=0;u<t.size;u+=n){const d=t.slice(u,Math.min(u+n,t.size)),h=new Uint8Array(await d.arrayBuffer());if(o<this.transferProgressBytes){o+=h.length;continue}yield new J(h),a.bufferedAmount>c&&await new Promise(p=>{a.addEventListener("bufferedamountlow",()=>p(),{once:!0})}),o+=h.length,this.transferProgressBytes+=h.length,this.progressTracker.updateProgress(this.transferProgressBytes,t.size,"send")}}.bind(this);await Fc(l(),e.sink),this.progressTracker.updateProgress(this.transferProgressBytes,t.size,"send",!0),this.transferProgressBytes=0}catch(s){throw s}}createFileHeader(e){return JSON.stringify({name:e.name,size:e.size,type:e.type||"application/octet-stream"})}async receiveFileFromStream(e){try{for await(const t of e.source){if(!t||t.length===0)continue;const n=t.subarray();if(this.headerReceived)this.receivedFileWriter!=null&&(await this.receivedFileWriter.write(n),this.receivedBytesTotal+=n.length,this.progressTracker.updateProgress(this.receivedBytesTotal,this.fileSizeFromHeader,"receive"));else{const s=this.parseFileHeader(n);s.header&&(this.fileNameFromHeader=s.header.name||this.fileNameFromHeader,this.fileSizeFromHeader=s.header.size||this.fileSizeFromHeader,this.fileTypeFromHeader=s.header.type||this.fileTypeFromHeader,this.headerReceived=!0,console.log(`Receiving file: ${this.fileNameFromHeader} (${this.fileSizeFromHeader} bytes)`),this.receivedFileStream===null&&(this.receivedFileStream=Xd.createWriteStream(this.fileNameFromHeader,{size:this.fileSizeFromHeader})),this.receivedFileWriter===null&&(this.receivedFileWriter=this.receivedFileStream.getWriter())),s.bodyData&&s.bodyData.length>0&&this.receivedFileWriter!=null&&(await this.receivedFileWriter.write(s.bodyData),this.receivedBytesTotal+=s.bodyData.length,this.progressTracker.updateProgress(this.receivedBytesTotal,this.fileSizeFromHeader,"receive"))}if(this.headerReceived&&this.receivedBytesTotal>=this.fileSizeFromHeader&&this.fileSizeFromHeader>0){this.progressTracker.updateProgress(this.receivedBytesTotal,this.fileSizeFromHeader,"receive",!0),this.uiManager.showReceivedFileDetails(this.fileNameFromHeader,this.fileSizeFromHeader),this.receivedFileWriter!=null&&(await this.receivedFileWriter.close(),this.receivedFileWriter=null),this.appState.clearActiveTransfer(),await this.closeActiveStream();break}}}catch(t){throw t}}async closeActiveStream(){const e=this.appState.getActiveStream();e&&(await e.close(),this.appState.setActiveStream(null))}parseFileHeader(e){try{const t=new TextDecoder("utf-8",{fatal:!1}).decode(e),n=t.indexOf(`
`);if(n!==-1){const s=t.substring(0,n),o=new TextEncoder().encode(s+`
`).length;try{const a=JSON.parse(s),c=o<e.byteLength?e.subarray(o):null;return{header:a,bodyData:c}}catch{return{header:null,bodyData:e}}}return{header:null,bodyData:e}}catch{return{header:null,bodyData:e}}}async getWakelock(){if("wakeLock"in navigator){async function e(){let t=null;try{return t=await navigator.wakeLock.request("screen"),t}catch{return null}}this.wakeLock=await e()||null}}async releaseWakelock(){this.wakeLock?.release().catch(e=>{})}async transferComplete(){if(this.appState.isTransferActive()&&this.appState.getMode()==="receiver")try{this.receivedFileWriter?.close(),this.closeActiveStream()}catch{}this.appState.declareFinished(),await this.node.stop(),this.releaseWakelock()}}class QA{node;appState;errorHandler;relayPeerId;relayMultiaddr;reservationStatus;constructor(e,t,n){this.node=e,this.appState=t,this.errorHandler=n,this.relayPeerId=null,this.relayMultiaddr=null,this.reservationStatus=null}async connectToRelay(e){try{if(this.relayMultiaddr=Y(e),!this.relayMultiaddr.getPeerId())throw new Error("Could not parse PeerId from relay multiaddr");this.relayPeerId=this.parseRelayPeerId(this.relayMultiaddr),console.log(`Connecting to relay: ${e}`),console.log(`Relay peer ID: ${this.relayPeerId}`);const n=await this.node.dial(this.relayMultiaddr,{signal:AbortSignal.timeout(1e4)});return console.log(`Successfully connected to relay: ${this.relayPeerId}`),n}catch(t){const n=t;throw console.error(`Failed to connect to relay: ${n.message}`),this.errorHandler.handleConnectionError(n,{relay:e}),t}}async waitForRelayAddress(){return new Promise((e,t)=>{let n,s=0;const i=60,o=()=>{s++;const c=this.getCircuitAddress();if(c){console.log(`Circuit address obtained: ${c.toString()}`),clearInterval(n),e(c);return}if(s>=i){clearInterval(n),t(new Error("Timeout: Could not obtain a circuit address via relay."));return}console.log(`Waiting for circuit address... (attempt ${s}/${i})`)},a=this.getCircuitAddress();if(a){console.log(`Circuit address already available: ${a.toString()}`),e(a);return}n=window.setInterval(o,500)})}isConnectedToRelay(){if(!this.relayPeerId)return console.log("No relay peer ID set"),!1;const e=this.appState.getConnectionsForPeer(this.relayPeerId.toString());if(!e)return!1;let t=!1;for(const n of e.values())if(n!==void 0&&n.status==="open"){t=!0;break}return console.log(`Relay connection status: ${t?"connected":"disconnected"}`),t}getCircuitAddress(){return this.node.getMultiaddrs().find(t=>t.toString().includes("/p2p-circuit"))}async reserveRelay(){try{return this.isConnectedToRelay()?await this.waitForRelayAddress()?(this.reservationStatus="reserved",console.log("Relay reservation successful"),!0):!1:(console.log("Not connected to relay, cannot reserve"),!1)}catch(e){const t=e;return console.error(`Relay reservation failed: ${t.message}`),this.errorHandler.handleConnectionError(t,{operation:"reserveRelay"}),!1}}async releaseRelay(){try{if(this.reservationStatus!=="reserved")return console.log("No active relay reservation to release"),!0;if(console.log("Releasing relay reservation..."),this.relayPeerId){const e=this.appState.getConnectionsForPeer(this.relayPeerId.toString());if(e)for(const t of e.values())t&&t.status==="open"&&(await t.close(),console.log("Relay connection closed"));this.appState.removeAllConnectionsWithPeer(this.relayPeerId.toString())}return this.reservationStatus=null,console.log("Relay reservation released"),!0}catch(e){const t=e;return console.error(`Failed to release relay: ${t.message}`),this.errorHandler.handleConnectionError(t,{operation:"releaseRelay"}),!1}}parseRelayPeerId(e){try{const t=e.getPeerId();if(!t)throw new Error("No peer ID found in multiaddr");if(!e.protos().find(s=>s.name==="p2p"))throw new Error("Multiaddr does not contain a p2p component");return console.log(`Parsed relay peer ID: ${t}`),{toString:()=>t}}catch(t){const n=t;return console.error(`Failed to parse relay peer ID: ${n.message}`),this.errorHandler.handleConnectionError(n,{operation:"parseRelayPeerId"}),null}}validateRelayConnection(e){if(!e)return console.log("No connection provided for validation"),!1;if(e.status!=="open")return console.log(`Connection status is ${e.status}, not open`),!1;if(!this.relayPeerId)return console.log("No relay peer ID to validate against"),!1;const t=e.remotePeer.toString()===this.relayPeerId.toString();return console.log(`Relay connection validation: ${t?"valid":"invalid"}`),t}getRelayPeerId(){return this.relayPeerId}getRelayMultiaddr(){return this.relayMultiaddr}getReservationStatus(){return this.reservationStatus}async canUseRelay(){return this.isConnectedToRelay()?!0:(console.log("Cannot use relay: not connected"),!1)}getRelayInfo(){return{peerId:this.relayPeerId?.toString(),multiaddr:this.relayMultiaddr?.toString(),connected:this.isConnectedToRelay(),reservationStatus:this.reservationStatus,circuitAddress:this.getCircuitAddress()?.toString()}}}class ZA{geoLocUrl;hostUrl;geoUserUrl;cacheKey;cacheDuration;constructor(){this.geoLocUrl="https://raw.githubusercontent.com/pradt2/always-online-stun/master/geoip_cache.txt",this.hostUrl="https://raw.githubusercontent.com/pradt2/always-online-stun/master/valid_hosts.txt",this.geoUserUrl="https://geoip.fileferry.xyz",this.cacheKey="userGeoData",this.cacheDuration=48*60*60*1e3}async getClosestStunServer(){try{const e=await this.fetchGeoData(),t=await this.getUserGeoData(),n=await this.fetchStunServers();return this.findClosestServer(t,e,n)}catch(e){console.error("Error in getClosestStunServer:",e),this.clearExpiredCache();return}}async fetchGeoData(){return await(await fetch(this.geoLocUrl)).json()}async getUserGeoData(){const e=this.getCachedGeoData();if(e)return e;const t=await fetch(this.geoUserUrl);if(!t.ok)throw new Error(`Failed to fetch user geo data: ${t.status} ${t.statusText}`);const n=await t.json();return this.setCachedGeoData(n),n}calculateDistance(e,t,n,s){return Math.sqrt(Math.pow(e-n,2)+Math.pow(t-s,2))}findClosestServer(e,t,n){const{lat:s,lon:i}=e;return n.trim().split(`
`).map(o=>{const a=o.split(":")[0];if(!t[a])return[o,1/0];const[c,l]=t[a];if(typeof c!="number"||typeof l!="number")return[o,1/0];const u=this.calculateDistance(s,i,c,l);return[o,u]}).reduce(([o,a],[c,l])=>a<=l?[o,a]:[c,l])[0]}getCachedGeoData(){const e=localStorage.getItem(this.cacheKey);if(e){const t=JSON.parse(e);if(t.expiry&&t.expiry>Date.now())return t.data;localStorage.removeItem(this.cacheKey)}return null}setCachedGeoData(e){const t={data:e,expiry:Date.now()+this.cacheDuration};localStorage.setItem(this.cacheKey,JSON.stringify(t))}clearExpiredCache(){localStorage.removeItem(this.cacheKey)}async fetchStunServers(){return await(await fetch(this.hostUrl)).text()}validateStunServer(e){return!!(e&&e.includes(":")&&e.split(":").length===2)}}var Zs={exports:{}},Qd;function JA(){return Qd||(Qd=1,function(r,e){var t=globalThis.require&&e||{};(function(n,s){let i=globalThis.crypto;s._sep=/[\s,:-]+/,s._mword="mnemonic",s._normalize=function(o){return o.normalize("NFKD").trim().toLowerCase()},s.generate=async function(o=128){let a=o/8,c=i.getRandomValues(new Uint8Array(a));return await s.encode(c)},s.encode=async function(o){let a=8*o.length,c=a/32;o=new Uint8Array(o);let l=await i.subtle.digest("SHA-256",o),u=new Uint8Array(l),d="";o.forEach(function(S){let x=S.toString(2).padStart(8,"0");d+=x});let p=u[0].toString(2);p=p.padStart(8,"0");let f=p.slice(0,c);d+=f;let g=[];for(let S=0;S<a+c;S+=11){let x=parseInt(d.slice(S,S+11).padStart(8,"0"),2);g.push(x)}return g.map(function(S){return s.base2048[S]}).join(" ")},s.verify=async function(o){return await s.decode(o),!0},s.checksum=s.verify,s.decode=async function(o,a){o=s._normalize(o);let c=[];o.split(s._sep).forEach(function(w){let y=s.base2048.indexOf(w);if(y<0){let v=new Error(`dashphrase.js: decode failed: unknown word '${w}'`);throw v.code="E_UNKNOWN_WORD",v}c.push(y)});let u=c.map(function(w){return w.toString(2).padStart(11,"0")}).join(""),d=Math.floor(u.length/32),h=u.length-d,p=u.slice(-d),f=[];for(let w=0;w<h;w+=8){let y=u.slice(w,w+8),v=parseInt(y,2);v>=0&&f.push(v)}let g=Uint8Array.from(f),m=await i.subtle.digest("SHA-256",g),x=new Uint8Array(m)[0].toString(2).padStart(8,"0").slice(0,d);if(x!==p&&a?.verify!==!1){let w=new Error(`dashphrase.js: bad checksum: expected '${x}' but got '${p}'`);throw w.code="E_BAD_CHECKSUM",w}return g},s.toSeed=async function(o,a="",c={}){c.verify!==!1&&await s.verify(o),o=s._normalize(o),a=a.normalize("NFKD");let u=new TextEncoder().encode(o),d=new TextEncoder().encode(s._mword+a),g=await s._pbkdf2(u,d,2048,512,"SHA-512");return new Uint8Array(g)},s.pbkdf2=s.toSeed,s._pbkdf2=async function(a,c,l,u,d){let h=!1,p=await i.subtle.importKey("raw",a,{name:"PBKDF2"},h,["deriveKey"]);h=!0;let f=await i.subtle.deriveKey({name:"PBKDF2",salt:c,iterations:l,hash:d},p,{name:"HMAC",hash:d,length:u},h,["sign","verify"]),g=await i.subtle.exportKey("raw",f);return new Uint8Array(g)},s._sha256=async function(o,a=""){o=s._normalize(o),a=a.normalize("NFKD");let c=new TextEncoder().encode(o),l=new TextEncoder().encode(a),u=new Uint8Array(c.length+l.length),d=0;for(let p=0;p<c.length;p+=1)u[d]=c[p],d+=1;for(let p=0;p<l.length;p+=1)u[d]=l[p],d+=1;let h=await i.subtle.digest("SHA-256",u);return new Uint8Array(h)},s.CATMONIC="cat swing flag economy stadium alone churn speed unique patch report train",s.ZOOMONIC="zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",s.ZECRET="TREZOR",s.ZEED="ac27495480225222079d7be181583751e86f571027b0497b5b5d11218e0a8a13332572917f0f8e5a589620c6f15b11c61dee327651a14c34e18231052e48c069",s.base2048="abandon ability able about above absent absorb abstract absurd abuse access accident account accuse achieve acid acoustic acquire across act action actor actress actual adapt add addict address adjust admit adult advance advice aerobic affair afford afraid again age agent agree ahead aim air airport aisle alarm album alcohol alert alien all alley allow almost alone alpha already also alter always amateur amazing among amount amused analyst anchor ancient anger angle angry animal ankle announce annual another answer antenna antique anxiety any apart apology appear apple approve april arch arctic area arena argue arm armed armor army around arrange arrest arrive arrow art artefact artist artwork ask aspect assault asset assist assume asthma athlete atom attack attend attitude attract auction audit august aunt author auto autumn average avocado avoid awake aware away awesome awful awkward axis baby bachelor bacon badge bag balance balcony ball bamboo banana banner bar barely bargain barrel base basic basket battle beach bean beauty because become beef before begin behave behind believe below belt bench benefit best betray better between beyond bicycle bid bike bind biology bird birth bitter black blade blame blanket blast bleak bless blind blood blossom blouse blue blur blush board boat body boil bomb bone bonus book boost border boring borrow boss bottom bounce box boy bracket brain brand brass brave bread breeze brick bridge brief bright bring brisk broccoli broken bronze broom brother brown brush bubble buddy budget buffalo build bulb bulk bullet bundle bunker burden burger burst bus business busy butter buyer buzz cabbage cabin cable cactus cage cake call calm camera camp can canal cancel candy cannon canoe canvas canyon capable capital captain car carbon card cargo carpet carry cart case cash casino castle casual cat catalog catch category cattle caught cause caution cave ceiling celery cement census century cereal certain chair chalk champion change chaos chapter charge chase chat cheap check cheese chef cherry chest chicken chief child chimney choice choose chronic chuckle chunk churn cigar cinnamon circle citizen city civil claim clap clarify claw clay clean clerk clever click client cliff climb clinic clip clock clog close cloth cloud clown club clump cluster clutch coach coast coconut code coffee coil coin collect color column combine come comfort comic common company concert conduct confirm congress connect consider control convince cook cool copper copy coral core corn correct cost cotton couch country couple course cousin cover coyote crack cradle craft cram crane crash crater crawl crazy cream credit creek crew cricket crime crisp critic crop cross crouch crowd crucial cruel cruise crumble crunch crush cry crystal cube culture cup cupboard curious current curtain curve cushion custom cute cycle dad damage damp dance danger daring dash daughter dawn day deal debate debris decade december decide decline decorate decrease deer defense define defy degree delay deliver demand demise denial dentist deny depart depend deposit depth deputy derive describe desert design desk despair destroy detail detect develop device devote diagram dial diamond diary dice diesel diet differ digital dignity dilemma dinner dinosaur direct dirt disagree discover disease dish dismiss disorder display distance divert divide divorce dizzy doctor document dog doll dolphin domain donate donkey donor door dose double dove draft dragon drama drastic draw dream dress drift drill drink drip drive drop drum dry duck dumb dune during dust dutch duty dwarf dynamic eager eagle early earn earth easily east easy echo ecology economy edge edit educate effort egg eight either elbow elder electric elegant element elephant elevator elite else embark embody embrace emerge emotion employ empower empty enable enact end endless endorse enemy energy enforce engage engine enhance enjoy enlist enough enrich enroll ensure enter entire entry envelope episode equal equip era erase erode erosion error erupt escape essay essence estate eternal ethics evidence evil evoke evolve exact example excess exchange excite exclude excuse execute exercise exhaust exhibit exile exist exit exotic expand expect expire explain expose express extend extra eye eyebrow fabric face faculty fade faint faith fall false fame family famous fan fancy fantasy farm fashion fat fatal father fatigue fault favorite feature february federal fee feed feel female fence festival fetch fever few fiber fiction field figure file film filter final find fine finger finish fire firm first fiscal fish fit fitness fix flag flame flash flat flavor flee flight flip float flock floor flower fluid flush fly foam focus fog foil fold follow food foot force forest forget fork fortune forum forward fossil foster found fox fragile frame frequent fresh friend fringe frog front frost frown frozen fruit fuel fun funny furnace fury future gadget gain galaxy gallery game gap garage garbage garden garlic garment gas gasp gate gather gauge gaze general genius genre gentle genuine gesture ghost giant gift giggle ginger giraffe girl give glad glance glare glass glide glimpse globe gloom glory glove glow glue goat goddess gold good goose gorilla gospel gossip govern gown grab grace grain grant grape grass gravity great green grid grief grit grocery group grow grunt guard guess guide guilt guitar gun gym habit hair half hammer hamster hand happy harbor hard harsh harvest hat have hawk hazard head health heart heavy hedgehog height hello helmet help hen hero hidden high hill hint hip hire history hobby hockey hold hole holiday hollow home honey hood hope horn horror horse hospital host hotel hour hover hub huge human humble humor hundred hungry hunt hurdle hurry hurt husband hybrid ice icon idea identify idle ignore ill illegal illness image imitate immense immune impact impose improve impulse inch include income increase index indicate indoor industry infant inflict inform inhale inherit initial inject injury inmate inner innocent input inquiry insane insect inside inspire install intact interest into invest invite involve iron island isolate issue item ivory jacket jaguar jar jazz jealous jeans jelly jewel job join joke journey joy judge juice jump jungle junior junk just kangaroo keen keep ketchup key kick kid kidney kind kingdom kiss kit kitchen kite kitten kiwi knee knife knock know lab label labor ladder lady lake lamp language laptop large later latin laugh laundry lava law lawn lawsuit layer lazy leader leaf learn leave lecture left leg legal legend leisure lemon lend length lens leopard lesson letter level liar liberty library license life lift light like limb limit link lion liquid list little live lizard load loan lobster local lock logic lonely long loop lottery loud lounge love loyal lucky luggage lumber lunar lunch luxury lyrics machine mad magic magnet maid mail main major make mammal man manage mandate mango mansion manual maple marble march margin marine market marriage mask mass master match material math matrix matter maximum maze meadow mean measure meat mechanic medal media melody melt member memory mention menu mercy merge merit merry mesh message metal method middle midnight milk million mimic mind minimum minor minute miracle mirror misery miss mistake mix mixed mixture mobile model modify mom moment monitor monkey monster month moon moral more morning mosquito mother motion motor mountain mouse move movie much muffin mule multiply muscle museum mushroom music must mutual myself mystery myth naive name napkin narrow nasty nation nature near neck need negative neglect neither nephew nerve nest net network neutral never news next nice night noble noise nominee noodle normal north nose notable note nothing notice novel now nuclear number nurse nut oak obey object oblige obscure observe obtain obvious occur ocean october odor off offer office often oil okay old olive olympic omit once one onion online only open opera opinion oppose option orange orbit orchard order ordinary organ orient original orphan ostrich other outdoor outer output outside oval oven over own owner oxygen oyster ozone pact paddle page pair palace palm panda panel panic panther paper parade parent park parrot party pass patch path patient patrol pattern pause pave payment peace peanut pear peasant pelican pen penalty pencil people pepper perfect permit person pet phone photo phrase physical piano picnic picture piece pig pigeon pill pilot pink pioneer pipe pistol pitch pizza place planet plastic plate play please pledge pluck plug plunge poem poet point polar pole police pond pony pool popular portion position possible post potato pottery poverty powder power practice praise predict prefer prepare present pretty prevent price pride primary print priority prison private prize problem process produce profit program project promote proof property prosper protect proud provide public pudding pull pulp pulse pumpkin punch pupil puppy purchase purity purpose purse push put puzzle pyramid quality quantum quarter question quick quit quiz quote rabbit raccoon race rack radar radio rail rain raise rally ramp ranch random range rapid rare rate rather raven raw razor ready real reason rebel rebuild recall receive recipe record recycle reduce reflect reform refuse region regret regular reject relax release relief rely remain remember remind remove render renew rent reopen repair repeat replace report require rescue resemble resist resource response result retire retreat return reunion reveal review reward rhythm rib ribbon rice rich ride ridge rifle right rigid ring riot ripple risk ritual rival river road roast robot robust rocket romance roof rookie room rose rotate rough round route royal rubber rude rug rule run runway rural sad saddle sadness safe sail salad salmon salon salt salute same sample sand satisfy satoshi sauce sausage save say scale scan scare scatter scene scheme school science scissors scorpion scout scrap screen script scrub sea search season seat second secret section security seed seek segment select sell seminar senior sense sentence series service session settle setup seven shadow shaft shallow share shed shell sheriff shield shift shine ship shiver shock shoe shoot shop short shoulder shove shrimp shrug shuffle shy sibling sick side siege sight sign silent silk silly silver similar simple since sing siren sister situate six size skate sketch ski skill skin skirt skull slab slam sleep slender slice slide slight slim slogan slot slow slush small smart smile smoke smooth snack snake snap sniff snow soap soccer social sock soda soft solar soldier solid solution solve someone song soon sorry sort soul sound soup source south space spare spatial spawn speak special speed spell spend sphere spice spider spike spin spirit split spoil sponsor spoon sport spot spray spread spring spy square squeeze squirrel stable stadium staff stage stairs stamp stand start state stay steak steel stem step stereo stick still sting stock stomach stone stool story stove strategy street strike strong struggle student stuff stumble style subject submit subway success such sudden suffer sugar suggest suit summer sun sunny sunset super supply supreme sure surface surge surprise surround survey suspect sustain swallow swamp swap swarm swear sweet swift swim swing switch sword symbol symptom syrup system table tackle tag tail talent talk tank tape target task taste tattoo taxi teach team tell ten tenant tennis tent term test text thank that theme then theory there they thing this thought three thrive throw thumb thunder ticket tide tiger tilt timber time tiny tip tired tissue title toast tobacco today toddler toe together toilet token tomato tomorrow tone tongue tonight tool tooth top topic topple torch tornado tortoise toss total tourist toward tower town toy track trade traffic tragic train transfer trap trash travel tray treat tree trend trial tribe trick trigger trim trip trophy trouble truck true truly trumpet trust truth try tube tuition tumble tuna tunnel turkey turn turtle twelve twenty twice twin twist two type typical ugly umbrella unable unaware uncle uncover under undo unfair unfold unhappy uniform unique unit universe unknown unlock until unusual unveil update upgrade uphold upon upper upset urban urge usage use used useful useless usual utility vacant vacuum vague valid valley valve van vanish vapor various vast vault vehicle velvet vendor venture venue verb verify version very vessel veteran viable vibrant vicious victory video view village vintage violin virtual virus visa visit visual vital vivid vocal voice void volcano volume vote voyage wage wagon wait walk wall walnut want warfare warm warrior wash wasp waste water wave way wealth weapon wear weasel weather web wedding weekend weird welcome west wet whale what wheat wheel when where whip whisper wide width wife wild will win window wine wing wink winner winter wire wisdom wise wish witness wolf woman wonder wood wool word work world worry worth wrap wreck wrestle wrist write wrong yard year yellow you young youth zebra zero zone zoo".normalize("NFKD").split(" "),n.DashPhrase=s})(globalThis.window||{},t),r.exports=t}(Zs,Zs.exports)),Zs.exports}var eC=JA();const tC=bs(eC);class rC{apiUrl;constructor(e){this.apiUrl=e}async generatePhrase(){const e=await tC.generate(16);return[Math.floor(Math.random()*100)+1,...e.split(" ")].join("-")}async registerPhrase(e,t){try{const n=await this.makeApiRequest("/phrase","POST",{Maddr:t.toString(),Phrase:e});if(!n.ok)throw new Error(`Failed to register phrase. Status: ${n.status}`);return await n.json()}catch(n){throw this.handleApiError(n),n}}async lookupPhrase(e){try{const t=await this.makeApiRequest(`/phrase/${encodeURIComponent(e)}`,"GET");if(!t.ok)throw new Error(`Failed to lookup phrase. Status: ${t.status}`);return await t.json()}catch(t){throw this.handleApiError(t),t}}async makeApiRequest(e,t,n=null){const s=`${this.apiUrl}${e}`,i={method:t,headers:{"Content-type":"application/json; charset=UTF-8"}};return n&&(i.body=JSON.stringify(n)),await fetch(s,i)}handleApiError(e){console.error("API Error:",e)}validatePhrase(e){return e!=null&&e.trim().length>0}sanitizePhrase(e){return e.trim().toLowerCase()}}class nC{appState;elements;theme="light";onFileSelected=()=>{};onPhraseEntered=()=>{};onReceiveModeRequested=()=>{};constructor(e){this.appState=e,this.elements=this.getUIElements(),this.initTheme(),this.clearPhrase()}showSenderMode(){this.hideElement("initialDropUI"),this.showElement("fileInfoArea")}showSendingInProgress(){this.hideElement("fileInfoArea"),this.showElement("sendInProgress")}showReceiverMode(){this.hideElement("initialReceiveUI"),this.showElement("receiveInProgress")}showHome(){window.location.reload()}showSendWindow(){this.showElement("goBackButton","flex"),this.hideElement("goSendButton"),this.hideElement("goReceiveButton"),this.showElement("sendWindow"),this.hideElement("receiveWindow")}showReceiveWindow(){this.showElement("goBackButton","flex"),this.hideElement("goSendButton"),this.hideElement("goReceiveButton"),this.showElement("receiveWindow"),this.hideElement("sendWindow")}resetUI(){this.showHome(),this.clearFileDisplay(),this.hideErrorPopup()}initTheme(){this.theme=localStorage.theme||this.getSystemTheme(),document.documentElement.classList.add(this.theme)}toggleTheme(){this.theme==="light"?(this.theme="dark",localStorage.theme="dark",document.documentElement.classList.remove("light"),document.documentElement.classList.add("dark")):(this.theme="light",localStorage.theme="light",document.documentElement.classList.remove("dark"),document.documentElement.classList.add("light"))}getSystemTheme(){return window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?(localStorage.theme="dark","dark"):(localStorage.theme="light","light")}displaySelectedFile(e){this.updateElement("fileNameDisplay",e.name),this.updateElement("fileSizeDisplay",`${(e.size/1024/1024).toFixed(2)} MB`)}showFileProgress(e,t){const{percentage:n,current:s,total:i,rate:o}=e,a=t==="send"?"sendProgressBar":"receiveProgressBar",c=t==="send"?"sendProgressText":"receiveProgressText",l=t==="send"?"sendRate":"receiveRate";this.updateProgressBar(a,n),this.updateElement(c,`${s} MB / ${i} MB`),this.updateElement(l,`${o} Mbps`)}showReceivedFileDetails(e,t){this.updateElement("receivedFileName",e),this.updateElement("receivedFileSize",`${(t/1024/1024).toFixed(2)} MB`)}showTransferComplete(e){const t=e==="send"?"sendInProgress":"receiveInProgress",n=e==="send"?"sendComplete":"receiveComplete";this.hideElement(t),this.showElement(n)}updateProgressBar(e,t){const n=document.getElementById(e);n&&(n.style.width=`${t}%`)}clearFileDisplay(){this.updateElement("fileNameDisplay",""),this.updateElement("fileSizeDisplay","")}showReconnecting(){this.appState.getMode()==="sender"?(this.hideElement("sendInProgress"),this.showElement("reconnectingSend")):this.appState.getMode()==="receiver"&&(this.hideElement("receiveInProgress"),this.showElement("reconnectingReceive"))}hideReconnecting(){this.appState.getMode()==="sender"?(this.hideElement("reconnectingSend"),this.showElement("sendInProgress")):this.appState.getMode()==="receiver"&&(this.hideElement("reconnectingReceive"),this.showElement("receiveInProgress"))}showErrorPopup(e){this.updateElement("errorMessageText",e),this.elements.errorWindow?.classList.remove("hidden")}hideErrorPopup(){this.elements.errorWindow?.classList.add("hidden")}setupEventListeners(){this.setupFileHandlers(),this.setupButtonHandlers(),this.setupErrorHandlers()}setupFileHandlers(){const e=this.elements.dropZone,t=this.elements.fileInput;e?.addEventListener("dragover",this.handleDragOver.bind(this)),e?.addEventListener("drop",this.handleFileDrop.bind(this)),t?.addEventListener("change",this.handleFileSelect.bind(this))}setupButtonHandlers(){this.elements.sun?.addEventListener("click",()=>this.toggleTheme()),this.elements.moon?.addEventListener("click",()=>this.toggleTheme()),this.elements.selectFileButton?.addEventListener("click",()=>this.elements.fileInput?.click()),this.elements.goSendButton?.addEventListener("click",this.showSendWindow.bind(this)),this.elements.goReceiveButton?.addEventListener("click",this.showReceiveWindow.bind(this)),this.elements.goBackButton?.addEventListener("click",this.showHome.bind(this)),this.elements.copyPhraseButton?.addEventListener("click",this.copyPhrase.bind(this)),this.elements.receiveModeButton?.addEventListener("click",()=>{const t=document.getElementById("phraseInput").value.trim();if(!t){this.showErrorPopup("Please enter a valid phrase.");return}this.showReceiverMode(),this.onPhraseEntered(t)})}setupErrorHandlers(){const e=this.elements.errorWindow,t=this.elements.closeErrorButton;e?.addEventListener("click",n=>{n.target===e&&(this.hideErrorPopup(),this.resetUI())}),t?.addEventListener("click",()=>{this.hideErrorPopup(),this.resetUI()})}handleDragOver(e){e.preventDefault()}handleFileDrop(e){e.preventDefault();let t=null;if(e.dataTransfer?.items){const n=[...e.dataTransfer.items].find(s=>s.kind==="file");n&&(t=n.getAsFile())}else e.dataTransfer?.files&&e.dataTransfer.files.length>0&&(t=e.dataTransfer.files[0]);t&&(this.appState.setSelectedFile(t),this.displaySelectedFile(t),this.onFileSelected(t))}handleFileSelect(e){const t=e.target;if(t.files&&t.files[0]){const n=t.files[0];this.appState.setSelectedFile(n),this.displaySelectedFile(n),this.onFileSelected(n)}}showPhrase(e){this.updateElement("generatedPhraseDisplay",e)}copyPhrase(){this.elements.generatedPhraseDisplay?.innerText&&navigator.clipboard.writeText(this.elements.generatedPhraseDisplay.innerText)}clearPhrase(){const e=document.getElementById("phraseInput");e&&(e.value="")}updateElement(e,t){const n=document.getElementById(e);n&&(n.textContent=t)}showElement(e,t="block"){const n=document.getElementById(e);n&&(n.style.display=t)}hideElement(e){const t=document.getElementById(e);t&&(t.style.display="none")}getUIElements(){return{dropZone:document.getElementById("drop_zone"),fileInput:document.getElementById("fileInput"),copyPhraseButton:document.getElementById("copyPhraseButton"),receiveModeButton:document.getElementById("receiveModeButton"),goSendButton:document.getElementById("goSendButton"),goReceiveButton:document.getElementById("goReceiveButton"),goBackButton:document.getElementById("goBackButton"),selectFileButton:document.getElementById("selectFileButton"),errorWindow:document.getElementById("errorWindow"),closeErrorButton:document.getElementById("closeErrorButton"),generatedPhraseDisplay:document.getElementById("generatedPhraseDisplay"),sun:document.getElementById("sun"),moon:document.getElementById("moon")}}}class sC{uiManager;lastUpdateTime;lastBytes;updateInterval;constructor(e){this.uiManager=e,this.lastUpdateTime=0,this.lastBytes=0,this.updateInterval=250}updateProgress(e,t,n,s=!1){const i=Date.now(),o=i-this.lastUpdateTime;if(!s&&o<this.updateInterval)return;const a=o/1e3,c=e-this.lastBytes;let l=0;a>0&&c>0&&(l=c/a*8/(1024*1024));const u=t>0?e/t*100:0,d=(e/(1024*1024)).toFixed(2),h=(t/(1024*1024)).toFixed(2);if(console.log("Receive progress: "+u.toFixed(2)+"% ("+d+" MB / "+h+" MB)"),this.uiManager.showSendingInProgress(),u>=100)this.uiManager.showTransferComplete(n);else{const p={percentage:u,current:d,total:h,rate:l.toFixed(2)};this.uiManager.showFileProgress(p,n)}this.lastUpdateTime=i,this.lastBytes=e}}class iC{uiManager;constructor(e){this.uiManager=e}handleConnectionError(e,t){const n=`Connection error: ${e.message}`;this.logError(e,t),this.uiManager.showErrorPopup(n)}tryAgainError(){this.uiManager.showErrorPopup("The FileFerry got lost at sea, make sure your maps are in order and try again.")}handleTransferError(e,t){const n=`Transfer error: ${e.message}`;this.logError(e,t),this.uiManager.showErrorPopup(n)}handleApiError(e,t){const n=`API error: ${e.message}`;this.logError(e,t),this.uiManager.showErrorPopup(n)}reconnecting(){this.uiManager.showReconnecting()}reconnected(){this.uiManager.hideReconnecting()}logError(e,t){console.error("Error:",e.message,"Context:",t)}isNetworkError(e){return e.message.includes("network")||e.message.includes("connection")||e.code==="NETWORK_ERROR"}isTimeoutError(e){return e.message.includes("timeout")||e.message.includes("timed out")||e.code==="TIMEOUT"}isRecoverableError(e){return this.isNetworkError(e)||this.isTimeoutError(e)}}class oC{config;constructor(){this.config={relay:{address:"/dns4/relay.fileferry.xyz/tcp/443/tls/ws/p2p/12D3KooWPUXghsjtba2yaKbxJAPUpCgZ1UzciEdCPzohBQi7wiPg",timeout:3e4},api:{url:"https://exchange.fileferry.xyz",timeout:1e4},transfer:{chunkSize:256*256,protocol:"/fileferry/filetransfer/1.0.0"},stun:{fallback:"stun:l.google.com:19302",timeout:5e3},debug:!0}}getRelayAddress(){return this.config.relay.address}getApiUrl(){return this.config.api.url}getStunServers(){return[this.config.stun.fallback,"turn:relay.fileferry.xyz:3478?transport=udp","turn:relay.fileferry.xyz:3478?transport=tcp"]}getTransferSettings(){return this.config.transfer}getFileTransferProtocol(){return this.config.transfer.protocol}validateConfig(){const e=["relay.address","api.url","transfer.protocol"];for(const t of e)if(!this.getConfigValue(t))throw new Error(`Missing required configuration: ${t}`);return!0}getConfigValue(e,t=null){const n=e.split(".");let s=this.config;for(const i of n){if(s[i]===void 0)return t;s=s[i]}return s}}class aC{config;appState;node;services;managers;constructor(){this.config=new oC,this.appState=new wA,this.node=null,this.services={},this.managers={}}async initialize(){try{this.config.validateConfig(),await this.setupServices(),await this.setupLibp2pNode(),await this.setupManagers(),await this.setupUI(),console.log("FileFerry app initialized successfully")}catch(e){throw console.error("Failed to initialize app:",e),e}}async setupServices(){this.services.stun=new ZA,this.services.phrase=new rC(this.config.getApiUrl())}async setupLibp2pNode(){const e=await this.getStunConfiguration(),t={addresses:{listen:["/p2p-circuit","/webrtc"]},transports:[N_({filter:vp}),G_(),b_({rtcConfiguration:{iceServers:[{urls:e},{urls:"turn:relay.fileferry.xyz:3478?transport=udp",username:"ferryCaptain",credential:"i^YV13eTPOHdVzWm#2t5"},{urls:"turn:relay.fileferry.xyz:3478?transport=tcp",username:"ferryCaptain",credential:"i^YV13eTPOHdVzWm#2t5"}],bundlePolicy:"max-bundle",rtcpMuxPolicy:"require"}}),eE()],connectionEncrypters:[Sf()],streamMuxers:[Av({maxStreamWindowSize:1024*1024*4})],connectionGater:{denyDialMultiaddr:()=>!1},services:{identify:IE(),identifyPush:TE(),ping:FE()}};this.node=await yA(t),await this.node.start(),console.log(`Node started with Peer ID: ${this.node.peerId.toString()}`),console.log("This is the node",this.node)}async setupManagers(){if(!this.node)throw new Error("Libp2p node is not initialized.");this.managers.ui=new nC(this.appState),this.managers.error=new iC(this.managers.ui),this.managers.progress=new sC(this.managers.ui),this.managers.fileTransfer=new XA(this.node,this.appState,this.managers.progress,this.managers.ui,this.managers.error),this.managers.relay=new QA(this.node,this.appState,this.managers.error),this.managers.connection=new bA(this.node,this.appState,this.managers.error,this.config,this.managers.fileTransfer),this.setupEventListeners(),this.managers.fileTransfer.setupFileTransferProtocol()}async setupUI(){if(!this.managers.ui)throw new Error("UIManager not initialized");this.managers.ui.setupEventListeners(),this.managers.ui.onFileSelected=this.handleFileSelected.bind(this),this.managers.ui.onPhraseEntered=this.handlePhraseEntered.bind(this),this.managers.ui.onReceiveModeRequested=this.handleReceiveModeRequested.bind(this)}setupEventListeners(){!this.node||!this.managers.connection||(this.node.addEventListener("connection:open",this.managers.connection.onConnectionEstablished.bind(this.managers.connection)),this.node.addEventListener("connection:close",this.managers.connection.onConnectionClosed.bind(this.managers.connection)))}async getStunConfiguration(){if(!this.services.stun)return this.config.getStunServers()[0];try{const e=await this.services.stun.getClosestStunServer();return e?`stun:${e}`:this.config.getStunServers()[0]}catch(e){return console.warn("Could not fetch closest STUN server:",e),this.config.getStunServers()[0]}}async handleFileSelected(e){if(!(!this.managers.ui||!this.managers.error))try{this.managers.ui.showSenderMode(),await this.startSenderMode(e)}catch(t){this.managers.error.handleTransferError(t,{operation:"fileSelected",direction:"send"})}}async handlePhraseEntered(e){if(this.managers.error)try{await this.startReceiverMode(e)}catch(t){this.managers.error.handleApiError(t,{operation:"phraseEntered"})}}async handleReceiveModeRequested(){this.managers.ui&&this.managers.ui.showReceiverMode()}async startSenderMode(e){if(!(!this.services.phrase||!this.managers.relay||!this.managers.error))try{this.appState.setSelectedFile(e),this.appState.setMode("sender"),console.log("Starting sender mode...");const t=await this.services.phrase.generatePhrase();console.log(`Generated phrase: ${t}`);const n=document.getElementById("generatedPhraseDisplay");if(n&&(n.textContent=t),await this.managers.relay.connectToRelay(this.config.getRelayAddress()),console.log("Waiting for relay to be ready..."),!await this.managers.relay.canUseRelay())throw new Error("Relay is not ready for use");const i=await this.managers.relay.waitForRelayAddress();console.log("Registering phrase..."),await this.services.phrase.registerPhrase(t,i),console.log("Sender mode setup complete. Waiting for receiver...")}catch(t){throw console.error("Failed to start sender mode:",t),this.managers.error.handleTransferError(t,{operation:"startSenderMode",direction:"send"}),this.appState.setMode("idle"),t}}async startReceiverMode(e){if(!this.appState||!this.services.phrase||!this.managers.relay||!this.managers.connection||!this.node)return;this.appState.setMode("receiver");const t=await this.services.phrase.lookupPhrase(e);if(!t.maddr)throw new Error("No address found for phrase");if(await this.managers.relay.connectToRelay(this.config.getRelayAddress()),console.log("Waiting for relay to be ready..."),!await this.managers.relay.canUseRelay())throw new Error("Relay is not ready for use");await this.managers.relay.waitForRelayAddress();const s=Y(t.maddr),i=await this.managers.connection.dialPeer(s,{signal:AbortSignal.timeout(6e4)});console.log(`Connected to sender via phrase: ${e}`),this.appState.setActivePeer(i.remotePeer.toString());const o=setInterval(()=>{if(!this.node){clearInterval(o);return}const c=this.node.getConnections(i.remotePeer).find(l=>l.remoteAddr.toString().includes("/webrtc"));c&&c.status==="open"&&(clearInterval(o),console.log("WebRTC connection established, circuit can now be closed safely"))},1e3)}async start(){await this.initialize(),console.log("FileFerry app started")}async stop(){this.node&&await this.node.stop(),this.appState.reset(),console.log("FileFerry app stopped")}async cleanup(){await this.stop()}}const jg=new aC;document.addEventListener("DOMContentLoaded",async()=>{try{await jg.start()}catch(r){console.error("Failed to start FileFerry app:",r)}});window.addEventListener("unhandledrejection",r=>{console.error("Unhandled promise rejection:",r.reason)});window.addEventListener("error",r=>{console.error("Global error:",r.error)});window.fileFerryApp=jg;
