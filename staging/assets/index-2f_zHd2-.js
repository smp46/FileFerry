(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function t(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(s){if(s.ep)return;s.ep=!0;const i=t(s);fetch(s.href,i)}})();const Rh=Symbol.for("@libp2p/connection"),ga=Symbol.for("@libp2p/content-routing"),ma=Symbol.for("@libp2p/peer-discovery"),Co=Symbol.for("@libp2p/peer-id");function Ol(r){return!!r?.[Co]}const ya=Symbol.for("@libp2p/peer-routing"),Io="keep-alive",To=Symbol.for("@libp2p/transport");var jr;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(jr||(jr={}));let jt=class extends Error{static name="AbortError";constructor(e="The operation was aborted"){super(e),this.name="AbortError"}};class Oh extends Error{static name="UnexpectedPeerError";constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}}let Nh=class extends Error{static name="InvalidCryptoExchangeError";constructor(e="Invalid crypto exchange"){super(e),this.name="InvalidCryptoExchangeError"}};class V extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}}class Nl extends Error{static name="InvalidPublicKeyError";constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}}class Fh extends Error{static name="ConnectionClosingError";constructor(e="The connection is closing"){super(e),this.name="ConnectionClosingError"}}class Fl extends Error{static name="ConnectionClosedError";constructor(e="The connection is closed"){super(e),this.name="ConnectionClosedError"}}class Ul extends Error{static name="ConnectionFailedError";constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}}class Nr extends Error{static name="MuxerClosedError";constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}}class Uh extends Error{static name="StreamResetError";constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}}class Ki extends Error{static name="StreamStateError";constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}}let qi=class extends Error{static name="NotFoundError";constructor(e="Not found"){super(e),this.name="NotFoundError"}};class Bl extends Error{static name="InvalidPeerIdError";constructor(e="Invalid PeerID"){super(e),this.name="InvalidPeerIdError"}}class ko extends Error{static name="InvalidMultiaddrError";constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}}class Bh extends Error{static name="InvalidCIDError";constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}}class $h extends Error{static name="InvalidMultihashError";constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}}class _o extends Error{static name="UnsupportedProtocolError";constructor(e="Unsupported protocol error"){super(e),this.name="UnsupportedProtocolError"}}class ut extends Error{static name="InvalidMessageError";constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}}class zh extends Error{static name="ProtocolError";constructor(e="Protocol error"){super(e),this.name="ProtocolError"}}let Po=class extends Error{static name="TimeoutError";constructor(e="Timed out"){super(e),this.name="TimeoutError"}};class jn extends Error{static name="NotStartedError";constructor(e="Not started"){super(e),this.name="NotStartedError"}}class Vr extends Error{static name="DialError";constructor(e="Dial error"){super(e),this.name="DialError"}}class Wi extends Error{static name="ListenError";constructor(e="Listen error"){super(e),this.name="ListenError"}}class $l extends Error{static name="LimitedConnectionError";constructor(e="Limited connection"){super(e),this.name="LimitedConnectionError"}}class Kh extends Error{static name="TooManyInboundProtocolStreamsError";constructor(e="Too many inbound protocol streams"){super(e),this.name="TooManyInboundProtocolStreamsError"}}class zl extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}}class Lo extends Error{static name="UnsupportedKeyTypeError";constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}}class Ut extends EventTarget{#e=new Map;constructor(){super()}listenerCount(e){const t=this.#e.get(e);return t==null?0:t.length}addEventListener(e,t,n){super.addEventListener(e,t,n);let s=this.#e.get(e);s==null&&(s=[],this.#e.set(e,s)),s.push({callback:t,once:(n!==!0&&n!==!1&&n?.once)??!1})}removeEventListener(e,t,n){super.removeEventListener(e.toString(),t??null,n);let s=this.#e.get(e);s!=null&&(s=s.filter(({callback:i})=>i!==t),this.#e.set(e,s))}dispatchEvent(e){const t=super.dispatchEvent(e);let n=this.#e.get(e.type);return n==null||(n=n.filter(({once:s})=>!s),this.#e.set(e.type,n)),t}safeDispatchEvent(e,t={}){return this.dispatchEvent(new CustomEvent(e,t))}}function Do(r){return r!=null&&typeof r.start=="function"&&typeof r.stop=="function"}async function Kl(...r){const e=[];for(const t of r)Do(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStart!=null&&await t.beforeStart()})),await Promise.all(e.map(async t=>{await t.start()})),await Promise.all(e.map(async t=>{t.afterStart!=null&&await t.afterStart()}))}async function ql(...r){const e=[];for(const t of r)Do(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStop!=null&&await t.beforeStop()})),await Promise.all(e.map(async t=>{await t.stop()})),await Promise.all(e.map(async t=>{t.afterStop!=null&&await t.afterStop()}))}const it=Symbol.for("@libp2p/service-capabilities"),Zn=Symbol.for("@libp2p/service-dependencies");function qh(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function Rs(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function Wh(r){return new TextEncoder().encode(r)}function Vh(r){return new TextDecoder().decode(r)}function Hh(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var s=0;s<r.length;s++){var i=r.charAt(s),o=i.charCodeAt(0);if(t[o]!==255)throw new TypeError(i+" is ambiguous");t[o]=s}var a=r.length,c=r.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function d(f){if(f instanceof Uint8Array||(ArrayBuffer.isView(f)?f=new Uint8Array(f.buffer,f.byteOffset,f.byteLength):Array.isArray(f)&&(f=Uint8Array.from(f))),!(f instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(f.length===0)return"";for(var g=0,m=0,v=0,k=f.length;v!==k&&f[v]===0;)v++,g++;for(var b=(k-v)*u+1>>>0,w=new Uint8Array(b);v!==k;){for(var E=f[v],P=0,x=b-1;(E!==0||P<m)&&x!==-1;x--,P++)E+=256*w[x]>>>0,w[x]=E%a>>>0,E=E/a>>>0;if(E!==0)throw new Error("Non-zero carry");m=P,v++}for(var _=b-m;_!==b&&w[_]===0;)_++;for(var D=c.repeat(g);_<b;++_)D+=r.charAt(w[_]);return D}function h(f){if(typeof f!="string")throw new TypeError("Expected String");if(f.length===0)return new Uint8Array;var g=0;if(f[g]!==" "){for(var m=0,v=0;f[g]===c;)m++,g++;for(var k=(f.length-g)*l+1>>>0,b=new Uint8Array(k);f[g];){var w=t[f.charCodeAt(g)];if(w===255)return;for(var E=0,P=k-1;(w!==0||E<v)&&P!==-1;P--,E++)w+=a*b[P]>>>0,b[P]=w%256>>>0,w=w/256>>>0;if(w!==0)throw new Error("Non-zero carry");v=E,g++}if(f[g]!==" "){for(var x=k-v;x!==k&&b[x]===0;)x++;for(var _=new Uint8Array(m+(k-x)),D=m;x!==k;)_[D++]=b[x++];return _}}}function p(f){var g=h(f);if(g)return g;throw new Error(`Non-${e} character`)}return{encode:d,decodeUnsafe:h,decode:p}}var Gh=Hh,Yh=Gh;class Xh{name;prefix;baseEncode;constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}let Qh=class{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,n){this.name=e,this.prefix=t;const s=t.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return Wl(this,e)}};class jh{decoders;constructor(e){this.decoders=e}or(e){return Wl(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n!=null)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function Wl(r,e){return new jh({...r.decoders??{[r.prefix]:r},...e.decoders??{[e.prefix]:e}})}class Zh{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,n,s){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=s,this.encoder=new Xh(e,t,n),this.decoder=new Qh(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function Os({name:r,prefix:e,encode:t,decode:n}){return new Zh(r,e,t,n)}function fn({name:r,prefix:e,alphabet:t}){const{encode:n,decode:s}=Yh(t,r);return Os({prefix:e,name:r,encode:n,decode:i=>Rs(s(i))})}function Jh(r,e,t,n){let s=r.length;for(;r[s-1]==="=";)--s;const i=new Uint8Array(s*t/8|0);let o=0,a=0,c=0;for(let l=0;l<s;++l){const u=e[r[l]];if(u===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<t|u,o+=t,o>=8&&(o-=8,i[c++]=255&a>>o)}if(o>=t||(255&a<<8-o)!==0)throw new SyntaxError("Unexpected end of data");return i}function ef(r,e,t){const n=e[e.length-1]==="=",s=(1<<t)-1;let i="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>t;)o-=t,i+=e[s&a>>o];if(o!==0&&(i+=e[s&a<<t-o]),n)for(;(i.length*t&7)!==0;)i+="=";return i}function tf(r){const e={};for(let t=0;t<r.length;++t)e[r[t]]=t;return e}function Te({name:r,prefix:e,bitsPerChar:t,alphabet:n}){const s=tf(n);return Os({prefix:e,name:r,encode(i){return ef(i,n,t)},decode(i){return Jh(i,s,t,r)}})}const ye=fn({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),rf=fn({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),nf=Object.freeze(Object.defineProperty({__proto__:null,base58btc:ye,base58flickr:rf},Symbol.toStringTag,{value:"Module"})),xt=Te({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),sf=Te({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),of=Te({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),af=Te({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),cf=Te({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),lf=Te({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),uf=Te({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),df=Te({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),hf=Te({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),ff=Object.freeze(Object.defineProperty({__proto__:null,base32:xt,base32hex:cf,base32hexpad:uf,base32hexpadupper:df,base32hexupper:lf,base32pad:of,base32padupper:af,base32upper:sf,base32z:hf},Symbol.toStringTag,{value:"Module"})),Yn=fn({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),pf=fn({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),gf=Object.freeze(Object.defineProperty({__proto__:null,base36:Yn,base36upper:pf},Symbol.toStringTag,{value:"Module"}));var mf=Vl,wa=128,yf=-128,wf=Math.pow(2,31);function Vl(r,e,t){e=e||[],t=t||0;for(var n=t;r>=wf;)e[t++]=r&255|wa,r/=128;for(;r&yf;)e[t++]=r&255|wa,r>>>=7;return e[t]=r|0,Vl.bytes=t-n+1,e}var bf=Vi,vf=128,ba=127;function Vi(r,n){var t=0,n=n||0,s=0,i=n,o,a=r.length;do{if(i>=a)throw Vi.bytes=0,new RangeError("Could not decode varint");o=r[i++],t+=s<28?(o&ba)<<s:(o&ba)*Math.pow(2,s),s+=7}while(o>=vf);return Vi.bytes=i-n,t}var Ef=Math.pow(2,7),Sf=Math.pow(2,14),xf=Math.pow(2,21),Af=Math.pow(2,28),Cf=Math.pow(2,35),If=Math.pow(2,42),Tf=Math.pow(2,49),kf=Math.pow(2,56),_f=Math.pow(2,63),Pf=function(r){return r<Ef?1:r<Sf?2:r<xf?3:r<Af?4:r<Cf?5:r<If?6:r<Tf?7:r<kf?8:r<_f?9:10},Lf={encode:mf,decode:bf,encodingLength:Pf},Jn=Lf;function Hi(r,e=0){return[Jn.decode(r,e),Jn.decode.bytes]}function es(r,e,t=0){return Jn.encode(r,e,t),e}function ts(r){return Jn.encodingLength(r)}function Zr(r,e){const t=e.byteLength,n=ts(r),s=n+ts(t),i=new Uint8Array(s+t);return es(r,i,0),es(t,i,n),i.set(e,s),new Mo(r,t,e,i)}function tr(r){const e=Rs(r),[t,n]=Hi(e),[s,i]=Hi(e.subarray(n)),o=e.subarray(n+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new Mo(t,s,o,e)}function Df(r,e){if(r===e)return!0;{const t=e;return r.code===t.code&&r.size===t.size&&t.bytes instanceof Uint8Array&&qh(r.bytes,t.bytes)}}class Mo{code;size;digest;bytes;constructor(e,t,n,s){this.code=e,this.size=t,this.digest=n,this.bytes=s}}function va(r,e){const{bytes:t,version:n}=r;switch(n){case 0:return Rf(t,Gi(r),e??ye.encoder);default:return Of(t,Gi(r),e??xt.encoder)}}const Ea=new WeakMap;function Gi(r){const e=Ea.get(r);if(e==null){const t=new Map;return Ea.set(r,t),t}return e}class ae{code;version;multihash;bytes;"/";constructor(e,t,n,s){this.code=t,this.version=e,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==Fr)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Nf)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return ae.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=Zr(e,t);return ae.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return ae.equals(this,e)}static equals(e,t){const n=t;return n!=null&&e.code===n.code&&e.version===n.version&&Df(e.multihash,n.multihash)}toString(e){return va(this,e)}toJSON(){return{"/":va(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof ae)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:n,code:s,multihash:i,bytes:o}=t;return new ae(n,s,i,o??Sa(n,s,i.bytes))}else if(t[Ff]===!0){const{version:n,multihash:s,code:i}=t,o=tr(s);return ae.create(n,i,o)}else return null}static create(e,t,n){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==Fr)throw new Error(`Version 0 CID must use dag-pb (code: ${Fr}) block encoding`);return new ae(e,t,n,n.bytes)}case 1:{const s=Sa(e,t,n.bytes);return new ae(e,t,n,s)}default:throw new Error("Invalid version")}}static createV0(e){return ae.create(0,Fr,e)}static createV1(e,t){return ae.create(1,e,t)}static decode(e){const[t,n]=ae.decodeFirst(e);if(n.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=ae.inspectBytes(e),n=t.size-t.multihashSize,s=Rs(e.subarray(n,n+t.multihashSize));if(s.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=s.subarray(t.multihashSize-t.digestSize),o=new Mo(t.multihashCode,t.digestSize,i,s);return[t.version===0?ae.createV0(o):ae.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[d,h]=Hi(e.subarray(t));return t+=h,d};let s=n(),i=Fr;if(s===18?(s=0,t=0):i=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=t,a=n(),c=n(),l=t+c,u=l-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:u,size:l}}static parse(e,t){const[n,s]=Mf(e,t),i=ae.decode(s);if(i.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Gi(i).set(n,e),i}}function Mf(r,e){switch(r[0]){case"Q":{const t=e??ye;return[ye.prefix,t.decode(`${ye.prefix}${r}`)]}case ye.prefix:{const t=e??ye;return[ye.prefix,t.decode(r)]}case xt.prefix:{const t=e??xt;return[xt.prefix,t.decode(r)]}case Yn.prefix:{const t=e??Yn;return[Yn.prefix,t.decode(r)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],e.decode(r)]}}}function Rf(r,e,t){const{prefix:n}=t;if(n!==ye.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const s=e.get(n);if(s==null){const i=t.encode(r).slice(1);return e.set(n,i),i}else return s}function Of(r,e,t){const{prefix:n}=t,s=e.get(n);if(s==null){const i=t.encode(r);return e.set(n,i),i}else return s}const Fr=112,Nf=18;function Sa(r,e,t){const n=ts(r),s=n+ts(e),i=new Uint8Array(s+t.byteLength);return es(r,i,0),es(e,i,n),i.set(t,s),i}const Ff=Symbol.for("@ipld/js-cid/CID"),Hl=0,Uf="identity",Gl=Rs;function Bf(r){return Zr(Hl,Gl(r))}const pn={code:Hl,name:Uf,encode:Gl,digest:Bf};function Oe(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function se(r=0){return new Uint8Array(r)}function ft(r=0){return new Uint8Array(r)}function ot(r,e){e==null&&(e=r.reduce((s,i)=>s+i.length,0));const t=ft(e);let n=0;for(const s of r)t.set(s,n),n+=s.length;return t}const Yl=Symbol.for("@achingbrain/uint8arraylist");function xa(r,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(const n of r){const s=t+n.byteLength;if(e<s)return{buf:n,index:e-t};t=s}throw new RangeError("index is out of bounds")}function In(r){return!!r?.[Yl]}class Z{bufs;length;[Yl]=!0;constructor(...e){this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const n of e)if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.push(n);else if(In(n))t+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const n of e.reverse())if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.unshift(n);else if(In(n))t+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){const t=xa(this.bufs,e);return t.buf[t.index]}set(e,t){const n=xa(this.bufs,e);n.buf[n.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let n=0;n<e.length;n++)this.set(t+n,e[n]);else if(In(e))for(let n=0;n<e.length;n++)this.set(t+n,e.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){const{bufs:n,length:s}=this._subList(e,t);return ot(n,s)}subarray(e,t){const{bufs:n,length:s}=this._subList(e,t);return n.length===1?n[0]:ot(n,s)}sublist(e,t){const{bufs:n,length:s}=this._subList(e,t),i=new Z;return i.length=s,i.bufs=[...n],i}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};const n=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],a=s,c=a+o.byteLength;if(s=c,e>=c)continue;const l=e>=a&&e<c,u=t>a&&t<=c;if(l&&u){if(e===a&&t===c){n.push(o);break}const d=e-a;n.push(o.subarray(d,d+(t-e)));break}if(l){if(e===0){n.push(o);continue}n.push(o.subarray(e-a));continue}if(u){if(t===c){n.push(o);break}n.push(o.subarray(0,t-a));break}n.push(o)}return{bufs:n,length:t-e}}indexOf(e,t=0){if(!In(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const n=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const s=n.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let d=0;d<i;d++)o[d]=-1;for(let d=0;d<s;d++)o[n[d]]=d;const a=o,c=this.byteLength-n.byteLength,l=n.byteLength-1;let u;for(let d=t;d<=c;d+=u){u=0;for(let h=l;h>=0;h--){const p=this.get(d+h);if(n[h]!==p){u=Math.max(1,h-a[p]);break}}if(u===0)return d}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const n=ft(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,t),this.write(n,e)}getInt16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,t)}setInt16(e,t,n){const s=se(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,t,n),this.write(s,e)}getInt32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,t)}setInt32(e,t,n){const s=se(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,t,n),this.write(s,e)}getBigInt64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,t)}setBigInt64(e,t,n){const s=se(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,t,n),this.write(s,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const n=ft(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,t),this.write(n,e)}getUint16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,t)}setUint16(e,t,n){const s=se(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,t,n),this.write(s,e)}getUint32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,t)}setUint32(e,t,n){const s=se(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,t,n),this.write(s,e)}getBigUint64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,t)}setBigUint64(e,t,n){const s=se(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,t,n),this.write(s,e)}getFloat32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,t)}setFloat32(e,t,n){const s=se(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,t,n),this.write(s,e)}getFloat64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,t)}setFloat64(e,t,n){const s=se(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,t,n),this.write(s,e)}equals(e){if(e==null||!(e instanceof Z)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!Oe(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const n=new Z;return n.bufs=e,t==null&&(t=e.reduce((s,i)=>s+i.byteLength,0)),n.length=t,n}}const $f=fn({prefix:"9",name:"base10",alphabet:"0123456789"}),zf=Object.freeze(Object.defineProperty({__proto__:null,base10:$f},Symbol.toStringTag,{value:"Module"})),Kf=Te({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),qf=Te({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),Wf=Object.freeze(Object.defineProperty({__proto__:null,base16:Kf,base16upper:qf},Symbol.toStringTag,{value:"Module"})),Vf=Te({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),Hf=Object.freeze(Object.defineProperty({__proto__:null,base2:Vf},Symbol.toStringTag,{value:"Module"})),Xl=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),Gf=Xl.reduce((r,e,t)=>(r[t]=e,r),[]),Yf=Xl.reduce((r,e,t)=>{const n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);return r[n]=t,r},[]);function Xf(r){return r.reduce((e,t)=>(e+=Gf[t],e),"")}function Qf(r){const e=[];for(const t of r){const n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);const s=Yf[n];if(s==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(s)}return new Uint8Array(e)}const jf=Os({prefix:"ðŸš€",name:"base256emoji",encode:Xf,decode:Qf}),Zf=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:jf},Symbol.toStringTag,{value:"Module"})),Ql=Te({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Jf=Te({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),jl=Te({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),ep=Te({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),tp=Object.freeze(Object.defineProperty({__proto__:null,base64:Ql,base64pad:Jf,base64url:jl,base64urlpad:ep},Symbol.toStringTag,{value:"Module"})),rp=Te({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),np=Object.freeze(Object.defineProperty({__proto__:null,base8:rp},Symbol.toStringTag,{value:"Module"})),sp=Os({prefix:"\0",name:"identity",encode:r=>Vh(r),decode:r=>Wh(r)}),ip=Object.freeze(Object.defineProperty({__proto__:null,identity:sp},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;function op({name:r,code:e,encode:t}){return new ap(r,e,t)}class ap{name;code;encode;constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?Zr(this.code,t):t.then(n=>Zr(this.code,n))}else throw Error("Unknown type, must be binary type")}}function cp(r){return async e=>new Uint8Array(await crypto.subtle.digest(r,e))}const Zl=op({name:"sha2-256",code:18,encode:cp("SHA-256")}),Yi={...ip,...Hf,...np,...zf,...Wf,...ff,...gf,...nf,...tp,...Zf};function Jl(r,e,t,n){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:n}}}const Aa=Jl("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),Qs=Jl("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);const e=ft(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),eu={utf8:Aa,"utf-8":Aa,hex:Yi.base16,latin1:Qs,ascii:Qs,binary:Qs,...Yi};function q(r,e="utf8"){const t=eu[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${r}`)}function Y(r,e="utf8"){const t=eu[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(r).substring(1)}const lp=parseInt("11111",2),Xi=parseInt("10000000",2),up=parseInt("01111111",2),Ca={0:Ur,1:Ur,2:dp,3:pp,4:gp,5:fp,6:hp,16:Ur,22:Ur,48:Ur};function Ns(r,e={offset:0}){const t=r[e.offset]&lp;if(e.offset++,Ca[t]!=null)return Ca[t](r,e);throw new Error("No decoder for tag "+t)}function gn(r,e){let t=0;if((r[e.offset]&Xi)===Xi){const n=r[e.offset]&up;let s="0x";e.offset++;for(let i=0;i<n;i++,e.offset++)s+=r[e.offset].toString(16).padStart(2,"0");t=parseInt(s,16)}else t=r[e.offset],e.offset++;return t}function Ur(r,e){gn(r,e);const t=[];for(;!(e.offset>=r.byteLength);){const n=Ns(r,e);if(n===null)break;t.push(n)}return t}function dp(r,e){const t=gn(r,e),n=e.offset,s=e.offset+t,i=[];for(let o=n;o<s;o++)o===n&&r[o]===0||i.push(r[o]);return e.offset+=t,Uint8Array.from(i)}function hp(r,e){const t=gn(r,e),n=e.offset+t,s=r[e.offset];e.offset++;let i=0,o=0;s<40?(i=0,o=s):s<80?(i=1,o=s-40):(i=2,o=s-80);let a=`${i}.${o}`,c=[];for(;e.offset<n;){const l=r[e.offset];if(e.offset++,c.push(l&127),l<128){c.reverse();let u=0;for(let d=0;d<c.length;d++)u+=c[d]<<d*7;a+=`.${u}`,c=[]}}return a}function fp(r,e){return e.offset++,null}function pp(r,e){const t=gn(r,e),n=r[e.offset];e.offset++;const s=r.subarray(e.offset,e.offset+t-1);if(e.offset+=t,n!==0)throw new Error("Unused bits in bit string is unimplemented");return s}function gp(r,e){const t=gn(r,e),n=r.subarray(e.offset,e.offset+t);return e.offset+=t,n}function mp(r){let e=r.toString(16);e.length%2===1&&(e="0"+e);const t=new Z;for(let n=0;n<e.length;n+=2)t.append(Uint8Array.from([parseInt(`${e[n]}${e[n+1]}`,16)]));return t}function Ro(r){if(r.byteLength<128)return Uint8Array.from([r.byteLength]);const e=mp(r.byteLength);return new Z(Uint8Array.from([e.byteLength|Xi]),e)}function Qi(r){const e=new Z,t=128;return(r.subarray()[0]&t)===t&&e.append(Uint8Array.from([0])),e.append(r),new Z(Uint8Array.from([2]),Ro(e),e)}function tu(r){const e=Uint8Array.from([0]),t=new Z(e,r);return new Z(Uint8Array.from([3]),Ro(t),t)}function Hr(r,e=48){const t=new Z;for(const n of r)t.append(n);return new Z(Uint8Array.from([e]),Ro(t),t)}async function yp(r,e,t){const n=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv??"P-256"},!1,["verify"]);return crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},n,e,t.subarray())}const wp=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),bp=Uint8Array.from([6,5,43,129,4,0,34]),vp=Uint8Array.from([6,5,43,129,4,0,35]),Ep={ext:!0,kty:"EC",crv:"P-256"},Sp={ext:!0,kty:"EC",crv:"P-384"},xp={ext:!0,kty:"EC",crv:"P-521"},js=32,Zs=48,Js=66;function ru(r){const e=Ns(r);return Ap(e)}function Ap(r){const e=r[1][1][0],t=1;let n,s;if(e.byteLength===js*2+1)return n=Y(e.subarray(t,t+js),"base64url"),s=Y(e.subarray(t+js),"base64url"),new ei({...Ep,key_ops:["verify"],x:n,y:s});if(e.byteLength===Zs*2+1)return n=Y(e.subarray(t,t+Zs),"base64url"),s=Y(e.subarray(t+Zs),"base64url"),new ei({...Sp,key_ops:["verify"],x:n,y:s});if(e.byteLength===Js*2+1)return n=Y(e.subarray(t,t+Js),"base64url"),s=Y(e.subarray(t+Js),"base64url"),new ei({...xp,key_ops:["verify"],x:n,y:s});throw new V(`coordinates were wrong length, got ${e.byteLength}, expected 65, 97 or 133`)}function Cp(r){return Hr([Qi(Uint8Array.from([1])),Hr([Ip(r.crv)],160),Hr([tu(new Z(Uint8Array.from([4]),q(r.x??"","base64url"),q(r.y??"","base64url")))],161)]).subarray()}function Ip(r){if(r==="P-256")return wp;if(r==="P-384")return bp;if(r==="P-521")return vp;throw new V(`Invalid curve ${r}`)}class ei{type="ECDSA";jwk;_raw;constructor(e){this.jwk=e}get raw(){return this._raw==null&&(this._raw=Cp(this.jwk)),this._raw}toMultihash(){return pn.digest(At(this))}toCID(){return ae.createV1(114,this.toMultihash())}toString(){return ye.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Oe(this.raw,e.raw)}async verify(e,t){return yp(this.jwk,t,e)}}const nr=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Tp(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function rs(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function mn(r,...e){if(!Tp(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function Oo(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");rs(r.outputLen),rs(r.blockLen)}function ns(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function kp(r,e){mn(r);const t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function Zt(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function ti(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function at(r,e){return r<<32-e|r>>>e}function _p(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}function Jr(r){return typeof r=="string"&&(r=_p(r)),mn(r),r}function Pp(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];mn(s),e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const i=r[n];t.set(i,s),s+=i.length}return t}class nu{}function su(r){const e=n=>r().update(Jr(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function Fs(r=32){if(nr&&typeof nr.getRandomValues=="function")return nr.getRandomValues(new Uint8Array(r));if(nr&&typeof nr.randomBytes=="function")return Uint8Array.from(nr.randomBytes(r));throw new Error("crypto.getRandomValues must be defined")}function Lp(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const s=BigInt(32),i=BigInt(4294967295),o=Number(t>>s&i),a=Number(t&i),c=n?4:0,l=n?0:4;r.setUint32(e+c,o,n),r.setUint32(e+l,a,n)}function Dp(r,e,t){return r&e^~r&t}function Mp(r,e,t){return r&e^r&t^e&t}class iu extends nu{constructor(e,t,n,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=s,this.buffer=new Uint8Array(e),this.view=ti(this.buffer)}update(e){ns(this),e=Jr(e),mn(e);const{view:t,buffer:n,blockLen:s}=this,i=e.length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a===s){const c=ti(e);for(;s<=i-o;o+=s)this.process(c,o);continue}n.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){ns(this),kp(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:s,isLE:i}=this;let{pos:o}=this;t[o++]=128,Zt(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(n,0),o=0);for(let d=o;d<s;d++)t[d]=0;Lp(n,s-8,BigInt(this.length*8),i),this.process(n,0);const a=ti(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=c/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<l;d++)a.setUint32(4*d,u[d],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:s,finished:i,destroyed:o,pos:a}=this;return e.destroyed=o,e.finished=i,e.length=s,e.pos=a,s%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}}const kt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),_e=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Tn=BigInt(2**32-1),Ia=BigInt(32);function Rp(r,e=!1){return e?{h:Number(r&Tn),l:Number(r>>Ia&Tn)}:{h:Number(r>>Ia&Tn)|0,l:Number(r&Tn)|0}}function Op(r,e=!1){const t=r.length;let n=new Uint32Array(t),s=new Uint32Array(t);for(let i=0;i<t;i++){const{h:o,l:a}=Rp(r[i],e);[n[i],s[i]]=[o,a]}return[n,s]}const Ta=(r,e,t)=>r>>>t,ka=(r,e,t)=>r<<32-t|e>>>t,sr=(r,e,t)=>r>>>t|e<<32-t,ir=(r,e,t)=>r<<32-t|e>>>t,kn=(r,e,t)=>r<<64-t|e>>>t-32,_n=(r,e,t)=>r>>>t-32|e<<64-t;function gt(r,e,t,n){const s=(e>>>0)+(n>>>0);return{h:r+t+(s/2**32|0)|0,l:s|0}}const Np=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),Fp=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,Up=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),Bp=(r,e,t,n,s)=>e+t+n+s+(r/2**32|0)|0,$p=(r,e,t,n,s)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(s>>>0),zp=(r,e,t,n,s,i)=>e+t+n+s+i+(r/2**32|0)|0,Kp=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),_t=new Uint32Array(64);class qp extends iu{constructor(e=32){super(64,e,8,!1),this.A=kt[0]|0,this.B=kt[1]|0,this.C=kt[2]|0,this.D=kt[3]|0,this.E=kt[4]|0,this.F=kt[5]|0,this.G=kt[6]|0,this.H=kt[7]|0}get(){const{A:e,B:t,C:n,D:s,E:i,F:o,G:a,H:c}=this;return[e,t,n,s,i,o,a,c]}set(e,t,n,s,i,o,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let d=0;d<16;d++,t+=4)_t[d]=e.getUint32(t,!1);for(let d=16;d<64;d++){const h=_t[d-15],p=_t[d-2],f=at(h,7)^at(h,18)^h>>>3,g=at(p,17)^at(p,19)^p>>>10;_t[d]=g+_t[d-7]+f+_t[d-16]|0}let{A:n,B:s,C:i,D:o,E:a,F:c,G:l,H:u}=this;for(let d=0;d<64;d++){const h=at(a,6)^at(a,11)^at(a,25),p=u+h+Dp(a,c,l)+Kp[d]+_t[d]|0,g=(at(n,2)^at(n,13)^at(n,22))+Mp(n,s,i)|0;u=l,l=c,c=a,a=o+p|0,o=i,i=s,s=n,n=p+g|0}n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(n,s,i,o,a,c,l,u)}roundClean(){Zt(_t)}destroy(){this.set(0,0,0,0,0,0,0,0),Zt(this.buffer)}}const ou=Op(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Wp=ou[0],Vp=ou[1],Pt=new Uint32Array(80),Lt=new Uint32Array(80);class Hp extends iu{constructor(e=64){super(128,e,16,!1),this.Ah=_e[0]|0,this.Al=_e[1]|0,this.Bh=_e[2]|0,this.Bl=_e[3]|0,this.Ch=_e[4]|0,this.Cl=_e[5]|0,this.Dh=_e[6]|0,this.Dl=_e[7]|0,this.Eh=_e[8]|0,this.El=_e[9]|0,this.Fh=_e[10]|0,this.Fl=_e[11]|0,this.Gh=_e[12]|0,this.Gl=_e[13]|0,this.Hh=_e[14]|0,this.Hl=_e[15]|0}get(){const{Ah:e,Al:t,Bh:n,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:l,El:u,Fh:d,Fl:h,Gh:p,Gl:f,Hh:g,Hl:m}=this;return[e,t,n,s,i,o,a,c,l,u,d,h,p,f,g,m]}set(e,t,n,s,i,o,a,c,l,u,d,h,p,f,g,m){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=d|0,this.Fl=h|0,this.Gh=p|0,this.Gl=f|0,this.Hh=g|0,this.Hl=m|0}process(e,t){for(let b=0;b<16;b++,t+=4)Pt[b]=e.getUint32(t),Lt[b]=e.getUint32(t+=4);for(let b=16;b<80;b++){const w=Pt[b-15]|0,E=Lt[b-15]|0,P=sr(w,E,1)^sr(w,E,8)^Ta(w,E,7),x=ir(w,E,1)^ir(w,E,8)^ka(w,E,7),_=Pt[b-2]|0,D=Lt[b-2]|0,U=sr(_,D,19)^kn(_,D,61)^Ta(_,D,6),L=ir(_,D,19)^_n(_,D,61)^ka(_,D,6),N=Up(x,L,Lt[b-7],Lt[b-16]),M=Bp(N,P,U,Pt[b-7],Pt[b-16]);Pt[b]=M|0,Lt[b]=N|0}let{Ah:n,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:l,Dl:u,Eh:d,El:h,Fh:p,Fl:f,Gh:g,Gl:m,Hh:v,Hl:k}=this;for(let b=0;b<80;b++){const w=sr(d,h,14)^sr(d,h,18)^kn(d,h,41),E=ir(d,h,14)^ir(d,h,18)^_n(d,h,41),P=d&p^~d&g,x=h&f^~h&m,_=$p(k,E,x,Vp[b],Lt[b]),D=zp(_,v,w,P,Wp[b],Pt[b]),U=_|0,L=sr(n,s,28)^kn(n,s,34)^kn(n,s,39),N=ir(n,s,28)^_n(n,s,34)^_n(n,s,39),M=n&i^n&a^i&a,$=s&o^s&c^o&c;v=g|0,k=m|0,g=p|0,m=f|0,p=d|0,f=h|0,{h:d,l:h}=gt(l|0,u|0,D|0,U|0),l=a|0,u=c|0,a=i|0,c=o|0,i=n|0,o=s|0;const C=Np(U,N,$);n=Fp(C,D,L,M),s=C|0}({h:n,l:s}=gt(this.Ah|0,this.Al|0,n|0,s|0)),{h:i,l:o}=gt(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=gt(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:u}=gt(this.Dh|0,this.Dl|0,l|0,u|0),{h:d,l:h}=gt(this.Eh|0,this.El|0,d|0,h|0),{h:p,l:f}=gt(this.Fh|0,this.Fl|0,p|0,f|0),{h:g,l:m}=gt(this.Gh|0,this.Gl|0,g|0,m|0),{h:v,l:k}=gt(this.Hh|0,this.Hl|0,v|0,k|0),this.set(n,s,i,o,a,c,l,u,d,h,p,f,g,m,v,k)}roundClean(){Zt(Pt,Lt)}destroy(){Zt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const au=su(()=>new qp),Gp=su(()=>new Hp);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const No=BigInt(0),ji=BigInt(1);function yn(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Fo(r){if(!yn(r))throw new Error("Uint8Array expected")}function Ot(r,e){if(typeof e!="boolean")throw new Error(r+" boolean expected, got "+e)}function Pn(r){const e=r.toString(16);return e.length&1?"0"+e:e}function cu(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?No:BigInt("0x"+r)}const lu=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Yp=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function mr(r){if(Fo(r),lu)return r.toHex();let e="";for(let t=0;t<r.length;t++)e+=Yp[r[t]];return e}const mt={_0:48,_9:57,A:65,F:70,a:97,f:102};function _a(r){if(r>=mt._0&&r<=mt._9)return r-mt._0;if(r>=mt.A&&r<=mt.F)return r-(mt.A-10);if(r>=mt.a&&r<=mt.f)return r-(mt.a-10)}function ss(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(lu)return Uint8Array.fromHex(r);const e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let s=0,i=0;s<t;s++,i+=2){const o=_a(r.charCodeAt(i)),a=_a(r.charCodeAt(i+1));if(o===void 0||a===void 0){const c=r[i]+r[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}n[s]=o*16+a}return n}function Yt(r){return cu(mr(r))}function Xt(r){return Fo(r),cu(mr(Uint8Array.from(r).reverse()))}function wn(r,e){return ss(r.toString(16).padStart(e*2,"0"))}function en(r,e){return wn(r,e).reverse()}function de(r,e,t){let n;if(typeof e=="string")try{n=ss(e)}catch(i){throw new Error(r+" must be hex string or Uint8Array, cause: "+i)}else if(yn(e))n=Uint8Array.from(e);else throw new Error(r+" must be hex string or Uint8Array");const s=n.length;if(typeof t=="number"&&s!==t)throw new Error(r+" of length "+t+" expected, got "+s);return n}function yr(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];Fo(s),e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const i=r[n];t.set(i,s),s+=i.length}return t}const ri=r=>typeof r=="bigint"&&No<=r;function Uo(r,e,t){return ri(r)&&ri(e)&&ri(t)&&e<=r&&r<t}function Ye(r,e,t,n){if(!Uo(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function Xp(r){let e;for(e=0;r>No;r>>=ji,e+=1);return e}const Us=r=>(ji<<BigInt(r))-ji,ni=r=>new Uint8Array(r),Pa=r=>Uint8Array.from(r);function Qp(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=ni(r),s=ni(r),i=0;const o=()=>{n.fill(1),s.fill(0),i=0},a=(...d)=>t(s,n,...d),c=(d=ni(0))=>{s=a(Pa([0]),d),n=a(),d.length!==0&&(s=a(Pa([1]),d),n=a())},l=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let d=0;const h=[];for(;d<e;){n=a();const p=n.slice();h.push(p),d+=n.length}return yr(...h)};return(d,h)=>{o(),c(d);let p;for(;!(p=h(l()));)c();return o(),p}}const jp={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||yn(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function Lr(r,e,t={}){const n=(s,i,o)=>{const a=jp[i];if(typeof a!="function")throw new Error("invalid validator function");const c=r[s];if(!(o&&c===void 0)&&!a(c,r))throw new Error("param "+String(s)+" is invalid. Expected "+i+", got "+c)};for(const[s,i]of Object.entries(e))n(s,i,!1);for(const[s,i]of Object.entries(t))n(s,i,!0);return r}function is(r){const e=new WeakMap;return(t,...n)=>{const s=e.get(t);if(s!==void 0)return s;const i=r(t,...n);return e.set(t,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const We=BigInt(0),Ie=BigInt(1),Vt=BigInt(2),Zp=BigInt(3),uu=BigInt(4),du=BigInt(5),hu=BigInt(8);function ce(r,e){const t=r%e;return t>=We?t:e+t}function ue(r,e,t){let n=r;for(;e-- >We;)n*=n,n%=t;return n}function Zi(r,e){if(r===We)throw new Error("invert: expected non-zero number");if(e<=We)throw new Error("invert: expected positive modulus, got "+e);let t=ce(r,e),n=e,s=We,i=Ie;for(;t!==We;){const a=n/t,c=n%t,l=s-i*a;n=t,t=c,s=i,i=l}if(n!==Ie)throw new Error("invert: does not exist");return ce(s,e)}function fu(r,e){const t=(r.ORDER+Ie)/uu,n=r.pow(e,t);if(!r.eql(r.sqr(n),e))throw new Error("Cannot find square root");return n}function Jp(r,e){const t=(r.ORDER-du)/hu,n=r.mul(e,Vt),s=r.pow(n,t),i=r.mul(e,s),o=r.mul(r.mul(i,Vt),s),a=r.mul(i,r.sub(o,r.ONE));if(!r.eql(r.sqr(a),e))throw new Error("Cannot find square root");return a}function eg(r){if(r<BigInt(3))throw new Error("sqrt is not defined for small field");let e=r-Ie,t=0;for(;e%Vt===We;)e/=Vt,t++;let n=Vt;const s=bn(r);for(;La(s,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return fu;let i=s.pow(n,e);const o=(e+Ie)/Vt;return function(c,l){if(c.is0(l))return l;if(La(c,l)!==1)throw new Error("Cannot find square root");let u=t,d=c.mul(c.ONE,i),h=c.pow(l,e),p=c.pow(l,o);for(;!c.eql(h,c.ONE);){if(c.is0(h))return c.ZERO;let f=1,g=c.sqr(h);for(;!c.eql(g,c.ONE);)if(f++,g=c.sqr(g),f===u)throw new Error("Cannot find square root");const m=Ie<<BigInt(u-f-1),v=c.pow(d,m);u=f,d=c.sqr(v),h=c.mul(h,d),p=c.mul(p,v)}return p}}function tg(r){return r%uu===Zp?fu:r%hu===du?Jp:eg(r)}const rg=(r,e)=>(ce(r,e)&Ie)===Ie,ng=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function sg(r){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=ng.reduce((n,s)=>(n[s]="function",n),e);return Lr(r,t)}function ig(r,e,t){if(t<We)throw new Error("invalid exponent, negatives unsupported");if(t===We)return r.ONE;if(t===Ie)return e;let n=r.ONE,s=e;for(;t>We;)t&Ie&&(n=r.mul(n,s)),s=r.sqr(s),t>>=Ie;return n}function Bo(r,e,t=!1){const n=new Array(e.length).fill(t?r.ZERO:void 0),s=e.reduce((o,a,c)=>r.is0(a)?o:(n[c]=o,r.mul(o,a)),r.ONE),i=r.inv(s);return e.reduceRight((o,a,c)=>r.is0(a)?o:(n[c]=r.mul(o,n[c]),r.mul(o,a)),i),n}function La(r,e){const t=(r.ORDER-Ie)/Vt,n=r.pow(e,t),s=r.eql(n,r.ONE),i=r.eql(n,r.ZERO),o=r.eql(n,r.neg(r.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function pu(r,e){e!==void 0&&rs(e);const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function bn(r,e,t=!1,n={}){if(r<=We)throw new Error("invalid field: expected ORDER > 0, got "+r);const{nBitLength:s,nByteLength:i}=pu(r,e);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const a=Object.freeze({ORDER:r,isLE:t,BITS:s,BYTES:i,MASK:Us(s),ZERO:We,ONE:Ie,create:c=>ce(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return We<=c&&c<r},is0:c=>c===We,isOdd:c=>(c&Ie)===Ie,neg:c=>ce(-c,r),eql:(c,l)=>c===l,sqr:c=>ce(c*c,r),add:(c,l)=>ce(c+l,r),sub:(c,l)=>ce(c-l,r),mul:(c,l)=>ce(c*l,r),pow:(c,l)=>ig(a,c,l),div:(c,l)=>ce(c*Zi(l,r),r),sqrN:c=>c*c,addN:(c,l)=>c+l,subN:(c,l)=>c-l,mulN:(c,l)=>c*l,inv:c=>Zi(c,r),sqrt:n.sqrt||(c=>(o||(o=tg(r)),o(a,c))),toBytes:c=>t?en(c,i):wn(c,i),fromBytes:c=>{if(c.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+c.length);return t?Xt(c):Yt(c)},invertBatch:c=>Bo(a,c),cmov:(c,l,u)=>u?l:c});return Object.freeze(a)}function gu(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function mu(r){const e=gu(r);return e+Math.ceil(e/2)}function og(r,e,t=!1){const n=r.length,s=gu(e),i=mu(e);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);const o=t?Xt(r):Yt(r),a=ce(o,e-Ie)+Ie;return t?en(a,s):wn(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Da=BigInt(0),Ji=BigInt(1);function si(r,e){const t=e.negate();return r?t:e}function yu(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function ii(r,e){yu(r,e);const t=Math.ceil(e/r)+1,n=2**(r-1),s=2**r,i=Us(r),o=BigInt(r);return{windows:t,windowSize:n,mask:i,maxNumber:s,shiftBy:o}}function Ma(r,e,t){const{windowSize:n,mask:s,maxNumber:i,shiftBy:o}=t;let a=Number(r&s),c=r>>o;a>n&&(a-=i,c+=Ji);const l=e*n,u=l+Math.abs(a)-1,d=a===0,h=a<0,p=e%2!==0;return{nextN:c,offset:u,isZero:d,isNeg:h,isNegF:p,offsetF:l}}function ag(r,e){if(!Array.isArray(r))throw new Error("array expected");r.forEach((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)})}function cg(r,e){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)})}const oi=new WeakMap,wu=new WeakMap;function ai(r){return wu.get(r)||1}function bu(r,e){return{constTimeNegate:si,hasPrecomputes(t){return ai(t)!==1},unsafeLadder(t,n,s=r.ZERO){let i=t;for(;n>Da;)n&Ji&&(s=s.add(i)),i=i.double(),n>>=Ji;return s},precomputeWindow(t,n){const{windows:s,windowSize:i}=ii(n,e),o=[];let a=t,c=a;for(let l=0;l<s;l++){c=a,o.push(c);for(let u=1;u<i;u++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(t,n,s){let i=r.ZERO,o=r.BASE;const a=ii(t,e);for(let c=0;c<a.windows;c++){const{nextN:l,offset:u,isZero:d,isNeg:h,isNegF:p,offsetF:f}=Ma(s,c,a);s=l,d?o=o.add(si(p,n[f])):i=i.add(si(h,n[u]))}return{p:i,f:o}},wNAFUnsafe(t,n,s,i=r.ZERO){const o=ii(t,e);for(let a=0;a<o.windows&&s!==Da;a++){const{nextN:c,offset:l,isZero:u,isNeg:d}=Ma(s,a,o);if(s=c,!u){const h=n[l];i=i.add(d?h.negate():h)}}return i},getPrecomputes(t,n,s){let i=oi.get(n);return i||(i=this.precomputeWindow(n,t),t!==1&&oi.set(n,s(i))),i},wNAFCached(t,n,s){const i=ai(t);return this.wNAF(i,this.getPrecomputes(i,t,s),n)},wNAFCachedUnsafe(t,n,s,i){const o=ai(t);return o===1?this.unsafeLadder(t,n,i):this.wNAFUnsafe(o,this.getPrecomputes(o,t,s),n,i)},setWindowSize(t,n){yu(n,e),wu.set(t,n),oi.delete(t)}}}function vu(r,e,t,n){ag(t,r),cg(n,e);const s=t.length,i=n.length;if(s!==i)throw new Error("arrays of points and scalars must have equal length");const o=r.ZERO,a=Xp(BigInt(s));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const l=Us(c),u=new Array(Number(l)+1).fill(o),d=Math.floor((e.BITS-1)/c)*c;let h=o;for(let p=d;p>=0;p-=c){u.fill(o);for(let g=0;g<i;g++){const m=n[g],v=Number(m>>BigInt(p)&l);u[v]=u[v].add(t[g])}let f=o;for(let g=u.length-1,m=o;g>0;g--)m=m.add(u[g]),f=f.add(m);if(h=h.add(f),p!==0)for(let g=0;g<c;g++)h=h.double()}return h}function $o(r){return sg(r.Fp),Lr(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...pu(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ct=BigInt(0),Ne=BigInt(1),Ra=BigInt(2),lg=BigInt(8),ug={zip215:!0};function dg(r){const e=$o(r);return Lr(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function hg(r){const e=dg(r),{Fp:t,n,prehash:s,hash:i,randomBytes:o,nByteLength:a,h:c}=e,l=Ra<<BigInt(a*8)-Ne,u=t.create,d=bn(e.n,e.nBitLength);function h(A,y){const S=t.sqr(A),T=t.sqr(y),O=t.add(t.mul(e.a,S),T),B=t.add(t.ONE,t.mul(e.d,t.mul(S,T)));return t.eql(O,B)}if(!h(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const p=e.uvRatio||((A,y)=>{try{return{isValid:!0,value:t.sqrt(A*t.inv(y))}}catch{return{isValid:!1,value:ct}}}),f=e.adjustScalarBytes||(A=>A),g=e.domain||((A,y,S)=>{if(Ot("phflag",S),y.length||S)throw new Error("Contexts/pre-hash are not supported");return A});function m(A,y,S=!1){const T=S?Ne:ct;Ye("coordinate "+A,y,T,l)}function v(A){if(!(A instanceof w))throw new Error("ExtendedPoint expected")}const k=is((A,y)=>{const{ex:S,ey:T,ez:O}=A,B=A.is0();y==null&&(y=B?lg:t.inv(O));const z=u(S*y),K=u(T*y),W=u(O*y);if(B)return{x:ct,y:Ne};if(W!==Ne)throw new Error("invZ was invalid");return{x:z,y:K}}),b=is(A=>{const{a:y,d:S}=e;if(A.is0())throw new Error("bad point: ZERO");const{ex:T,ey:O,ez:B,et:z}=A,K=u(T*T),W=u(O*O),H=u(B*B),te=u(H*H),ee=u(K*y),Se=u(H*u(ee+W)),$e=u(te+u(S*u(K*W)));if(Se!==$e)throw new Error("bad point: equation left != right (1)");const be=u(T*O),ke=u(B*z);if(be!==ke)throw new Error("bad point: equation left != right (2)");return!0});class w{constructor(y,S,T,O){m("x",y),m("y",S),m("z",T,!0),m("t",O),this.ex=y,this.ey=S,this.ez=T,this.et=O,Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(y){if(y instanceof w)throw new Error("extended point not allowed");const{x:S,y:T}=y||{};return m("x",S),m("y",T),new w(S,T,Ne,u(S*T))}static normalizeZ(y){const S=Bo(t,y.map(T=>T.ez));return y.map((T,O)=>T.toAffine(S[O])).map(w.fromAffine)}static msm(y,S){return vu(w,d,y,S)}_setWindowSize(y){x.setWindowSize(this,y)}assertValidity(){b(this)}equals(y){v(y);const{ex:S,ey:T,ez:O}=this,{ex:B,ey:z,ez:K}=y,W=u(S*K),H=u(B*O),te=u(T*K),ee=u(z*O);return W===H&&te===ee}is0(){return this.equals(w.ZERO)}negate(){return new w(u(-this.ex),this.ey,this.ez,u(-this.et))}double(){const{a:y}=e,{ex:S,ey:T,ez:O}=this,B=u(S*S),z=u(T*T),K=u(Ra*u(O*O)),W=u(y*B),H=S+T,te=u(u(H*H)-B-z),ee=W+z,Se=ee-K,$e=W-z,be=u(te*Se),ke=u(ee*$e),Ve=u(te*$e),et=u(Se*ee);return new w(be,ke,et,Ve)}add(y){v(y);const{a:S,d:T}=e,{ex:O,ey:B,ez:z,et:K}=this,{ex:W,ey:H,ez:te,et:ee}=y,Se=u(O*W),$e=u(B*H),be=u(K*T*ee),ke=u(z*te),Ve=u((O+B)*(W+H)-Se-$e),et=ke-be,Or=ke+be,pa=u($e-S*Se),Ph=u(Ve*et),Lh=u(Or*pa),Dh=u(Ve*pa),Mh=u(et*Or);return new w(Ph,Lh,Mh,Dh)}subtract(y){return this.add(y.negate())}wNAF(y){return x.wNAFCached(this,y,w.normalizeZ)}multiply(y){const S=y;Ye("scalar",S,Ne,n);const{p:T,f:O}=this.wNAF(S);return w.normalizeZ([T,O])[0]}multiplyUnsafe(y,S=w.ZERO){const T=y;return Ye("scalar",T,ct,n),T===ct?P:this.is0()||T===Ne?this:x.wNAFCachedUnsafe(this,T,w.normalizeZ,S)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return x.unsafeLadder(this,n).is0()}toAffine(y){return k(this,y)}clearCofactor(){const{h:y}=e;return y===Ne?this:this.multiplyUnsafe(y)}static fromHex(y,S=!1){const{d:T,a:O}=e,B=t.BYTES;y=de("pointHex",y,B),Ot("zip215",S);const z=y.slice(),K=y[B-1];z[B-1]=K&-129;const W=Xt(z),H=S?l:t.ORDER;Ye("pointHex.y",W,ct,H);const te=u(W*W),ee=u(te-Ne),Se=u(T*te-O);let{isValid:$e,value:be}=p(ee,Se);if(!$e)throw new Error("Point.fromHex: invalid y coordinate");const ke=(be&Ne)===Ne,Ve=(K&128)!==0;if(!S&&be===ct&&Ve)throw new Error("Point.fromHex: x=0 and x_0=1");return Ve!==ke&&(be=u(-be)),w.fromAffine({x:be,y:W})}static fromPrivateKey(y){const{scalar:S}=U(y);return E.multiply(S)}toRawBytes(){const{x:y,y:S}=this.toAffine(),T=en(S,t.BYTES);return T[T.length-1]|=y&Ne?128:0,T}toHex(){return mr(this.toRawBytes())}}w.BASE=new w(e.Gx,e.Gy,Ne,u(e.Gx*e.Gy)),w.ZERO=new w(ct,Ne,Ne,ct);const{BASE:E,ZERO:P}=w,x=bu(w,a*8);function _(A){return ce(A,n)}function D(A){return _(Xt(A))}function U(A){const y=t.BYTES;A=de("private key",A,y);const S=de("hashed private key",i(A),2*y),T=f(S.slice(0,y)),O=S.slice(y,2*y),B=D(T);return{head:T,prefix:O,scalar:B}}function L(A){const{head:y,prefix:S,scalar:T}=U(A),O=E.multiply(T),B=O.toRawBytes();return{head:y,prefix:S,scalar:T,point:O,pointBytes:B}}function N(A){return L(A).pointBytes}function M(A=Uint8Array.of(),...y){const S=yr(...y);return D(i(g(S,de("context",A),!!s)))}function $(A,y,S={}){A=de("message",A),s&&(A=s(A));const{prefix:T,scalar:O,pointBytes:B}=L(y),z=M(S.context,T,A),K=E.multiply(z).toRawBytes(),W=M(S.context,K,B,A),H=_(z+W*O);Ye("signature.s",H,ct,n);const te=yr(K,en(H,t.BYTES));return de("result",te,t.BYTES*2)}const C=ug;function I(A,y,S,T=C){const{context:O,zip215:B}=T,z=t.BYTES;A=de("signature",A,2*z),y=de("message",y),S=de("publicKey",S,z),B!==void 0&&Ot("zip215",B),s&&(y=s(y));const K=Xt(A.slice(z,2*z));let W,H,te;try{W=w.fromHex(S,B),H=w.fromHex(A.slice(0,z),B),te=E.multiplyUnsafe(K)}catch{return!1}if(!B&&W.isSmallOrder())return!1;const ee=M(O,H.toRawBytes(),W.toRawBytes(),y);return H.add(W.multiplyUnsafe(ee)).subtract(te).clearCofactor().equals(w.ZERO)}return E._setWindowSize(8),{CURVE:e,getPublicKey:N,sign:$,verify:I,ExtendedPoint:w,utils:{getExtendedPublicKey:L,randomPrivateKey:()=>o(t.BYTES),precompute(A=8,y=w.BASE){return y._setWindowSize(A),y.multiply(BigInt(3)),y}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Br=BigInt(0),or=BigInt(1),Ln=BigInt(2);function fg(r){return Lr(r,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...r})}function pg(r){const e=fg(r),{P:t,type:n,adjustScalarBytes:s,powPminus2:i}=e,o=n==="x25519";if(!o&&n!=="x448")throw new Error("invalid type");const a=o?255:448,c=o?32:56,l=BigInt(o?9:5),u=BigInt(o?121665:39081),d=o?Ln**BigInt(254):Ln**BigInt(447),h=o?BigInt(8)*Ln**BigInt(251)-or:BigInt(4)*Ln**BigInt(445)-or,p=d+h+or,f=x=>ce(x,t),g=m(l);function m(x){return en(f(x),c)}function v(x){const _=de("u coordinate",x,c);return o&&(_[31]&=127),f(Xt(_))}function k(x){return Xt(s(de("scalar",x,c)))}function b(x,_){const D=P(v(_),k(x));if(D===Br)throw new Error("invalid private or public key received");return m(D)}function w(x){return b(x,g)}function E(x,_,D){const U=f(x*(_-D));return _=f(_-U),D=f(D+U),{x_2:_,x_3:D}}function P(x,_){Ye("u",x,Br,t),Ye("scalar",_,d,p);const D=_,U=x;let L=or,N=Br,M=x,$=or,C=Br;for(let R=BigInt(a-1);R>=Br;R--){const A=D>>R&or;C^=A,{x_2:L,x_3:M}=E(C,L,M),{x_2:N,x_3:$}=E(C,N,$),C=A;const y=L+N,S=f(y*y),T=L-N,O=f(T*T),B=S-O,z=M+$,K=M-$,W=f(K*y),H=f(z*T),te=W+H,ee=W-H;M=f(te*te),$=f(U*f(ee*ee)),L=f(S*O),N=f(B*(S+f(u*B)))}({x_2:L,x_3:M}=E(C,L,M)),{x_2:N,x_3:$}=E(C,N,$);const I=i(N);return f(L*I)}return{scalarMult:b,scalarMultBase:w,getSharedSecret:(x,_)=>b(x,_),getPublicKey:x=>w(x),utils:{randomPrivateKey:()=>e.randomBytes(c)},GuBytes:g.slice()}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const tn=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Oa=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const gg=BigInt(1),Na=BigInt(2),mg=BigInt(3),yg=BigInt(5),wg=BigInt(8);function Eu(r){const e=BigInt(10),t=BigInt(20),n=BigInt(40),s=BigInt(80),i=tn,a=r*r%i*r%i,c=ue(a,Na,i)*a%i,l=ue(c,gg,i)*r%i,u=ue(l,yg,i)*l%i,d=ue(u,e,i)*u%i,h=ue(d,t,i)*d%i,p=ue(h,n,i)*h%i,f=ue(p,s,i)*p%i,g=ue(f,s,i)*p%i,m=ue(g,e,i)*u%i;return{pow_p_5_8:ue(m,Na,i)*r%i,b2:a}}function Su(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function bg(r,e){const t=tn,n=ce(e*e*e,t),s=ce(n*n*e,t),i=Eu(r*s).pow_p_5_8;let o=ce(r*n*i,t);const a=ce(e*o*o,t),c=o,l=ce(o*Oa,t),u=a===r,d=a===ce(-r,t),h=a===ce(-r*Oa,t);return u&&(o=c),(d||h)&&(o=l),rg(o,t)&&(o=ce(-o,t)),{isValid:u||d,value:o}}const Fa=bn(tn,void 0,!0),vg={a:Fa.create(BigInt(-1)),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Fa,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:wg,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Gp,randomBytes:Fs,adjustScalarBytes:Su,uvRatio:bg},os=hg(vg),Dn=pg({P:tn,type:"x25519",powPminus2:r=>{const e=tn,{pow_p_5_8:t,b2:n}=Eu(r);return ce(ue(t,mg,e)*n,e)},adjustScalarBytes:Su,randomBytes:Fs}),xu=32,Au=64,eo=32;function Eg(){const r=os.utils.randomPrivateKey(),e=os.getPublicKey(r);return{privateKey:Ag(r,e),publicKey:e}}function Sg(r,e){const t=r.subarray(0,eo);return os.sign(e instanceof Uint8Array?e:e.subarray(),t)}function xg(r,e,t){return os.verify(e,t instanceof Uint8Array?t:t.subarray(),r)}function Ag(r,e){const t=new Uint8Array(Au);for(let n=0;n<eo;n++)t[n]=r[n],t[eo+n]=e[n];return t}class Cu{type="Ed25519";raw;constructor(e){this.raw=zo(e,xu)}toMultihash(){return pn.digest(At(this))}toCID(){return ae.createV1(114,this.toMultihash())}toString(){return ye.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Oe(this.raw,e.raw)}verify(e,t){return xg(this.raw,t,e)}}class Cg{type="Ed25519";raw;publicKey;constructor(e,t){this.raw=zo(e,Au),this.publicKey=new Cu(t)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Oe(this.raw,e.raw)}sign(e){return Sg(this.raw,e)}}function Iu(r){return r=zo(r,xu),new Cu(r)}async function Ig(){const{privateKey:r,publicKey:e}=Eg();return new Cg(r,e)}function zo(r,e){if(r=Uint8Array.from(r??[]),r.length!==e)throw new V(`Key must be a Uint8Array of length ${e}, got ${r.length}`);return r}const Tg=Math.pow(2,7),kg=Math.pow(2,14),_g=Math.pow(2,21),Ko=Math.pow(2,28),qo=Math.pow(2,35),Wo=Math.pow(2,42),Vo=Math.pow(2,49),re=128,Le=127;function Ae(r){if(r<Tg)return 1;if(r<kg)return 2;if(r<_g)return 3;if(r<Ko)return 4;if(r<qo)return 5;if(r<Wo)return 6;if(r<Vo)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Tu(r,e,t=0){switch(Ae(r)){case 8:e[t++]=r&255|re,r/=128;case 7:e[t++]=r&255|re,r/=128;case 6:e[t++]=r&255|re,r/=128;case 5:e[t++]=r&255|re,r/=128;case 4:e[t++]=r&255|re,r>>>=7;case 3:e[t++]=r&255|re,r>>>=7;case 2:e[t++]=r&255|re,r>>>=7;case 1:{e[t++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return e}function Pg(r,e,t=0){switch(Ae(r)){case 8:e.set(t++,r&255|re),r/=128;case 7:e.set(t++,r&255|re),r/=128;case 6:e.set(t++,r&255|re),r/=128;case 5:e.set(t++,r&255|re),r/=128;case 4:e.set(t++,r&255|re),r>>>=7;case 3:e.set(t++,r&255|re),r>>>=7;case 2:e.set(t++,r&255|re),r>>>=7;case 1:{e.set(t++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return e}function ku(r,e){let t=r[e],n=0;if(n+=t&Le,t<re||(t=r[e+1],n+=(t&Le)<<7,t<re)||(t=r[e+2],n+=(t&Le)<<14,t<re)||(t=r[e+3],n+=(t&Le)<<21,t<re)||(t=r[e+4],n+=(t&Le)*Ko,t<re)||(t=r[e+5],n+=(t&Le)*qo,t<re)||(t=r[e+6],n+=(t&Le)*Wo,t<re)||(t=r[e+7],n+=(t&Le)*Vo,t<re))return n;throw new RangeError("Could not decode varint")}function Lg(r,e){let t=r.get(e),n=0;if(n+=t&Le,t<re||(t=r.get(e+1),n+=(t&Le)<<7,t<re)||(t=r.get(e+2),n+=(t&Le)<<14,t<re)||(t=r.get(e+3),n+=(t&Le)<<21,t<re)||(t=r.get(e+4),n+=(t&Le)*Ko,t<re)||(t=r.get(e+5),n+=(t&Le)*qo,t<re)||(t=r.get(e+6),n+=(t&Le)*Wo,t<re)||(t=r.get(e+7),n+=(t&Le)*Vo,t<re))return n;throw new RangeError("Could not decode varint")}function dt(r,e,t=0){return e==null&&(e=ft(Ae(r))),e instanceof Uint8Array?Tu(r,e,t):Pg(r,e,t)}function rr(r,e=0){return r instanceof Uint8Array?ku(r,e):Lg(r,e)}const Ho=new Float32Array([-0]),Mt=new Uint8Array(Ho.buffer);function Dg(r,e,t){Ho[0]=r,e[t]=Mt[0],e[t+1]=Mt[1],e[t+2]=Mt[2],e[t+3]=Mt[3]}function Mg(r,e){return Mt[0]=r[e],Mt[1]=r[e+1],Mt[2]=r[e+2],Mt[3]=r[e+3],Ho[0]}const Go=new Float64Array([-0]),De=new Uint8Array(Go.buffer);function Rg(r,e,t){Go[0]=r,e[t]=De[0],e[t+1]=De[1],e[t+2]=De[2],e[t+3]=De[3],e[t+4]=De[4],e[t+5]=De[5],e[t+6]=De[6],e[t+7]=De[7]}function Og(r,e){return De[0]=r[e],De[1]=r[e+1],De[2]=r[e+2],De[3]=r[e+3],De[4]=r[e+4],De[5]=r[e+5],De[6]=r[e+6],De[7]=r[e+7],Go[0]}const Ng=BigInt(Number.MAX_SAFE_INTEGER),Fg=BigInt(Number.MIN_SAFE_INTEGER);class Re{lo;hi;constructor(e,t){this.lo=e|0,this.hi=t|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(t+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(BigInt(t)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?t===0?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:n<128?9:10}static fromBigInt(e){if(e===0n)return Qt;if(e<Ng&&e>Fg)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let n=e>>32n,s=e-(n<<32n);return t&&(n=~n|0n,s=~s|0n,++s>Ua&&(s=0n,++n>Ua&&(n=0n))),new Re(Number(s),Number(n))}static fromNumber(e){if(e===0)return Qt;const t=e<0;t&&(e=-e);let n=e>>>0,s=(e-n)/4294967296>>>0;return t&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new Re(n,s)}static from(e){return typeof e=="number"?Re.fromNumber(e):typeof e=="bigint"?Re.fromBigInt(e):typeof e=="string"?Re.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new Re(e.low>>>0,e.high>>>0):Qt}}const Qt=new Re(0,0);Qt.toBigInt=function(){return 0n};Qt.zzEncode=Qt.zzDecode=function(){return this};Qt.length=function(){return 1};const Ua=4294967296n;function Ug(r){let e=0,t=0;for(let n=0;n<r.length;++n)t=r.charCodeAt(n),t<128?e+=1:t<2048?e+=2:(t&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,e+=4):e+=3;return e}function Bg(r,e,t){if(t-e<1)return"";let s;const i=[];let o=0,a;for(;e<t;)a=r[e++],a<128?i[o++]=a:a>191&&a<224?i[o++]=(a&31)<<6|r[e++]&63:a>239&&a<365?(a=((a&7)<<18|(r[e++]&63)<<12|(r[e++]&63)<<6|r[e++]&63)-65536,i[o++]=55296+(a>>10),i[o++]=56320+(a&1023)):i[o++]=(a&15)<<12|(r[e++]&63)<<6|r[e++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function _u(r,e,t){const n=t;let s,i;for(let o=0;o<r.length;++o)s=r.charCodeAt(o),s<128?e[t++]=s:s<2048?(e[t++]=s>>6|192,e[t++]=s&63|128):(s&64512)===55296&&((i=r.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,e[t++]=s>>18|240,e[t++]=s>>12&63|128,e[t++]=s>>6&63|128,e[t++]=s&63|128):(e[t++]=s>>12|224,e[t++]=s>>6&63|128,e[t++]=s&63|128);return t-n}function tt(r,e){return RangeError(`index out of range: ${r.pos} + ${e??1} > ${r.len}`)}function Mn(r,e){return(r[e-4]|r[e-3]<<8|r[e-2]<<16|r[e-1]<<24)>>>0}class $g{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(e){this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,tt(this,10);return e}int32(){return this.uint32()|0}sint32(){const e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw tt(this,4);return Mn(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw tt(this,4);return Mn(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw tt(this,4);const e=Mg(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw tt(this,4);const e=Og(this.buf,this.pos);return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,n=this.pos+e;if(n>this.len)throw tt(this,e);return this.pos+=e,t===n?new Uint8Array(0):this.buf.subarray(t,n)}string(){const e=this.bytes();return Bg(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw tt(this,e);this.pos+=e}else do if(this.pos>=this.len)throw tt(this);while((this.buf[this.pos++]&128)!==0);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new Re(0,0);let t=0;if(this.len-this.pos>4){for(;t<4;++t)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw tt(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,e}if(this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw tt(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw tt(this,8);const e=Mn(this.buf,this.pos+=4),t=Mn(this.buf,this.pos+=4);return new Re(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=ku(this.buf,this.pos);return this.pos+=Ae(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function zg(r){return new $g(r instanceof Uint8Array?r:r.subarray())}function pe(r,e,t){const n=zg(r);return e.decode(n,void 0,t)}function Kg(r){let n,s=8192;return function(o){if(o<1||o>4096)return ft(o);s+o>8192&&(n=ft(8192),s=0);const a=n.subarray(s,s+=o);return(s&7)!==0&&(s=(s|7)+1),a}}class qr{fn;len;next;val;constructor(e,t,n){this.fn=e,this.len=t,this.next=void 0,this.val=n}}function ci(){}class qg{head;tail;len;next;constructor(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}}const Wg=Kg();function Vg(r){return globalThis.Buffer!=null?ft(r):Wg(r)}class to{len;head;tail;states;constructor(){this.len=0,this.head=new qr(ci,0,0),this.tail=this.head,this.states=null}_push(e,t,n){return this.tail=this.tail.next=new qr(e,t,n),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new Gg((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(Rn,10,Re.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=Re.fromBigInt(e);return this._push(Rn,t.length(),t)}uint64Number(e){return this._push(Tu,Ae(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=Re.fromBigInt(e).zzEncode();return this._push(Rn,t.length(),t)}sint64Number(e){const t=Re.fromNumber(e).zzEncode();return this._push(Rn,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(li,1,e?1:0)}fixed32(e){return this._push($r,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=Re.fromBigInt(e);return this._push($r,4,t.lo)._push($r,4,t.hi)}fixed64Number(e){const t=Re.fromNumber(e);return this._push($r,4,t.lo)._push($r,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(Dg,4,e)}double(e){return this._push(Rg,8,e)}bytes(e){const t=e.length>>>0;return t===0?this._push(li,1,0):this.uint32(t)._push(Yg,t,e)}string(e){const t=Ug(e);return t!==0?this.uint32(t)._push(_u,t,e):this._push(li,1,0)}fork(){return this.states=new qg(this),this.head=this.tail=new qr(ci,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new qr(ci,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=e.next,this.tail=t,this.len+=n),this}finish(){let e=this.head.next;const t=Vg(this.len);let n=0;for(;e!=null;)e.fn(e.val,t,n),n+=e.len,e=e.next;return t}}function li(r,e,t){e[t]=r&255}function Hg(r,e,t){for(;r>127;)e[t++]=r&127|128,r>>>=7;e[t]=r}class Gg extends qr{next;constructor(e,t){super(Hg,e,t),this.next=void 0}}function Rn(r,e,t){for(;r.hi!==0;)e[t++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)e[t++]=r.lo&127|128,r.lo=r.lo>>>7;e[t++]=r.lo}function $r(r,e,t){e[t]=r&255,e[t+1]=r>>>8&255,e[t+2]=r>>>16&255,e[t+3]=r>>>24}function Yg(r,e,t){e.set(r,t)}globalThis.Buffer!=null&&(to.prototype.bytes=function(r){const e=r.length>>>0;return this.uint32(e),e>0&&this._push(Xg,e,r),this},to.prototype.string=function(r){const e=globalThis.Buffer.byteLength(r);return this.uint32(e),e>0&&this._push(Qg,e,r),this});function Xg(r,e,t){e.set(r,t)}function Qg(r,e,t){r.length<40?_u(r,e,t):e.utf8Write!=null?e.utf8Write(r,t):e.set(q(r),t)}function jg(){return new to}function ge(r,e){const t=jg();return e.encode(r,t,{lengthDelimited:!1}),t.finish()}var as;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(as||(as={}));function Pu(r,e,t,n){return{name:r,type:e,encode:t,decode:n}}function Dr(r){function e(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}const t=function(i,o){const a=e(i);o.int32(a)},n=function(i){const o=i.int32();return e(o)};return Pu("enum",as.VARINT,t,n)}function me(r,e){return Pu("message",as.LENGTH_DELIMITED,r,e)}class It extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"}class Ba extends Error{code="ERR_MAX_SIZE";name="MaxSizeError"}var Ce;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1",r.ECDSA="ECDSA"})(Ce||(Ce={}));var ro;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1",r[r.ECDSA=3]="ECDSA"})(ro||(ro={}));(function(r){r.codec=()=>Dr(ro)})(Ce||(Ce={}));var wr;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),Ce.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.Type=Ce.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(wr||(wr={}));var $a;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),Ce.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.Type=Ce.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})($a||($a={}));function Yo(r){if(isNaN(r)||r<=0)throw new V("random bytes length must be a Number bigger than 0");return Fs(r)}class za extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}}class Zg extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}}const Ka={get(r=globalThis){const e=r.crypto;if(e?.subtle==null)throw new Zg("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return e}},Xn=au;class Jg{type="RSA";jwk;_raw;_multihash;constructor(e,t){this.jwk=e,this._multihash=t}get raw(){return this._raw==null&&(this._raw=sm(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return ae.createV1(114,this._multihash)}toString(){return ye.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Oe(this.raw,e.raw)}verify(e,t){return am(this.jwk,t,e)}}const em=18,tm=1062,rm=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function nm(r){const e=Ns(r[1],{offset:0});return{kty:"RSA",n:Y(e[0],"base64url"),e:Y(e[1],"base64url")}}function sm(r){if(r.n==null||r.e==null)throw new V("JWK was missing components");return Hr([rm,tu(Hr([Qi(q(r.n,"base64url")),Qi(q(r.e,"base64url"))]))]).subarray()}function im(r,e){if(r.byteLength>=tm)throw new Nl("Key size is too large");const t=Ns(r,{offset:0});return om(t,r,e)}function om(r,e,t){const n=nm(r);if(t==null){const s=Xn(wr.encode({Type:Ce.RSA,Data:e}));t=Zr(em,s)}return new Jg(n,t)}async function am(r,e,t){const n=await Ka.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);return Ka.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},n,e,t instanceof Uint8Array?t:t.subarray())}class Lu extends nu{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Oo(e);const n=Jr(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(n.length>s?e.create().update(n).digest():n);for(let o=0;o<i.length;o++)i[o]^=54;this.iHash.update(i),this.oHash=e.create();for(let o=0;o<i.length;o++)i[o]^=106;this.oHash.update(i),Zt(i)}update(e){return ns(this),this.iHash.update(e),this}digestInto(e){ns(this),mn(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=i,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Bs=(r,e,t)=>new Lu(r,e).update(t).digest();Bs.create=(r,e)=>new Lu(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function qa(r){r.lowS!==void 0&&Ot("lowS",r.lowS),r.prehash!==void 0&&Ot("prehash",r.prehash)}function cm(r){const e=$o(r);Lr(e,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:t,Fp:n,a:s}=e;if(t){if(!n.eql(s,n.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...e})}class lm extends Error{constructor(e=""){super(e)}}const vt={Err:lm,_tlv:{encode:(r,e)=>{const{Err:t}=vt;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const n=e.length/2,s=Pn(n);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const i=n>127?Pn(s.length/2|128):"";return Pn(r)+i+s+e},decode(r,e){const{Err:t}=vt;let n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");const s=e[n++],i=!!(s&128);let o=0;if(!i)o=s;else{const c=s&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const l=e.subarray(n,n+c);if(l.length!==c)throw new t("tlv.decode: length bytes not complete");if(l[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const u of l)o=o<<8|u;if(n+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(n,n+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+o)}}},_int:{encode(r){const{Err:e}=vt;if(r<St)throw new e("integer: negative integers are not allowed");let t=Pn(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(r){const{Err:e}=vt;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return Yt(r)}},toSig(r){const{Err:e,_int:t,_tlv:n}=vt,s=de("signature",r),{v:i,l:o}=n.decode(48,s);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,i),{v:l,l:u}=n.decode(2,c);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(l)}},hexFromSig(r){const{_tlv:e,_int:t}=vt,n=e.encode(2,t.encode(r.r)),s=e.encode(2,t.encode(r.s)),i=n+s;return e.encode(48,i)}};function ui(r,e){return mr(wn(r,e))}const St=BigInt(0),Ee=BigInt(1);BigInt(2);const di=BigInt(3),um=BigInt(4);function dm(r){const e=cm(r),{Fp:t}=e,n=bn(e.n,e.nBitLength),s=e.toBytes||((b,w,E)=>{const P=w.toAffine();return yr(Uint8Array.from([4]),t.toBytes(P.x),t.toBytes(P.y))}),i=e.fromBytes||(b=>{const w=b.subarray(1),E=t.fromBytes(w.subarray(0,t.BYTES)),P=t.fromBytes(w.subarray(t.BYTES,2*t.BYTES));return{x:E,y:P}});function o(b){const{a:w,b:E}=e,P=t.sqr(b),x=t.mul(P,b);return t.add(t.add(x,t.mul(b,w)),E)}function a(b,w){const E=t.sqr(w),P=o(b);return t.eql(E,P)}if(!a(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const c=t.mul(t.pow(e.a,di),um),l=t.mul(t.sqr(e.b),BigInt(27));if(t.is0(t.add(c,l)))throw new Error("bad curve params: a or b");function u(b){return Uo(b,Ee,e.n)}function d(b){const{allowedPrivateKeyLengths:w,nByteLength:E,wrapPrivateKey:P,n:x}=e;if(w&&typeof b!="bigint"){if(yn(b)&&(b=mr(b)),typeof b!="string"||!w.includes(b.length))throw new Error("invalid private key");b=b.padStart(E*2,"0")}let _;try{_=typeof b=="bigint"?b:Yt(de("private key",b,E))}catch{throw new Error("invalid private key, expected hex or "+E+" bytes, got "+typeof b)}return P&&(_=ce(_,x)),Ye("private key",_,Ee,x),_}function h(b){if(!(b instanceof g))throw new Error("ProjectivePoint expected")}const p=is((b,w)=>{const{px:E,py:P,pz:x}=b;if(t.eql(x,t.ONE))return{x:E,y:P};const _=b.is0();w==null&&(w=_?t.ONE:t.inv(x));const D=t.mul(E,w),U=t.mul(P,w),L=t.mul(x,w);if(_)return{x:t.ZERO,y:t.ZERO};if(!t.eql(L,t.ONE))throw new Error("invZ was invalid");return{x:D,y:U}}),f=is(b=>{if(b.is0()){if(e.allowInfinityPoint&&!t.is0(b.py))return;throw new Error("bad point: ZERO")}const{x:w,y:E}=b.toAffine();if(!t.isValid(w)||!t.isValid(E))throw new Error("bad point: x or y not FE");if(!a(w,E))throw new Error("bad point: equation left != right");if(!b.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(w,E,P){if(w==null||!t.isValid(w))throw new Error("x required");if(E==null||!t.isValid(E)||t.is0(E))throw new Error("y required");if(P==null||!t.isValid(P))throw new Error("z required");this.px=w,this.py=E,this.pz=P,Object.freeze(this)}static fromAffine(w){const{x:E,y:P}=w||{};if(!w||!t.isValid(E)||!t.isValid(P))throw new Error("invalid affine point");if(w instanceof g)throw new Error("projective point not allowed");const x=_=>t.eql(_,t.ZERO);return x(E)&&x(P)?g.ZERO:new g(E,P,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(w){const E=Bo(t,w.map(P=>P.pz));return w.map((P,x)=>P.toAffine(E[x])).map(g.fromAffine)}static fromHex(w){const E=g.fromAffine(i(de("pointHex",w)));return E.assertValidity(),E}static fromPrivateKey(w){return g.BASE.multiply(d(w))}static msm(w,E){return vu(g,n,w,E)}_setWindowSize(w){k.setWindowSize(this,w)}assertValidity(){f(this)}hasEvenY(){const{y:w}=this.toAffine();if(t.isOdd)return!t.isOdd(w);throw new Error("Field doesn't support isOdd")}equals(w){h(w);const{px:E,py:P,pz:x}=this,{px:_,py:D,pz:U}=w,L=t.eql(t.mul(E,U),t.mul(_,x)),N=t.eql(t.mul(P,U),t.mul(D,x));return L&&N}negate(){return new g(this.px,t.neg(this.py),this.pz)}double(){const{a:w,b:E}=e,P=t.mul(E,di),{px:x,py:_,pz:D}=this;let U=t.ZERO,L=t.ZERO,N=t.ZERO,M=t.mul(x,x),$=t.mul(_,_),C=t.mul(D,D),I=t.mul(x,_);return I=t.add(I,I),N=t.mul(x,D),N=t.add(N,N),U=t.mul(w,N),L=t.mul(P,C),L=t.add(U,L),U=t.sub($,L),L=t.add($,L),L=t.mul(U,L),U=t.mul(I,U),N=t.mul(P,N),C=t.mul(w,C),I=t.sub(M,C),I=t.mul(w,I),I=t.add(I,N),N=t.add(M,M),M=t.add(N,M),M=t.add(M,C),M=t.mul(M,I),L=t.add(L,M),C=t.mul(_,D),C=t.add(C,C),M=t.mul(C,I),U=t.sub(U,M),N=t.mul(C,$),N=t.add(N,N),N=t.add(N,N),new g(U,L,N)}add(w){h(w);const{px:E,py:P,pz:x}=this,{px:_,py:D,pz:U}=w;let L=t.ZERO,N=t.ZERO,M=t.ZERO;const $=e.a,C=t.mul(e.b,di);let I=t.mul(E,_),R=t.mul(P,D),A=t.mul(x,U),y=t.add(E,P),S=t.add(_,D);y=t.mul(y,S),S=t.add(I,R),y=t.sub(y,S),S=t.add(E,x);let T=t.add(_,U);return S=t.mul(S,T),T=t.add(I,A),S=t.sub(S,T),T=t.add(P,x),L=t.add(D,U),T=t.mul(T,L),L=t.add(R,A),T=t.sub(T,L),M=t.mul($,S),L=t.mul(C,A),M=t.add(L,M),L=t.sub(R,M),M=t.add(R,M),N=t.mul(L,M),R=t.add(I,I),R=t.add(R,I),A=t.mul($,A),S=t.mul(C,S),R=t.add(R,A),A=t.sub(I,A),A=t.mul($,A),S=t.add(S,A),I=t.mul(R,S),N=t.add(N,I),I=t.mul(T,S),L=t.mul(y,L),L=t.sub(L,I),I=t.mul(y,R),M=t.mul(T,M),M=t.add(M,I),new g(L,N,M)}subtract(w){return this.add(w.negate())}is0(){return this.equals(g.ZERO)}wNAF(w){return k.wNAFCached(this,w,g.normalizeZ)}multiplyUnsafe(w){const{endo:E,n:P}=e;Ye("scalar",w,St,P);const x=g.ZERO;if(w===St)return x;if(this.is0()||w===Ee)return this;if(!E||k.hasPrecomputes(this))return k.wNAFCachedUnsafe(this,w,g.normalizeZ);let{k1neg:_,k1:D,k2neg:U,k2:L}=E.splitScalar(w),N=x,M=x,$=this;for(;D>St||L>St;)D&Ee&&(N=N.add($)),L&Ee&&(M=M.add($)),$=$.double(),D>>=Ee,L>>=Ee;return _&&(N=N.negate()),U&&(M=M.negate()),M=new g(t.mul(M.px,E.beta),M.py,M.pz),N.add(M)}multiply(w){const{endo:E,n:P}=e;Ye("scalar",w,Ee,P);let x,_;if(E){const{k1neg:D,k1:U,k2neg:L,k2:N}=E.splitScalar(w);let{p:M,f:$}=this.wNAF(U),{p:C,f:I}=this.wNAF(N);M=k.constTimeNegate(D,M),C=k.constTimeNegate(L,C),C=new g(t.mul(C.px,E.beta),C.py,C.pz),x=M.add(C),_=$.add(I)}else{const{p:D,f:U}=this.wNAF(w);x=D,_=U}return g.normalizeZ([x,_])[0]}multiplyAndAddUnsafe(w,E,P){const x=g.BASE,_=(U,L)=>L===St||L===Ee||!U.equals(x)?U.multiplyUnsafe(L):U.multiply(L),D=_(this,E).add(_(w,P));return D.is0()?void 0:D}toAffine(w){return p(this,w)}isTorsionFree(){const{h:w,isTorsionFree:E}=e;if(w===Ee)return!0;if(E)return E(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:w,clearCofactor:E}=e;return w===Ee?this:E?E(g,this):this.multiplyUnsafe(e.h)}toRawBytes(w=!0){return Ot("isCompressed",w),this.assertValidity(),s(g,this,w)}toHex(w=!0){return Ot("isCompressed",w),mr(this.toRawBytes(w))}}g.BASE=new g(e.Gx,e.Gy,t.ONE),g.ZERO=new g(t.ZERO,t.ONE,t.ZERO);const{endo:m,nBitLength:v}=e,k=bu(g,m?Math.ceil(v/2):v);return{CURVE:e,ProjectivePoint:g,normPrivateKeyToScalar:d,weierstrassEquation:o,isWithinCurveOrder:u}}function hm(r){const e=$o(r);return Lr(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function fm(r){const e=hm(r),{Fp:t,n,nByteLength:s,nBitLength:i}=e,o=t.BYTES+1,a=2*t.BYTES+1;function c(C){return ce(C,n)}function l(C){return Zi(C,n)}const{ProjectivePoint:u,normPrivateKeyToScalar:d,weierstrassEquation:h,isWithinCurveOrder:p}=dm({...e,toBytes(C,I,R){const A=I.toAffine(),y=t.toBytes(A.x),S=yr;return Ot("isCompressed",R),R?S(Uint8Array.from([I.hasEvenY()?2:3]),y):S(Uint8Array.from([4]),y,t.toBytes(A.y))},fromBytes(C){const I=C.length,R=C[0],A=C.subarray(1);if(I===o&&(R===2||R===3)){const y=Yt(A);if(!Uo(y,Ee,t.ORDER))throw new Error("Point is not on curve");const S=h(y);let T;try{T=t.sqrt(S)}catch(z){const K=z instanceof Error?": "+z.message:"";throw new Error("Point is not on curve"+K)}const O=(T&Ee)===Ee;return(R&1)===1!==O&&(T=t.neg(T)),{x:y,y:T}}else if(I===a&&R===4){const y=t.fromBytes(A.subarray(0,t.BYTES)),S=t.fromBytes(A.subarray(t.BYTES,2*t.BYTES));return{x:y,y:S}}else{const y=o,S=a;throw new Error("invalid Point, expected length of "+y+", or uncompressed "+S+", got "+I)}}});function f(C){const I=n>>Ee;return C>I}function g(C){return f(C)?c(-C):C}const m=(C,I,R)=>Yt(C.slice(I,R));class v{constructor(I,R,A){Ye("r",I,Ee,n),Ye("s",R,Ee,n),this.r=I,this.s=R,A!=null&&(this.recovery=A),Object.freeze(this)}static fromCompact(I){const R=s;return I=de("compactSignature",I,R*2),new v(m(I,0,R),m(I,R,2*R))}static fromDER(I){const{r:R,s:A}=vt.toSig(de("DER",I));return new v(R,A)}assertValidity(){}addRecoveryBit(I){return new v(this.r,this.s,I)}recoverPublicKey(I){const{r:R,s:A,recovery:y}=this,S=x(de("msgHash",I));if(y==null||![0,1,2,3].includes(y))throw new Error("recovery id invalid");const T=y===2||y===3?R+e.n:R;if(T>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const O=(y&1)===0?"02":"03",B=u.fromHex(O+ui(T,t.BYTES)),z=l(T),K=c(-S*z),W=c(A*z),H=u.BASE.multiplyAndAddUnsafe(B,K,W);if(!H)throw new Error("point at infinify");return H.assertValidity(),H}hasHighS(){return f(this.s)}normalizeS(){return this.hasHighS()?new v(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return ss(this.toDERHex())}toDERHex(){return vt.hexFromSig(this)}toCompactRawBytes(){return ss(this.toCompactHex())}toCompactHex(){const I=s;return ui(this.r,I)+ui(this.s,I)}}const k={isValidPrivateKey(C){try{return d(C),!0}catch{return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{const C=mu(e.n);return og(e.randomBytes(C),e.n)},precompute(C=8,I=u.BASE){return I._setWindowSize(C),I.multiply(BigInt(3)),I}};function b(C,I=!0){return u.fromPrivateKey(C).toRawBytes(I)}function w(C){if(typeof C=="bigint")return!1;if(C instanceof u)return!0;const R=de("key",C).length,A=t.BYTES,y=A+1,S=2*A+1;if(!(e.allowedPrivateKeyLengths||s===y))return R===y||R===S}function E(C,I,R=!0){if(w(C)===!0)throw new Error("first arg must be private key");if(w(I)===!1)throw new Error("second arg must be public key");return u.fromHex(I).multiply(d(C)).toRawBytes(R)}const P=e.bits2int||function(C){if(C.length>8192)throw new Error("input is too large");const I=Yt(C),R=C.length*8-i;return R>0?I>>BigInt(R):I},x=e.bits2int_modN||function(C){return c(P(C))},_=Us(i);function D(C){return Ye("num < 2^"+i,C,St,_),wn(C,s)}function U(C,I,R=L){if(["recovered","canonical"].some(ee=>ee in R))throw new Error("sign() legacy options not supported");const{hash:A,randomBytes:y}=e;let{lowS:S,prehash:T,extraEntropy:O}=R;S==null&&(S=!0),C=de("msgHash",C),qa(R),T&&(C=de("prehashed msgHash",A(C)));const B=x(C),z=d(I),K=[D(z),D(B)];if(O!=null&&O!==!1){const ee=O===!0?y(t.BYTES):O;K.push(de("extraEntropy",ee))}const W=yr(...K),H=B;function te(ee){const Se=P(ee);if(!p(Se))return;const $e=l(Se),be=u.BASE.multiply(Se).toAffine(),ke=c(be.x);if(ke===St)return;const Ve=c($e*c(H+ke*z));if(Ve===St)return;let et=(be.x===ke?0:2)|Number(be.y&Ee),Or=Ve;return S&&f(Ve)&&(Or=g(Ve),et^=1),new v(ke,Or,et)}return{seed:W,k2sig:te}}const L={lowS:e.lowS,prehash:!1},N={lowS:e.lowS,prehash:!1};function M(C,I,R=L){const{seed:A,k2sig:y}=U(C,I,R),S=e;return Qp(S.hash.outputLen,S.nByteLength,S.hmac)(A,y)}u.BASE._setWindowSize(8);function $(C,I,R,A=N){const y=C;I=de("msgHash",I),R=de("publicKey",R);const{lowS:S,prehash:T,format:O}=A;if(qa(A),"strict"in A)throw new Error("options.strict was renamed to lowS");if(O!==void 0&&O!=="compact"&&O!=="der")throw new Error("format must be compact or der");const B=typeof y=="string"||yn(y),z=!B&&!O&&typeof y=="object"&&y!==null&&typeof y.r=="bigint"&&typeof y.s=="bigint";if(!B&&!z)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let K,W;try{if(z&&(K=new v(y.r,y.s)),B){try{O!=="compact"&&(K=v.fromDER(y))}catch(et){if(!(et instanceof vt.Err))throw et}!K&&O!=="der"&&(K=v.fromCompact(y))}W=u.fromHex(R)}catch{return!1}if(!K||S&&K.hasHighS())return!1;T&&(I=e.hash(I));const{r:H,s:te}=K,ee=x(I),Se=l(te),$e=c(ee*Se),be=c(H*Se),ke=u.BASE.multiplyAndAddUnsafe(W,$e,be)?.toAffine();return ke?c(ke.x)===H:!1}return{CURVE:e,getPublicKey:b,getSharedSecret:E,sign:M,verify:$,ProjectivePoint:u,Signature:v,utils:k}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function pm(r){return{hash:r,hmac:(e,...t)=>Bs(r,e,Pp(...t)),randomBytes:Fs}}function gm(r,e){const t=n=>fm({...r,...pm(n)});return{...t(e),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Du=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Wa=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),mm=BigInt(0),ym=BigInt(1),no=BigInt(2),Va=(r,e)=>(r+e/no)/e;function wm(r){const e=Du,t=BigInt(3),n=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),l=r*r*r%e,u=l*l*r%e,d=ue(u,t,e)*u%e,h=ue(d,t,e)*u%e,p=ue(h,no,e)*l%e,f=ue(p,s,e)*p%e,g=ue(f,i,e)*f%e,m=ue(g,a,e)*g%e,v=ue(m,c,e)*m%e,k=ue(v,a,e)*g%e,b=ue(k,t,e)*u%e,w=ue(b,o,e)*f%e,E=ue(w,n,e)*l%e,P=ue(E,no,e);if(!so.eql(so.sqr(P),r))throw new Error("Cannot find square root");return P}const so=bn(Du,void 0,void 0,{sqrt:wm}),cs=gm({a:mm,b:BigInt(7),Fp:so,n:Wa,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{const e=Wa,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-ym*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=t,o=BigInt("0x100000000000000000000000000000000"),a=Va(i*r,e),c=Va(-n*r,e);let l=ce(r-a*t-c*s,e),u=ce(-a*n-c*i,e);const d=l>o,h=u>o;if(d&&(l=e-l),h&&(u=e-u),l>o||u>o)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:d,k1:l,k2neg:h,k2:u}}}},au);function bm(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}function vm(r,e,t){const n=Zl.digest(t instanceof Uint8Array?t:t.subarray());if(bm(n))return n.then(({digest:s})=>cs.verify(e,s,r)).catch(s=>{throw new za(String(s))});try{return cs.verify(e,n.digest,r)}catch(s){throw new za(String(s))}}class Em{type="secp256k1";raw;_key;constructor(e){this._key=xm(e),this.raw=Sm(this._key)}toMultihash(){return pn.digest(At(this))}toCID(){return ae.createV1(114,this.toMultihash())}toString(){return ye.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Oe(this.raw,e.raw)}verify(e,t){return vm(this._key,t,e)}}function Mu(r){return new Em(r)}function Sm(r){return cs.ProjectivePoint.fromHex(r).toRawBytes(!0)}function xm(r){try{return cs.ProjectivePoint.fromHex(r),r}catch(e){throw new Nl(String(e))}}async function Am(r,e){return Ig()}function Bt(r,e){const{Type:t,Data:n}=wr.decode(r),s=n??new Uint8Array;switch(t){case Ce.RSA:return im(s,e);case Ce.Ed25519:return Iu(s);case Ce.secp256k1:return Mu(s);case Ce.ECDSA:return ru(s);default:throw new Lo}}function Cm(r){const{Type:e,Data:t}=wr.decode(r.digest),n=t??new Uint8Array;switch(e){case Ce.Ed25519:return Iu(n);case Ce.secp256k1:return Mu(n);case Ce.ECDSA:return ru(n);default:throw new Lo}}function At(r){return wr.encode({Type:Ce[r.type],Data:r.raw})}const Ru=Symbol.for("nodejs.util.inspect.custom"),Im=114;class Xo{type;multihash;publicKey;string;constructor(e){this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[Co]=!0;toString(){return this.string==null&&(this.string=ye.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ae.createV1(Im,this.multihash)}toJSON(){return this.toString()}equals(e){if(e==null)return!1;if(e instanceof Uint8Array)return Oe(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(e?.toMultihash()?.bytes!=null)return Oe(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[Ru](){return`PeerId(${this.toString()})`}}class Ou extends Xo{type="RSA";publicKey;constructor(e){super({...e,type:"RSA"}),this.publicKey=e.publicKey}}class Nu extends Xo{type="Ed25519";publicKey;constructor(e){super({...e,type:"Ed25519"}),this.publicKey=e.publicKey}}class Fu extends Xo{type="secp256k1";publicKey;constructor(e){super({...e,type:"secp256k1"}),this.publicKey=e.publicKey}}const Tm=2336;class Uu{type="url";multihash;publicKey;url;constructor(e){this.url=e.toString(),this.multihash=pn.digest(q(this.url))}[Ru](){return`PeerId(${this.url})`}[Co]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return ae.createV1(Tm,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=Y(e)),e.toString()===this.toString())}}const km=114,Ha=2336;function pt(r,e){let t;if(r.charAt(0)==="1"||r.charAt(0)==="Q")t=tr(ye.decode(`z${r}`));else{if(r.startsWith("k51qzi5uqu5")||r.startsWith("kzwfwjn5ji4")||r.startsWith("k2k4r8")||r.startsWith("bafz"))return En(ae.parse(r));throw new V('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return vn(t)}function rn(r){if(r.type==="Ed25519")return new Nu({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new Fu({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new Ou({multihash:r.toCID().multihash,publicKey:r});throw new Lo}function _m(r){return rn(r.publicKey)}function vn(r){if(Lm(r))return new Ou({multihash:r});if(Pm(r))try{const e=Cm(r);if(e.type==="Ed25519")return new Nu({multihash:r,publicKey:e});if(e.type==="secp256k1")return new Fu({multihash:r,publicKey:e})}catch{const t=Y(r.digest);return new Uu(new URL(t))}throw new $h("Supplied PeerID Multihash is invalid")}function En(r){if(r?.multihash==null||r.version==null||r.version===1&&r.code!==km&&r.code!==Ha)throw new Bh("Supplied PeerID CID is invalid");if(r.code===Ha){const e=Y(r.multihash.digest);return new Uu(new URL(e))}return vn(r.multihash)}function Pm(r){return r.code===pn.code}function Lm(r){return r.code===Zl.code}const Dm=8,Qo=1024*1024*4;let Mm=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},Bu=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},Rm=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"},Ga=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};function $u(r){return r[Symbol.asyncIterator]!=null}function zu(r,e){if(r.byteLength>e)throw new Bu("Message length too long")}const $s=r=>{const e=Ae(r),t=ft(e);return dt(r,t),$s.bytes=e,t};$s.bytes=0;function ls(r,e){e=e??{};const t=e.lengthEncoder??$s,n=e?.maxDataLength??Qo;function*s(i){zu(i,n);const o=t(i.byteLength);o instanceof Uint8Array?yield o:yield*o,i instanceof Uint8Array?yield i:yield*i}return $u(r)?async function*(){for await(const i of r)yield*s(i)}():function*(){for(const i of r)yield*s(i)}()}ls.single=(r,e)=>{e=e??{};const t=e.lengthEncoder??$s,n=e?.maxDataLength??Qo;return zu(r,n),new Z(t(r.byteLength),r)};var Wt;(function(r){r[r.LENGTH=0]="LENGTH",r[r.DATA=1]="DATA"})(Wt||(Wt={}));const jo=r=>{const e=rr(r);return jo.bytes=Ae(e),e};jo.bytes=0;function us(r,e){const t=new Z;let n=Wt.LENGTH,s=-1;const i=e?.lengthDecoder??jo,o=e?.maxLengthLength??Dm,a=e?.maxDataLength??Qo;function*c(){for(;t.byteLength>0;){if(n===Wt.LENGTH)try{if(s=i(t),s<0)throw new Mm("Invalid message length");if(s>a)throw new Bu("Message length too long");const l=i.bytes;t.consume(l),e?.onLength!=null&&e.onLength(s),n=Wt.DATA}catch(l){if(l instanceof RangeError){if(t.byteLength>o)throw new Rm("Message length length too long");break}throw l}if(n===Wt.DATA){if(t.byteLength<s)break;const l=t.sublist(0,s);t.consume(s),e?.onData!=null&&e.onData(l),yield l,n=Wt.LENGTH}}}return $u(r)?async function*(){for await(const l of r)t.append(l),yield*c();if(t.byteLength>0)throw new Ga("Unexpected end of input")}():function*(){for(const l of r)t.append(l),yield*c();if(t.byteLength>0)throw new Ga("Unexpected end of input")}()}us.fromReader=(r,e)=>{let t=1;const n=async function*(){for(;;)try{const{done:i,value:o}=await r.next(t);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{t=1}}();return us(n,{...e??{},onLength:i=>{t=i}})};function he(){const r={};return r.promise=new Promise((e,t)=>{r.resolve=e,r.reject=t}),r}let Ya=class extends Error{type;code;constructor(e,t,n){super(e??"The operation was aborted"),this.type="aborted",this.name=n??"AbortError",this.code=t??"ABORT_ERR"}};async function Je(r,e,t){if(e==null)return r;if(e.aborted)return r.catch(()=>{}),Promise.reject(new Ya(t?.errorMessage,t?.errorCode,t?.errorName));let n;const s=new Ya(t?.errorMessage,t?.errorCode,t?.errorName);try{return await Promise.race([r,new Promise((i,o)=>{n=()=>{o(s)},e.addEventListener("abort",n)})])}finally{n!=null&&e.removeEventListener("abort",n)}}class Om{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=he(),this.haveNext=he()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=he(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=he(),await Je(this.readNext.promise,t?.signal,t)}}function Ku(){return new Om}class Nm extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"}function ds(r,e){const t=Ku();r.sink(t).catch(async o=>{await t.end(o)}),r.sink=async o=>{for await(const a of o)await t.push(a);await t.end()};let n=r.source;r.source[Symbol.iterator]!=null?n=r.source[Symbol.iterator]():r.source[Symbol.asyncIterator]!=null&&(n=r.source[Symbol.asyncIterator]());const s=new Z;return{read:async o=>{if(o?.signal?.throwIfAborted(),o?.bytes==null){const{done:c,value:l}=await Je(n.next(),o?.signal);return c===!0?null:l}for(;s.byteLength<o.bytes;){const{value:c,done:l}=await Je(n.next(),o?.signal);if(l===!0)throw new Nm("unexpected end of input");s.append(c)}const a=s.sublist(0,o.bytes);return s.consume(o.bytes),a},write:async(o,a)=>{a?.signal?.throwIfAborted(),o instanceof Uint8Array?await t.push(o,a):await t.push(o.subarray(),a)},unwrap:()=>{if(s.byteLength>0){const o=r.source;r.source=async function*(){e?.yieldBytes===!1?yield s:yield*s,yield*o}()}return r}}}class Fm extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"}class Um extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"}class Bm extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"}function br(r,e={}){const t=ds(r,e);e.maxDataLength!=null&&e.maxLengthLength==null&&(e.maxLengthLength=Ae(e.maxDataLength));const n=e?.lengthDecoder??rr,s=e?.lengthEncoder??dt;return{read:async o=>{let a=-1;const c=new Z;for(;;){c.append(await t.read({...o,bytes:1}));try{a=n(c)}catch(l){if(l instanceof RangeError)continue;throw l}if(a<0)throw new Fm("Invalid message length");if(e?.maxLengthLength!=null&&c.byteLength>e.maxLengthLength)throw new Bm("message length length too long");if(a>-1)break}if(e?.maxDataLength!=null&&a>e.maxDataLength)throw new Um("message length too long");return t.read({...o,bytes:a})},write:async(o,a)=>{await t.write(new Z(s(o.byteLength),o),a)},writeV:async(o,a)=>{const c=new Z(...o.flatMap(l=>[s(l.byteLength),l]));await t.write(c,a)},unwrap:()=>t.unwrap()}}function Xa(){const r=he();let e=!1;return{sink:async t=>{if(e)throw new Error("already piped");e=!0,r.resolve(t)},source:async function*(){yield*await r.promise}()}}function $m(){const r=Xa(),e=Xa();return[{source:r.source,sink:e.sink},{source:e.source,sink:r.sink}]}class Qa{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||(e-1&e)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}}class hi{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new Qa(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return e?.byteLength!=null?e.byteLength:1}push(e){if(e?.value!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new Qa(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return e?.value!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}let zm=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}};function Sn(r={}){return Km(t=>{const n=t.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function Km(r,e){e=e??{};let t=e.onEnd,n=new hi,s,i,o,a=he();const c=async()=>{try{return n.isEmpty()?o?{done:!0}:await new Promise((m,v)=>{i=k=>{i=null,n.push(k);try{m(r(n))}catch(b){v(b)}return s}}):r(n)}finally{n.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=he()})}},l=m=>i!=null?i(m):(n.push(m),s),u=m=>(n=new hi,i!=null?i({error:m}):(n.push({error:m}),s)),d=m=>{if(o)return s;if(e?.objectMode!==!0&&m?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:m})},h=m=>o?s:(o=!0,m!=null?u(m):l({done:!0})),p=()=>(n=new hi,h(),{done:!0}),f=m=>(h(m),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:c,return:p,throw:f,push:d,end:h,get readableLength(){return n.size},onEmpty:async m=>{const v=m?.signal;if(v?.throwIfAborted(),n.isEmpty())return;let k,b;v!=null&&(k=new Promise((w,E)=>{b=()=>{E(new zm)},v.addEventListener("abort",b)}));try{await Promise.race([a.promise,k])}finally{b!=null&&v!=null&&v?.removeEventListener("abort",b)}}},t==null)return s;const g=s;return s={[Symbol.asyncIterator](){return this},next(){return g.next()},throw(m){return g.throw(m),t!=null&&(t(m),t=void 0),{done:!0}},return(){return g.return(),t!=null&&(t(),t=void 0),{done:!0}},push:d,end(m){return g.end(m),t!=null&&(t(m),t=void 0),s},get readableLength(){return g.readableLength},onEmpty:m=>g.onEmpty(m)},s}function qm(r){return r[Symbol.asyncIterator]!=null}async function Wm(r,e,t){try{await Promise.all(r.map(async n=>{for await(const s of n)await e.push(s,{signal:t}),t.throwIfAborted()})),await e.end(void 0,{signal:t})}catch(n){await e.end(n,{signal:t}).catch(()=>{})}}async function*Vm(r){const e=new AbortController,t=Ku();Wm(r,t,e.signal).catch(()=>{});try{yield*t}finally{e.abort()}}function*Hm(r){for(const e of r)yield*e}function hs(...r){const e=[];for(const t of r)qm(t)||e.push(t);return e.length===r.length?Hm(e):Vm(r)}function qu(r,...e){if(r==null)throw new Error("Empty pipeline");if(fi(r)){const n=r;r=()=>n.source}else if(Vu(r)||Wu(r)){const n=r;r=()=>n}const t=[r,...e];if(t.length>1&&fi(t[t.length-1])&&(t[t.length-1]=t[t.length-1].sink),t.length>2)for(let n=1;n<t.length-1;n++)fi(t[n])&&(t[n]=Ym(t[n]));return Gm(...t)}const Gm=(...r)=>{let e;for(;r.length>0;)e=r.shift()(e);return e},Wu=r=>r?.[Symbol.asyncIterator]!=null,Vu=r=>r?.[Symbol.iterator]!=null,fi=r=>r==null?!1:r.sink!=null&&r.source!=null,Ym=r=>e=>{const t=r.sink(e);if(t?.then!=null){const n=Sn({objectMode:!0});t.then(()=>{n.end()},o=>{n.end(o)});let s;const i=r.source;if(Wu(i))s=async function*(){yield*i,n.end()};else if(Vu(i))s=function*(){yield*i,n.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return hs(n,s())}return r.source};var Xm={};const nn=65535,ja=nn-16,xn=!!Xm?.DUMP_SESSION_KEYS;/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function Hu(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function io(r){if(typeof r!="boolean")throw new Error(`boolean expected, not ${r}`)}function pi(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function Ke(r,...e){if(!Hu(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function Za(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Qm(r,e){Ke(r);const t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function Nt(r){return new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength/4))}function vr(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function jm(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}const Zm=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Jm(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}function oo(r){if(typeof r=="string")r=Jm(r);else if(Hu(r))r=ao(r);else throw new Error("Uint8Array expected, got "+typeof r);return r}function ey(r,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(r,e)}function ty(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}const ry=(r,e)=>{function t(n,...s){if(Ke(n),!Zm)throw new Error("Non little-endian hardware is not yet supported");if(r.nonceLength!==void 0){const u=s[0];if(!u)throw new Error("nonce / iv required");r.varSizeNonce?Ke(u):Ke(u,r.nonceLength)}const i=r.tagLength;i&&s[1]!==void 0&&Ke(s[1]);const o=e(n,...s),a=(u,d)=>{if(d!==void 0){if(u!==2)throw new Error("cipher output not supported");Ke(d)}};let c=!1;return{encrypt(u,d){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,Ke(u),a(o.encrypt.length,d),o.encrypt(u,d)},decrypt(u,d){if(Ke(u),i&&u.length<i)throw new Error("invalid ciphertext length: smaller than tagLength="+i);return a(o.decrypt.length,d),o.decrypt(u,d)}}}return Object.assign(t,r),t};function Ja(r,e,t=!0){if(e===void 0)return new Uint8Array(r);if(e.length!==r)throw new Error("invalid output length, expected "+r+", got: "+e.length);if(t&&!sy(e))throw new Error("invalid output, must be aligned");return e}function ec(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const s=BigInt(32),i=BigInt(4294967295),o=Number(t>>s&i),a=Number(t&i),c=4,l=0;r.setUint32(e+c,o,n),r.setUint32(e+l,a,n)}function ny(r,e,t){io(t);const n=new Uint8Array(16),s=jm(n);return ec(s,0,BigInt(e),t),ec(s,8,BigInt(r),t),n}function sy(r){return r.byteOffset%4===0}function ao(r){return Uint8Array.from(r)}const Gu=r=>Uint8Array.from(r.split("").map(e=>e.charCodeAt(0))),iy=Gu("expand 16-byte k"),oy=Gu("expand 32-byte k"),ay=Nt(iy),cy=Nt(oy);function J(r,e){return r<<e|r>>>32-e}function co(r){return r.byteOffset%4===0}const On=64,ly=16,Yu=2**32-1,tc=new Uint32Array;function uy(r,e,t,n,s,i,o,a){const c=s.length,l=new Uint8Array(On),u=Nt(l),d=co(s)&&co(i),h=d?Nt(s):tc,p=d?Nt(i):tc;for(let f=0;f<c;o++){if(r(e,t,n,u,o,a),o>=Yu)throw new Error("arx: counter overflow");const g=Math.min(On,c-f);if(d&&g===On){const m=f/4;if(f%4!==0)throw new Error("arx: invalid block position");for(let v=0,k;v<ly;v++)k=m+v,p[k]=h[k]^u[v];f+=On;continue}for(let m=0,v;m<g;m++)v=f+m,i[v]=s[v]^l[m];f+=g}}function dy(r,e){const{allowShortKeys:t,extendNonceFn:n,counterLength:s,counterRight:i,rounds:o}=ey({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof r!="function")throw new Error("core must be a function");return pi(s),pi(o),io(i),io(t),(a,c,l,u,d=0)=>{Ke(a),Ke(c),Ke(l);const h=l.length;if(u===void 0&&(u=new Uint8Array(h)),Ke(u),pi(d),d<0||d>=Yu)throw new Error("arx: counter overflow");if(u.length<h)throw new Error(`arx: output (${u.length}) is shorter than data (${h})`);const p=[];let f=a.length,g,m;if(f===32)p.push(g=ao(a)),m=cy;else if(f===16&&t)g=new Uint8Array(32),g.set(a),g.set(a,16),m=ay,p.push(g);else throw new Error(`arx: invalid 32-byte key, got length=${f}`);co(c)||p.push(c=ao(c));const v=Nt(g);if(n){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");n(m,v,Nt(c.subarray(0,16)),v),c=c.subarray(16)}const k=16-s;if(k!==c.length)throw new Error(`arx: nonce must be ${k} or 16 bytes`);if(k!==12){const w=new Uint8Array(12);w.set(c,i?0:12-c.length),c=w,p.push(c)}const b=Nt(c);return uy(r,m,v,b,l,u,d,o),vr(...p),u}}const xe=(r,e)=>r[e++]&255|(r[e++]&255)<<8;class hy{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=oo(e),Ke(e,32);const t=xe(e,0),n=xe(e,2),s=xe(e,4),i=xe(e,6),o=xe(e,8),a=xe(e,10),c=xe(e,12),l=xe(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|n<<3)&8191,this.r[2]=(n>>>10|s<<6)&7939,this.r[3]=(s>>>7|i<<9)&8191,this.r[4]=(i>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|l<<8)&8191,this.r[9]=l>>>5&127;for(let u=0;u<8;u++)this.pad[u]=xe(e,16+2*u)}process(e,t,n=!1){const s=n?0:2048,{h:i,r:o}=this,a=o[0],c=o[1],l=o[2],u=o[3],d=o[4],h=o[5],p=o[6],f=o[7],g=o[8],m=o[9],v=xe(e,t+0),k=xe(e,t+2),b=xe(e,t+4),w=xe(e,t+6),E=xe(e,t+8),P=xe(e,t+10),x=xe(e,t+12),_=xe(e,t+14);let D=i[0]+(v&8191),U=i[1]+((v>>>13|k<<3)&8191),L=i[2]+((k>>>10|b<<6)&8191),N=i[3]+((b>>>7|w<<9)&8191),M=i[4]+((w>>>4|E<<12)&8191),$=i[5]+(E>>>1&8191),C=i[6]+((E>>>14|P<<2)&8191),I=i[7]+((P>>>11|x<<5)&8191),R=i[8]+((x>>>8|_<<8)&8191),A=i[9]+(_>>>5|s),y=0,S=y+D*a+U*(5*m)+L*(5*g)+N*(5*f)+M*(5*p);y=S>>>13,S&=8191,S+=$*(5*h)+C*(5*d)+I*(5*u)+R*(5*l)+A*(5*c),y+=S>>>13,S&=8191;let T=y+D*c+U*a+L*(5*m)+N*(5*g)+M*(5*f);y=T>>>13,T&=8191,T+=$*(5*p)+C*(5*h)+I*(5*d)+R*(5*u)+A*(5*l),y+=T>>>13,T&=8191;let O=y+D*l+U*c+L*a+N*(5*m)+M*(5*g);y=O>>>13,O&=8191,O+=$*(5*f)+C*(5*p)+I*(5*h)+R*(5*d)+A*(5*u),y+=O>>>13,O&=8191;let B=y+D*u+U*l+L*c+N*a+M*(5*m);y=B>>>13,B&=8191,B+=$*(5*g)+C*(5*f)+I*(5*p)+R*(5*h)+A*(5*d),y+=B>>>13,B&=8191;let z=y+D*d+U*u+L*l+N*c+M*a;y=z>>>13,z&=8191,z+=$*(5*m)+C*(5*g)+I*(5*f)+R*(5*p)+A*(5*h),y+=z>>>13,z&=8191;let K=y+D*h+U*d+L*u+N*l+M*c;y=K>>>13,K&=8191,K+=$*a+C*(5*m)+I*(5*g)+R*(5*f)+A*(5*p),y+=K>>>13,K&=8191;let W=y+D*p+U*h+L*d+N*u+M*l;y=W>>>13,W&=8191,W+=$*c+C*a+I*(5*m)+R*(5*g)+A*(5*f),y+=W>>>13,W&=8191;let H=y+D*f+U*p+L*h+N*d+M*u;y=H>>>13,H&=8191,H+=$*l+C*c+I*a+R*(5*m)+A*(5*g),y+=H>>>13,H&=8191;let te=y+D*g+U*f+L*p+N*h+M*d;y=te>>>13,te&=8191,te+=$*u+C*l+I*c+R*a+A*(5*m),y+=te>>>13,te&=8191;let ee=y+D*m+U*g+L*f+N*p+M*h;y=ee>>>13,ee&=8191,ee+=$*d+C*u+I*l+R*c+A*a,y+=ee>>>13,ee&=8191,y=(y<<2)+y|0,y=y+S|0,S=y&8191,y=y>>>13,T+=y,i[0]=S,i[1]=T,i[2]=O,i[3]=B,i[4]=z,i[5]=K,i[6]=W,i[7]=H,i[8]=te,i[9]=ee}finalize(){const{h:e,pad:t}=this,n=new Uint16Array(10);let s=e[1]>>>13;e[1]&=8191;for(let a=2;a<10;a++)e[a]+=s,s=e[a]>>>13,e[a]&=8191;e[0]+=s*5,s=e[0]>>>13,e[0]&=8191,e[1]+=s,s=e[1]>>>13,e[1]&=8191,e[2]+=s,n[0]=e[0]+5,s=n[0]>>>13,n[0]&=8191;for(let a=1;a<10;a++)n[a]=e[a]+s,s=n[a]>>>13,n[a]&=8191;n[9]-=8192;let i=(s^1)-1;for(let a=0;a<10;a++)n[a]&=i;i=~i;for(let a=0;a<10;a++)e[a]=e[a]&i|n[a];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let o=e[0]+t[0];e[0]=o&65535;for(let a=1;a<8;a++)o=(e[a]+t[a]|0)+(o>>>16)|0,e[a]=o&65535;vr(n)}update(e){Za(this),e=oo(e),Ke(e);const{buffer:t,blockLen:n}=this,s=e.length;for(let i=0;i<s;){const o=Math.min(n-this.pos,s-i);if(o===n){for(;n<=s-i;i+=n)this.process(e,i);continue}t.set(e.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===n&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){vr(this.h,this.r,this.buffer,this.pad)}digestInto(e){Za(this),Qm(e,this),this.finished=!0;const{buffer:t,h:n}=this;let{pos:s}=this;if(s){for(t[s++]=1;s<16;s++)t[s]=0;this.process(t,0,!0)}this.finalize();let i=0;for(let o=0;o<8;o++)e[i++]=n[o]>>>0,e[i++]=n[o]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}}function fy(r){const e=(n,s)=>r(s).update(oo(n)).digest(),t=r(new Uint8Array(32));return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=n=>r(n),e}const py=fy(r=>new hy(r));function gy(r,e,t,n,s,i=20){let o=r[0],a=r[1],c=r[2],l=r[3],u=e[0],d=e[1],h=e[2],p=e[3],f=e[4],g=e[5],m=e[6],v=e[7],k=s,b=t[0],w=t[1],E=t[2],P=o,x=a,_=c,D=l,U=u,L=d,N=h,M=p,$=f,C=g,I=m,R=v,A=k,y=b,S=w,T=E;for(let B=0;B<i;B+=2)P=P+U|0,A=J(A^P,16),$=$+A|0,U=J(U^$,12),P=P+U|0,A=J(A^P,8),$=$+A|0,U=J(U^$,7),x=x+L|0,y=J(y^x,16),C=C+y|0,L=J(L^C,12),x=x+L|0,y=J(y^x,8),C=C+y|0,L=J(L^C,7),_=_+N|0,S=J(S^_,16),I=I+S|0,N=J(N^I,12),_=_+N|0,S=J(S^_,8),I=I+S|0,N=J(N^I,7),D=D+M|0,T=J(T^D,16),R=R+T|0,M=J(M^R,12),D=D+M|0,T=J(T^D,8),R=R+T|0,M=J(M^R,7),P=P+L|0,T=J(T^P,16),I=I+T|0,L=J(L^I,12),P=P+L|0,T=J(T^P,8),I=I+T|0,L=J(L^I,7),x=x+N|0,A=J(A^x,16),R=R+A|0,N=J(N^R,12),x=x+N|0,A=J(A^x,8),R=R+A|0,N=J(N^R,7),_=_+M|0,y=J(y^_,16),$=$+y|0,M=J(M^$,12),_=_+M|0,y=J(y^_,8),$=$+y|0,M=J(M^$,7),D=D+U|0,S=J(S^D,16),C=C+S|0,U=J(U^C,12),D=D+U|0,S=J(S^D,8),C=C+S|0,U=J(U^C,7);let O=0;n[O++]=o+P|0,n[O++]=a+x|0,n[O++]=c+_|0,n[O++]=l+D|0,n[O++]=u+U|0,n[O++]=d+L|0,n[O++]=h+N|0,n[O++]=p+M|0,n[O++]=f+$|0,n[O++]=g+C|0,n[O++]=m+I|0,n[O++]=v+R|0,n[O++]=k+A|0,n[O++]=b+y|0,n[O++]=w+S|0,n[O++]=E+T|0}const my=dy(gy,{counterRight:!1,counterLength:4,allowShortKeys:!1}),yy=new Uint8Array(16),rc=(r,e)=>{r.update(e);const t=e.length%16;t&&r.update(yy.subarray(t))},wy=new Uint8Array(32);function nc(r,e,t,n,s){const i=r(e,t,wy),o=py.create(i);s&&rc(o,s),rc(o,n);const a=ny(n.length,s?s.length:0,!0);o.update(a);const c=o.digest();return vr(i,a),c}const by=r=>(e,t,n)=>({encrypt(i,o){const a=i.length;o=Ja(a+16,o,!1),o.set(i);const c=o.subarray(0,-16);r(e,t,c,c,1);const l=nc(r,e,t,c,n);return o.set(l,a),vr(l),o},decrypt(i,o){o=Ja(i.length-16,o,!1);const a=i.subarray(0,-16),c=i.subarray(-16),l=nc(r,e,t,a,n);if(!ty(c,l))throw new Error("invalid tag");return o.set(i.subarray(0,-16)),r(e,t,o,o,1),vr(l),o}}),sc=ry({blockSize:64,nonceLength:12,tagLength:16},by(my));function vy(r,e,t){return Oo(r),t===void 0&&(t=new Uint8Array(r.outputLen)),Bs(r,Jr(t),Jr(e))}const gi=Uint8Array.from([0]),ic=Uint8Array.of();function Ey(r,e,t,n=32){Oo(r),rs(n);const s=r.outputLen;if(n>255*s)throw new Error("Length should be <= 255*HashLen");const i=Math.ceil(n/s);t===void 0&&(t=ic);const o=new Uint8Array(i*s),a=Bs.create(r,e),c=a._cloneInto(),l=new Uint8Array(a.outputLen);for(let u=0;u<i;u++)gi[0]=u+1,c.update(u===0?ic:l).update(t).update(gi).digestInto(l),o.set(l,s*u),a._cloneInto(c);return a.destroy(),c.destroy(),Zt(l,gi),o.slice(0,n)}const Sy={hashSHA256(r){return Xn(r.subarray())},getHKDF(r,e){const t=vy(Xn,e,r),s=Ey(Xn,t,void 0,96),i=s.subarray(0,32),o=s.subarray(32,64),a=s.subarray(64,96);return[i,o,a]},generateX25519KeyPair(){const r=Dn.utils.randomPrivateKey();return{publicKey:Dn.getPublicKey(r),privateKey:r}},generateX25519KeyPairFromSeed(r){return{publicKey:Dn.getPublicKey(r),privateKey:r}},generateX25519SharedKey(r,e){return Dn.getSharedSecret(r.subarray(),e.subarray())},chaCha20Poly1305Encrypt(r,e,t,n){return sc(n,e,t).encrypt(r.subarray())},chaCha20Poly1305Decrypt(r,e,t,n,s){return sc(n,e,t).decrypt(r.subarray(),s)}},xy=Sy;function Ay(r){return{generateKeypair:r.generateX25519KeyPair,dh:(e,t)=>r.generateX25519SharedKey(e.privateKey,t).subarray(0,32),encrypt:r.chaCha20Poly1305Encrypt,decrypt:r.chaCha20Poly1305Decrypt,hash:r.hashSHA256,hkdf:r.getHKDF}}const fs=r=>{const e=ft(2);return e[0]=r>>8,e[1]=r,e};fs.bytes=2;const Qn=r=>{if(r.length<2)throw RangeError("Could not decode int16BE");if(r instanceof Uint8Array){let e=0;return e+=r[0]<<8,e+=r[1],e}return r.getUint16(0)};Qn.bytes=2;function Cy(r){return{xxHandshakeSuccesses:r.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:r.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:r.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:r.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:r.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}function Xu(r,e){!e.enabled||!xn||(r?(e(`LOCAL_STATIC_PUBLIC_KEY ${Y(r.publicKey,"hex")}`),e(`LOCAL_STATIC_PRIVATE_KEY ${Y(r.privateKey,"hex")}`)):e("Missing local static keys."))}function Qu(r,e){!e.enabled||!xn||(r?(e(`LOCAL_PUBLIC_EPHEMERAL_KEY ${Y(r.publicKey,"hex")}`),e(`LOCAL_PRIVATE_EPHEMERAL_KEY ${Y(r.privateKey,"hex")}`)):e("Missing local ephemeral keys."))}function Iy(r,e){!e.enabled||!xn||e(r?`REMOTE_STATIC_PUBLIC_KEY ${Y(r.subarray(),"hex")}`:"Missing remote static public key.")}function ju(r,e){!e.enabled||!xn||e(r?`REMOTE_EPHEMERAL_PUBLIC_KEY ${Y(r.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function Zu(r,e,t){!t.enabled||!xn||(t(`CIPHER_STATE_1 ${r.n.getUint64()} ${r.k&&Y(r.k,"hex")}`),t(`CIPHER_STATE_2 ${e.n.getUint64()} ${e.k&&Y(e.k,"hex")}`))}class Gr extends Error{code;constructor(e="Invalid crypto exchange"){super(e),this.code=Gr.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"}const Ty=0,ky=4294967295,_y="Cipherstate has reached maximum n, a new handshake must be performed";class Py{n;bytes;view;constructor(e=Ty){this.n=e,this.bytes=se(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,e,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>ky)throw new Error(_y)}}const hr=se(0);class Nn{k;n;crypto;constructor(e,t=void 0,n=0){this.crypto=e,this.k=t,this.n=new Py(n)}hasKey(){return!!this.k}encryptWithAd(e,t){if(!this.hasKey())return t;this.n.assertValue();const n=this.crypto.encrypt(t,this.n.getBytes(),e,this.k);return this.n.increment(),n}decryptWithAd(e,t,n){if(!this.hasKey())return t;this.n.assertValue();const s=this.crypto.decrypt(t,this.n.getBytes(),e,this.k,n);return this.n.increment(),s}}class Ly{cs;ck;h;crypto;constructor(e,t){this.crypto=e;const n=q(t,"utf-8");this.h=My(e,n),this.ck=this.h,this.cs=new Nn(e)}mixKey(e){const[t,n]=this.crypto.hkdf(this.ck,e);this.ck=t,this.cs=new Nn(this.crypto,n)}mixHash(e){this.h=this.crypto.hash(new Z(this.h,e))}encryptAndHash(e){const t=this.cs.encryptWithAd(this.h,e);return this.mixHash(t),t}decryptAndHash(e){const t=this.cs.decryptWithAd(this.h,e);return this.mixHash(e),t}split(){const[e,t]=this.crypto.hkdf(this.ck,hr);return[new Nn(this.crypto,e),new Nn(this.crypto,t)]}}class Dy{ss;s;e;rs;re;initiator;crypto;constructor(e){const{crypto:t,protocolName:n,prologue:s,initiator:i,s:o,e:a,rs:c,re:l}=e;this.crypto=t,this.ss=new Ly(t,n),this.ss.mixHash(s),this.initiator=i,this.s=o,this.e=a,this.rs=c,this.re=l}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const e=this.crypto.generateKeypair();return this.ss.mixHash(e.publicKey),this.e=e,e.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(e,t=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(e.byteLength<t+32)throw new Error("message is not long enough");this.re=e.sublist(t,t+32),this.ss.mixHash(this.re)}readS(e,t=0){if(this.rs)throw new Error("remote static public key is already set");const n=32+(this.ss.cs.hasKey()?16:0);if(e.byteLength<t+n)throw new Error("message is not long enough");const s=e.sublist(t,t+n);return this.rs=this.ss.decryptAndHash(s),n}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class Ju extends Dy{writeMessageA(e){return new Z(this.writeE(),this.ss.encryptAndHash(e))}writeMessageB(e){const t=this.writeE();this.writeEE();const n=this.writeS();return this.writeES(),new Z(t,n,this.ss.encryptAndHash(e))}writeMessageC(e){const t=this.writeS();return this.writeSE(),new Z(t,this.ss.encryptAndHash(e))}readMessageA(e){try{return this.readE(e),this.ss.decryptAndHash(e.sublist(32))}catch(t){throw new Gr(`handshake stage 0 validation fail: ${t.message}`)}}readMessageB(e){try{this.readE(e),this.readEE();const t=this.readS(e,32);return this.readES(),this.ss.decryptAndHash(e.sublist(32+t))}catch(t){throw new Gr(`handshake stage 1 validation fail: ${t.message}`)}}readMessageC(e){try{const t=this.readS(e);return this.readSE(),this.ss.decryptAndHash(e.sublist(t))}catch(t){throw new Gr(`handshake stage 2 validation fail: ${t.message}`)}}}function My(r,e){if(e.length<=32){const t=se(32);return t.set(e),t}else return r.hash(e)}var ps;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.webtransportCerthashes!=null)for(const i of t.webtransportCerthashes)n.uint32(10),n.bytes(i);if(t.streamMuxers!=null)for(const i of t.streamMuxers)n.uint32(18),n.string(i);s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={webtransportCerthashes:[],streamMuxers:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(s.limits?.webtransportCerthashes!=null&&i.webtransportCerthashes.length===s.limits.webtransportCerthashes)throw new It('Decode error - map field "webtransportCerthashes" had too many elements');i.webtransportCerthashes.push(t.bytes());break}case 2:{if(s.limits?.streamMuxers!=null&&i.streamMuxers.length===s.limits.streamMuxers)throw new It('Decode error - map field "streamMuxers" had too many elements');i.streamMuxers.push(t.string());break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(ps||(ps={}));var gs;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.identityKey!=null&&t.identityKey.byteLength>0&&(n.uint32(10),n.bytes(t.identityKey)),t.identitySig!=null&&t.identitySig.byteLength>0&&(n.uint32(18),n.bytes(t.identitySig)),t.extensions!=null&&(n.uint32(34),ps.codec().encode(t.extensions,n)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={identityKey:se(0),identitySig:se(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.identityKey=t.bytes();break}case 2:{i.identitySig=t.bytes();break}case 4:{i.extensions=ps.codec().decode(t,t.uint32(),{limits:s.limits?.extensions});break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(gs||(gs={}));async function ed(r,e,t){const n=await r.sign(rd(e));return gs.encode({identityKey:At(r.publicKey),identitySig:n,extensions:t})}async function td(r,e,t){try{const n=gs.decode(r),s=Bt(n.identityKey);if(t?.equals(s)===!1)throw new Error(`Payload identity key ${s} does not match expected remote identity key ${t}`);if(!e)throw new Error("Remote static does not exist");const i=rd(e);if(!await s.verify(i,n.identitySig))throw new Error("Invalid payload signature");return n}catch(n){throw new Oh(n.message)}}function rd(r){const e=q("noise-libp2p-static-key:");return r instanceof Uint8Array?ot([e,r],e.length+r.length):(r.prepend(e),r)}async function Ry(r,e){const{log:t,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=r,u=await ed(i,a.publicKey,l),d=new Ju({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});Xu(d.s,t),t.trace("Stage 0 - Initiator starting to send first message."),await n.write(d.writeMessageA(hr),e),t.trace("Stage 0 - Initiator finished sending first message."),Qu(d.e,t),t.trace("Stage 1 - Initiator waiting to receive first message from responder...");const h=d.readMessageB(await n.read(e));t.trace("Stage 1 - Initiator received the message."),ju(d.re,t),Iy(d.rs,t),t.trace("Initiator going to check remote's signature...");const p=await td(h,d.rs,c);t.trace("All good with the signature!"),t.trace("Stage 2 - Initiator sending third handshake message."),await n.write(d.writeMessageC(u),e),t.trace("Stage 2 - Initiator sent message with signed payload.");const[f,g]=d.ss.split();return Zu(f,g,t),{payload:p,encrypt:m=>f.encryptWithAd(hr,m),decrypt:(m,v)=>g.decryptWithAd(hr,m,v)}}async function Oy(r,e){const{log:t,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=r,u=await ed(i,a.publicKey,l),d=new Ju({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});Xu(d.s,t),t.trace("Stage 0 - Responder waiting to receive first message."),d.readMessageA(await n.read(e)),t.trace("Stage 0 - Responder received first message."),ju(d.re,t),t.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await n.write(d.writeMessageB(u),e),t.trace("Stage 1 - Responder sent the second handshake message with signed payload."),Qu(d.e,t),t.trace("Stage 2 - Responder waiting for third handshake message...");const h=d.readMessageC(await n.read(e));t.trace("Stage 2 - Responder received the message, finished handshake.");const p=await td(h,d.rs,c),[f,g]=d.ss.split();return Zu(f,g,t),{payload:p,encrypt:m=>g.encryptWithAd(hr,m),decrypt:(m,v)=>f.decryptWithAd(hr,m,v)}}const oc=16;function Ny(r,e){return async function*(t){for await(const n of t)for(let s=0;s<n.length;s+=ja){let i=s+ja;i>n.length&&(i=n.length);let o;n instanceof Uint8Array?o=r.encrypt(n.subarray(s,i)):o=r.encrypt(n.sublist(s,i)),e?.encryptedPackets.increment(),yield new Z(fs(o.byteLength),o)}}}function Fy(r,e){return async function*(t){for await(const n of t)for(let s=0;s<n.length;s+=nn){let i=s+nn;if(i>n.length&&(i=n.length),i-oc<s)throw new Error("Invalid chunk");const o=n.sublist(s,i),a=n.subarray(s,i-oc);try{const c=r.decrypt(o,a);e?.decryptedPackets.increment(),yield c}catch(c){throw e?.decryptErrors.increment(),c}}}}class Uy{protocol="/noise";crypto;prologue;staticKey;extensions;metrics;components;constructor(e,t={}){const{staticNoiseKey:n,extensions:s,crypto:i,prologueBytes:o}=t,{metrics:a}=e;this.components=e;const c=i??xy;this.crypto=Ay(c),this.extensions={webtransportCerthashes:[],...s},this.metrics=a?Cy(a):void 0,n?this.staticKey=c.generateX25519KeyPairFromSeed(n):this.staticKey=c.generateX25519KeyPair(),this.prologue=o??se(0)}[Symbol.toStringTag]="@chainsafe/libp2p-noise";[it]=["@libp2p/connection-encryption","@chainsafe/libp2p-noise"];async secureOutbound(e,t){const n=br(e,{lengthEncoder:fs,lengthDecoder:Qn,maxDataLength:nn}),s=await this.performHandshakeInitiator(n,this.components.privateKey,t?.remotePeer?.publicKey,t),i=await this.createSecureConnection(n,s);e.source=i.source,e.sink=i.sink;const o=Bt(s.payload.identityKey);return{conn:e,remoteExtensions:s.payload.extensions,remotePeer:rn(o),streamMuxer:t?.skipStreamMuxerNegotiation===!0?void 0:this.getStreamMuxer(s.payload.extensions?.streamMuxers)}}getStreamMuxer(e){if(e==null||e.length===0)return;const t=this.components.upgrader.getStreamMuxers();if(t!=null)for(const n of e){const s=t.get(n);if(s!=null)return s}if(e.length)throw new Nh("Early muxer negotiation was requested but the initiator and responder had no common muxers")}async secureInbound(e,t){const n=br(e,{lengthEncoder:fs,lengthDecoder:Qn,maxDataLength:nn}),s=await this.performHandshakeResponder(n,this.components.privateKey,t?.remotePeer?.publicKey,t),i=await this.createSecureConnection(n,s);e.source=i.source,e.sink=i.sink;const o=Bt(s.payload.identityKey);return{conn:e,remoteExtensions:s.payload.extensions,remotePeer:rn(o),streamMuxer:t?.skipStreamMuxerNegotiation===!0?void 0:this.getStreamMuxer(s.payload.extensions?.streamMuxers)}}async performHandshakeInitiator(e,t,n,s){let i;const o=s?.skipStreamMuxerNegotiation===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{i=await Ry({connection:e,privateKey:t,remoteIdentityKey:n,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:o,webtransportCerthashes:[],...this.extensions}},s),this.metrics?.xxHandshakeSuccesses.increment()}catch(a){throw this.metrics?.xxHandshakeErrors.increment(),a}return i}async performHandshakeResponder(e,t,n,s){let i;const o=s?.skipStreamMuxerNegotiation===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{i=await Oy({connection:e,privateKey:t,remoteIdentityKey:n,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:o,webtransportCerthashes:[],...this.extensions}},s),this.metrics?.xxHandshakeSuccesses.increment()}catch(a){throw this.metrics?.xxHandshakeErrors.increment(),a}return i}async createSecureConnection(e,t){const[n,s]=$m(),i=e.unwrap();return await qu(n,Ny(t,this.metrics),i,o=>us(o,{lengthDecoder:Qn}),Fy(t,this.metrics),n),s}}function By(r={}){return e=>new Uy(e,r)}function nd(r){if(r!=null){if(typeof r[Symbol.iterator]=="function")return r[Symbol.iterator]();if(typeof r[Symbol.asyncIterator]=="function")return r[Symbol.asyncIterator]();if(typeof r.next=="function")return r}throw new Error("argument is not an iterator or iterable")}class ur extends Error{static name="InvalidFrameError";constructor(e="The frame was invalid"){super(e),this.name="InvalidFrameError"}}class sd extends Error{static name="UnrequestedPingError";constructor(e="Unrequested ping error"){super(e),this.name="UnrequestedPingError"}}class id extends Error{static name="NotMatchingPingError";constructor(e="Unrequested ping error"){super(e),this.name="NotMatchingPingError"}}class $y extends Error{static name="InvalidStateError";constructor(e="Invalid state"){super(e),this.name="InvalidStateError"}}class zy extends Error{static name="StreamAlreadyExistsError";constructor(e="Strean already exists"){super(e),this.name="StreamAlreadyExistsError"}}class Ky extends Error{static name="DecodeInvalidVersionError";constructor(e="Decode invalid version"){super(e),this.name="DecodeInvalidVersionError"}}class qy extends Error{static name="BothClientsError";constructor(e="Both clients"){super(e),this.name="BothClientsError"}}class od extends Error{static name="ReceiveWindowExceededError";constructor(e="Receive window exceeded"){super(e),this.name="ReceiveWindowExceededError"}}const Wy=new Set([ur.name,sd.name,id.name,zy.name,Ky.name,qy.name,od.name]),Zo=256*1024,Vy=16*1024*1024,Hy={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:Zo,maxStreamWindowSize:Vy,maxMessageSize:64*1024};function Gy(r){if(r.keepAliveInterval<=0)throw new V("keep-alive interval must be positive");if(r.maxInboundStreams<0)throw new V("max inbound streams must be larger or equal 0");if(r.maxOutboundStreams<0)throw new V("max outbound streams must be larger or equal 0");if(r.initialStreamWindowSize<Zo)throw new V("InitialStreamWindowSize must be larger or equal 256 kB");if(r.maxStreamWindowSize<r.initialStreamWindowSize)throw new V("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(r.maxStreamWindowSize>2**32-1)throw new V("MaxStreamWindowSize must be less than equal MAX_UINT32");if(r.maxMessageSize<1024)throw new V("MaxMessageSize must be greater than a kilobyte")}var we;(function(r){r[r.Data=0]="Data",r[r.WindowUpdate=1]="WindowUpdate",r[r.Ping=2]="Ping",r[r.GoAway=3]="GoAway"})(we||(we={}));var fe;(function(r){r[r.SYN=1]="SYN",r[r.ACK=2]="ACK",r[r.FIN=4]="FIN",r[r.RST=8]="RST"})(fe||(fe={}));Object.values(fe).filter(r=>typeof r!="string");const Yy=0;var lt;(function(r){r[r.NormalTermination=0]="NormalTermination",r[r.ProtocolError=1]="ProtocolError",r[r.InternalError=2]="InternalError"})(lt||(lt={}));const Yr=12,ac=2**24;function Xy(r){if(r[0]!==Yy)throw new ur("Invalid frame version");return{type:r[1],flag:(r[2]<<8)+r[3],streamID:r[4]*ac+(r[5]<<16)+(r[6]<<8)+r[7],length:r[8]*ac+(r[9]<<16)+(r[10]<<8)+r[11]}}class Qy{source;buffer;frameInProgress;constructor(e){this.source=jy(e),this.buffer=new Z,this.frameInProgress=!1}async*emitFrames(){for await(const e of this.source)for(this.buffer.append(e);;){const t=this.readHeader();if(t===void 0)break;const{type:n,length:s}=t;n===we.Data?(this.frameInProgress=!0,yield{header:t,readData:this.readBytes.bind(this,s)}):yield{header:t}}}readHeader(){if(this.frameInProgress)throw new $y("decoding frame already in progress");if(this.buffer.length<Yr)return;const e=Xy(this.buffer.subarray(0,Yr));return this.buffer.consume(Yr),e}async readBytes(e){if(this.buffer.length<e){for await(const n of this.source)if(this.buffer.append(n),this.buffer.length>=e)break}const t=this.buffer.sublist(0,e);return this.buffer.consume(e),this.frameInProgress=!1,t}}function jy(r){if(r[Symbol.iterator]!==void 0){const e=r[Symbol.iterator]();return e.return=void 0,{[Symbol.iterator](){return e}}}else if(r[Symbol.asyncIterator]!==void 0){const e=r[Symbol.asyncIterator]();return e.return=void 0,{[Symbol.asyncIterator](){return e}}}else throw new Error("a source must be either an iterable or an async iterable")}function cc(r){const e=new Uint8Array(Yr);return e[1]=r.type,e[2]=r.flag>>>8,e[3]=r.flag,e[4]=r.streamID>>>24,e[5]=r.streamID>>>16,e[6]=r.streamID>>>8,e[7]=r.streamID,e[8]=r.length>>>24,e[9]=r.length>>>16,e[10]=r.length>>>8,e[11]=r.length,e}function Zy(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}function Jy(r,e){const t=nd(r).return?.();Zy(t)&&t.catch(n=>{e.error("could not cause iterator to return",n)})}const ew=5e3;function mi(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class ad{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;sendingData;constructor(e){this.sinkController=new AbortController,this.sinkEnd=he(),this.closed=he(),this.log=e.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=e.id,this.metadata=e.metadata??{},this.direction=e.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=e.sendCloseWriteTimeout??ew,this.onEnd=e.onEnd,this.onCloseRead=e.onCloseRead,this.onCloseWrite=e.onCloseWrite,this.onReset=e.onReset,this.onAbort=e.onAbort,this.source=this.streamSource=Sn({onEnd:t=>{t!=null?this.log.trace("source ended with error",t):this.log.trace("source ended"),this.onSourceEnd(t)}}),this.sink=this.sink.bind(this)}async sink(e){if(this.writeStatus!=="ready")throw new Ki(`writable end state is "${this.writeStatus}" not "ready"`);try{this.writeStatus="writing";const t={signal:this.sinkController.signal};if(this.direction==="outbound"){const s=this.sendNewStream(t);mi(s)&&await s}const n=()=>{Jy(e,this.log)};try{this.sinkController.signal.addEventListener("abort",n),this.log.trace("sink reading from source");for await(let s of e){s=s instanceof Uint8Array?new Z(s):s;const i=this.sendData(s,t);mi(i)&&(this.sendingData=he(),await i,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",n)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),this.writeStatus==="writing"&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(t){throw this.log.trace("sink ended with error, calling abort with error",t),this.abort(t),t}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(e){this.timeline.closeRead==null&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),this.onCloseRead?.(),this.timeline.closeWrite!=null?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(e){this.timeline.closeWrite==null&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),this.onCloseWrite?.(),this.timeline.closeRead!=null?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(e){this.status==="open"&&(this.log.trace("closing gracefully"),this.status="closing",await Je(Promise.all([this.closeWrite(e),this.closeRead(e),this.closed.promise]),e?.signal),this.status="closed",this.log.trace("closed gracefully"))}async closeRead(e={}){if(this.readStatus==="closing"||this.readStatus==="closed")return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);const t=this.readStatus;this.readStatus="closing",this.status!=="reset"&&this.status!=="aborted"&&this.timeline.closeRead==null&&(this.log.trace("send close read to remote"),await this.sendCloseRead(e)),t==="ready"&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(e={}){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),this.writeStatus==="ready"&&(this.log.trace("sink was never sunk, sink an empty array"),await Je(this.sink([]),e.signal)),this.writeStatus==="writing"&&(this.sendingData!=null&&await Je(this.sendingData.promise,e.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await Je(this.sinkEnd.promise,e.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(e){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;this.log("abort with error",e),this.log("try to send reset to remote");const t=this.sendReset();mi(t)&&t.catch(n=>{this.log.error("error sending reset message",n)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(e),this.onAbort?.(e)}reset(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;const e=new Uh("stream reset");this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(e),this.onReset?.()}_closeSinkAndSource(e){this._closeSink(e),this._closeSource(e)}_closeSink(e){this.writeStatus==="writing"&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(e)}_closeSource(e){this.readStatus!=="closing"&&this.readStatus!=="closed"&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(e))}remoteCloseWrite(){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("received remote close write but local source is already closed");return}this.log.trace("remote close write"),this._closeSource()}remoteCloseRead(){if(this.writeStatus==="closing"||this.writeStatus==="closed"){this.log("received remote close read but local sink is already closed");return}this.log.trace("remote close read"),this._closeSink()}destroy(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset"){this.log("received destroy but we are already closed");return}this.log.trace("stream destroyed"),this._closeSinkAndSource()}sourcePush(e){this.streamSource.push(e)}sourceReadableLength(){return this.streamSource.readableLength}}function cd(r){const[e,t]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>e.next(),push:s=>{n.push(s)},next:()=>n.length>0?{done:!1,value:n.shift()}:e.next(),[t](){return this}}}function tw(r){return r[Symbol.asyncIterator]!=null}function lc(r){return r?.then!=null}function ld(r,e){let t=0;if(tw(r))return async function*(){for await(const c of r){const l=e(c,t++);lc(l)&&await l,yield c}}();const n=cd(r),{value:s,done:i}=n.next();if(i===!0)return function*(){}();if(typeof e(s,t++)?.then=="function")return async function*(){yield s;for await(const c of n){const l=e(c,t++);lc(l)&&await l,yield c}}();const a=e;return function*(){yield s;for(const c of n)a(c,t++),yield c}()}var nt;(function(r){r[r.Init=0]="Init",r[r.SYNSent=1]="SYNSent",r[r.SYNReceived=2]="SYNReceived",r[r.Established=3]="Established",r[r.Finished=4]="Finished"})(nt||(nt={}));class rw extends ad{name;state;config;_id;sendWindowCapacity;sendWindowCapacityUpdate;recvWindow;recvWindowCapacity;epochStart;getRTT;sendFrame;constructor(e){super({...e,onEnd:t=>{this.state=nt.Finished,e.onEnd?.(t)}}),this.config=e.config,this._id=parseInt(e.id,10),this.name=e.name,this.state=e.state,this.sendWindowCapacity=Zo,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=e.getRTT,this.sendFrame=e.sendFrame,this.source=ld(this.source,()=>{this.sendWindowUpdate()})}async sendNewStream(){}async sendData(e,t={}){for(e=e.sublist();e.byteLength!==0;){if(this.sendWindowCapacity===0&&(this.log?.trace("wait for send window capacity, status %s",this.status),await this.waitForSendWindowCapacity(t),this.status==="closed"||this.status==="aborted"||this.status==="reset")){this.log?.trace("%s while waiting for send window capacity",this.status);return}const n=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-Yr,e.length),s=this.getSendFlags();this.sendFrame({type:we.Data,flag:s,streamID:this._id,length:n},e.sublist(0,n)),this.sendWindowCapacity-=n,e.consume(n)}}async sendReset(){this.sendFrame({type:we.WindowUpdate,flag:fe.RST,streamID:this._id,length:0})}async sendCloseWrite(){const e=this.getSendFlags()|fe.FIN;this.sendFrame({type:we.WindowUpdate,flag:e,streamID:this._id,length:0})}async sendCloseRead(){}async waitForSendWindowCapacity(e={}){if(this.sendWindowCapacity>0)return;let t,n;const s=()=>{this.status==="open"||this.status==="closing"?n(new jt("Stream aborted")):t()};e.signal?.addEventListener("abort",s);try{await new Promise((i,o)=>{this.sendWindowCapacityUpdate=()=>{i()},n=o,t=i})}finally{e.signal?.removeEventListener("abort",s)}}handleWindowUpdate(e){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(e.flag);const t=this.sendWindowCapacity;this.sendWindowCapacity+=e.length,t===0&&e.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(e,t){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(e.flag),this.recvWindowCapacity<e.length)throw new od("Receive window exceeded");const n=await t();this.recvWindowCapacity-=e.length,this.sourcePush(n)}processFlags(e){(e&fe.ACK)===fe.ACK&&this.state===nt.SYNSent&&(this.state=nt.Established),(e&fe.FIN)===fe.FIN&&this.remoteCloseWrite(),(e&fe.RST)===fe.RST&&this.reset()}getSendFlags(){switch(this.state){case nt.Init:return this.state=nt.SYNSent,fe.SYN;case nt.SYNReceived:return this.state=nt.Established,fe.ACK;default:return 0}}sendWindowUpdate(){const e=this.getSendFlags(),t=Date.now(),n=this.getRTT();if(e===0&&n>-1&&t-this.epochStart<n*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&e===0)return;const s=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=t,this.sendFrame({type:we.WindowUpdate,flag:e,streamID:this._id,length:s})}}const ud="/yamux/1.0.0",nw=500;class sw{protocol=ud;_components;_init;constructor(e,t={}){this._components=e,this._init=t}[Symbol.toStringTag]="@chainsafe/libp2p-yamux";[it]=["@libp2p/stream-multiplexing"];createStreamMuxer(e){return new iw(this._components,{...this._init,...e})}}class iw{protocol=ud;source;sink;config;log;logger;closeController;nextStreamID;_streams;nextPingID;activePing;rtt;client;localGoAway;remoteGoAway;numInboundStreams;numOutboundStreams;onIncomingStream;onStreamEnd;constructor(e,t){this.client=t.direction==="outbound",this.config={...Hy,...t},this.logger=e.logger,this.log=this.logger.forComponent("libp2p:yamux"),Gy(this.config),this.closeController=new AbortController,this.closeController.signal,this.onIncomingStream=t.onIncomingStream,this.onStreamEnd=t.onStreamEnd,this._streams=new Map,this.source=Sn({onEnd:()=>{this.log?.trace("muxer source ended"),this._streams.forEach(n=>{n.destroy()})}}),this.sink=async n=>{const s=()=>{const a=nd(n);if(a.return!=null){const c=a.return();ow(c)&&c.catch(l=>{this.log?.("could not cause sink source to return",l)})}};let i,o;try{const a=new Qy(n);try{this.closeController.signal.addEventListener("abort",s);for await(const c of a.emitFrames())await this.handleFrame(c.header,c.readData)}finally{this.closeController.signal.removeEventListener("abort",s)}i=lt.NormalTermination}catch(a){Wy.has(a.name)?(this.log?.error("protocol error in sink",a),i=lt.ProtocolError):(this.log?.error("internal error in sink",a),i=lt.InternalError),o=a}this.log?.trace("muxer sink ended"),o!=null?this.abort(o,i):await this.close({reason:i})},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(n=>this.log?.error("keepalive error: %s",n)),this.ping().catch(n=>this.log?.error("ping error: %s",n))}get streams(){return Array.from(this._streams.values())}newStream(e){if(this.remoteGoAway!==void 0)throw new Nr("Muxer closed remotely");if(this.localGoAway!==void 0)throw new Nr("Muxer closed locally");const t=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new zl("max outbound streams exceeded");this.log?.trace("new outgoing stream id=%s",t);const n=this._newStream(t,e,nt.Init,"outbound");return this._streams.set(t,n),this.numOutboundStreams++,n.sendWindowUpdate(),n}async ping(){if(this.remoteGoAway!==void 0)throw new Nr("Muxer closed remotely");if(this.localGoAway!==void 0)throw new Nr("Muxer closed locally");if(this.activePing===void 0){let e=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((s,i)=>{const o=()=>{i(new Nr("Muxer closed locally"))};this.closeController.signal.addEventListener("abort",o,{once:!0}),e=()=>{this.closeController.signal.removeEventListener("abort",o),s()}}),resolve:e};const t=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}const n=Date.now();this.rtt=n-t}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}async close(e={}){if(this.closeController.signal.aborted)return;const t=e?.reason??lt.NormalTermination;if(this.log?.trace("muxer close reason=%s",t),e.signal==null){const n=AbortSignal.timeout(nw);e={...e,signal:n}}try{await Promise.all([...this._streams.values()].map(async n=>n.close(e))),this.sendGoAway(t),this._closeMuxer()}catch(n){this.abort(n)}}abort(e,t){if(!this.closeController.signal.aborted){t=t??lt.InternalError,this.log?.error("muxer abort reason=%s error=%s",t,e);for(const n of this._streams.values())n.abort(e);this.sendGoAway(t),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(e,t,n,s){if(this._streams.get(e)!=null)throw new V("Stream already exists with that id");const i=new rw({id:e.toString(),name:t,state:n,direction:s,sendFrame:this.sendFrame.bind(this),onEnd:()=>{this.closeStream(e),this.onStreamEnd?.(i)},log:this.logger.forComponent(`libp2p:yamux:${s}:${e}`),config:this.config,getRTT:this.getRTT.bind(this)});return i}closeStream(e){this.client===(e%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(e)}async keepAliveLoop(){const e=new Promise((t,n)=>{this.closeController.signal.addEventListener("abort",n,{once:!0})});for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let t;try{await Promise.race([e,new Promise(n=>{t=setTimeout(n,this.config.keepAliveInterval)})]),this.ping().catch(n=>this.log?.error("ping error: %s",n))}catch{clearInterval(t);return}}}async handleFrame(e,t){const{streamID:n,type:s,length:i}=e;if(this.log?.trace("received frame %o",e),n===0)switch(s){case we.Ping:{this.handlePing(e);return}case we.GoAway:{this.handleGoAway(i);return}default:throw new ur("Invalid frame type")}else switch(e.type){case we.Data:case we.WindowUpdate:{await this.handleStreamMessage(e,t);return}default:throw new ur("Invalid frame type")}}handlePing(e){if(e.flag===fe.SYN)this.log?.trace("received ping request pingId=%s",e.length),this.sendPing(e.length,fe.ACK);else if(e.flag===fe.ACK)this.log?.trace("received ping response pingId=%s",e.length),this.handlePingResponse(e.length);else throw new ur("Invalid frame flag")}handlePingResponse(e){if(this.activePing===void 0)throw new sd("ping not requested");if(this.activePing.id!==e)throw new id("ping doesn't match our id");this.activePing.resolve()}handleGoAway(e){this.log?.trace("received GoAway reason=%s",lt[e]??"unknown"),this.remoteGoAway=e;for(const t of this._streams.values())t.reset();this._closeMuxer()}async handleStreamMessage(e,t){const{streamID:n,flag:s,type:i}=e;(s&fe.SYN)===fe.SYN&&this.incomingStream(n);const o=this._streams.get(n);if(o===void 0){if(i===we.Data){if(this.log?.("discarding data for stream id=%s",n),t===void 0)throw new Error("unreachable");await t()}else this.log?.trace("frame for missing stream id=%s",n);return}switch(i){case we.WindowUpdate:{o.handleWindowUpdate(e);return}case we.Data:{if(t===void 0)throw new Error("unreachable");await o.handleData(e,t);return}default:throw new Error("unreachable")}}incomingStream(e){if(this.client!==(e%2===0))throw new V("Both endpoints are clients");if(this._streams.has(e))return;if(this.log?.trace("new incoming stream id=%s",e),this.localGoAway!==void 0){this.sendFrame({type:we.WindowUpdate,flag:fe.RST,streamID:e,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){this.log?.("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:we.WindowUpdate,flag:fe.RST,streamID:e,length:0});return}const t=this._newStream(e,void 0,nt.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(e,t),this.onIncomingStream?.(t)}sendFrame(e,t){if(this.log?.trace("sending frame %o",e),e.type===we.Data){if(t===void 0)throw new ur("Invalid frame");this.source.push(new Z(cc(e),t))}else this.source.push(cc(e))}sendPing(e,t=fe.SYN){t===fe.SYN?this.log?.trace("sending ping request pingId=%s",e):this.log?.trace("sending ping response pingId=%s",e),this.sendFrame({type:we.Ping,flag:t,streamID:0,length:e})}sendGoAway(e=lt.NormalTermination){this.log?.("sending GoAway reason=%s",lt[e]),this.localGoAway=e,this.sendFrame({type:we.GoAway,flag:0,streamID:0,length:e})}}function ow(r){return r!=null&&typeof r.then=="function"}function aw(r={}){return e=>new sw(e,r)}var ms;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&t.payload.byteLength>0&&(n.uint32(26),n.bytes(t.payload)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={publicKey:se(0),payloadType:se(0),payload:se(0),signature:se(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=t.bytes();break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(ms||(ms={}));class cw extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}}class ht{static createFromProtobuf=async e=>{const t=ms.decode(e),n=Bt(t.publicKey);return new ht({publicKey:n,payloadType:t.payloadType,payload:t.payload,signature:t.signature})};static seal=async(e,t)=>{if(t==null)throw new Error("Missing private key");const n=e.domain,s=e.codec,i=e.marshal(),o=uc(n,s,i),a=await t.sign(o.subarray());return new ht({publicKey:t.publicKey,payloadType:s,payload:i,signature:a})};static openAndCertify=async(e,t)=>{const n=await ht.createFromProtobuf(e);if(!await n.validate(t))throw new cw("Envelope signature is not valid for the given domain");return n};publicKey;payloadType;payload;signature;marshaled;constructor(e){const{publicKey:t,payloadType:n,payload:s,signature:i}=e;this.publicKey=t,this.payloadType=n,this.payload=s,this.signature=i}marshal(){return this.marshaled==null&&(this.marshaled=ms.encode({publicKey:At(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return e==null?!1:Oe(this.marshal(),e.marshal())}async validate(e){const t=uc(e,this.payloadType,this.payload);return this.publicKey.verify(t.subarray(),this.signature)}}const uc=(r,e,t)=>{const n=q(r),s=dt(n.byteLength),i=dt(e.length),o=dt(t.length);return new Z(s,n,i,e,o,t)};function lw(r,e){const t=(n,s)=>n.toString().localeCompare(s.toString());return r.length!==e.length?!1:(e.sort(t),r.sort(t).every((n,s)=>e[s].equals(n)))}class uw{index=0;input="";new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,n=e();return n===void 0&&(this.index=t),n}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{const t=this.readChar();if(t===e)return t})}readSeparator(e,t,n){return this.readAtomically(()=>{if(!(t>0&&this.readGivenChar(e)===void 0))return n()})}readNumber(e,t,n,s){return this.readAtomically(()=>{let i=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",l=2**(8*s)-1;for(;;){const u=this.readAtomically(()=>{const d=this.readChar();if(d===void 0)return;const h=Number.parseInt(d,e);if(!Number.isNaN(h))return h});if(u===void 0)break;if(i*=e,i+=u,i>l||(o+=1,t!==void 0&&o>t))return}if(o!==0)return!n&&c&&o>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const n=this.readSeparator(".",t,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;e[t]=n}return e})}readIPv6Addr(){const e=t=>{for(let n=0;n<t.length/2;n++){const s=n*2;if(n<t.length-3){const o=this.readSeparator(":",n,()=>this.readIPv4Addr());if(o!==void 0)return t[s]=o[0],t[s+1]=o[1],t[s+2]=o[2],t[s+3]=o[3],[s+4,!0]}const i=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(i===void 0)return[s,!1];t[s]=i>>8,t[s+1]=i&255}return[t.length,!1]};return this.readAtomically(()=>{const t=new Uint8Array(16),[n,s]=e(t);if(n===16)return t;if(s||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const i=new Uint8Array(14),o=16-(n+2),[a]=e(i.subarray(0,o));return t.set(i.subarray(0,a),16-a),t})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const dd=45,dw=15,Er=new uw;function hd(r){if(!(r.length>dw))return Er.new(r).parseWith(()=>Er.readIPv4Addr())}function fd(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>dd))return Er.new(r).parseWith(()=>Er.readIPv6Addr())}function ys(r,e=!1){if(r.includes("%")&&(r=r.split("%")[0]),r.length>dd)return;const t=Er.new(r).parseWith(()=>Er.readIPAddr());if(t)return e&&t.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,t[0],t[1],t[2],t[3]]):t}function hw(r,e,t){let n=0;for(const s of r)if(!(n<e)){if(n>t)break;if(s!==255)return!1;n++}return!0}function fw(r,e,t,n){let s=0;for(const i of r)if(!(s<t)){if(s>n)break;if(i!==e[s])return!1;s++}return!0}function pw(r){switch(r.length){case sn:return r.join(".");case on:{const e=[];for(let t=0;t<r.length;t++)t%2===0&&e.push(r[t].toString(16).padStart(2,"0")+r[t+1].toString(16).padStart(2,"0"));return e.join(":")}default:throw new Error("Invalid ip length")}}function gw(r){let e=0;for(let[t,n]of r.entries()){if(n===255){e+=8;continue}for(;(n&128)!=0;)e++,n=n<<1;if((n&128)!=0)return-1;for(let s=t+1;s<r.length;s++)if(r[s]!=0)return-1;break}return e}function mw(r){let e="0x";for(const t of r)e+=(t>>4).toString(16)+(t&15).toString(16);return e}const sn=4,on=16,yw=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function pd(r,e){e.length===on&&r.length===sn&&hw(e,0,11)&&(e=e.slice(12)),e.length===sn&&r.length===on&&fw(r,yw,0,11)&&(r=r.slice(12));const t=r.length;if(t!=e.length)throw new Error("Failed to mask ip");const n=new Uint8Array(t);for(let s=0;s<t;s++)n[s]=r[s]&e[s];return n}function ww(r,e){if(typeof e=="string"&&(e=ys(e)),e==null)throw new Error("Invalid ip");if(e.length!==r.network.length)return!1;for(let t=0;t<e.length;t++)if((r.network[t]&r.mask[t])!==(e[t]&r.mask[t]))return!1;return!0}function bw(r){const[e,t]=r.split("/");if(!e||!t)throw new Error("Failed to parse given CIDR: "+r);let n=sn,s=hd(e);if(s==null&&(n=on,s=fd(e),s==null))throw new Error("Failed to parse given CIDR: "+r);const i=parseInt(t,10);if(Number.isNaN(i)||String(i).length!==t.length||i<0||i>n*8)throw new Error("Failed to parse given CIDR: "+r);const o=gd(i,8*n);return{network:pd(s,o),mask:o}}function gd(r,e){if(e!==8*sn&&e!==8*on)throw new Error("Invalid CIDR mask");if(r<0||r>e)throw new Error("Invalid CIDR mask");const t=e/8,n=new Uint8Array(t);for(let s=0;s<t;s++){if(r>=8){n[s]=255,r-=8;continue}n[s]=255-(255>>r),r=0}return n}class md{constructor(e,t){if(t==null)({network:this.network,mask:this.mask}=bw(e));else{const n=ys(e);if(n==null)throw new Error("Failed to parse network");t=String(t);const s=parseInt(t,10);if(Number.isNaN(s)||String(s).length!==t.length||s<0||s>n.length*8){const i=ys(t);if(i==null)throw new Error("Failed to parse mask");this.mask=i}else this.mask=gd(s,8*n.length);this.network=pd(n,this.mask)}}contains(e){return ww({network:this.network,mask:this.mask},e)}toString(){const e=gw(this.mask),t=e!==-1?String(e):mw(this.mask);return pw(this.network)+"/"+t}}function vw(r,e){return new md(r).contains(e)}function Sr(r){return!!hd(r)}function Jo(r){return!!fd(r)}function yd(r){return!!ys(r)}const dc=Sr,Ew=Jo,wd=function(r){let e=0;if(r=r.toString().trim(),dc(r)){const t=new Uint8Array(e+4);return r.split(/\./g).forEach(n=>{t[e++]=parseInt(n,10)&255}),t}if(Ew(r)){const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const i=dc(t[n]);let o;i&&(o=wd(t[n]),t[n]=Y(o.slice(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,Y(o.slice(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const i=[n,1];for(n=9-t.length;n>0;n--)i.push("0");t.splice.apply(t,i)}const s=new Uint8Array(e+16);for(n=0;n<t.length;n++){const i=parseInt(t[n],16);s[e++]=i>>8&255,s[e++]=i&255}return s}throw new Error("invalid ip address")},Sw=function(r,e=0,t){e=~~e,t=t??r.length-e;const n=new DataView(r.buffer);if(t===4){const s=[];for(let i=0;i<t;i++)s.push(r[e+i]);return s.join(".")}if(t===16){const s=[];for(let i=0;i<t;i+=2)s.push(n.getUint16(e+i).toString(16));return s.join(":").replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}return""},He=-1,an={},lo={},xw=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,He,"ip6zone"],[43,8,"ipcidr"],[53,He,"dns",!0],[54,He,"dns4",!0],[55,He,"dns6",!0],[56,He,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,He,"unix",!1,!0],[421,He,"ipfs"],[421,He,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,He,"garlic64"],[448,0,"tls"],[449,He,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,He,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[481,He,"http-path"],[777,He,"memory"]];xw.forEach(r=>{const e=Aw(...r);lo[e.code]=e,an[e.name]=e});function Aw(r,e,t,n,s){return{code:r,size:e,name:t,resolvable:!!n,path:!!s}}function G(r){if(typeof r=="number"){if(lo[r]!=null)return lo[r];throw new Error(`no protocol with code: ${r}`)}else if(typeof r=="string"){if(an[r]!=null)return an[r];throw new Error(`no protocol with name: ${r}`)}throw new Error(`invalid protocol id type: ${typeof r}`)}const Cw=G("ip4"),Iw=G("ip6"),Tw=G("ipcidr");function bd(r,e){switch(G(r).code){case 4:case 41:return Pw(e);case 42:return bi(e);case 43:return Y(e,"base10");case 6:case 273:case 33:case 132:return vd(e).toString();case 53:case 54:case 55:case 56:case 400:case 449:case 777:return bi(e);case 421:return Rw(e);case 444:return pc(e);case 445:return pc(e);case 466:return Mw(e);case 481:return globalThis.encodeURIComponent(bi(e));default:return Y(e,"base16")}}function hc(r,e){switch(G(r).code){case 4:return fc(e);case 41:return fc(e);case 42:return wi(e);case 43:return q(e,"base10");case 6:case 273:case 33:case 132:return ea(parseInt(e,10));case 53:case 54:case 55:case 56:case 400:case 449:case 777:return wi(e);case 421:return Lw(e);case 444:return Ow(e);case 445:return Nw(e);case 466:return Dw(e);case 481:return wi(globalThis.decodeURIComponent(e));default:return q(e,"base16")}}function kw(r){let e,t;if(r.stringTuples().forEach(([n,s])=>{(n===Cw.code||n===Iw.code)&&(t=s),n===Tw.code&&(e=s)}),e==null||t==null)throw new Error("Invalid multiaddr");return new md(t,e)}const yi=Object.values(Yi).map(r=>r.decoder),_w=function(){let r=yi[0].or(yi[1]);return yi.slice(2).forEach(e=>r=r.or(e)),r}();function fc(r){if(!yd(r))throw new Error("invalid ip address");return wd(r)}function Pw(r){const e=Sw(r,0,r.length);if(e==null)throw new Error("ipBuff is required");if(!yd(e))throw new Error("invalid ip address");return e}function ea(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,r),new Uint8Array(e)}function vd(r){return new DataView(r.buffer).getUint16(r.byteOffset)}function wi(r){const e=q(r),t=Uint8Array.from(dt(e.length));return ot([t,e],t.length+e.length)}function bi(r){const e=rr(r);if(r=r.slice(Ae(e)),r.length!==e)throw new Error("inconsistent lengths");return Y(r)}function Lw(r){let e;r[0]==="Q"||r[0]==="1"?e=tr(ye.decode(`z${r}`)).bytes:e=ae.parse(r).multihash.bytes;const t=Uint8Array.from(dt(e.length));return ot([t,e],t.length+e.length)}function Dw(r){const e=_w.decode(r),t=Uint8Array.from(dt(e.length));return ot([t,e],t.length+e.length)}function Mw(r){const e=rr(r),t=r.slice(Ae(e));if(t.length!==e)throw new Error("inconsistent lengths");return"u"+Y(t,"base64url")}function Rw(r){const e=rr(r),t=r.slice(Ae(e));if(t.length!==e)throw new Error("inconsistent lengths");return Y(t,"base58btc")}function Ow(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=xt.decode("b"+e[0]),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=ea(n);return ot([t,s],t.length+s.length)}function Nw(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=xt.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=ea(n);return ot([t,s],t.length+s.length)}function pc(r){const e=r.slice(0,r.length-2),t=r.slice(r.length-2),n=Y(e,"base32"),s=vd(t);return`${n}:${s}`}function Fw(r){r=uo(r);const e=[],t=[];let n=null;const s=r.split("/").slice(1);if(s.length===1&&s[0]==="")return{bytes:new Uint8Array,string:"/",tuples:[],stringTuples:[],path:null};for(let i=0;i<s.length;i++){const o=s[i],a=G(o);if(a.size===0){e.push([a.code]),t.push([a.code]);continue}if(i++,i>=s.length)throw new xd("invalid address: "+r);if(a.path===!0){n=uo(s.slice(i).join("/")),e.push([a.code,hc(a.code,n)]),t.push([a.code,n]);break}const c=hc(a.code,s[i]);e.push([a.code,c]),t.push([a.code,bd(a.code,c)])}return{string:Ed(t),bytes:Sd(e),tuples:e,stringTuples:t,path:n}}function gc(r){const e=[],t=[];let n=null,s=0;for(;s<r.length;){const i=rr(r,s),o=Ae(i),a=G(i),c=Uw(a,r.slice(s+o));if(c===0){e.push([i]),t.push([i]),s+=o;continue}const l=r.slice(s+o,s+o+c);if(s+=c+o,s>r.length)throw new xd("Invalid address Uint8Array: "+Y(r,"base16"));e.push([i,l]);const u=bd(i,l);if(t.push([i,u]),a.path===!0){n=u;break}}return{bytes:Uint8Array.from(r),string:Ed(t),tuples:e,stringTuples:t,path:n}}function Ed(r){const e=[];return r.map(t=>{const n=G(t[0]);return e.push(n.name),t.length>1&&t[1]!=null&&e.push(t[1]),null}),uo(e.join("/"))}function Sd(r){return ot(r.map(e=>{const t=G(e[0]);let n=Uint8Array.from(dt(t.code));return e.length>1&&e[1]!=null&&(n=ot([n,e[1]])),n}))}function Uw(r,e){if(r.size>0)return r.size/8;if(r.size===0)return 0;{const t=rr(e instanceof Uint8Array?e:Uint8Array.from(e));return t+Ae(t)}}function uo(r){return"/"+r.trim().split("/").filter(e=>e).join("/")}class xd extends Error{static name="ParseError";name="ParseError";constructor(e){super(`Error parsing address: ${e}`)}}const Bw=Symbol.for("nodejs.util.inspect.custom"),Ad=Symbol.for("@multiformats/js-multiaddr/multiaddr"),$w=[G("dns").code,G("dns4").code,G("dns6").code,G("dnsaddr").code];class zw extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}}class dr{bytes;#e;#t;#r;#a;[Ad]=!0;constructor(e){e==null&&(e="");let t;if(e instanceof Uint8Array)t=gc(e);else if(typeof e=="string"){if(e.length>0&&e.charAt(0)!=="/")throw new Error(`multiaddr "${e}" must start with a "/"`);t=Fw(e)}else if(zs(e))t=gc(e.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr");this.bytes=t.bytes,this.#e=t.string,this.#t=t.tuples,this.#r=t.stringTuples,this.#a=t.path}toString(){return this.#e}toJSON(){return this.toString()}toOptions(){let e,t,n,s,i="";const o=G("tcp"),a=G("udp"),c=G("ip4"),l=G("ip6"),u=G("dns6"),d=G("ip6zone");for(const[p,f]of this.stringTuples())p===d.code&&(i=`%${f??""}`),$w.includes(p)&&(t=o.name==="tcp"?"tcp":"udp",s=443,n=`${f??""}${i}`,e=p===u.code?6:4),(p===o.code||p===a.code)&&(t=G(p).name==="tcp"?"tcp":"udp",s=parseInt(f??"")),(p===c.code||p===l.code)&&(t=G(p).name==="tcp"?"tcp":"udp",n=`${f??""}${i}`,e=p===l.code?6:4);if(e==null||t==null||n==null||s==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:n,transport:t,port:s}}protos(){return this.#t.map(([e])=>Object.assign({},G(e)))}protoCodes(){return this.#t.map(([e])=>e)}protoNames(){return this.#t.map(([e])=>G(e).name)}tuples(){return this.#t.map(([e,t])=>t==null?[e]:[e,t])}stringTuples(){return this.#r.map(([e,t])=>t==null?[e]:[e,t])}encapsulate(e){return e=new dr(e),new dr(this.toString()+e.toString())}decapsulate(e){const t=e.toString(),n=this.toString(),s=n.lastIndexOf(t);if(s<0)throw new Error(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new dr(n.slice(0,s))}decapsulateCode(e){const t=this.tuples();for(let n=t.length-1;n>=0;n--)if(t[n][0]===e)return new dr(Sd(t.slice(0,n)));return this}getPeerId(){try{let e=[];this.stringTuples().forEach(([n,s])=>{n===an.p2p.code&&e.push([n,s]),n===an["p2p-circuit"].code&&(e=[])});const t=e.pop();if(t?.[1]!=null){const n=t[1];return n[0]==="Q"||n[0]==="1"?Y(ye.decode(`z${n}`),"base58btc"):Y(ae.parse(n).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){return this.#a}equals(e){return Oe(this.bytes,e.bytes)}async resolve(e){const t=this.protos().find(i=>i.resolvable);if(t==null)return[this];const n=ta.get(t.name);if(n==null)throw new zw(`no available resolver for ${t.name}`);return(await n(this,e)).map(i=>X(i))}nodeAddress(){const e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(e){const t=(e??this).protos();return!(t.length!==2||t[0].code!==4&&t[0].code!==41||t[1].code!==6&&t[1].code!==273)}[Bw](){return`Multiaddr(${this.#e})`}}const ta=new Map;function zs(r){return!!r?.[Ad]}function X(r){return new dr(r)}const Kw="libp2p-peer-record",qw=Uint8Array.from([3,1]);var ws;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=me((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.multiaddr!=null&&s.multiaddr.byteLength>0&&(i.uint32(10),i.bytes(s.multiaddr)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={multiaddr:se(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.multiaddr=s.bytes();break}default:{s.skipType(l&7);break}}}return a})),n),t.encode=s=>ge(s,t.codec()),t.decode=(s,i)=>pe(s,t.codec(),i)})(r.AddressInfo||(r.AddressInfo={}));let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.peerId!=null&&t.peerId.byteLength>0&&(n.uint32(10),n.bytes(t.peerId)),t.seq!=null&&t.seq!==0n&&(n.uint32(16),n.uint64(t.seq)),t.addresses!=null)for(const i of t.addresses)n.uint32(26),r.AddressInfo.codec().encode(i,n);s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={peerId:se(0),seq:0n,addresses:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.peerId=t.bytes();break}case 2:{i.seq=t.uint64();break}case 3:{if(s.limits?.addresses!=null&&i.addresses.length===s.limits.addresses)throw new It('Decode error - map field "addresses" had too many elements');i.addresses.push(r.AddressInfo.codec().decode(t,t.uint32(),{limits:s.limits?.addresses$}));break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(ws||(ws={}));class Qe{static createFromProtobuf=e=>{const t=ws.decode(e),n=vn(tr(t.peerId)),s=(t.addresses??[]).map(o=>X(o.multiaddr)),i=t.seq;return new Qe({peerId:n,multiaddrs:s,seqNumber:i})};static DOMAIN=Kw;static CODEC=qw;peerId;multiaddrs;seqNumber;domain=Qe.DOMAIN;codec=Qe.CODEC;marshaled;constructor(e){const{peerId:t,multiaddrs:n,seqNumber:s}=e;this.peerId=t,this.multiaddrs=n??[],this.seqNumber=s??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=ws.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(e=>({multiaddr:e.bytes}))})),this.marshaled}equals(e){return!(!(e instanceof Qe)||!this.peerId.equals(e.peerId)||this.seqNumber!==e.seqNumber||!lw(this.multiaddrs,e.multiaddrs))}}function Tt(r,e){const t=br(r,e),n={read:async(s,i)=>{const o=await t.read(i);return s.decode(o)},write:async(s,i,o)=>{await t.write(i.encode(s),o)},writeV:async(s,i,o)=>{await t.writeV(s.map(a=>i.encode(a)),o)},pb:s=>({read:async i=>n.read(s,i),write:async(i,o)=>n.write(i,s,o),writeV:async(i,o)=>n.writeV(i,s,o),unwrap:()=>n}),unwrap:()=>t.unwrap()};return n}const Ww=290,Vw=1,Cd=2e3,Hw=100,Fn=`${Io}-circuit-relay`;BigInt(1<<17);const bs="/libp2p/circuit/relay/0.2.0/hop",mc="/libp2p/circuit/relay/0.2.0/stop",yc=300,Gw=4096,Yw=.001;var xr;(function(r){(function(n){n.RESERVE="RESERVE",n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let e;(function(n){n[n.RESERVE=0]="RESERVE",n[n.CONNECT=1]="CONNECT",n[n.STATUS=2]="STATUS"})(e||(e={})),function(n){n.codec=()=>Dr(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=me((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.peer!=null&&(s.uint32(18),Ar.codec().encode(n.peer,s)),n.reservation!=null&&(s.uint32(26),vs.codec().encode(n.reservation,s)),n.limit!=null&&(s.uint32(34),Cr.codec().encode(n.limit,s)),n.status!=null&&(s.uint32(40),Ue.codec().encode(n.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=Ar.codec().decode(n,n.uint32(),{limits:i.limits?.peer});break}case 3:{o.reservation=vs.codec().decode(n,n.uint32(),{limits:i.limits?.reservation});break}case 4:{o.limit=Cr.codec().decode(n,n.uint32(),{limits:i.limits?.limit});break}case 5:{o.status=Ue.codec().decode(n);break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>ge(n,r.codec()),r.decode=(n,s)=>pe(n,r.codec(),s)})(xr||(xr={}));var bt;(function(r){(function(n){n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let e;(function(n){n[n.CONNECT=0]="CONNECT",n[n.STATUS=1]="STATUS"})(e||(e={})),function(n){n.codec=()=>Dr(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=me((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.peer!=null&&(s.uint32(18),Ar.codec().encode(n.peer,s)),n.limit!=null&&(s.uint32(26),Cr.codec().encode(n.limit,s)),n.status!=null&&(s.uint32(32),Ue.codec().encode(n.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=Ar.codec().decode(n,n.uint32(),{limits:i.limits?.peer});break}case 3:{o.limit=Cr.codec().decode(n,n.uint32(),{limits:i.limits?.limit});break}case 4:{o.status=Ue.codec().decode(n);break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>ge(n,r.codec()),r.decode=(n,s)=>pe(n,r.codec(),s)})(bt||(bt={}));var Ar;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.id!=null&&t.id.byteLength>0&&(n.uint32(10),n.bytes(t.id)),t.addrs!=null)for(const i of t.addrs)n.uint32(18),n.bytes(i);s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={id:se(0),addrs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.id=t.bytes();break}case 2:{if(s.limits?.addrs!=null&&i.addrs.length===s.limits.addrs)throw new It('Decode error - map field "addrs" had too many elements');i.addrs.push(t.bytes());break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(Ar||(Ar={}));var vs;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.expire!=null&&t.expire!==0n&&(n.uint32(8),n.uint64(t.expire)),t.addrs!=null)for(const i of t.addrs)n.uint32(18),n.bytes(i);t.voucher!=null&&(n.uint32(26),Ss.codec().encode(t.voucher,n)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={expire:0n,addrs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.expire=t.uint64();break}case 2:{if(s.limits?.addrs!=null&&i.addrs.length===s.limits.addrs)throw new It('Decode error - map field "addrs" had too many elements');i.addrs.push(t.bytes());break}case 3:{i.voucher=Ss.codec().decode(t,t.uint32(),{limits:s.limits?.voucher});break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(vs||(vs={}));var Cr;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.duration!=null&&(n.uint32(8),n.uint32(t.duration)),t.data!=null&&(n.uint32(16),n.uint64(t.data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.duration=t.uint32();break}case 2:{i.data=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(Cr||(Cr={}));var Ue;(function(r){r.UNUSED="UNUSED",r.OK="OK",r.RESERVATION_REFUSED="RESERVATION_REFUSED",r.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",r.PERMISSION_DENIED="PERMISSION_DENIED",r.CONNECTION_FAILED="CONNECTION_FAILED",r.NO_RESERVATION="NO_RESERVATION",r.MALFORMED_MESSAGE="MALFORMED_MESSAGE",r.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(Ue||(Ue={}));var ho;(function(r){r[r.UNUSED=0]="UNUSED",r[r.OK=100]="OK",r[r.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",r[r.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",r[r.PERMISSION_DENIED=202]="PERMISSION_DENIED",r[r.CONNECTION_FAILED=203]="CONNECTION_FAILED",r[r.NO_RESERVATION=204]="NO_RESERVATION",r[r.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",r[r.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(ho||(ho={}));(function(r){r.codec=()=>Dr(ho)})(Ue||(Ue={}));var Es;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.relay!=null&&t.relay.byteLength>0&&(n.uint32(10),n.bytes(t.relay)),t.peer!=null&&t.peer.byteLength>0&&(n.uint32(18),n.bytes(t.peer)),t.expiration!=null&&t.expiration!==0n&&(n.uint32(24),n.uint64(t.expiration)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={relay:se(0),peer:se(0),expiration:0n},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.relay=t.bytes();break}case 2:{i.peer=t.bytes();break}case 3:{i.expiration=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(Es||(Es={}));var Ss;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&(n.uint32(26),Es.codec().encode(t.payload,n)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={publicKey:se(0),payloadType:se(0),signature:se(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=Es.codec().decode(t,t.uint32(),{limits:s.limits?.payload});break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(Ss||(Ss={}));const Xw=r=>r.toString().split("/").slice(1),An=r=>({match:e=>e.length<1?!1:r(e[0])?e.slice(1):!1,pattern:"fn"}),Q=r=>({match:e=>An(t=>t===r).match(e),pattern:r}),Mr=()=>({match:r=>An(e=>typeof e=="string").match(r),pattern:"{string}"}),cn=()=>({match:r=>An(e=>!isNaN(parseInt(e))).match(r),pattern:"{number}"}),oe=()=>({match:r=>{if(r.length<2||r[0]!=="p2p"&&r[0]!=="ipfs")return!1;if(r[1].startsWith("Q")||r[1].startsWith("1"))try{ye.decode(`z${r[1]}`)}catch{return!1}else return!1;return r.slice(2)},pattern:"/p2p/{peerid}"}),xs=()=>({match:r=>{if(r.length<2||r[0]!=="certhash")return!1;try{jl.decode(r[1])}catch{return!1}return r.slice(2)},pattern:"/certhash/{certhash}"}),ne=r=>({match:e=>{const t=r.match(e);return t===!1?e:t},pattern:`optional(${r.pattern})`}),Be=(...r)=>({match:e=>{let t;for(const n of r){const s=n.match(e);s!==!1&&(t==null||s.length<t.length)&&(t=s)}return t??!1},pattern:`or(${r.map(e=>e.pattern).join(", ")})`}),j=(...r)=>({match:e=>{for(const t of r){const n=t.match(e);if(n===!1)return!1;e=n}return e},pattern:`and(${r.map(e=>e.pattern).join(", ")})`});function le(...r){function e(s){let i=Xw(s);for(const o of r){const a=o.match(i);if(a===!1)return!1;i=a}return i}function t(s){return e(s)!==!1}function n(s){const i=e(s);return i===!1?!1:i.length===0}return{matchers:r,matches:t,exactMatch:n}}const Qw=oe(),jw=le(Qw),Ks=j(Q("dns4"),Mr()),qs=j(Q("dns6"),Mr()),Ws=j(Q("dnsaddr"),Mr()),ra=j(Q("dns"),Mr());le(Ks,ne(oe()));le(qs,ne(oe()));le(Ws,ne(oe()));le(Be(ra,Ws,Ks,qs),ne(oe()));const Id=j(Q("ip4"),An(Sr)),Td=j(Q("ip6"),An(Jo)),na=Be(Id,Td),Ct=Be(na,ra,Ks,qs,Ws),Zw=le(Be(na,j(Be(ra,Ws,Ks,qs),ne(oe())))),wc=le(Id),bc=le(Td);le(na);const sa=j(Ct,Q("tcp"),cn()),Cn=j(Ct,Q("udp"),cn()),As=le(j(sa,ne(oe())));le(Cn);const ia=j(Cn,Q("quic"),ne(oe())),Vs=j(Cn,Q("quic-v1"),ne(oe())),Jw=Be(ia,Vs);le(ia);const eb=le(Vs),fo=Be(Ct,sa,Cn,ia,Vs),kd=Be(j(fo,Q("ws"),ne(oe()))),ln=le(kd),_d=Be(j(fo,Q("wss"),ne(oe())),j(fo,Q("tls"),ne(j(Q("sni"),Mr())),Q("ws"),ne(oe()))),Cs=le(_d),Pd=j(Cn,Q("webrtc-direct"),ne(xs()),ne(xs()),ne(oe())),vc=le(Pd),Ld=j(Vs,Q("webtransport"),ne(xs()),ne(xs()),ne(oe())),Ec=le(Ld),Is=Be(kd,_d,j(sa,ne(oe())),j(Jw,ne(oe())),j(Ct,ne(oe())),Pd,Ld,oe()),Dd=le(Is),tb=j(Is,Q("p2p-circuit"),oe()),un=le(tb),rb=Be(j(Is,Q("p2p-circuit"),Q("webrtc"),ne(oe())),j(Is,Q("webrtc"),ne(oe())),j(Q("webrtc"),ne(oe()))),po=le(rb),nb=Be(j(Ct,Q("tcp"),cn(),Q("http"),ne(oe())),j(Ct,Q("http"),ne(oe())));le(nb);const sb=Be(j(Ct,Q("tcp"),Be(j(Q("443"),Q("http")),j(cn(),Q("https")),j(cn(),Q("tls"),Q("http"))),ne(oe())),j(Ct,Q("tls"),Q("http"),ne(oe())),j(Ct,Q("https"),ne(oe())));le(sb);const ib=Be(j(Q("memory"),Mr(),ne(oe())));le(ib);function $t(r){const e=new globalThis.AbortController;function t(){e.abort();for(const i of r)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}for(const i of r){if(i?.aborted===!0){t();break}i?.addEventListener!=null&&i.addEventListener("abort",t)}function n(){for(const i of r)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}const s=e.signal;return s.clear=n,s}class Sc extends Error{static name="HadEnoughRelaysError";name="HadEnoughRelaysError"}class ob extends Error{static name="DoubleRelayError";name="DoubleRelayError"}class ab extends Error{static name="RelayQueueFullError";name="RelayQueueFullError"}function xc(r){const e=r*BigInt(1e3),t=new Date().getTime();return Number(e-BigInt(t))}class Ac{expires;bytes;constructor(e){e?.duration!=null&&e?.duration!==0&&(this.expires=Date.now()+e.duration*1e3),this.bytes=e?.data,this.bytes===0n&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(e){this.bytes!=null&&(this.bytes-=BigInt(e.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(this.expires==null&&this.bytes==null)return;const e={};if(this.bytes!=null){const t=this;Object.defineProperty(e,"bytes",{get(){return t.bytes}})}if(this.expires!=null){const t=this;Object.defineProperty(e,"seconds",{get(){return Math.round(((t.expires??0)-Date.now())/1e3)}})}return e}}const Md=le(j(Dd.matchers[0],Q("p2p-circuit"))),Rd=le(Q("p2p-circuit"));function Xr(r,e){const t={[Symbol.iterator]:()=>t,next:()=>{const n=r.next(),s=n.value;return n.done===!0||s==null?{done:!0,value:void 0}:{done:!1,value:e(s)}}};return t}function vi(r){const e=tr(ye.decode(`z${r}`));return vn(e)}class Hs{map;constructor(e){if(this.map=new Map,e!=null)for(const[t,n]of e.entries())this.map.set(t.toString(),{key:t,value:n})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return Xr(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach((t,n)=>{e(t.value,t.key,this)})}get(e){return this.map.get(e.toString())?.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return Xr(this.map.values(),e=>e.key)}values(){return Xr(this.map.values(),e=>e.value)}get size(){return this.map.size}}class fr{set;constructor(e){if(this.set=new Set,e!=null)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return Xr(this.set.entries(),e=>{const t=vi(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const n=vi(t);e(n,n,this)})}has(e){return this.set.has(e.toString())}values(){return Xr(this.set.values(),e=>vi(e))}intersection(e){const t=new fr;for(const n of e)this.has(n)&&t.add(n);return t}difference(e){const t=new fr;for(const n of this)e.has(n)||t.add(n);return t}union(e){const t=new fr;for(const n of e)t.add(n);for(const n of this)t.add(n);return t}}const oa={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},Od={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},Nd=new globalThis.TextEncoder;function cb(r,e){const t=oa[e];let n=Od[e];for(let s=0;s<r.length;s++)n^=BigInt(r[s]),n=BigInt.asUintN(e,n*t);return n}function lb(r,e,t){if(t.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const n=oa[e];let s=Od[e],i=r;for(;i.length>0;){const o=Nd.encodeInto(i,t);i=i.slice(o.read);for(let a=0;a<o.written;a++)s^=BigInt(t[a]),s=BigInt.asUintN(e,s*n)}return s}function ub(r,{size:e=32,utf8Buffer:t}={}){if(!oa[e])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof r=="string"){if(t)return lb(r,e,t);r=Nd.encode(r)}return cb(r,e)}const aa={hash:r=>Number(ub(r,{size:32})),hashV:(r,e)=>db(aa.hash(r,e))};function db(r){let e=r.toString(16);return e.length%2===1&&(e=`0${e}`),q(e,"base16")}const Fd=64;class Ht{fp;h;seed;constructor(e,t,n,s=2){if(s>Fd)throw new TypeError("Invalid Fingerprint Size");const i=t.hashV(e,n),o=se(s);for(let a=0;a<o.length;a++)o[a]=i[a];o.length===0&&(o[0]=7),this.fp=o,this.h=t,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return e?.fp instanceof Uint8Array?Oe(this.fp,e.fp):!1}}function Ts(r,e){return Math.floor(Math.random()*(e-r))+r}class Un{contents;constructor(e){this.contents=new Array(e).fill(null)}has(e){if(!(e instanceof Ht))throw new TypeError("Invalid Fingerprint");return this.contents.some(t=>e.equals(t))}add(e){if(!(e instanceof Ht))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(this.contents[t]==null)return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof Ht))throw new TypeError("Invalid Fingerprint");const t=Ts(0,this.contents.length-1),n=this.contents[t];return this.contents[t]=e,n}remove(e){if(!(e instanceof Ht))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex(n=>e.equals(n));return t>-1?(this.contents[t]=null,!0):!1}}const hb=500;class Cc{bucketSize;filterSize;fingerprintSize;buckets;count;hash;seed;constructor(e){this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??aa,this.seed=e.seed??Ts(0,Math.pow(2,10))}add(e){typeof e=="string"&&(e=q(e));const t=new Ht(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=(n^t.hash())%this.filterSize;if(this.buckets[n]==null&&(this.buckets[n]=new Un(this.bucketSize)),this.buckets[s]==null&&(this.buckets[s]=new Un(this.bucketSize)),this.buckets[n].add(t)||this.buckets[s].add(t))return this.count++,!0;const i=[n,s];let o=i[Ts(0,i.length-1)];this.buckets[o]==null&&(this.buckets[o]=new Un(this.bucketSize));for(let a=0;a<hb;a++){const c=this.buckets[o].swap(t);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new Un(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(e){typeof e=="string"&&(e=q(e));const t=new Ht(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=this.buckets[n]?.has(t)??!1;if(s)return s;const i=(n^t.hash())%this.filterSize;return this.buckets[i]?.has(t)??!1}remove(e){typeof e=="string"&&(e=q(e));const t=new Ht(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=this.buckets[n]?.remove(t)??!1;if(s)return this.count--,s;const i=(n^t.hash())%this.filterSize,o=this.buckets[i]?.remove(t)??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const fb={1:.5,2:.84,4:.95,8:.98};function pb(r=.001){return r>.002?2:r>1e-5?4:8}function gb(r,e=.001){const t=pb(e),n=fb[t],s=Math.round(r/n),i=Math.min(Math.ceil(Math.log2(1/e)+Math.log2(2*t)),Fd);return{filterSize:s,bucketSize:t,fingerprintSize:i}}class mb{filterSize;bucketSize;fingerprintSize;scale;filterSeries;hash;seed;constructor(e){this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??aa,this.seed=e.seed??Ts(0,Math.pow(2,10)),this.filterSeries=[new Cc({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if(typeof e=="string"&&(e=q(e)),this.has(e))return!0;let t=this.filterSeries.find(n=>n.reliable);if(t==null){const n=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new Cc({filterSize:n,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){typeof e=="string"&&(e=q(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){typeof e=="string"&&(e=q(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce((e,t)=>e+t.count,0)}}function dn(r,e=.001,t){return new mb({...gb(r,e)})}class yb{filter;constructor(e,t){this.filter=dn(e,t)}has(e){return this.filter.has(e.toMultihash().bytes)}add(e){this.filter.add(e.toMultihash().bytes)}remove(e){this.filter.remove?.(e.toMultihash().bytes)}}function wb(r,e=.001){return new yb(r,e)}function Ic(r){const{stream:e,remoteAddr:t,logger:n,onDataRead:s,onDataWrite:i}=r,o=n.forComponent("libp2p:stream:converter");let a=!1,c=!1;const l=e.close.bind(e);e.close=async f=>{await l(f),p(!0)};const u=e.abort.bind(e);e.abort=f=>{u(f),p(!0)};const d=e.sink.bind(e);e.sink=async f=>{try{await d(qu(f,g=>ld(g,m=>i?.(m))))}catch(g){g.type!=="aborted"&&o.error("%s error in sink",t,g)}finally{c=!0,p()}};const h={log:o,sink:e.sink,source:async function*(){try{for await(const f of e.source)s?.(f),yield f}finally{a=!0,p()}}(),remoteAddr:t,timeline:{open:Date.now(),close:void 0},close:e.close,abort:e.abort};function p(f){f===!0&&(a=!0,c=!0),a&&c&&h.timeline.close==null&&(h.timeline.close=Date.now())}return h}class ie extends Event{type;detail;constructor(e,t){super(e),this.type=e,this.detail=t}}let bb=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.name="AbortError",this.code=t??"ABORT_ERR"}};async function pr(r,e,t,n){const s=new bb(n?.errorMessage,n?.errorCode);return t?.aborted===!0?Promise.reject(s):new Promise((i,o)=>{function a(){t?.removeEventListener("abort",u),r.removeEventListener(e,c),n?.errorEvent!=null&&r.removeEventListener(n.errorEvent,l)}const c=d=>{try{if(n?.filter?.(d)===!1)return}catch(h){a(),o(h);return}a(),i(d)},l=d=>{a(),o(d.detail)},u=()=>{a(),o(s)};t?.addEventListener("abort",u),r.addEventListener(e,c),n?.errorEvent!=null&&r.addEventListener(n.errorEvent,l)})}function go(r,e){let t;const n=function(){const s=function(){t=void 0,r()};clearTimeout(t),t=setTimeout(s,e)};return n.start=()=>{},n.stop=()=>{clearTimeout(t)},n}class vb extends Error{remainingPoints;msBeforeNext;consumedPoints;isFirstInDuration;constructor(e="Rate limit exceeded",t){super(e),this.name="RateLimitError",this.remainingPoints=t.remainingPoints,this.msBeforeNext=t.msBeforeNext,this.consumedPoints=t.consumedPoints,this.isFirstInDuration=t.isFirstInDuration}}class Eb extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}class Sb{deferred;signal;constructor(e){this.signal=e,this.deferred=he(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new jt)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}}function xb(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class Ab{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=xb(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,n)=>t&&n.signal?.aborted===!0,!0)&&(this.controller.abort(new jt),this.cleanup())}async join(e={}){const t=new Sb(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await Je(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}}class Ud extends Ut{concurrency;maxSize;queue;pending;sort;constructor(e={}){super(),this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,e.metricName!=null&&e.metrics?.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})}),this.sort=e.sort,this.queue=[],this.emitEmpty=go(this.emitEmpty.bind(this),1),this.emitIdle=go(this.emitIdle.bind(this),1)}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if(t.status==="queued"){e=t;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new Eb;const n=new Ab(e,t);return this.enqueue(n),this.safeDispatchEvent("add"),this.tryToStartAnother(),n.join(t).then(s=>(this.safeDispatchEvent("completed",{detail:s}),this.safeDispatchEvent("success",{detail:{job:n,result:s}}),s)).catch(s=>{if(n.status==="queued"){for(let i=0;i<this.queue.length;i++)if(this.queue[i]===n){this.queue.splice(i,1);break}}throw this.safeDispatchEvent("error",{detail:s}),this.safeDispatchEvent("failure",{detail:{job:n,error:s}}),s})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new jt)}),this.clear()}async onEmpty(e){this.size!==0&&await pr(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await pr(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await pr(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=Sn({objectMode:!0}),n=c=>{c!=null?this.abort():this.clear(),t.end(c)},s=c=>{c.detail!=null&&t.push(c.detail)},i=c=>{n(c.detail)},o=()=>{n()},a=()=>{n(new jt("Queue aborted"))};this.addEventListener("completed",s),this.addEventListener("error",i),this.addEventListener("idle",o),e?.signal?.addEventListener("abort",a);try{yield*t}finally{this.removeEventListener("completed",s),this.removeEventListener("error",i),this.removeEventListener("idle",o),e?.signal?.removeEventListener("abort",a),n()}}}class ca extends Ud{has(e){return this.find(e)!=null}find(e){return this.queue.find(t=>e.equals(t.options.peerId))}}class Cb extends Ut{peerStore;registrar;connectionManager;randomWalk;started;running;topologyId;log;discoveryController;filter;queue;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.started=!1,this.running=!1,this.peerStore=e.peerStore,this.registrar=e.registrar,this.connectionManager=e.connectionManager,this.randomWalk=e.randomWalk,this.filter=t.filter,this.discoveryController=new AbortController,this.discoveryController.signal}isStarted(){return this.started}async start(){this.topologyId=await this.registrar.register(bs,{filter:this.filter,onConnect:e=>{this.log.trace("discovered relay %p queue (length: %d, active %d)",e,this.queue?.size,this.queue?.running),this.safeDispatchEvent("relay:discover",{detail:e})}}),this.started=!0}stop(){this.topologyId!=null&&this.registrar.unregister(this.topologyId),this.discoveryController?.abort(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,this.discoveryController.signal,Promise.resolve().then(async()=>{this.log("searching peer store for relays");const e=await this.peerStore.all({filters:[n=>n.protocols.includes(bs)],orders:[()=>Math.random()<.5?1:-1,(n,s)=>{const i=Tc(n),o=Tc(s);return i>o?-1:o>i?1:0}]});for(const n of e)this.log.trace("found relay peer %p in peer store",n.id),this.safeDispatchEvent("relay:discover",{detail:n.id});this.log("found %d relay peers in peer store",e.length);const t=this.queue=new ca({concurrency:5});this.log("start random walk");for await(const n of this.randomWalk.walk({signal:this.discoveryController.signal})){if(this.log.trace("found random peer %p",n.id),t.has(n.id)){this.log.trace("random peer %p was already in queue",n.id);continue}if(this.connectionManager.getConnections(n.id)?.length>0){this.log.trace("random peer %p was already connected",n.id);continue}if(!await this.connectionManager.isDialable(n.multiaddrs)){this.log.trace("random peer %p was not dialable",n.id,n.multiaddrs.map(s=>s.toString()));continue}t.queued>10&&(this.log.trace("wait for space in queue for %p",n.id),await t.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",n.id,t.size,t.running),t.add(async()=>{const s=$t([this.discoveryController.signal,AbortSignal.timeout(5e3)]);try{await this.connectionManager.openConnection(n.id,{signal:s})}finally{s.clear()}},{peerId:n.id,signal:this.discoveryController.signal}).catch(s=>{this.log.error("error opening connection to random peer %p",n.id,s)})}this.log("stop random walk"),await t.onIdle()}).catch(e=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network",e)}))}stopDiscovery(){this.log("stop discovery"),this.running=!1,this.discoveryController?.abort()}}function Tc(r){const e=r.metadata.get("last-dial-success");return e==null?0:new Date(Y(e)).getTime()}class Ib extends Ut{connectionManager;addressManager;reservationStore;listeningAddrs;log;listenTimeout;reservationId;relay;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.connectionManager=e.connectionManager,this.addressManager=e.addressManager,this.reservationStore=e.reservationStore,this.listeningAddrs=[],this.listenTimeout=t.listenTimeout??Cd,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}_onRemoveRelayPeer=e=>{this.log("relay removed %p our relay %p",e.detail.relay,this.relay,this.relay?.equals(e.detail.relay)),this.relay?.equals(e.detail.relay)===!0&&(this.log("relay peer removed %p",e.detail.relay),this.listeningAddrs.forEach(t=>{this.addressManager.removeObservedAddr(t)}),this.listeningAddrs=[],this.safeDispatchEvent("listening"))};_onAddRelayPeer=e=>{const{details:t}=e.detail;t.type!=="configured"&&t.id===this.reservationId&&this.addedRelay(e.detail)};async listen(e){if(Rd.exactMatch(e))this.log("searching for circuit relay servers"),this.reservationId=this.reservationStore.reserveRelay();else if(Md.exactMatch(e)){this.log("listen on specific relay server %a",e);const t=AbortSignal.timeout(this.listenTimeout),n=e.decapsulate("/p2p-circuit"),s=await this.connectionManager.openConnection(n,{signal:t});if(!this.reservationStore.hasReservation(s.remotePeer)){this.log("making reservation on peer %p",s.remotePeer);const i=await this.reservationStore.addRelay(s.remotePeer,"configured");this.addedRelay(i)}}else throw new Wi(`Could not listen on p2p-circuit address "${e}"`)}getAddrs(){return[...this.listeningAddrs.values()].flat()}updateAnnounceAddrs(){}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask(()=>{this.safeDispatchEvent("close")})}addedRelay(e){this.log("relay peer added %p",e.relay),this.relay=e.relay,this.listeningAddrs=e.details.reservation.addrs.map(t=>X(t).encapsulate("/p2p-circuit")),this.listeningAddrs.forEach(t=>{this.addressManager.confirmObservedAddr(t,{type:"transport"})}),queueMicrotask(()=>{this.safeDispatchEvent("listening")})}}function Tb(r){return new Ib(r)}const kb="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";let _b=(r=21)=>{let e="",t=crypto.getRandomValues(new Uint8Array(r|=0));for(;r--;)e+=kb[t[r]&63];return e};const Pb=60*1e3*10,Lb=60*1e3*5,Db=30*1e3;class Mb extends Ut{peerId;connectionManager;peerStore;events;reserveQueue;reservations;pendingReservations;maxReservationQueueLength;reservationCompletionTimeout;started;log;relayFilter;constructor(e,t){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.reservations=new Hs,this.pendingReservations=[],this.maxReservationQueueLength=t?.maxReservationQueueLength??Hw,this.reservationCompletionTimeout=t?.reservationCompletionTimeout??Cd,this.started=!1,this.relayFilter=dn(100),this.reserveQueue=new ca({concurrency:t?.reservationConcurrency??Vw,metricName:"libp2p_relay_reservation_queue",metrics:e.metrics}),this.events.addEventListener("connection:close",n=>{[...this.reservations.values()].find(i=>i.connection===n.detail.id)!=null&&this.#t(n.detail.remotePeer).catch(i=>{this.log("could not remove relay %p - %e",n.detail,i)})})}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>t.tags.has(Fn)]});this.log("removing tag from %d old relays",e.length),await Promise.all(e.map(async t=>{await this.peerStore.merge(t.id,{tags:{[Fn]:void 0}})})),this.log("redialing %d old relays",e.length),await Promise.all(e.map(async t=>this.addRelay(t.id,"discovered"))),this.#r()}).catch(e=>{this.log.error(e)})}stop(){this.reserveQueue.clear(),this.reservations.forEach(({timeout:e})=>{clearTimeout(e)}),this.reservations.clear(),this.started=!1}reserveRelay(){const e=_b();return this.pendingReservations.push(e),this.#r(),e}async addRelay(e,t){if(this.peerId.equals(e))throw this.log.trace("not trying to use self as relay"),new Wi("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new ab("The reservation queue is full");const n=this.reserveQueue.find(e);if(n!=null)return this.log.trace("potential relay peer %p is already in the reservation queue",e),n.join();if(this.relayFilter.has(e.toMultihash().bytes))throw new Wi("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",e),this.reserveQueue.add(async()=>{const s=Date.now();try{const i=this.reservations.get(e);if(i!=null){const f=this.connectionManager.getConnections(e);let g=!1;if(f.length===0&&this.log("already have relay reservation with %p but we are no longer connected",e),f.map(m=>m.id).includes(i.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",e),g=!0),g&&xc(i.reservation.expire)>Pb)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",e),{relay:e,details:i};await this.#t(e)}if(t==="discovered"&&this.pendingReservations.length===0)throw new Sc("Not making reservation on discovered relay because we do not need any more relays");const o=AbortSignal.timeout(this.reservationCompletionTimeout);const a=await this.connectionManager.openConnection(e,{signal:o});if(un.matches(a.remoteAddr))throw new ob("not creating reservation over relayed connection");const c=await this.#e(a,{signal:o}),l=xc(c.expire);this.log("created reservation on relay peer %p, expiry date is %s",e,new Date(Date.now()+l).toString());const u=Math.min(Math.max(l-Lb,Db),Math.pow(2,31)-1),d=setTimeout(()=>{this.log("refresh reservation to relay %p",e),this.addRelay(e,t).catch(async f=>{this.log.error("could not refresh reservation to relay %p - %e",e,f),await this.#t(e)}).catch(f=>{this.log.error("could not remove expired reservation to relay %p - %e",e,f)})},u);let h;if(t==="discovered"){const f=this.pendingReservations.pop();if(f==null)throw new Sc("Made reservation on relay but did not need any more discovered relays");h={timeout:d,reservation:c,type:t,connection:a.id,id:f}}else h={timeout:d,reservation:c,type:t,connection:a.id};this.reservations.set(e,h),await this.peerStore.merge(e,{tags:{[Fn]:{value:1,ttl:l}}}),this.#r();const p={relay:e,details:h};return this.safeDispatchEvent("relay:created-reservation",{detail:p}),p}catch(i){throw t==="discovered"&&i.name==="HadEnoughRelaysError"||this.log.error("could not reserve slot on %p after %dms - %e",e,Date.now()-s,i),(i.name==="DialError"||i.name==="UnsupportedProtocolError")&&this.relayFilter.add(e.toMultihash().bytes),this.#t(e).catch(o=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",e,o)}),i}},{peerId:e})}hasReservation(e){return this.reservations.has(e)}getReservation(e){return this.reservations.get(e)?.reservation}reservationCount(e){return e==null?this.reservations.size:[...this.reservations.values()].reduce((t,n)=>(n.type===e&&t++,t),0)}cancelReservations(){[...this.reservations.values()].forEach(e=>{clearTimeout(e.timeout)}),this.reservations.clear()}async#e(e,t){t.signal?.throwIfAborted(),this.log("requesting reservation from %p",e.remotePeer);const n=await e.newStream(bs,t),i=Tt(n).pb(xr);this.log.trace("send RESERVE to %p",e.remotePeer),await i.write({type:xr.Type.RESERVE},t);let o;try{this.log.trace("reading response from %p",e.remotePeer),o=await i.read(t)}catch(c){throw n.abort(c),c}finally{n.status!=="closed"&&await n.close(t)}if(this.log.trace("read response %o",o),o.status===Ue.OK&&o.reservation!=null){const c=new Set;c.add(e.remoteAddr.toString());for(const l of o.reservation.addrs){let u=X(l);u.getPeerId()==null&&(u=u.encapsulate(`/p2p/${e.remotePeer}`)),u=X(u.toString().replace(`/p2p/${e.remotePeer}/p2p/${e.remotePeer}`,`/p2p/${e.remotePeer}`)),c.add(u.toString())}return o.reservation.addrs=[...c].map(l=>X(l).bytes),o.reservation}const a=`reservation failed with status ${o.status??"undefined"}`;throw this.log.error(a),new Error(a)}async#t(e){const t=this.reservations.get(e);t!=null&&(this.log("removing relay reservation with %p from local store",e),clearTimeout(t.timeout),this.reservations.delete(e),t.type==="discovered"&&this.pendingReservations.push(t.id),await this.peerStore.merge(e,{tags:{[Fn]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:e,details:t}}),this.#r())}#r(){if(this.pendingReservations.length===0){this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),this.safeDispatchEvent("relay:found-enough-relays");return}this.relayFilter=dn(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")}}const Rb=r=>{if(r.peer==null)return!1;try{r.peer.addrs.forEach(X)}catch{return!1}return!0},kc={maxInboundStopStreams:yc,maxOutboundStopStreams:yc};class Ob{discovery;registrar;peerStore;connectionManager;transportManager;peerId;upgrader;addressManager;connectionGater;reservationStore;logger;maxInboundStopStreams;maxOutboundStopStreams;started;log;shutdownController;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:circuit-relay:transport"),this.registrar=e.registrar,this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.transportManager=e.transportManager,this.logger=e.logger,this.peerId=e.peerId,this.upgrader=e.upgrader,this.addressManager=e.addressManager,this.connectionGater=e.connectionGater,this.maxInboundStopStreams=t.maxInboundStopStreams??kc.maxInboundStopStreams,this.maxOutboundStopStreams=t.maxOutboundStopStreams??kc.maxOutboundStopStreams,this.shutdownController=new AbortController,this.discovery=new Cb(e,{filter:t.discoveryFilter??wb(Gw,Yw)}),this.discovery.addEventListener("relay:discover",n=>{this.reservationStore.addRelay(n.detail,"discovered").catch(s=>{s.name!=="HadEnoughRelaysError"&&s.name!=="RelayQueueFullError"&&this.log.error("could not add discovered relay %p",n.detail,s)})}),this.reservationStore=new Mb(e,t),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{this.discovery?.startDiscovery()}),this.reservationStore.addEventListener("relay:found-enough-relays",()=>{this.discovery?.stopDiscovery()}),this.started=!1}[Symbol.toStringTag]="@libp2p/circuit-relay-v2-transport";[it]=["@libp2p/transport","@libp2p/circuit-relay-v2-transport"];get[Zn](){return this.discovery!=null?["@libp2p/identify"]:[]}[To]=!0;isStarted(){return this.started}async start(){this.shutdownController=new AbortController,this.shutdownController.signal,await this.registrar.handle(mc,e=>{const t=this.upgrader.createInboundAbortSignal(this.shutdownController.signal);this.onStop(e,t).catch(n=>{this.log.error("error while handling STOP protocol",n),e.stream.abort(n)}).finally(()=>{t.clear()})},{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await Kl(this.discovery,this.reservationStore),this.started=!0}async stop(){this.shutdownController.abort(),await ql(this.discovery,this.reservationStore),await this.registrar.unhandle(mc),this.started=!1}async dial(e,t){if(e.protoCodes().filter(p=>p===Ww).length!==1){const p="Invalid circuit relay address";throw this.log.error(p,e),new Vr(p)}const n=e.toString().split("/p2p-circuit"),s=X(n[0]),i=X(n[n.length-1]),o=s.getPeerId(),a=i.getPeerId();if(o==null||a==null){const p=`ircuit relay dial to ${e.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${p}`),new Vr(`C${p}`)}const c=pt(o),l=pt(a);let d=this.connectionManager.getConnections(c)[0];d==null?(await this.peerStore.merge(c,{multiaddrs:[s]}),t.onProgress?.(new ie("circuit-relay:open-connection")),d=await this.connectionManager.openConnection(c,t)):t.onProgress?.(new ie("circuit-relay:reuse-connection"));let h;try{t.onProgress?.(new ie("circuit-relay:open-hop-stream")),h=await d.newStream(bs,t);const p=Tt(h),f=p.pb(xr);t.onProgress?.(new ie("circuit-relay:write-connect-message")),await f.write({type:xr.Type.CONNECT,peer:{id:l.toMultihash().bytes,addrs:[X(i).bytes]}},t),t.onProgress?.(new ie("circuit-relay:read-connect-response"));const g=await f.read(t);if(g.status!==Ue.OK)throw new ut(`failed to connect via relay with status ${g?.status?.toString()??"undefined"}`);const m=new Ac(g.limit),v=Ic({stream:p.unwrap(),remoteAddr:e,localAddr:s.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),logger:this.logger,onDataRead:m.onData,onDataWrite:m.onData});return this.log("new outbound relayed connection %a",v.remoteAddr),await this.upgrader.upgradeOutbound(v,{...t,limits:m.getLimits()})}catch(p){throw this.log.error("circuit relay dial to destination %p via relay %p failed",l,c,p),h?.abort(p),p}}createListener(e){return Tb({peerId:this.peerId,connectionManager:this.connectionManager,addressManager:this.addressManager,reservationStore:this.reservationStore,logger:this.logger})}listenFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>Md.exactMatch(t)||Rd.exactMatch(t))}dialFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>un.exactMatch(t))}async onStop({connection:e,stream:t},n){if(!this.reservationStore.hasReservation(e.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.transportManager.listen([e.remoteAddr.encapsulate("/p2p-circuit")])}catch(u){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on",u)}const s=Tt(t).pb(bt),i=await s.read({signal:n});if(this.log("new circuit relay v2 stop stream from %p with type %s",e.remotePeer,i.type),i?.type===void 0){this.log.error("type was missing from circuit v2 stop protocol request from %s",e.remotePeer),await s.write({type:bt.Type.STATUS,status:Ue.MALFORMED_MESSAGE},{signal:n}),await t.close();return}if(i.type!==bt.Type.CONNECT){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await s.write({type:bt.Type.STATUS,status:Ue.UNEXPECTED_MESSAGE},{signal:n}),await t.close();return}if(!Rb(i)){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await s.write({type:bt.Type.STATUS,status:Ue.MALFORMED_MESSAGE},{signal:n}),await t.close({signal:n});return}const o=vn(tr(i.peer.id));if(await this.connectionGater.denyInboundRelayedConnection?.(e.remotePeer,o)===!0){this.log.error("connection gater denied inbound relayed connection from %p",e.remotePeer),await s.write({type:bt.Type.STATUS,status:Ue.PERMISSION_DENIED},{signal:n}),await t.close({signal:n});return}this.log.trace("sending success response to %p",e.remotePeer),await s.write({type:bt.Type.STATUS,status:Ue.OK},{signal:n});const a=new Ac(i.limit),c=e.remoteAddr.encapsulate(`/p2p-circuit/p2p/${o.toString()}`);this.addressManager.getAddresses()[0];const l=Ic({stream:s.unwrap().unwrap(),remoteAddr:c,logger:this.logger,onDataRead:a.onData,onDataWrite:a.onData});this.log("new inbound relayed connection %a",l.remoteAddr),await this.upgrader.upgradeInbound(l,{limits:a.getLimits(),signal:n}),this.log("%s connection %a upgraded","inbound",l.remoteAddr)}}function Nb(r={}){return e=>new Ob(e,r)}function Fb(r){return r[Symbol.asyncIterator]!=null}function mo(r){if(Fb(r))return(async()=>{for await(const e of r);})();for(const e of r);}const Bn=globalThis.CustomEvent??Event;async function*Bd(r,e={}){let t=e.concurrency??1/0;t<1&&(t=1/0);const n=e.ordered??!1,s=new EventTarget,i=[];let o=he(),a=he(),c=!1,l,u=!1;s.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const f of r){if(i.length===t&&(o=he(),await o.promise),u)break;const g={done:!1};i.push(g),f().then(m=>{g.done=!0,g.ok=!0,g.value=m,s.dispatchEvent(new Bn("task-complete"))},m=>{g.done=!0,g.err=m,s.dispatchEvent(new Bn("task-complete"))})}c=!0,s.dispatchEvent(new Bn("task-complete"))}catch(f){l=f,s.dispatchEvent(new Bn("task-complete"))}});function d(){return n?i[0]?.done:!!i.find(f=>f.done)}function*h(){for(;i.length>0&&i[0].done;){const f=i[0];if(i.shift(),f.ok)yield f.value;else throw u=!0,o.resolve(),f.err;o.resolve()}}function*p(){for(;d();)for(let f=0;f<i.length;f++)if(i[f].done){const g=i[f];if(i.splice(f,1),f--,g.ok)yield g.value;else throw u=!0,o.resolve(),g.err;o.resolve()}}for(;;){if(d()||(a=he(),await a.promise),l!=null||(n?yield*h():yield*p(),l!=null))throw l;if(c&&i.length===0)break}}const Ub="0.1.0",Bb="id",$b="id/push",zb="1.0.0",Kb="1.0.0",qb=1024*8,Wb=32;var Ir;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.protocolVersion!=null&&(n.uint32(42),n.string(t.protocolVersion)),t.agentVersion!=null&&(n.uint32(50),n.string(t.agentVersion)),t.publicKey!=null&&(n.uint32(10),n.bytes(t.publicKey)),t.listenAddrs!=null)for(const i of t.listenAddrs)n.uint32(18),n.bytes(i);if(t.observedAddr!=null&&(n.uint32(34),n.bytes(t.observedAddr)),t.protocols!=null)for(const i of t.protocols)n.uint32(26),n.string(i);t.signedPeerRecord!=null&&(n.uint32(66),n.bytes(t.signedPeerRecord)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={listenAddrs:[],protocols:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 5:{i.protocolVersion=t.string();break}case 6:{i.agentVersion=t.string();break}case 1:{i.publicKey=t.bytes();break}case 2:{if(s.limits?.listenAddrs!=null&&i.listenAddrs.length===s.limits.listenAddrs)throw new It('Decode error - map field "listenAddrs" had too many elements');i.listenAddrs.push(t.bytes());break}case 4:{i.observedAddr=t.bytes();break}case 3:{if(s.limits?.protocols!=null&&i.protocols.length===s.limits.protocols)throw new It('Decode error - map field "protocols" had too many elements');i.protocols.push(t.string());break}case 8:{i.signedPeerRecord=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(Ir||(Ir={}));const Ze={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:qb,runOnConnectionOpen:!0,runOnSelfUpdate:!0,runOnLimitedConnection:!0,concurrency:Wb};function Vb(r){if(r!=null&&r.length>0)try{return X(r)}catch{}}function Hb(r,e){return e??r.userAgent}async function $d(r,e,t,n,s){if(t("received identify from %p",n.remotePeer),s==null)throw new ut("message was null or undefined");const i={};if(s.listenAddrs.length>0&&(i.addresses=s.listenAddrs.map(c=>({isCertified:!1,multiaddr:X(c)}))),s.protocols.length>0&&(i.protocols=s.protocols),s.publicKey!=null){const c=Bt(s.publicKey);if(!rn(c).equals(n.remotePeer))throw new ut("public key did not match remote PeerId");i.publicKey=c}let o;if(s.signedPeerRecord!=null){t.trace("received signedPeerRecord from %p",n.remotePeer);let c=s.signedPeerRecord;const l=await ht.openAndCertify(c,Qe.DOMAIN);let u=Qe.createFromProtobuf(l.payload);const d=En(l.publicKey.toCID());if(!u.peerId.equals(d))throw new ut("signing key does not match PeerId in the PeerRecord");if(!n.remotePeer.equals(u.peerId))throw new ut("signing key does not match remote PeerId");let h;try{h=await r.get(u.peerId)}catch(p){if(p.name!=="NotFoundError")throw p}if(h!=null&&(i.metadata=h.metadata,h.peerRecordEnvelope!=null)){const p=await ht.createFromProtobuf(h.peerRecordEnvelope),f=Qe.createFromProtobuf(p.payload);f.seqNumber>=u.seqNumber&&(t("sequence number was lower or equal to existing sequence number - stored: %d received: %d",f.seqNumber,u.seqNumber),u=f,c=h.peerRecordEnvelope)}i.peerRecordEnvelope=c,i.addresses=u.multiaddrs.map(p=>({isCertified:!0,multiaddr:p})),o={seq:u.seqNumber,addresses:u.multiaddrs}}else t("%p did not send a signed peer record",n.remotePeer);if(t.trace("patching %p with",n.remotePeer,i),await r.patch(n.remotePeer,i),s.agentVersion!=null||s.protocolVersion!=null){const c={};s.agentVersion!=null&&(c.AgentVersion=q(s.agentVersion)),s.protocolVersion!=null&&(c.ProtocolVersion=q(s.protocolVersion)),t.trace("merging %p metadata",n.remotePeer,c),await r.merge(n.remotePeer,{metadata:c})}const a={peerId:n.remotePeer,protocolVersion:s.protocolVersion,agentVersion:s.agentVersion,publicKey:s.publicKey,listenAddrs:s.listenAddrs.map(c=>X(c)),observedAddr:s.observedAddr==null?void 0:X(s.observedAddr),protocols:s.protocols,signedPeerRecord:o,connection:n};return e.safeDispatchEvent("peer:identify",{detail:a}),a}class zd{host;protocol;started;timeout;peerId;privateKey;peerStore;registrar;addressManager;maxInboundStreams;maxOutboundStreams;maxMessageSize;maxObservedAddresses;events;runOnLimitedConnection;log;constructor(e,t){this.protocol=t.protocol,this.started=!1,this.peerId=e.peerId,this.privateKey=e.privateKey,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.events=e.events,this.log=t.log,this.timeout=t.timeout??Ze.timeout,this.maxInboundStreams=t.maxInboundStreams??Ze.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??Ze.maxOutboundStreams,this.maxMessageSize=t.maxMessageSize??Ze.maxMessageSize,this.maxObservedAddresses=t.maxObservedAddresses??Ze.maxObservedAddresses,this.runOnLimitedConnection=t.runOnLimitedConnection??Ze.runOnLimitedConnection,this.host={protocolVersion:`${t.protocolPrefix??Ze.protocolPrefix}/${Ub}`,agentVersion:Hb(e.nodeInfo,t.agentVersion)}}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:q(this.host.agentVersion),ProtocolVersion:q(this.host.protocolVersion)}}),await this.registrar.handle(this.protocol,e=>{this.handleProtocol(e).catch(t=>{this.log.error(t)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.registrar.unhandle(this.protocol),this.started=!1}}class Gb extends zd{connectionManager;concurrency;constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??Ze.protocolPrefix}/${$b}/${Kb}`,log:e.logger.forComponent("libp2p:identify-push")}),this.connectionManager=e.connectionManager,this.concurrency=t.concurrency??Ze.concurrency,(t.runOnSelfUpdate??Ze.runOnSelfUpdate)&&e.events.addEventListener("self:peer:update",n=>{this.push().catch(s=>{this.log.error(s)})})}[it]=["@libp2p/identify-push"];async push(){if(!this.isStarted())return;const e=this.addressManager.getAddresses().map(u=>u.decapsulateCode(G("p2p").code)),t=new Qe({peerId:this.peerId,multiaddrs:e}),n=await ht.seal(t,this.privateKey),s=this.registrar.getProtocols(),i=await this.peerStore.get(this.peerId),o=Y(i.metadata.get("AgentVersion")??q(this.host.agentVersion)),a=Y(i.metadata.get("ProtocolVersion")??q(this.host.protocolVersion)),c=this;async function*l(){for(const u of c.connectionManager.getConnections())(await c.peerStore.get(u.remotePeer)).protocols.includes(c.protocol)&&(yield async()=>{let h;const p=AbortSignal.timeout(c.timeout);try{h=await u.newStream(c.protocol,{signal:p,runOnLimitedConnection:c.runOnLimitedConnection}),await Tt(h,{maxDataLength:c.maxMessageSize}).pb(Ir).write({listenAddrs:e.map(g=>g.bytes),signedPeerRecord:n.marshal(),protocols:s,agentVersion:o,protocolVersion:a},{signal:p}),await h.close({signal:p})}catch(f){c.log.error("could not push identify update to peer",f),h?.abort(f)}})}await mo(Bd(l(),{concurrency:this.concurrency}))}async handleProtocol(e){const{connection:t,stream:n}=e;try{if(this.peerId.equals(t.remotePeer))throw new Error("received push from ourselves?");const s={signal:AbortSignal.timeout(this.timeout)},o=await Tt(n,{maxDataLength:this.maxMessageSize}).pb(Ir).read(s);await n.close(s),await $d(this.peerStore,this.events,this.log,t,o)}catch(s){this.log.error("received invalid message",s),n.abort(s);return}this.log.trace("handled push from %p",t.remotePeer)}}const Yb=41;function Xb(r){try{const[[e,t]]=r.stringTuples();if(t==null)return!1;if(e===Yb)return vw("2000::/3",t)}catch{}return!1}function Gs(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var ar={},_c;function Qb(){return _c||(_c=1,function(){var r,e,t,n,s,i,o,a;a=function(c){var l,u,d,h;return l=(c&255<<24)>>>24,u=(c&255<<16)>>>16,d=(c&65280)>>>8,h=c&255,[l,u,d,h].join(".")},o=function(c){var l,u,d,h,p,f;for(l=[],d=h=0;h<=3&&c.length!==0;d=++h){if(d>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}f=e(c),p=f[0],u=f[1],c=c.substring(u),l.push(p)}if(c.length!==0)throw new Error("Invalid IP");switch(l.length){case 1:if(l[0]>4294967295)throw new Error("Invalid IP");return l[0]>>>0;case 2:if(l[0]>255||l[1]>16777215)throw new Error("Invalid IP");return(l[0]<<24|l[1])>>>0;case 3:if(l[0]>255||l[1]>255||l[2]>65535)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2])>>>0;case 4:if(l[0]>255||l[1]>255||l[2]>255||l[3]>255)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2]<<8|l[3])>>>0;default:throw new Error("Invalid IP")}},t=function(c){return c.charCodeAt(0)},n=t("0"),i=t("a"),s=t("A"),e=function(c){var l,u,d,h,p;for(h=0,l=10,u="9",d=0,c.length>1&&c[d]==="0"&&(c[d+1]==="x"||c[d+1]==="X"?(d+=2,l=16):"0"<=c[d+1]&&c[d+1]<="9"&&(d++,l=8,u="7")),p=d;d<c.length;){if("0"<=c[d]&&c[d]<=u)h=h*l+(t(c[d])-n)>>>0;else if(l===16)if("a"<=c[d]&&c[d]<="f")h=h*l+(10+t(c[d])-i)>>>0;else if("A"<=c[d]&&c[d]<="F")h=h*l+(10+t(c[d])-s)>>>0;else break;else break;if(h>4294967295)throw new Error("too large");d++}if(d===p)throw new Error("empty octet");return[h,d]},r=function(){function c(l,u){var d,h,p;if(typeof l!="string")throw new Error("Missing `net' parameter");if(u||(p=l.split("/",2),l=p[0],u=p[1]),u||(u=32),typeof u=="string"&&u.indexOf(".")>-1){try{this.maskLong=o(u)}catch{throw new Error("Invalid mask: "+u)}for(d=h=32;h>=0;d=--h)if(this.maskLong===4294967295<<32-d>>>0){this.bitmask=d;break}}else if(u||u===0)this.bitmask=parseInt(u,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(l)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+l)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+u);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(l){return typeof l=="string"&&(l.indexOf("/")>0||l.split(".").length!==4)&&(l=new c(l)),l instanceof c?this.contains(l.base)&&this.contains(l.broadcast||l.last):(o(l)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(l){return l==null&&(l=1),new c(a(this.netLong+this.size*l),this.mask)},c.prototype.forEach=function(l){var u,d,h;for(h=o(this.first),d=o(this.last),u=0;h<=d;)l(a(h),h,u),u++,h++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),ar.ip2long=o,ar.long2ip=a,ar.Netmask=r}.call(ar)),ar}var jb=Qb();const Zb=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],Jb=Zb.map(r=>new jb.Netmask(r));function la(r){for(const e of Jb)if(e.contains(r))return!0;return!1}function e0(r){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(r)}function t0(r){const e=r.split(":");if(e.length<2)return!1;const t=e[e.length-1].padStart(4,"0"),n=e[e.length-2].padStart(4,"0"),s=`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(t.substring(0,2),16)}.${parseInt(t.substring(2),16)}`;return la(s)}function r0(r){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)}function n0(r){const e=r.split(":"),t=e[e.length-1];return la(t)}function s0(r){return/^::$/.test(r)||/^::1$/.test(r)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(r)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(r)||/^ff([0-9a-fA-F]{2,2}):/i.test(r)}function Ys(r){return Sr(r)?la(r):e0(r)?t0(r):r0(r)?n0(r):Jo(r)?s0(r):void 0}const i0=4,o0=41;function Kd(r){try{const[[e]]=r.stringTuples();return e===i0||e===o0}catch{}return!1}function hn(r){try{if(!Kd(r))return!1;const[[,e]]=r.stringTuples();return e==null?!1:Ys(e)??!1}catch{}return!0}const a0=41;class c0 extends zd{constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??Ze.protocolPrefix}/${Bb}/${zb}`,log:e.logger.forComponent("libp2p:identify")}),(t.runOnConnectionOpen??Ze.runOnConnectionOpen)&&e.events.addEventListener("connection:open",n=>{const s=n.detail;this.identify(s).catch(i=>{i.name!==_o.name&&this.log.error("error during identify trigged by connection:open",i)})})}[it]=["@libp2p/identify"];async _identify(e,t={}){let n;if(t.signal==null){const s=AbortSignal.timeout(this.timeout);t={...t,signal:s}}try{n=await e.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const i=await Tt(n,{maxDataLength:this.maxMessageSize}).pb(Ir).read(t);return await n.close(t),i}catch(s){throw n?.abort(s),s}}async identify(e,t={}){const n=await this._identify(e,t),{publicKey:s,protocols:i,observedAddr:o}=n;if(s==null)throw new ut("public key was missing from identify message");const a=Bt(s),c=En(a.toCID());if(!e.remotePeer.equals(c))throw new ut("identified peer does not match the expected peer");if(this.peerId.equals(c))throw new ut("identified peer is our own peer id?");return this.maybeAddObservedAddress(o),this.log("identify completed for peer %p and protocols %o",c,i),$d(this.peerStore,this.events,this.log,e,n)}maybeAddObservedAddress(e){const t=Vb(e);if(t==null)return;if(this.log.trace("our observed address was %a",t),hn(t)){this.log.trace("our observed address was private");return}if(t.stringTuples()[0][0]===a0&&!Xb(t)){this.log.trace("our observed address was IPv6 but not a global unicast address");return}As.exactMatch(t)||(this.log.trace("storing the observed address"),this.addressManager.addObservedAddr(t))}async handleProtocol(e){const{connection:t,stream:n}=e,s=AbortSignal.timeout(this.timeout);try{const i=await this.peerStore.get(this.peerId),o=this.addressManager.getAddresses().map(u=>u.decapsulateCode(G("p2p").code));let a=i.peerRecordEnvelope;if(o.length>0&&a==null){const u=new Qe({peerId:this.peerId,multiaddrs:o});a=(await ht.seal(u,this.privateKey)).marshal().subarray()}let c=t.remoteAddr.bytes;Zw.matches(t.remoteAddr)||(c=void 0),await Tt(n).pb(Ir).write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:At(this.privateKey.publicKey),listenAddrs:o.map(u=>u.bytes),signedPeerRecord:a,observedAddr:c,protocols:i.protocols},{signal:s}),await n.close({signal:s})}catch(i){this.log.error("could not respond to identify request",i),n.abort(i)}}}function l0(r={}){return e=>new c0(e,r)}function u0(r={}){return e=>new Gb(e,r)}const Ei=32,d0="1.0.0",h0="ping",f0="ipfs",p0=1e4,g0=2,m0=1;class y0{protocol;components;started;timeout;maxInboundStreams;maxOutboundStreams;runOnLimitedConnection;log;constructor(e,t={}){this.components=e,this.log=e.logger.forComponent("libp2p:ping"),this.started=!1,this.protocol=`/${t.protocolPrefix??f0}/${h0}/${d0}`,this.timeout=t.timeout??p0,this.maxInboundStreams=t.maxInboundStreams??g0,this.maxOutboundStreams=t.maxOutboundStreams??m0,this.runOnLimitedConnection=t.runOnLimitedConnection??!0,this.handleMessage=this.handleMessage.bind(this)}[Symbol.toStringTag]="@libp2p/ping";[it]=["@libp2p/ping"];async start(){await this.components.registrar.handle(this.protocol,this.handleMessage,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(e){this.log("incoming ping from %p",e.connection.remotePeer);const{stream:t}=e,n=Date.now(),s=ds(t);let i=!1;Promise.resolve().then(async()=>{for(;;){const o=AbortSignal.timeout(this.timeout);o.addEventListener("abort",()=>{t?.abort(new Po("ping timeout"))});const a=await s.read({bytes:Ei,signal:o});await s.write(a,{signal:o}),i=!0}}).catch(o=>{i&&o.name==="UnexpectedEOFError"&&t.readStatus!=="ready"||(this.log.error("incoming ping from %p failed with error - %e",e.connection.remotePeer,o),t?.abort(o))}).finally(()=>{const o=Date.now()-n;this.log("incoming ping from %p complete in %dms",e.connection.remotePeer,o);const a=AbortSignal.timeout(this.timeout);t.close({signal:a}).catch(c=>{this.log.error("error closing ping stream from %p - %e",e.connection.remotePeer,c),t?.abort(c)})})}async ping(e,t={}){this.log("pinging %p",e);const n=Date.now(),s=Yo(Ei),i=await this.components.connectionManager.openConnection(e,t);let o;if(t.signal==null){const a=AbortSignal.timeout(this.timeout);t={...t,signal:a}}try{o=await i.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const a=ds(o),[,c]=await Promise.all([a.write(s,t),a.read({...t,bytes:Ei})]),l=Date.now()-n;if(!Oe(s,c.subarray()))throw new zh(`Received wrong ping ack after ${l}ms`);return this.log("ping %p complete in %dms",i.remotePeer,l),l}catch(a){throw this.log.error("error while pinging %p",i.remotePeer,a),o?.abort(a),a}finally{o!=null&&await o.close(t)}}}function w0(r={}){return e=>new y0(e,r)}var ze;(function(r){(function(n){n.FIN="FIN",n.STOP_SENDING="STOP_SENDING",n.RESET="RESET",n.FIN_ACK="FIN_ACK"})(r.Flag||(r.Flag={}));let e;(function(n){n[n.FIN=0]="FIN",n[n.STOP_SENDING=1]="STOP_SENDING",n[n.RESET=2]="RESET",n[n.FIN_ACK=3]="FIN_ACK"})(e||(e={})),function(n){n.codec=()=>Dr(e)}(r.Flag||(r.Flag={}));let t;r.codec=()=>(t==null&&(t=me((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.flag!=null&&(s.uint32(8),r.Flag.codec().encode(n.flag,s)),n.message!=null&&(s.uint32(18),s.bytes(n.message)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.flag=r.Flag.codec().decode(n);break}case 2:{o.message=n.bytes();break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>ge(n,r.codec()),r.decode=(n,s)=>pe(n,r.codec(),s)})(ze||(ze={}));const b0=["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478","stun:stun.cloudflare.com:3478","stun:stun.services.mozilla.com:3478"];Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");const v0=2*1024*1024,E0=30*1e3,qd=16*1024;function S0(r=qd){const e=Ae(r-Ae(r)),t=1+Ae(Object.keys(ze.Flag).length-1),n=1,s=r-e-t-n,i=Ae(s);return e+t+n+i}const x0=S0(),A0=5e3,C0=5e3,I0=3e4,Wd="/webrtc",yo="/webrtc-signaling/0.0.1";var Pc=function(r,e,t){if(t||arguments.length===2)for(var n=0,s=e.length,i;n<s;n++)(i||!(n in e))&&(i||(i=Array.prototype.slice.call(e,0,n)),i[n]=e[n]);return r.concat(i||Array.prototype.slice.call(e))},T0=function(){function r(e,t,n){this.name=e,this.version=t,this.os=n,this.type="browser"}return r}(),k0=function(){function r(e){this.version=e,this.type="node",this.name="node",this.os=process.platform}return r}(),_0=function(){function r(e,t,n,s){this.name=e,this.version=t,this.os=n,this.bot=s,this.type="bot-device"}return r}(),P0=function(){function r(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return r}(),L0=function(){function r(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return r}(),D0=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,M0=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,Lc=3,R0=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",D0]],Dc=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function O0(r){return typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new L0:typeof navigator<"u"?F0(navigator.userAgent):B0()}function N0(r){return r!==""&&R0.reduce(function(e,t){var n=t[0],s=t[1];if(e)return e;var i=s.exec(r);return!!i&&[n,i]},!1)}function F0(r){var e=N0(r);if(!e)return null;var t=e[0],n=e[1];if(t==="searchbot")return new P0;var s=n[1]&&n[1].split(".").join("_").split("_").slice(0,3);s?s.length<Lc&&(s=Pc(Pc([],s,!0),$0(Lc-s.length),!0)):s=[];var i=s.join("."),o=U0(r),a=M0.exec(r);return a&&a[1]?new _0(t,i,o,a[1]):new T0(t,i,o)}function U0(r){for(var e=0,t=Dc.length;e<t;e++){var n=Dc[e],s=n[0],i=n[1],o=i.exec(r);if(o)return s}return null}function B0(){var r=typeof process<"u"&&process.version;return r?new k0(process.version.slice(1)):null}function $0(r){for(var e=[],t=0;t<r;t++)e.push("0");return e}class Vd extends Error{constructor(e){super(e),this.name="TimeoutError"}}let z0=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}};const Mc=r=>globalThis.DOMException===void 0?new z0(r):new DOMException(r),Rc=r=>{const e=r.reason===void 0?Mc("This operation was aborted."):r.reason;return e instanceof Error?e:Mc(e)};function ua(r,e){const{milliseconds:t,fallback:n,message:s,customTimers:i={setTimeout,clearTimeout}}=e;let o,a;const l=new Promise((u,d)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(e.signal){const{signal:p}=e;p.aborted&&d(Rc(p)),a=()=>{d(Rc(p))},p.addEventListener("abort",a,{once:!0})}if(t===Number.POSITIVE_INFINITY){r.then(u,d);return}const h=new Vd;o=i.setTimeout.call(void 0,()=>{if(n){try{u(n())}catch(p){d(p)}return}typeof r.cancel=="function"&&r.cancel(),s===!1?u():s instanceof Error?d(s):(h.message=s??`Promise timed out after ${t} milliseconds`,d(h))},t),(async()=>{try{u(await r)}catch(p){d(p)}})()}).finally(()=>{l.clear(),a&&e.signal&&e.signal.removeEventListener("abort",a)});return l.clear=()=>{i.clearTimeout.call(void 0,o),o=void 0},l}const Oc=O0(),Hd=Oc!=null&&Oc.name==="firefox",Gd=async function*(){},Yd=async r=>{};function K0(r,e,t=I0,n){r.readyState==="open"&&Promise.resolve().then(async()=>{if(r.bufferedAmount>0){n.log("%s drain channel with %d buffered bytes",e,r.bufferedAmount);const s=he();let i=!1;r.bufferedAmountLowThreshold=0;const o=()=>{i||(n.log("%s drain channel closed before drain",e),s.resolve())};r.addEventListener("close",o,{once:!0}),r.addEventListener("bufferedamountlow",()=>{i=!0,r.removeEventListener("close",o),s.resolve()}),await ua(s.promise,{milliseconds:t})}}).then(async()=>{r.readyState==="open"&&r.close()}).catch(s=>{n.log.error("error closing outbound stream",s)})}async function Nc(r){return r=r??{},typeof r=="function"&&(r=await r()),r.iceServers=r.iceServers??b0.map(e=>({urls:[e]})),r}class Fc{log;peerConnection;remoteAddr;timeline;metrics;source=Gd();sink=Yd;constructor(e,t){this.log=e.logger.forComponent("libp2p:webrtc:maconn"),this.remoteAddr=t.remoteAddr,this.timeline=t.timeline,this.peerConnection=t.peerConnection;const n=this.peerConnection,s=n.connectionState;this.peerConnection.onconnectionstatechange=()=>{this.log.trace("peer connection state change",n.connectionState,"initial state",s),(n.connectionState==="disconnected"||n.connectionState==="failed"||n.connectionState==="closed")&&(this.timeline.close=Date.now())}}async close(e){this.log.trace("closing connection"),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({close:!0})}abort(e){this.log.error("closing connection due to error",e),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({abort:!0})}}class q0 extends ad{channel;incomingData;maxBufferedAmount;bufferedAmountLowEventTimeout;maxMessageSize;receiveFinAck;finAckTimeout;openTimeout;closeController;constructor(e){const t=e.onEnd;switch(e.onEnd=s=>{this.log.trace('readable and writeable ends closed with status "%s"',this.status),Promise.resolve(async()=>{if(!(this.timeline.abort!=null||this.timeline.reset!==null))try{await ua(this.receiveFinAck.promise,{milliseconds:this.finAckTimeout})}catch(i){this.log.error("error receiving FIN_ACK",i)}}).then(()=>{this.incomingData.end(),t?.(s)}).catch(i=>{this.log.error("error ending stream",i)}).finally(()=>{this.channel.close()})},super(e),this.channel=e.channel,this.channel.binaryType="arraybuffer",this.incomingData=Sn(),this.bufferedAmountLowEventTimeout=e.bufferedAmountLowEventTimeout??E0,this.maxBufferedAmount=e.maxBufferedAmount??v0,this.maxMessageSize=(e.maxMessageSize??qd)-x0,this.receiveFinAck=he(),this.finAckTimeout=e.closeTimeout??A0,this.openTimeout=e.openTimeout??C0,this.closeController=new AbortController,this.channel.readyState){case"open":this.timeline.open=new Date().getTime();break;case"closed":case"closing":(this.timeline.close===void 0||this.timeline.close===0)&&(this.timeline.close=Date.now());break;case"connecting":break;default:throw this.log.error("unknown datachannel state %s",this.channel.readyState),new Ki("Unknown datachannel state")}this.channel.onopen=s=>{this.timeline.open=new Date().getTime()},this.channel.onclose=s=>{this.log.trace("received onclose event"),this.closeController.abort(),this.receiveFinAck.resolve(),this.close().catch(i=>{this.log.error("error closing stream after channel closed",i)})},this.channel.onerror=s=>{this.log.trace("received onerror event"),this.closeController.abort();const i=s.error;this.abort(i)},this.channel.onmessage=async s=>{const{data:i}=s;i===null||i.byteLength===0||this.incomingData.push(new Uint8Array(i,0,i.byteLength))};const n=this;Promise.resolve().then(async()=>{for await(const s of us(this.incomingData)){const i=n.processIncomingProtobuf(s);i!=null&&n.sourcePush(new Z(i))}}).catch(s=>{this.log.error("error processing incoming data channel messages",s)})}sendNewStream(){}async _sendMessage(e,t=!0){if(this.channel.readyState==="closed"||this.channel.readyState==="closing")throw new Ki(`Invalid datachannel state - ${this.channel.readyState}`);if(this.channel.readyState!=="open"){const n=AbortSignal.timeout(this.openTimeout),s=$t([this.closeController.signal,n]);try{this.log('channel state is "%s" and not "open", waiting for "open" event before sending data',this.channel.readyState),await pr(this.channel,"open",s)}finally{s.clear()}this.log('channel state is now "%s", sending data',this.channel.readyState)}if(t&&this.channel.bufferedAmount>this.maxBufferedAmount){const n=AbortSignal.timeout(this.bufferedAmountLowEventTimeout),s=$t([this.closeController.signal,n]);try{this.log('channel buffer is %d, wait for "bufferedamountlow" event',this.channel.bufferedAmount),await pr(this.channel,"bufferedamountlow",s)}catch(i){throw n.aborted?new Po(`Timed out waiting for DataChannel buffer to clear after ${this.bufferedAmountLowEventTimeout}ms`):i}finally{s.clear()}}try{this.log.trace('sending message, channel state "%s"',this.channel.readyState),this.channel.send(e.subarray())}catch(n){this.log.error("error while sending message",n)}}async sendData(e){const t=e.byteLength;for(e=e.sublist();e.byteLength>0;){const n=Math.min(e.byteLength,this.maxMessageSize),s=e.subarray(0,n),i=ze.encode({message:s}),o=ls.single(i);this.log.trace("sending %d/%d bytes on channel",s.byteLength,t),await this._sendMessage(o),e.consume(n)}this.log.trace('finished sending data, channel state "%s"',this.channel.readyState)}async sendReset(){try{await this._sendFlag(ze.Flag.RESET)}catch(e){this.log.error("failed to send reset - %e",e)}finally{this.channel.close()}}async sendCloseWrite(e){if(this.channel.readyState!=="open"){this.receiveFinAck.resolve();return}if(await this._sendFlag(ze.Flag.FIN)){this.log.trace("awaiting FIN_ACK");try{await Je(this.receiveFinAck.promise,e?.signal,{errorMessage:"sending close-write was aborted before FIN_ACK was received",errorName:"FinAckNotReceivedError"})}catch(n){this.log.error("failed to await FIN_ACK",n)}}else this.log.trace("sending FIN failed, not awaiting FIN_ACK");this.receiveFinAck.resolve()}async sendCloseRead(){this.channel.readyState==="open"&&await this._sendFlag(ze.Flag.STOP_SENDING)}processIncomingProtobuf(e){const t=ze.decode(e);if(t.flag!==void 0&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',t.flag,this.writeStatus,this.readStatus),t.flag===ze.Flag.FIN&&(this.remoteCloseWrite(),this.log.trace("sending FIN_ACK"),this._sendFlag(ze.Flag.FIN_ACK).catch(n=>{this.log.error("error sending FIN_ACK immediately",n)})),t.flag===ze.Flag.RESET&&this.reset(),t.flag===ze.Flag.STOP_SENDING&&this.remoteCloseRead(),t.flag===ze.Flag.FIN_ACK&&(this.log.trace("received FIN_ACK"),this.receiveFinAck.resolve())),this.readStatus==="ready")return t.message}async _sendFlag(e){if(this.channel.readyState!=="open")return this.log.trace('not sending flag %s because channel is "%s" and not "open"',e.toString(),this.channel.readyState),!1;this.log.trace("sending flag %s",e.toString());const t=ze.encode({flag:e}),n=ls.single(t);try{return await this._sendMessage(n,!1),!0}catch(s){this.log.error("could not send flag %s - %e",e.toString(),s)}return!1}}function wo(r){const{channel:e,direction:t,handshake:n}=r;return new q0({id:`${e.id}`,log:r.logger.forComponent(`libp2p:webrtc:stream:${n===!0?"handshake":t}:${e.id}`),...r})}class Xd{protocol;peerConnection;bufferedStreams=[];metrics;dataChannelOptions;components;log;constructor(e,t){this.components=e,this.peerConnection=t.peerConnection,this.metrics=t.metrics,this.protocol=t.protocol??Wd,this.dataChannelOptions=t.dataChannelOptions??{},this.log=e.logger.forComponent("libp2p:webrtc:muxerfactory"),this.peerConnection.ondatachannel=({channel:n})=>{if(this.log.trace('incoming early datachannel with channel id %d and label "%s"',n.id),n.label==="init"){this.log.trace("closing early init channel"),n.close();return}const s={},i=wo({channel:n,direction:"inbound",onEnd:o=>{s.onEnd(o)},logger:e.logger,...this.dataChannelOptions});s.stream=i,s.channel=n,s.onEnd=()=>{this.bufferedStreams=this.bufferedStreams.filter(o=>o.stream.id!==i.id)},this.bufferedStreams.push(s)}}createStreamMuxer(e){return new W0(this.components,{...e,peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,streams:this.bufferedStreams,protocol:this.protocol})}}class W0{init;streams;protocol;log;peerConnection;dataChannelOptions;metrics;logger;constructor(e,t){this.init=t,this.log=e.logger.forComponent("libp2p:webrtc:muxer"),this.logger=e.logger,this.streams=t.streams.map(n=>n.stream),this.peerConnection=t.peerConnection,this.protocol=t.protocol??Wd,this.metrics=t.metrics,this.dataChannelOptions=t.dataChannelOptions??{},this.peerConnection.ondatachannel=({channel:n})=>{if(this.log.trace("incoming datachannel with channel id %d",n.id),n.label==="init"){this.log.trace("closing init channel"),n.close();return}const s=n.id,i=wo({channel:n,direction:"inbound",onEnd:()=>{this.#e(i,n),this.log("incoming channel %s ended",s)},logger:this.logger,...this.dataChannelOptions});this.streams.push(i),this.metrics?.increment({incoming_stream:!0}),t?.onIncomingStream?.(i)},this.init.streams.length>0&&queueMicrotask(()=>{this.init.streams.forEach(n=>{n.onEnd=()=>{this.log("incoming early channel %s ended with state %s",n.channel.id,n.channel.readyState),this.#e(n.stream,n.channel)},this.metrics?.increment({incoming_stream:!0}),this.init?.onIncomingStream?.(n.stream)})})}#e(e,t){this.log.trace("stream %s %s %s onEnd",e.direction,e.id,e.protocol),K0(t,`${e.direction} ${e.id} ${e.protocol}`,this.dataChannelOptions.drainTimeout,{log:this.log}),this.streams=this.streams.filter(n=>n.id!==e.id),this.metrics?.increment({stream_end:!0}),this.init?.onStreamEnd?.(e)}async close(e){try{await Promise.all(this.streams.map(async t=>t.close(e)))}catch(t){this.abort(t)}}abort(e){for(const t of this.streams)t.abort(e)}source=Gd();sink=Yd;newStream(){const e=this.peerConnection.createDataChannel(""),t=e.id;this.log.trace("opened outgoing datachannel with channel id %s",t);const n=wo({channel:e,direction:"outbound",onEnd:()=>{this.#e(n,e),this.log("outgoing channel %s ended",t)},logger:this.logger,...this.dataChannelOptions});return this.streams.push(n),this.metrics?.increment({outgoing_stream:!0}),n}}const Qd=globalThis.RTCPeerConnection,jd=globalThis.RTCSessionDescription,V0=globalThis.RTCIceCandidate;class H0 extends Error{constructor(e){super(`WebRTC transport error: ${e}`),this.name="WebRTCTransportError"}}class Rt extends H0{constructor(e="SDP handshake failed"){super(e),this.name="SDPHandshakeFailedError"}}var st;(function(r){(function(n){n.SDP_OFFER="SDP_OFFER",n.SDP_ANSWER="SDP_ANSWER",n.ICE_CANDIDATE="ICE_CANDIDATE"})(r.Type||(r.Type={}));let e;(function(n){n[n.SDP_OFFER=0]="SDP_OFFER",n[n.SDP_ANSWER=1]="SDP_ANSWER",n[n.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(e||(e={})),function(n){n.codec=()=>Dr(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=me((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.data!=null&&(s.uint32(18),s.string(n.data)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.data=n.string();break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>ge(n,r.codec()),r.decode=(n,s)=>pe(n,r.codec(),s)})(st||(st={}));const Zd=async(r,e,t)=>{try{const n=he();for(G0(r,n);;){const s=await Promise.race([n.promise,e.read({signal:t.signal}).catch(()=>{})]);if(s==null){t.signal?.throwIfAborted();break}if(s.type!==st.Type.ICE_CANDIDATE)throw new ut("ICE candidate message expected");const i=JSON.parse(s.data??"null");if(i===""||i===null){t.onProgress?.(new ie("webrtc:end-of-ice-candidates")),t.log.trace("end-of-candidates received");continue}const o=new V0(i);t.log.trace("%s received new ICE candidate %o",t.direction,i);try{t.onProgress?.(new ie("webrtc:add-ice-candidate",o.candidate)),await r.addIceCandidate(o)}catch(a){t.log.error("%s bad candidate received",t.direction,i,a)}}}catch(n){if(t.log.error("%s error parsing ICE candidate",t.direction,n),t.signal?.aborted===!0&&da(r)!=="connected")throw n}};function da(r){return Hd?r.iceConnectionState:r.connectionState}function G0(r,e){r[Hd?"oniceconnectionstatechange":"onconnectionstatechange"]=t=>{switch(da(r)){case"connected":e.resolve();break;case"failed":case"disconnected":case"closed":e.reject(new Ul("RTCPeerConnection was closed"));break}}}async function Y0({rtcConfiguration:r,dataChannel:e,signal:t,metrics:n,multiaddr:s,connectionManager:i,transportManager:o,log:a,logger:c,onProgress:l}){const{baseAddr:u}=j0(s);n?.dialerEvents.increment({open:!0}),a.trace("dialing base address: %a",u);const d=u.getPeerId();if(d==null)throw new V("Relay peer was missing");const h=i.getConnections(pt(d));let p,f=!1;h.length===0?(l?.(new ie("webrtc:dial-relay")),p=await o.dial(u,{signal:t,onProgress:l}),f=!0):(l?.(new ie("webrtc:reuse-relay-connection")),p=h[0]);try{l?.(new ie("webrtc:open-signaling-stream"));const g=await p.newStream(yo,{signal:t,runOnLimitedConnection:!0}),m=Tt(g).pb(st),v=new Qd(r),k=new Xd({logger:c},{peerConnection:v,dataChannelOptions:e});try{const b=v.createDataChannel("init");v.onicecandidate=({candidate:x})=>{const _=JSON.stringify(x?.toJSON()??null);a.trace("initiator sending ICE candidate %o",x),m.write({type:st.Type.ICE_CANDIDATE,data:_},{signal:t}).catch(D=>{a.error("error sending ICE candidate",D)})},v.onicecandidateerror=x=>{a.error("initiator ICE candidate error",x)};const w=await v.createOffer().catch(x=>{throw a.error("could not execute createOffer",x),new Rt("Failed to set createOffer")});a.trace("initiator send SDP offer %s",w.sdp),l?.(new ie("webrtc:send-sdp-offer")),await m.write({type:st.Type.SDP_OFFER,data:w.sdp},{signal:t}),await v.setLocalDescription(w).catch(x=>{throw a.error("could not execute setLocalDescription",x),new Rt("Failed to set localDescription")}),l?.(new ie("webrtc:read-sdp-answer")),a.trace("initiator read SDP answer");const E=await m.read({signal:t});if(E.type!==st.Type.SDP_ANSWER)throw new Rt("Remote should send an SDP answer");a.trace("initiator received SDP answer %s",E.data);const P=new jd({type:"answer",sdp:E.data});return await v.setRemoteDescription(P).catch(x=>{throw a.error("could not execute setRemoteDescription",x),new Rt("Failed to set remoteDescription")}),a.trace("initiator read candidates until connected"),l?.(new ie("webrtc:read-ice-candidates")),await Zd(v,m,{direction:"initiator",signal:t,log:a,onProgress:l}),a.trace("initiator connected, closing init channel"),b.close(),l?.(new ie("webrtc:close-signaling-stream")),a.trace("closing signaling channel"),await g.close({signal:t}),a.trace("initiator connected to remote address %s",s),{remoteAddress:s,peerConnection:v,muxerFactory:k}}catch(b){throw a.error("outgoing signaling error",b),v.close(),g.abort(b),b}finally{v.onicecandidate=null,v.onicecandidateerror=null}}finally{if(f)try{await p.close({signal:t})}catch(g){p.abort(g)}}}const Uc=le(Dd.matchers[0],Q("p2p-circuit"));class ha extends Ut{transportManager;shutdownController;events;constructor(e,t){super(),this.transportManager=e.transportManager,this.events=e.events,this.shutdownController=t.shutdownController,this.onTransportListening=this.onTransportListening.bind(this)}async listen(){this.events.addEventListener("transport:listening",this.onTransportListening)}onTransportListening(e){e.detail.getAddrs().filter(n=>Uc.exactMatch(n)).map(n=>n.encapsulate("/webrtc")).length>0&&this.safeDispatchEvent("listening")}getAddrs(){return this.transportManager.getListeners().filter(e=>!(e instanceof ha)).map(e=>e.getAddrs().filter(t=>Uc.exactMatch(t)).map(t=>t.encapsulate("/webrtc"))).flat()}updateAnnounceAddrs(){}async close(){this.events.removeEventListener("transport:listening",this.onTransportListening),this.shutdownController.abort(),queueMicrotask(()=>{this.safeDispatchEvent("close")})}}async function X0({peerConnection:r,stream:e,signal:t,connection:n,log:s}){s.trace("new inbound signaling stream");const i=Tt(e).pb(st);try{r.onicecandidate=({candidate:u})=>{const d=JSON.stringify(u?.toJSON()??null);s.trace("recipient sending ICE candidate %s",d),i.write({type:st.Type.ICE_CANDIDATE,data:d},{signal:t}).catch(h=>{s.error("error sending ICE candidate",h)})},s.trace("recipient read SDP offer");const a=await i.read({signal:t});if(a.type!==st.Type.SDP_OFFER)throw new Rt(`expected message type SDP_OFFER, received: ${a.type??"undefined"} `);s.trace("recipient received SDP offer %s",a.data);const c=new jd({type:"offer",sdp:a.data});await r.setRemoteDescription(c).catch(u=>{throw s.error("could not execute setRemoteDescription",u),new Rt("Failed to set remoteDescription")});const l=await r.createAnswer().catch(u=>{throw s.error("could not execute createAnswer",u),new Rt("Failed to create answer")});s.trace("recipient send SDP answer %s",l.sdp),await i.write({type:st.Type.SDP_ANSWER,data:l.sdp},{signal:t}),await r.setLocalDescription(l).catch(u=>{throw s.error("could not execute setLocalDescription",u),new Rt("Failed to set localDescription")}),s.trace("recipient read candidates until connected"),await Zd(r,i,{direction:"recipient",signal:t,log:s})}catch(a){if(da(r)!=="connected")throw s.error("error while handling signaling stream from peer %a",n.remoteAddr,a),r.close(),a;s("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",n.remoteAddr,a)}const o=X(`/webrtc/p2p/${n.remoteAddr.getPeerId()}`);return s.trace("recipient connected to remote address %s",o),{remoteAddress:o}}class Q0{components;init;log;_started=!1;metrics;shutdownController;constructor(e,t={}){this.components=e,this.init=t,this.log=e.logger.forComponent("libp2p:webrtc"),this.shutdownController=new AbortController,this.shutdownController.signal,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}[To]=!0;[Symbol.toStringTag]="@libp2p/webrtc";[it]=["@libp2p/transport"];[Zn]=["@libp2p/identify","@libp2p/circuit-relay-v2-transport"];isStarted(){return this._started}async start(){await this.components.registrar.handle(yo,e=>{const t=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);this._onProtocol(e,t).catch(n=>{this.log.error("failed to handle incoming connect from %p",e.connection.remotePeer,n)}).finally(()=>{t.clear()})},{runOnLimitedConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(yo),this._started=!1}createListener(e){return new ha(this.components,{shutdownController:this.shutdownController})}listenFilter(e){return e.filter(po.exactMatch)}dialFilter(e){return this.listenFilter(e)}async dial(e,t){this.log.trace("dialing address: %a",e);const{remoteAddress:n,peerConnection:s,muxerFactory:i}=await Y0({rtcConfiguration:await Nc(this.init.rtcConfiguration),dataChannel:this.init.dataChannel,multiaddr:e,dataChannelOptions:this.init.dataChannel,signal:t.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager,log:this.log,logger:this.components.logger,onProgress:t.onProgress}),o=new Fc(this.components,{peerConnection:s,timeline:{open:Date.now()},remoteAddr:n,metrics:this.metrics?.dialerEvents}),a=await t.upgrader.upgradeOutbound(o,{skipProtection:!0,skipEncryption:!0,muxerFactory:i,onProgress:t.onProgress,signal:t.signal});return this._closeOnShutdown(s,o),a}async _onProtocol({connection:e,stream:t},n){const s=new Qd(await Nc(this.init.rtcConfiguration)),i=new Xd(this.components,{peerConnection:s,dataChannelOptions:this.init.dataChannel});try{const{remoteAddress:o}=await X0({peerConnection:s,connection:e,stream:t,signal:n,log:this.log});await t.close({signal:n});const a=new Fc(this.components,{peerConnection:s,timeline:{open:new Date().getTime()},remoteAddr:o,metrics:this.metrics?.listenerEvents});await this.components.upgrader.upgradeInbound(a,{skipEncryption:!0,skipProtection:!0,muxerFactory:i,signal:n}),this._closeOnShutdown(s,a)}catch(o){throw this.log.error("incoming signaling error",o),s.close(),t.abort(o),o}}_closeOnShutdown(e,t){const n=()=>{t.close().catch(s=>{this.log.error("could not close WebRTCMultiaddrConnection",s)})};this.shutdownController.signal.addEventListener("abort",n),e.addEventListener("close",()=>{this.shutdownController.signal.removeEventListener("abort",n)})}}function j0(r){const e=r.toString().split("/webrtc/");if(e.length!==2)throw new V("webrtc protocol was not present in multiaddr");if(!e[0].includes("/p2p-circuit"))throw new V("p2p-circuit protocol was not present in multiaddr");let t=X(e[0]);const s=X("/"+e[1]).getPeerId();if(s==null)throw new V("destination peer id was missing");const i=t.protos().pop();if(i===void 0)throw new V("invalid multiaddr");return i.name!=="p2p"&&(t=t.encapsulate(`/p2p/${s}`)),{baseAddr:t,peerId:pt(s)}}const wt="/",Jd=new TextEncoder().encode(wt),$n=Jd[0];class Fe{_buf;constructor(e,t){if(typeof e=="string")this._buf=q(e);else if(e instanceof Uint8Array)this._buf=e;else throw new Error("Invalid key, should be String of Uint8Array");if(t==null&&(t=!0),t&&this.clean(),this._buf.byteLength===0||this._buf[0]!==$n)throw new Error("Invalid key")}toString(e="utf8"){return Y(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new Fe(e.join(wt))}static random(){return new Fe(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||typeof e=="string"?new Fe(e):typeof e.uint8Array=="function"?new Fe(e.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=Jd),this._buf[0]!==$n){const e=new Uint8Array(this._buf.byteLength+1);e.fill($n,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===$n;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),n=e.list();for(let s=0;s<t.length;s++){if(n.length<s+1)return!1;const i=t[s],o=n[s];if(i<o)return!0;if(i>o)return!1}return t.length<n.length}reverse(){return Fe.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(wt).slice(1)}type(){return Z0(this.baseNamespace())}name(){return J0(this.baseNamespace())}instance(e){return new Fe(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(wt)||(e+=wt),e+=this.type(),new Fe(e)}parent(){const e=this.list();return e.length===1?new Fe(wt):new Fe(e.slice(0,-1).join(wt))}child(e){return this.toString()===wt?e:e.toString()===wt?this:new Fe(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()===this.toString()?!1:e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()===this.toString()?!1:this.toString().startsWith(e.toString())}isTopLevel(){return this.list().length===1}concat(...e){return Fe.withNamespaces([...this.namespaces(),...ev(e.map(t=>t.namespaces()))])}}function Z0(r){const e=r.split(":");return e.length<2?"":e.slice(0,-1).join(":")}function J0(r){const e=r.split(":");return e[e.length-1]}function ev(r){return[].concat(...r)}function tv(r){return e=>new Q0(e,r)}const rv=[G("tcp").code,G("dns").code,G("dnsaddr").code,G("dns4").code,G("dns6").code];function Bc(r){return eh("sni",r)?.[1]}function $c(r){const e=eh("tcp",r)?.[1];return e==null?"":`:${e}`}function eh(r,e){let t;try{t=G(r).code}catch{return}for(const[n,s]of e)if(n===t&&s!=null)return[n,s]}function zc(r){return r.some(([e,t])=>e===G("tls").code)}function rt(r,e,t){const n=th[G(r).name];if(n==null)throw new Error(`Can't interpret protocol ${G(r).name}`);const s=n(e,t);return r===G("ip6").code?`[${s}]`:s}const th={ip4:(r,e)=>r,ip6:(r,e)=>e.length===0?r:`[${r}]`,tcp:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`tcp://${rt(t[0],t[1]??"",e)}:${r}`},udp:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`udp://${rt(t[0],t[1]??"",e)}:${r}`},dnsaddr:(r,e)=>r,dns4:(r,e)=>r,dns6:(r,e)=>r,dns:(r,e)=>r,ipfs:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${rt(t[0],t[1]??"",e)}`},p2p:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${rt(t[0],t[1]??"",e)}`},http:(r,e)=>{const t=zc(e),n=Bc(e),s=$c(e);if(t&&n!=null)return`https://${n}${s}`;const i=t?"https://":"http://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=rt(o[0],o[1]??"",e);return a=a.replace("tcp://",""),`${i}${a}`},"http-path":(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");const n=rt(t[0],t[1]??"",e),s=decodeURIComponent(r);return`${n}/${s}`},tls:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return rt(t[0],t[1]??"",e)},sni:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return rt(t[0],t[1]??"",e)},https:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let n=rt(t[0],t[1]??"",e);return n=n.replace("tcp://",""),`https://${n}`},ws:(r,e)=>{const t=zc(e),n=Bc(e),s=$c(e);if(t&&n!=null)return`wss://${n}${s}`;const i=t?"wss://":"ws://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=rt(o[0],o[1]??"",e);return a=a.replace("tcp://",""),`${i}${a}`},wss:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let n=rt(t[0],t[1]??"",e);return n=n.replace("tcp://",""),`wss://${n}`}};function nv(r,e){const n=X(r).stringTuples(),s=n.pop();if(s==null)throw new Error("Unexpected end of multiaddr");const i=G(s[0]),o=th[i.name];if(o==null)throw new Error(`No interpreter found for ${i.name}`);let a=o(s[1]??"",n);return rv.includes(s[0])&&(a=a.replace(/^.*:\/\//,""),s[1]==="443"?a=`https://${a}`:a=`http://${a}`),(a.startsWith("http://")||a.startsWith("https://")||a.startsWith("ws://")||a.startsWith("wss://"))&&(a=new URL(a).toString(),a.endsWith("/")&&(a=a.substring(0,a.length-1))),a}const sv=async r=>{if(r.readyState>=2)throw new Error("socket closed");r.readyState!==1&&await new Promise((e,t)=>{function n(){r.removeEventListener("open",s),r.removeEventListener("error",i)}function s(){n(),e()}function i(o){n(),t(o.error??new Error(`connect ECONNREFUSED ${r.url}`))}r.addEventListener("open",s),r.addEventListener("error",i)})},iv=(r,e)=>(e=e??{},e.closeOnEnd=e.closeOnEnd!==!1,async n=>{for await(const s of n){try{await sv(r)}catch(i){if(i.message==="socket closed")break;throw i}if(r.readyState===r.CLOSING||r.readyState===r.CLOSED)break;r.send(s)}e.closeOnEnd!=null&&r.readyState<=1&&await new Promise((s,i)=>{r.addEventListener("close",o=>{if(o.wasClean||o.code===1006)s();else{const a=Object.assign(new Error("ws error"),{event:o});i(a)}}),setTimeout(()=>{r.close()})})});var cr={},zr={},Kc;function ov(){if(Kc)return zr;Kc=1,Object.defineProperty(zr,"__esModule",{value:!0});class r{constructor(){this.pullQueue=[],this.pushQueue=[],this.eventHandlers={},this.isPaused=!1,this.isStopped=!1}push(n){if(this.isStopped)return;const s={value:n,done:!1};if(this.pullQueue.length){const i=this.pullQueue.shift();i&&i.resolve(s)}else this.pushQueue.push(Promise.resolve(s)),this.highWaterMark!==void 0&&this.pushQueue.length>=this.highWaterMark&&!this.isPaused&&(this.isPaused=!0,this.eventHandlers.highWater?this.eventHandlers.highWater():console&&console.warn(`EventIterator queue reached ${this.pushQueue.length} items`))}stop(){if(!this.isStopped){this.isStopped=!0,this.remove();for(const n of this.pullQueue)n.resolve({value:void 0,done:!0});this.pullQueue.length=0}}fail(n){if(!this.isStopped)if(this.isStopped=!0,this.remove(),this.pullQueue.length){for(const s of this.pullQueue)s.reject(n);this.pullQueue.length=0}else{const s=Promise.reject(n);s.catch(()=>{}),this.pushQueue.push(s)}}remove(){Promise.resolve().then(()=>{this.removeCallback&&this.removeCallback()})}[Symbol.asyncIterator](){return{next:n=>{const s=this.pushQueue.shift();return s?(this.lowWaterMark!==void 0&&this.pushQueue.length<=this.lowWaterMark&&this.isPaused&&(this.isPaused=!1,this.eventHandlers.lowWater&&this.eventHandlers.lowWater()),s):this.isStopped?Promise.resolve({value:void 0,done:!0}):new Promise((i,o)=>{this.pullQueue.push({resolve:i,reject:o})})},return:()=>(this.isStopped=!0,this.pushQueue.length=0,this.remove(),Promise.resolve({value:void 0,done:!0}))}}}class e{constructor(n,{highWaterMark:s=100,lowWaterMark:i=1}={}){const o=new r;o.highWaterMark=s,o.lowWaterMark=i,o.removeCallback=n({push:a=>o.push(a),stop:()=>o.stop(),fail:a=>o.fail(a),on:(a,c)=>{o.eventHandlers[a]=c}})||(()=>{}),this[Symbol.asyncIterator]=()=>o[Symbol.asyncIterator](),Object.freeze(this)}}return zr.EventIterator=e,zr.default=e,zr}var qc;function av(){if(qc)return cr;qc=1,Object.defineProperty(cr,"__esModule",{value:!0});const r=ov();cr.EventIterator=r.EventIterator;function e(t,n,s){return new r.EventIterator(({push:i})=>(this.addEventListener(t,i,n),()=>this.removeEventListener(t,i,n)),s)}return cr.subscribe=e,cr.default=r.EventIterator,cr}var cv=av();function Wc(r){return r instanceof ArrayBuffer||r?.constructor?.name==="ArrayBuffer"&&typeof r?.byteLength=="number"}const lv=r=>{r.binaryType="arraybuffer";const e=async()=>{await new Promise((i,o)=>{if(n){i();return}if(s!=null){o(s);return}const a=u=>{r.removeEventListener("open",c),r.removeEventListener("error",l),u()},c=()=>{a(i)},l=u=>{a(()=>{o(u.error??new Error(`connect ECONNREFUSED ${r.url}`))})};r.addEventListener("open",c),r.addEventListener("error",l)})},t=async function*(){const i=new cv.EventIterator(({push:o,stop:a,fail:c})=>{const l=d=>{let h=null;typeof d.data=="string"&&(h=q(d.data)),Wc(d.data)&&(h=new Uint8Array(d.data)),d.data instanceof Uint8Array&&(h=d.data),h!=null&&o(h)},u=d=>{c(d.error??new Error("Socket error"))};return r.addEventListener("message",l),r.addEventListener("error",u),r.addEventListener("close",a),()=>{r.removeEventListener("message",l),r.removeEventListener("error",u),r.removeEventListener("close",a)}},{highWaterMark:1/0});await e();for await(const o of i)yield Wc(o)?new Uint8Array(o):o}();let n=r.readyState===1,s;return r.addEventListener("open",()=>{n=!0,s=null}),r.addEventListener("close",()=>{n=!1,s=null}),r.addEventListener("error",i=>{n||(s=i.error??new Error(`connect ECONNREFUSED ${r.url}`))}),Object.assign(t,{connected:e})},uv=(r,e)=>{e=e??{};const t=lv(r);let n=e.remoteAddress,s=e.remotePort;if(r.url!=null)try{const o=new URL(r.url);n=o.hostname,s=parseInt(o.port,10)}catch{}if(n==null||s==null)throw new Error("Remote connection did not have address and/or port");return{sink:iv(r,e),source:t,connected:async()=>{await t.connected()},close:async()=>{(r.readyState===r.CONNECTING||r.readyState===r.OPEN)&&await new Promise(o=>{r.addEventListener("close",()=>{o()}),r.close()})},destroy:()=>{r.terminate!=null?r.terminate():r.close()},remoteAddress:n,remotePort:s,socket:r}},dv=WebSocket,hv={"http:":"ws:","https:":"wss:"},Vc="ws:",fv=(r,e)=>{if(r.startsWith("//")&&(r=`${e?.protocol??Vc}${r}`),r.startsWith("/")&&e!=null){const n=e.protocol??Vc,s=e.host,i=e.port!=null&&s?.endsWith(`:${e.port}`)!==!0?`:${e.port}`:"";r=`${n}//${s}${i}${r}`}const t=new URL(r);for(const[n,s]of Object.entries(hv))t.protocol===n&&(t.protocol=s);return t};function pv(r,e){const t=typeof window>"u"?void 0:window.location;e=e??{};const n=fv(r,t),s=new dv(n.toString(),e.websocket);return uv(s,e)}function rh(r){return r.filter(e=>Cs.exactMatch(e)||ln.exactMatch(e))}function gv(){throw new Error("WebSocket Servers can not be created in the browser!")}const mv=500;function yv(r,e,t){const n=t.logger.forComponent("libp2p:websockets:maconn"),s=t.metrics,i=t.metricPrefix??"",o={log:n,async sink(a){try{await r.sink(async function*(){for await(const c of a)c instanceof Uint8Array?yield c:yield c.subarray()}())}catch(c){c.type!=="aborted"&&n.error(c)}},source:r.source,remoteAddr:e,timeline:{open:Date.now()},async close(a={}){const c=Date.now();if(a.signal==null){const u=AbortSignal.timeout(mv);a={...a,signal:u}}const l=()=>{const{host:u,port:d}=o.remoteAddr.toOptions();n("timeout closing stream to %s:%s after %dms, destroying it manually",u,d,Date.now()-c),this.abort(new jt("Socket close timeout"))};a.signal?.addEventListener("abort",l);try{await r.close()}catch(u){n.error("error closing WebSocket gracefully",u),this.abort(u)}finally{a.signal?.removeEventListener("abort",l),o.timeline.close=Date.now()}},abort(a){const{host:c,port:l}=o.remoteAddr.toOptions();n("timeout closing stream to %s:%s due to error",c,l,a),r.destroy(),o.timeline.close=Date.now(),s?.increment({[`${i}error`]:!0})}};return r.socket.addEventListener("close",()=>{s?.increment({[`${i}close`]:!0}),o.timeline.close==null&&(o.timeline.close=Date.now())},{once:!0}),o}class wv{log;init;logger;metrics;components;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:websockets"),this.logger=e.logger,this.components=e,this.init=t,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total",{label:"event",help:"Total count of WebSockets dialer events by type"})})}[To]=!0;[Symbol.toStringTag]="@libp2p/websockets";[it]=["@libp2p/transport"];async dial(e,t){this.log("dialing %s",e),t=t??{};const n=await this._connect(e,t),s=yv(n,e,{logger:this.logger,metrics:this.metrics?.dialerEvents});this.log("new outbound connection %s",s.remoteAddr);const i=await t.upgrader.upgradeOutbound(s,t);return this.log("outbound connection %s upgraded",s.remoteAddr),i}async _connect(e,t){t?.signal?.throwIfAborted();const n=e.toOptions();this.log("dialing %s:%s",n.host,n.port);const s=he(),i=pv(nv(e),this.init);i.socket.addEventListener("error",()=>{const o=new Ul(`Could not connect to ${e.toString()}`);this.log.error("connection error:",o),this.metrics?.dialerEvents.increment({error:!0}),s.reject(o)});try{t.onProgress?.(new ie("websockets:open-connection")),await Je(Promise.race([i.connected(),s.promise]),t.signal)}catch(o){throw t.signal?.aborted&&this.metrics?.dialerEvents.increment({abort:!0}),i.close().catch(a=>{this.log.error("error closing raw socket",a)}),o}return this.log("connected %s",e),this.metrics?.dialerEvents.increment({connect:!0}),i}createListener(e){return gv({logger:this.logger,events:this.components.events,metrics:this.components.metrics},{...this.init,...e})}listenFilter(e){return e=Array.isArray(e)?e:[e],this.init?.filter!=null?this.init?.filter(e):rh(e)}dialFilter(e){return this.listenFilter(e)}}function bv(r={}){return e=>new wv(e,r)}function ks(r){if(typeof r!="object"||r===null)return!1;const e=Object.getPrototypeOf(r);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in r)&&!(Symbol.iterator in r)}const{hasOwnProperty:nh}=Object.prototype,{propertyIsEnumerable:vv}=Object,Tr=(r,e,t)=>{Object.defineProperty(r,e,{value:t,writable:!0,enumerable:!0,configurable:!0})},Ev=void 0,Hc={concatArrays:!1,ignoreUndefined:!1},Xs=r=>{const e=[];for(const t in r)nh.call(r,t)&&e.push(t);if(Object.getOwnPropertySymbols){const t=Object.getOwnPropertySymbols(r);for(const n of t)vv.call(r,n)&&e.push(n)}return e};function Rr(r){return Array.isArray(r)?Sv(r):ks(r)?xv(r):r}function Sv(r){const e=r.slice(0,0);return Xs(r).forEach(t=>{Tr(e,t,Rr(r[t]))}),e}function xv(r){const e=Object.getPrototypeOf(r)===null?Object.create(null):{};return Xs(r).forEach(t=>{Tr(e,t,Rr(r[t]))}),e}const sh=(r,e,t,n)=>(t.forEach(s=>{typeof e[s]>"u"&&n.ignoreUndefined||(s in r&&r[s]!==Object.getPrototypeOf(r)?Tr(r,s,bo(r[s],e[s],n)):Tr(r,s,Rr(e[s])))}),r),Av=(r,e,t)=>{let n=r.slice(0,0),s=0;return[r,e].forEach(i=>{const o=[];for(let a=0;a<i.length;a++)nh.call(i,a)&&(o.push(String(a)),i===r?Tr(n,s++,i[a]):Tr(n,s++,Rr(i[a])));n=sh(n,i,Xs(i).filter(a=>!o.includes(a)),t)}),n};function bo(r,e,t){return t.concatArrays&&Array.isArray(r)&&Array.isArray(e)?Av(r,e,t):!ks(e)||!ks(r)?Rr(e):sh(r,e,Xs(e),t)}function ih(...r){const e=bo(Rr(Hc),this!==Ev&&this||{},Hc);let t={_:{}};for(const n of r)if(n!==void 0){if(!ks(n))throw new TypeError("`"+n+"` is not an Option Object");t=bo(t,{_:n},e)}return t._}var Si={exports:{}},Gc;function Cv(){return Gc||(Gc=1,function(r){var e=Object.prototype.hasOwnProperty,t="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(t=!1));function s(c,l,u){this.fn=c,this.context=l,this.once=u||!1}function i(c,l,u,d,h){if(typeof u!="function")throw new TypeError("The listener must be a function");var p=new s(u,d||c,h),f=t?t+l:l;return c._events[f]?c._events[f].fn?c._events[f]=[c._events[f],p]:c._events[f].push(p):(c._events[f]=p,c._eventsCount++),c}function o(c,l){--c._eventsCount===0?c._events=new n:delete c._events[l]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var l=[],u,d;if(this._eventsCount===0)return l;for(d in u=this._events)e.call(u,d)&&l.push(t?d.slice(1):d);return Object.getOwnPropertySymbols?l.concat(Object.getOwnPropertySymbols(u)):l},a.prototype.listeners=function(l){var u=t?t+l:l,d=this._events[u];if(!d)return[];if(d.fn)return[d.fn];for(var h=0,p=d.length,f=new Array(p);h<p;h++)f[h]=d[h].fn;return f},a.prototype.listenerCount=function(l){var u=t?t+l:l,d=this._events[u];return d?d.fn?1:d.length:0},a.prototype.emit=function(l,u,d,h,p,f){var g=t?t+l:l;if(!this._events[g])return!1;var m=this._events[g],v=arguments.length,k,b;if(m.fn){switch(m.once&&this.removeListener(l,m.fn,void 0,!0),v){case 1:return m.fn.call(m.context),!0;case 2:return m.fn.call(m.context,u),!0;case 3:return m.fn.call(m.context,u,d),!0;case 4:return m.fn.call(m.context,u,d,h),!0;case 5:return m.fn.call(m.context,u,d,h,p),!0;case 6:return m.fn.call(m.context,u,d,h,p,f),!0}for(b=1,k=new Array(v-1);b<v;b++)k[b-1]=arguments[b];m.fn.apply(m.context,k)}else{var w=m.length,E;for(b=0;b<w;b++)switch(m[b].once&&this.removeListener(l,m[b].fn,void 0,!0),v){case 1:m[b].fn.call(m[b].context);break;case 2:m[b].fn.call(m[b].context,u);break;case 3:m[b].fn.call(m[b].context,u,d);break;case 4:m[b].fn.call(m[b].context,u,d,h);break;default:if(!k)for(E=1,k=new Array(v-1);E<v;E++)k[E-1]=arguments[E];m[b].fn.apply(m[b].context,k)}}return!0},a.prototype.on=function(l,u,d){return i(this,l,u,d,!1)},a.prototype.once=function(l,u,d){return i(this,l,u,d,!0)},a.prototype.removeListener=function(l,u,d,h){var p=t?t+l:l;if(!this._events[p])return this;if(!u)return o(this,p),this;var f=this._events[p];if(f.fn)f.fn===u&&(!h||f.once)&&(!d||f.context===d)&&o(this,p);else{for(var g=0,m=[],v=f.length;g<v;g++)(f[g].fn!==u||h&&!f[g].once||d&&f[g].context!==d)&&m.push(f[g]);m.length?this._events[p]=m.length===1?m[0]:m:o(this,p)}return this},a.prototype.removeAllListeners=function(l){var u;return l?(u=t?t+l:l,this._events[u]&&o(this,u)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,r.exports=a}(Si)),Si.exports}var Iv=Cv();const Tv=Gs(Iv);function kv(r,e,t){let n=0,s=r.length;for(;s>0;){const i=Math.trunc(s/2);let o=n+i;t(r[o],e)<=0?(n=++o,s-=i+1):s=i}return n}let _v=class{#e=[];enqueue(e,t){t={priority:0,...t};const n={priority:t.priority,id:t.id,run:e};if(this.size===0||this.#e[this.size-1].priority>=t.priority){this.#e.push(n);return}const s=kv(this.#e,n,(i,o)=>o.priority-i.priority);this.#e.splice(s,0,n)}setPriority(e,t){const n=this.#e.findIndex(i=>i.id===e);if(n===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[s]=this.#e.splice(n,1);this.enqueue(s.run,{priority:t,id:e})}dequeue(){return this.#e.shift()?.run}filter(e){return this.#e.filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return this.#e.length}};class vo extends Tv{#e;#t;#r=0;#a;#c;#p=0;#s;#l;#n;#g;#i=0;#u;#o;#m;#b=1n;timeout;constructor(e){if(super(),e={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:_v,...e},!(typeof e.intervalCap=="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString()??""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString()??""}\` (${typeof e.interval})`);this.#e=e.carryoverConcurrencyCount,this.#t=e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0,this.#a=e.intervalCap,this.#c=e.interval,this.#n=new e.queueClass,this.#g=e.queueClass,this.concurrency=e.concurrency,this.timeout=e.timeout,this.#m=e.throwOnTimeout===!0,this.#o=e.autoStart===!1}get#v(){return this.#t||this.#r<this.#a}get#E(){return this.#i<this.#u}#S(){this.#i--,this.#d(),this.emit("next")}#x(){this.#w(),this.#y(),this.#l=void 0}get#A(){const e=Date.now();if(this.#s===void 0){const t=this.#p-e;if(t<0)this.#r=this.#e?this.#i:0;else return this.#l===void 0&&(this.#l=setTimeout(()=>{this.#x()},t)),!0}return!1}#d(){if(this.#n.size===0)return this.#s&&clearInterval(this.#s),this.#s=void 0,this.emit("empty"),this.#i===0&&this.emit("idle"),!1;if(!this.#o){const e=!this.#A;if(this.#v&&this.#E){const t=this.#n.dequeue();return t?(this.emit("active"),t(),e&&this.#y(),!0):!1}}return!1}#y(){this.#t||this.#s!==void 0||(this.#s=setInterval(()=>{this.#w()},this.#c),this.#p=Date.now()+this.#c)}#w(){this.#r===0&&this.#i===0&&this.#s&&(clearInterval(this.#s),this.#s=void 0),this.#r=this.#e?this.#i:0,this.#h()}#h(){for(;this.#d(););}get concurrency(){return this.#u}set concurrency(e){if(!(typeof e=="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);this.#u=e,this.#h()}async#C(e){return new Promise((t,n)=>{e.addEventListener("abort",()=>{n(e.reason)},{once:!0})})}setPriority(e,t){this.#n.setPriority(e,t)}async add(e,t={}){return t.id??=(this.#b++).toString(),t={timeout:this.timeout,throwOnTimeout:this.#m,...t},new Promise((n,s)=>{this.#n.enqueue(async()=>{this.#i++,this.#r++;try{t.signal?.throwIfAborted();let i=e({signal:t.signal});t.timeout&&(i=ua(Promise.resolve(i),{milliseconds:t.timeout})),t.signal&&(i=Promise.race([i,this.#C(t.signal)]));const o=await i;n(o),this.emit("completed",o)}catch(i){if(i instanceof Vd&&!t.throwOnTimeout){n();return}s(i),this.emit("error",i)}finally{this.#S()}},t),this.emit("add"),this.#d()})}async addAll(e,t){return Promise.all(e.map(async n=>this.add(n,t)))}start(){return this.#o?(this.#o=!1,this.#h(),this):this}pause(){this.#o=!0}clear(){this.#n=new this.#g}async onEmpty(){this.#n.size!==0&&await this.#f("empty")}async onSizeLessThan(e){this.#n.size<e||await this.#f("next",()=>this.#n.size<e)}async onIdle(){this.#i===0&&this.#n.size===0||await this.#f("idle")}async#f(e,t){return new Promise(n=>{const s=()=>{t&&!t()||(this.off(e,s),n())};this.on(e,s)})}get size(){return this.#n.size}sizeBy(e){return this.#n.filter(e).length}get pending(){return this.#i}get isPaused(){return this.#o}}function oh(r){const e=[zt.A];return r==null?e:Array.isArray(r)?r.length===0?e:r:[r]}const ah=60;function ch(r){return{Status:r.Status??0,TC:r.TC??r.flag_tc??!1,RD:r.RD??r.flag_rd??!1,RA:r.RA??r.flag_ra??!1,AD:r.AD??r.flag_ad??!1,CD:r.CD??r.flag_cd??!1,Question:(r.Question??r.questions??[]).map(e=>({name:e.name,type:zt[e.type]})),Answer:(r.Answer??r.answers??[]).map(e=>({name:e.name,type:zt[e.type],TTL:e.TTL??e.ttl??ah,data:e.data instanceof Uint8Array?Y(e.data):e.data}))}}const Pv=4;function Yc(r,e={}){const t=new vo({concurrency:e.queryConcurrency??Pv});return async(n,s={})=>{const i=new URLSearchParams;i.set("name",n),oh(s.types).forEach(a=>{i.append("type",zt[a])}),s.onProgress?.(new ie("dns:query",{detail:n}));const o=await t.add(async()=>{const a=await fetch(`${r}?${i}`,{headers:{accept:"application/dns-json"},signal:s?.signal});if(a.status!==200)throw new Error(`Unexpected HTTP status: ${a.status} - ${a.statusText}`);const c=ch(await a.json());return s.onProgress?.(new ie("dns:response",{detail:c})),c},{signal:s.signal});if(o==null)throw new Error("No DNS response received");return o}}function Lv(){return[Yc("https://cloudflare-dns.com/dns-query"),Yc("https://dns.google/resolve")]}var xi,Xc;function Dv(){return Xc||(Xc=1,xi=function(r){if(!r)throw Error("hashlru must have a max value, of type number, greater than 0");var e=0,t=Object.create(null),n=Object.create(null);function s(i,o){t[i]=o,e++,e>=r&&(e=0,n=t,t=Object.create(null))}return{has:function(i){return t[i]!==void 0||n[i]!==void 0},remove:function(i){t[i]!==void 0&&(t[i]=void 0),n[i]!==void 0&&(n[i]=void 0)},get:function(i){var o=t[i];if(o!==void 0)return o;if((o=n[i])!==void 0)return s(i,o),o},set:function(i,o){t[i]!==void 0?t[i]=o:s(i,o)},clear:function(){t=Object.create(null),n=Object.create(null)}}}),xi}var Mv=Dv();const Rv=Gs(Mv);class Ov{lru;constructor(e){this.lru=Rv(e)}get(e,t){let n=!0;const s=[];for(const i of t){const o=this.getAnswers(e,i);if(o.length===0){n=!1;break}s.push(...o)}if(n)return ch({answers:s})}getAnswers(e,t){const n=`${e.toLowerCase()}-${t}`,s=this.lru.get(n);if(s!=null){const i=s.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:zt[a.type]}));return i.length===0&&this.lru.remove(n),i}return[]}add(e,t){const n=`${e.toLowerCase()}-${t.type}`,s=this.lru.get(n)??[];s.push({expires:Date.now()+(t.TTL??ah)*1e3,value:t}),this.lru.set(n,s)}remove(e,t){const n=`${e.toLowerCase()}-${t}`;this.lru.remove(n)}clear(){this.lru.clear()}}function Nv(r){return new Ov(r)}const Fv=1e3;class Uv{resolvers;cache;constructor(e){this.resolvers={},this.cache=Nv(e.cacheSize??Fv),Object.entries(e.resolvers??{}).forEach(([t,n])=>{Array.isArray(n)||(n=[n]),t.endsWith(".")||(t=`${t}.`),this.resolvers[t]=n}),this.resolvers["."]==null&&(this.resolvers["."]=Lv())}async query(e,t={}){const n=oh(t.types),s=t.cached!==!1?this.cache.get(e,n):void 0;if(s!=null)return t.onProgress?.(new ie("dns:cache",{detail:s})),s;const i=`${e.split(".").pop()}.`,o=(this.resolvers[i]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const c of o){if(t.signal?.aborted===!0)break;try{const l=await c(e,{...t,types:n});for(const u of l.Answer)this.cache.add(e,u);return l}catch(l){a.push(l),t.onProgress?.(new ie("dns:error",{detail:l}))}}throw a.length===1?a[0]:new AggregateError(a,`DNS lookup of ${e} ${n} failed`)}}var zt;(function(r){r[r.A=1]="A",r[r.CNAME=5]="CNAME",r[r.TXT=16]="TXT",r[r.AAAA=28]="AAAA"})(zt||(zt={}));function Bv(r={}){return new Uv(r)}const $v=32,{code:zv}=G("dnsaddr");class Kv extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}const lh=async function(e,t={}){const n=t.maxRecursiveDepth??$v;if(n===0)throw new Kv("Max recursive depth reached");const[,s]=e.stringTuples().find(([l])=>l===zv)??[],o=await(t?.dns??Bv()).query(`_dnsaddr.${s}`,{signal:t?.signal,types:[zt.TXT]}),a=e.getPeerId(),c=[];for(const l of o.Answer){const u=l.data.replace(/["']/g,"").trim().split("=")[1];if(u==null||a!=null&&!u.includes(a))continue;const d=X(u);if(u.startsWith("/dnsaddr")){const h=await d.resolve({...t,maxRecursiveDepth:n-1});c.push(...h.map(p=>p.toString()))}else c.push(d.toString())}return c};var qv={};const Wv={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter:r=>r},connectionManager:{resolvers:{dnsaddr:lh}},transportManager:{faultTolerance:jr.FATAL_ALL}};async function Vv(r){const e=ih(Wv,r);if(e.connectionProtector===null&&qv?.LIBP2P_FORCE_PNET!=null)throw new V("Private network is enforced, but no protector was provided");return e}const kr=1e3,_r=kr*60,Pr=_r*60,Jt=Pr*24,Hv=Jt*7,Gv=Jt*365.25;function uh(r,e){try{if(typeof r=="string"&&r.length>0)return Yv(r);if(typeof r=="number"&&isFinite(r))return e?.long?Qv(r):Xv(r);throw new Error("Value is not a string or number.")}catch(t){const n=jv(t)?`${t.message}. value=${JSON.stringify(r)}`:"An unknown error has occured.";throw new Error(n)}}function Yv(r){if(r=String(r),r.length>100)throw new Error("Value exceeds the maximum length of 100 characters.");const e=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(r);if(!e)return NaN;const t=parseFloat(e[1]),n=(e[2]||"ms").toLowerCase();switch(n){case"years":case"year":case"yrs":case"yr":case"y":return t*Gv;case"weeks":case"week":case"w":return t*Hv;case"days":case"day":case"d":return t*Jt;case"hours":case"hour":case"hrs":case"hr":case"h":return t*Pr;case"minutes":case"minute":case"mins":case"min":case"m":return t*_r;case"seconds":case"second":case"secs":case"sec":case"s":return t*kr;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:throw new Error(`The unit ${n} was matched, but no matching case exists.`)}}function Xv(r){const e=Math.abs(r);return e>=Jt?`${Math.round(r/Jt)}d`:e>=Pr?`${Math.round(r/Pr)}h`:e>=_r?`${Math.round(r/_r)}m`:e>=kr?`${Math.round(r/kr)}s`:`${r}ms`}function Qv(r){const e=Math.abs(r);return e>=Jt?zn(r,e,Jt,"day"):e>=Pr?zn(r,e,Pr,"hour"):e>=_r?zn(r,e,_r,"minute"):e>=kr?zn(r,e,kr,"second"):`${r} ms`}function zn(r,e,t,n){const s=e>=t*1.5;return`${Math.round(r/t)} ${n}${s?"s":""}`}function jv(r){return typeof r=="object"&&r!==null&&"message"in r}function Zv(r){t.debug=t,t.default=t,t.coerce=c,t.disable=i,t.enable=s,t.enabled=o,t.humanize=uh,t.destroy=l,Object.keys(r).forEach(u=>{t[u]=r[u]}),t.names=[],t.skips=[],t.formatters={};function e(u){let d=0;for(let h=0;h<u.length;h++)d=(d<<5)-d+u.charCodeAt(h),d|=0;return t.colors[Math.abs(d)%t.colors.length]}t.selectColor=e;function t(u){let d,h=null,p,f;function g(...m){if(!g.enabled)return;const v=g,k=Number(new Date),b=k-(d||k);v.diff=b,v.prev=d,v.curr=k,d=k,m[0]=t.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");let w=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,(P,x)=>{if(P==="%%")return"%";w++;const _=t.formatters[x];if(typeof _=="function"){const D=m[w];P=_.call(v,D),m.splice(w,1),w--}return P}),t.formatArgs.call(v,m),(v.log||t.log).apply(v,m)}return g.namespace=u,g.useColors=t.useColors(),g.color=t.selectColor(u),g.extend=n,g.destroy=t.destroy,Object.defineProperty(g,"enabled",{enumerable:!0,configurable:!1,get:()=>h!==null?h:(p!==t.namespaces&&(p=t.namespaces,f=t.enabled(u)),f),set:m=>{h=m}}),typeof t.init=="function"&&t.init(g),g}function n(u,d){const h=t(this.namespace+(typeof d>"u"?":":d)+u);return h.log=this.log,h}function s(u){t.save(u),t.namespaces=u,t.names=[],t.skips=[];let d;const h=(typeof u=="string"?u:"").split(/[\s,]+/),p=h.length;for(d=0;d<p;d++)h[d]&&(u=h[d].replace(/\*/g,".*?"),u[0]==="-"?t.skips.push(new RegExp("^"+u.substr(1)+"$")):t.names.push(new RegExp("^"+u+"$")))}function i(){const u=[...t.names.map(a),...t.skips.map(a).map(d=>"-"+d)].join(",");return t.enable(""),u}function o(u){if(u[u.length-1]==="*")return!0;let d,h;for(d=0,h=t.skips.length;d<h;d++)if(t.skips[d].test(u))return!1;for(d=0,h=t.names.length;d<h;d++)if(t.names[d].test(u))return!0;return!1}function a(u){return u.toString().substring(2,u.toString().length-2).replace(/\.\*\?$/,"*")}function c(u){return u instanceof Error?u.stack??u.message:u}function l(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.setupFormatters(t.formatters),t.enable(t.load()),t}var Jv={};const _s=oE(),eE=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function tE(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/)!=null?!1:typeof document<"u"&&document.documentElement?.style?.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/)!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/)}function rE(r){if(r[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+r[0]+(this.useColors?"%c ":" ")+"+"+uh(this.diff),!this.useColors)return;const e="color: "+this.color;r.splice(1,0,e,"color: inherit");let t=0,n=0;r[0].replace(/%[a-zA-Z%]/g,s=>{s!=="%%"&&(t++,s==="%c"&&(n=t))}),r.splice(n,0,e)}const nE=console.debug??console.log??(()=>{});function sE(r){try{r?_s?.setItem("debug",r):_s?.removeItem("debug")}catch{}}function iE(){let r;try{r=_s?.getItem("debug")}catch{}return!r&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(r=Jv.DEBUG),r}function oE(){try{return localStorage}catch{}}function aE(r){r.j=function(e){try{return JSON.stringify(e)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}}const Xe=Zv({formatArgs:rE,save:sE,load:iE,useColors:tE,setupFormatters:aE,colors:eE,storage:_s,log:nE});Xe.formatters.b=r=>r==null?"undefined":ye.baseEncode(r);Xe.formatters.t=r=>r==null?"undefined":xt.baseEncode(r);Xe.formatters.m=r=>r==null?"undefined":Ql.baseEncode(r);Xe.formatters.p=r=>r==null?"undefined":r.toString();Xe.formatters.c=r=>r==null?"undefined":r.toString();Xe.formatters.k=r=>r==null?"undefined":r.toString();Xe.formatters.a=r=>r==null?"undefined":r.toString();Xe.formatters.e=r=>r==null?"undefined":Qc(r.stack)??Qc(r.message)??r.toString();function cE(r){const e=()=>{};return e.enabled=!1,e.color="",e.diff=0,e.log=()=>{},e.namespace=r,e.destroy=()=>!0,e.extend=()=>e,e}function dh(){return{forComponent(r){return lE(r)}}}function lE(r){let e=cE(`${r}:trace`);return Xe.enabled(`${r}:trace`)&&Xe.names.map(t=>t.toString()).find(t=>t.includes(":trace"))!=null&&(e=Xe(`${r}:trace`)),Object.assign(Xe(r),{error:Xe(`${r}:error`),trace:e})}function Qc(r){if(r!=null&&(r=r.trim(),r.length!==0))return r}function uE(r){return r[Symbol.asyncIterator]!=null}function Eo(r){if(uE(r))return(async()=>{const t=[];for await(const n of r)t.push(n);return t})();const e=[];for(const t of r)e.push(t);return e}let hh=class extends Error{static name="AbortError";name="AbortError";constructor(e="The operation was aborted",...t){super(e,...t)}};const Ft={},er=r=>{r.addEventListener("message",e=>{er.dispatchEvent("message",r,e)}),r.port!=null&&r.port.addEventListener("message",e=>{er.dispatchEvent("message",r,e)})};er.addEventListener=(r,e)=>{Ft[r]==null&&(Ft[r]=[]),Ft[r].push(e)};er.removeEventListener=(r,e)=>{Ft[r]!=null&&(Ft[r]=Ft[r].filter(t=>t===e))};er.dispatchEvent=function(r,e,t){Ft[r]!=null&&Ft[r].forEach(n=>n(e,t))};const jc="lock:worker:request-read",Zc="lock:worker:abort-read-request",Jc="lock:worker:release-read",el="lock:master:grant-read",tl="lock:worker:request-write",rl="lock:worker:abort-write-request",nl="lock:worker:release-write",sl="lock:master:grant-write",dE=(r=10)=>Math.random().toString().substring(2,r+2),il=(r,e,t,n,s,i,o)=>(a,c)=>{if(c.data==null)return;const l={type:c.data.type,name:c.data.name,identifier:c.data.identifier};c.data.type===n&&r.dispatchEvent(new MessageEvent(e,{data:{name:l.name,handler:async()=>{a.postMessage({type:o,name:l.name,identifier:l.identifier}),await new Promise(u=>{const d=h=>{if(h?.data==null)return;const p={type:h.data.type,name:h.data.name,identifier:h.data.identifier};p.type===i&&p.identifier===l.identifier&&(a.removeEventListener("message",d),u())};a.addEventListener("message",d)})}}})),l.type===s&&(a.postMessage({type:s,name:l.name,identifier:l.identifier}),r.dispatchEvent(new MessageEvent(t,{data:{name:l.name}})))},ol=(r,e,t,n,s)=>async i=>{i?.signal?.throwIfAborted();const o=dE();return globalThis.postMessage({type:e,identifier:o,name:r}),new Promise((a,c)=>{const l=()=>{process.send?.({type:t,identifier:o,name:r}),c(new hh)};i?.signal?.addEventListener("abort",l,{once:!0});const u=d=>{if(d?.data==null)return;const h={type:d.data.type,identifier:d.data.identifier};h.type===n&&h.identifier===o&&(globalThis.removeEventListener("message",u),i?.signal?.removeEventListener("abort",l),a(()=>{globalThis.postMessage({type:s,identifier:o,name:r})}))};globalThis.addEventListener("message",u)})},hE={singleProcess:!1},fE=r=>{if(r=Object.assign({},hE,r),!!globalThis.document||r.singleProcess){const t=new EventTarget;return er.addEventListener("message",il(t,"requestReadLock","abortReadLockRequest",jc,Zc,Jc,el)),er.addEventListener("message",il(t,"requestWriteLock","abortWriteLockRequest",tl,rl,nl,sl)),t}return{isWorker:!0,readLock:t=>ol(t,jc,Zc,el,Jc),writeLock:t=>ol(t,tl,rl,sl,nl)}},Kt={};let je;async function Ai(r,e){let t,n;const s=new Promise((o,a)=>{t=o,n=a}),i=()=>{n(new hh)};return e?.signal?.addEventListener("abort",i,{once:!0}),r.add(async()=>{await new Promise(o=>{t(()=>{e?.signal?.removeEventListener("abort",i),o()})})},{signal:e?.signal}).catch(o=>{n(o)}),s}const pE=(r,e)=>{if(je.isWorker===!0)return{readLock:je.readLock(r,e),writeLock:je.writeLock(r,e)};const t=new vo({concurrency:1});let n;return{async readLock(s){if(n!=null)return Ai(n,s);n=new vo({concurrency:e.concurrency,autoStart:!1});const i=n,o=Ai(n,s);return t.add(async()=>{i.start(),await i.onIdle().then(()=>{n===i&&(n=null)})}),o},async writeLock(s){return n=null,Ai(t,s)}}},gE={name:"lock",concurrency:1/0,singleProcess:!1};function mE(r){const e=Object.assign({},gE,r);return je==null&&(je=fE(e),je.isWorker!==!0&&(je.addEventListener("requestReadLock",t=>{const n=t.data.name;if(Kt[n]==null)return;const s=new AbortController,i=o=>{o.data.name===n&&s.abort()};je.addEventListener("abortReadLockRequest",i),Kt[n].readLock({signal:s.signal}).then(async o=>t.data.handler().finally(()=>{o()})).finally(()=>{je.removeEventListener("abortReadLockRequest",i)})}),je.addEventListener("requestWriteLock",async t=>{const n=t.data.name;if(Kt[n]==null)return;const s=new AbortController,i=o=>{o.data.name===n&&s.abort()};je.addEventListener("abortWriteLockRequest",i),Kt[t.data.name].writeLock({signal:s.signal}).then(async o=>t.data.handler().finally(()=>{o()})).finally(()=>{je.removeEventListener("abortWriteLockRequest",i)})}))),Kt[e.name]==null&&(Kt[e.name]=pE(e.name,e)),Kt[e.name]}const yE=36e5,wE=216e5;var Gt;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=me((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&s.value.byteLength>0&&(i.uint32(18),i.bytes(s.value)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:"",value:se(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.key=s.string();break}case 2:{a.value=s.bytes();break}default:{s.skipType(l&7);break}}}return a})),n),t.encode=s=>ge(s,t.codec()),t.decode=(s,i)=>pe(s,t.codec(),i)})(r.Peer$metadataEntry||(r.Peer$metadataEntry={})),function(t){let n;t.codec=()=>(n==null&&(n=me((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&(i.uint32(18),Ls.codec().encode(s.value,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:""},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.key=s.string();break}case 2:{a.value=Ls.codec().decode(s,s.uint32(),{limits:o.limits?.value});break}default:{s.skipType(l&7);break}}}return a})),n),t.encode=s=>ge(s,t.codec()),t.decode=(s,i)=>pe(s,t.codec(),i)}(r.Peer$tagsEntry||(r.Peer$tagsEntry={}));let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.addresses!=null)for(const i of t.addresses)n.uint32(10),Ps.codec().encode(i,n);if(t.protocols!=null)for(const i of t.protocols)n.uint32(18),n.string(i);if(t.publicKey!=null&&(n.uint32(34),n.bytes(t.publicKey)),t.peerRecordEnvelope!=null&&(n.uint32(42),n.bytes(t.peerRecordEnvelope)),t.metadata!=null&&t.metadata.size!==0)for(const[i,o]of t.metadata.entries())n.uint32(50),r.Peer$metadataEntry.codec().encode({key:i,value:o},n);if(t.tags!=null&&t.tags.size!==0)for(const[i,o]of t.tags.entries())n.uint32(58),r.Peer$tagsEntry.codec().encode({key:i,value:o},n);t.updated!=null&&(n.uint32(64),n.uint64Number(t.updated)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(s.limits?.addresses!=null&&i.addresses.length===s.limits.addresses)throw new It('Decode error - map field "addresses" had too many elements');i.addresses.push(Ps.codec().decode(t,t.uint32(),{limits:s.limits?.addresses$}));break}case 2:{if(s.limits?.protocols!=null&&i.protocols.length===s.limits.protocols)throw new It('Decode error - map field "protocols" had too many elements');i.protocols.push(t.string());break}case 4:{i.publicKey=t.bytes();break}case 5:{i.peerRecordEnvelope=t.bytes();break}case 6:{if(s.limits?.metadata!=null&&i.metadata.size===s.limits.metadata)throw new Ba('Decode error - map field "metadata" had too many elements');const c=r.Peer$metadataEntry.codec().decode(t,t.uint32());i.metadata.set(c.key,c.value);break}case 7:{if(s.limits?.tags!=null&&i.tags.size===s.limits.tags)throw new Ba('Decode error - map field "tags" had too many elements');const c=r.Peer$tagsEntry.codec().decode(t,t.uint32(),{limits:{value:s.limits?.tags$value}});i.tags.set(c.key,c.value);break}case 8:{i.updated=t.uint64Number();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(Gt||(Gt={}));var Ps;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.multiaddr!=null&&t.multiaddr.byteLength>0&&(n.uint32(10),n.bytes(t.multiaddr)),t.isCertified!=null&&(n.uint32(16),n.bool(t.isCertified)),t.observed!=null&&(n.uint32(24),n.uint64Number(t.observed)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={multiaddr:se(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.multiaddr=t.bytes();break}case 2:{i.isCertified=t.bool();break}case 3:{i.observed=t.uint64Number();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(Ps||(Ps={}));var Ls;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.value!=null&&t.value!==0&&(n.uint32(8),n.uint32(t.value)),t.expiry!=null&&(n.uint32(16),n.uint64(t.expiry)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={value:0},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.value=t.uint32();break}case 2:{i.expiry=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(Ls||(Ls={}));function bE(r,e){if(r.publicKey!=null||e.publicKey==null)return r;let t;if(r.type==="RSA"){const s=ye.decode(`z${r}`);t=tr(s)}const n=Bt(e.publicKey,t);return rn(n)}function So(r,e,t){const n=Gt.decode(e);return xo(r,n,t)}function xo(r,e,t){const n=new Map,s=BigInt(Date.now());for(const[i,o]of e.tags.entries())o.expiry!=null&&o.expiry<s||n.set(i,o);return{...e,id:bE(r,e),addresses:e.addresses.filter(({observed:i})=>i!=null&&i>Date.now()-t).map(({multiaddr:i,isCertified:o})=>({multiaddr:X(i),isCertified:o??!1})),metadata:e.metadata,peerRecordEnvelope:e.peerRecordEnvelope??void 0,tags:n}}function vE(r,e){return EE(r.addresses,e.addresses)&&SE(r.protocols,e.protocols)&&xE(r.publicKey,e.publicKey)&&AE(r.peerRecordEnvelope,e.peerRecordEnvelope)&&CE(r.metadata,e.metadata)&&IE(r.tags,e.tags)}function EE(r,e){return ph(r,e,(t,n)=>!(t.isCertified!==n.isCertified||!Oe(t.multiaddr,n.multiaddr)))}function SE(r,e){return ph(r,e,(t,n)=>t===n)}function xE(r,e){return fh(r,e)}function AE(r,e){return fh(r,e)}function CE(r,e){return gh(r,e,(t,n)=>Oe(t,n))}function IE(r,e){return gh(r,e,(t,n)=>t.value===n.value&&t.expiry===n.expiry)}function fh(r,e){return r==null&&e==null?!0:r!=null&&e!=null?Oe(r,e):!1}function ph(r,e,t){if(r.length!==e.length)return!1;for(let n=0;n<r.length;n++)if(!t(r[n],e[n]))return!1;return!0}function gh(r,e,t){if(r.size!==e.size)return!1;for(const[n,s]of r.entries()){const i=e.get(n);if(i==null||!t(s,i))return!1}return!0}const mh="/peers/";function Kn(r){if(!Ol(r)||r.type==null)throw new V("Invalid PeerId");const e=r.toCID().toString();return new Fe(`${mh}${e}`)}async function TE(r,e,t,n){const s=new Map;for(const i of t){if(i==null)continue;if(i.multiaddr instanceof Uint8Array&&(i.multiaddr=X(i.multiaddr)),!zs(i.multiaddr))throw new V("Multiaddr was invalid");if(!await e(r,i.multiaddr))continue;const o=i.isCertified??!1,a=i.multiaddr.toString(),c=s.get(a);c!=null?i.isCertified=c.isCertified||o:s.set(a,{multiaddr:i.multiaddr,isCertified:o})}return[...s.values()].sort((i,o)=>i.multiaddr.toString().localeCompare(o.multiaddr.toString())).map(({isCertified:i,multiaddr:o})=>{const a=o.getPeerId();return r.equals(a)&&(o=o.decapsulate(X(`/p2p/${r}`))),{isCertified:i,multiaddr:o.bytes}})}async function Ci(r,e,t,n){if(e==null)throw new V("Invalid PeerData");if(e.publicKey!=null&&r.publicKey!=null&&!e.publicKey.equals(r.publicKey))throw new V("publicKey bytes do not match peer id publicKey bytes");const s=n.existingPeer?.peer;if(s!=null&&!r.equals(s.id))throw new V("peer id did not match existing peer id");let i=s?.addresses??[],o=new Set(s?.protocols??[]),a=s?.metadata??new Map,c=s?.tags??new Map,l=s?.peerRecordEnvelope;if(t==="patch"){if((e.multiaddrs!=null||e.addresses!=null)&&(i=[],e.multiaddrs!=null&&i.push(...e.multiaddrs.map(h=>({isCertified:!1,multiaddr:h}))),e.addresses!=null&&i.push(...e.addresses)),e.protocols!=null&&(o=new Set(e.protocols)),e.metadata!=null){const h=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);a=qn(h,{validate:al})}if(e.tags!=null){const h=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags);c=qn(h,{validate:cl,map:ll})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}if(t==="merge"){if(e.multiaddrs!=null&&i.push(...e.multiaddrs.map(h=>({isCertified:!1,multiaddr:h}))),e.addresses!=null&&i.push(...e.addresses),e.protocols!=null&&(o=new Set([...o,...e.protocols])),e.metadata!=null){const h=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);for(const[p,f]of h)f==null?a.delete(p):a.set(p,f);a=qn([...a.entries()],{validate:al})}if(e.tags!=null){const h=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags),p=new Map(c);for(const[f,g]of h)g==null?p.delete(f):p.set(f,g);c=qn([...p.entries()],{validate:cl,map:ll})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}let u;s?.id.publicKey!=null?u=At(s.id.publicKey):e.publicKey!=null?u=At(e.publicKey):r.publicKey!=null&&(u=At(r.publicKey));const d={addresses:await TE(r,n.addressFilter??(async()=>!0),i,n.existingPeer?.peerPB.addresses),protocols:[...o.values()].sort((h,p)=>h.localeCompare(p)),metadata:a,tags:c,publicKey:u,peerRecordEnvelope:l};return d.addresses.forEach(h=>{h.observed=n.existingPeer?.peerPB.addresses?.find(p=>Oe(p.multiaddr,p.multiaddr))?.observed??Date.now()}),r.type!=="RSA"&&delete d.publicKey,d}function qn(r,e){const t=new Map;for(const[n,s]of r)s!=null&&e.validate(n,s);for(const[n,s]of r.sort(([i],[o])=>i.localeCompare(o)))s!=null&&t.set(n,e.map?.(n,s)??s);return t}function al(r,e){if(typeof r!="string")throw new V("Metadata key must be a string");if(!(e instanceof Uint8Array))throw new V("Metadata value must be a Uint8Array")}function cl(r,e){if(typeof r!="string")throw new V("Tag name must be a string");if(e.value!=null){if(parseInt(`${e.value}`,10)!==e.value)throw new V("Tag value must be an integer");if(e.value<0||e.value>100)throw new V("Tag value must be between 0-100")}if(e.ttl!=null){if(parseInt(`${e.ttl}`,10)!==e.ttl)throw new V("Tag ttl must be an integer");if(e.ttl<0)throw new V("Tag ttl must be between greater than 0")}}function ll(r,e){let t;return e.expiry!=null&&(t=e.expiry),e.ttl!=null&&(t=BigInt(Date.now()+Number(e.ttl))),{value:e.value??0,expiry:t}}function yh(r){const e=r.toString().split("/")[2],t=ae.parse(e,xt);return En(t)}function Ii(r,e,t){const n=yh(r);return So(n,e,t)}function kE(r,e){return{prefix:mh,filters:(r.filters??[]).map(t=>({key:n,value:s})=>t(Ii(n,s,e))),orders:(r.orders??[]).map(t=>(n,s)=>t(Ii(n.key,n.value,e),Ii(s.key,s.value,e)))}}class _E{peerId;datastore;lock;addressFilter;log;maxAddressAge;maxPeerAge;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.lock=mE({name:"peer-store",singleProcess:!0}),this.maxAddressAge=t.maxAddressAge??yE,this.maxPeerAge=t.maxPeerAge??wE}async has(e){try{return await this.load(e),!0}catch(t){if(t.name!=="NotFoundError")throw t}return!1}async delete(e){this.peerId.equals(e)||await this.datastore.delete(Kn(e))}async load(e){const t=Kn(e),n=await this.datastore.get(t),s=Gt.decode(n);if(this.#r(e,s))throw await this.datastore.delete(t),new qi;return xo(e,s,this.peerId.equals(e)?1/0:this.maxAddressAge)}async save(e,t){const n=await this.#e(e),s=await Ci(e,t,"patch",{addressFilter:this.addressFilter});return this.#t(e,s,n)}async patch(e,t){const n=await this.#e(e),s=await Ci(e,t,"patch",{addressFilter:this.addressFilter,existingPeer:n});return this.#t(e,s,n)}async merge(e,t){const n=await this.#e(e),s=await Ci(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:n});return this.#t(e,s,n)}async*all(e){for await(const{key:t,value:n}of this.datastore.query(kE(e??{},this.maxAddressAge))){const s=yh(t);if(s.equals(this.peerId))continue;const i=Gt.decode(n);if(this.#r(s,i)){await this.datastore.delete(t);continue}yield xo(s,i,this.peerId.equals(s)?1/0:this.maxAddressAge)}}async#e(e){try{const t=Kn(e),n=await this.datastore.get(t),s=Gt.decode(n);if(this.#r(e,s))throw await this.datastore.delete(t),new qi;return{peerPB:s,peer:So(e,n,this.maxAddressAge)}}catch(t){t.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",t)}}async#t(e,t,n){t.updated=Date.now();const s=Gt.encode(t);return await this.datastore.put(Kn(e),s),{peer:So(e,s,this.maxAddressAge),previous:n?.peer,updated:n==null||!vE(t,n.peerPB)}}#r(e,t){if(t.updated==null)return!0;if(this.peerId.equals(e))return!1;const n=t.updated<Date.now()-this.maxPeerAge,s=Date.now()-this.maxAddressAge,i=t.addresses.filter(o=>o.observed!=null&&o.observed>s);return n&&i.length===0}}class PE{store;events;peerId;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new _E(e,t)}[Symbol.toStringTag]="@libp2p/peer-store";async forEach(e,t){this.log.trace("forEach await read lock");const n=await this.store.lock.readLock();this.log.trace("forEach got read lock");try{for await(const s of this.store.all(t))e(s)}finally{this.log.trace("forEach release read lock"),n()}}async all(e){this.log.trace("all await read lock");const t=await this.store.lock.readLock();this.log.trace("all got read lock");try{return await Eo(this.store.all(e))}finally{this.log.trace("all release read lock"),t()}}async delete(e){this.log.trace("delete await write lock");const t=await this.store.lock.writeLock();this.log.trace("delete got write lock");try{await this.store.delete(e)}finally{this.log.trace("delete release write lock"),t()}}async has(e){this.log.trace("has await read lock");const t=await this.store.lock.readLock();this.log.trace("has got read lock");try{return await this.store.has(e)}finally{this.log.trace("has release read lock"),t()}}async get(e){this.log.trace("get await read lock");const t=await this.store.lock.readLock();this.log.trace("get got read lock");try{return await this.store.load(e)}finally{this.log.trace("get release read lock"),t()}}async getInfo(e){const t=await this.get(e);return{id:t.id,multiaddrs:t.addresses.map(({multiaddr:n})=>n)}}async save(e,t){this.log.trace("save await write lock");const n=await this.store.lock.writeLock();this.log.trace("save got write lock");try{const s=await this.store.save(e,t);return this.#e(e,s),s.peer}finally{this.log.trace("save release write lock"),n()}}async patch(e,t){this.log.trace("patch await write lock");const n=await this.store.lock.writeLock();this.log.trace("patch got write lock");try{const s=await this.store.patch(e,t);return this.#e(e,s),s.peer}finally{this.log.trace("patch release write lock"),n()}}async merge(e,t){this.log.trace("merge await write lock");const n=await this.store.lock.writeLock();this.log.trace("merge got write lock");try{const s=await this.store.merge(e,t);return this.#e(e,s),s.peer}finally{this.log.trace("merge release write lock"),n()}}async consumePeerRecord(e,t){const n=await ht.openAndCertify(e,Qe.DOMAIN),s=En(n.publicKey.toCID());if(t?.equals(s)===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",t,s),!1;const i=Qe.createFromProtobuf(n.payload);let o;try{o=await this.get(s)}catch(a){if(a.name!=="NotFoundError")throw a}if(o?.peerRecordEnvelope!=null){const a=await ht.createFromProtobuf(o.peerRecordEnvelope),c=Qe.createFromProtobuf(a.payload);if(c.seqNumber>=i.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",c.seqNumber,i.seqNumber),!1}return await this.patch(i.peerId,{peerRecordEnvelope:e,addresses:i.multiaddrs.map(a=>({isCertified:!0,multiaddr:a}))}),!0}#e(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))}}function LE(r,e={}){return new PE(r,e)}class Ds extends Error{static name="NotFoundError";static code="ERR_NOT_FOUND";name=Ds.name;code=Ds.code;constructor(e="Not Found"){super(e)}}function DE(r){return r[Symbol.asyncIterator]!=null}function lr(r,e){let t=0;if(DE(r))return async function*(){for await(const c of r)await e(c,t++)&&(yield c)}();const n=cd(r),{value:s,done:i}=n.next();if(i===!0)return function*(){}();const o=e(s,t++);if(typeof o.then=="function")return async function*(){await o&&(yield s);for await(const c of n)await e(c,t++)&&(yield c)}();const a=e;return function*(){o===!0&&(yield s);for(const c of n)a(c,t++)&&(yield c)}()}function ME(r){return r[Symbol.asyncIterator]!=null}function ul(r,e){return ME(r)?async function*(){yield*(await Eo(r)).sort(e)}():function*(){yield*Eo(r).sort(e)}()}function RE(r){return r[Symbol.asyncIterator]!=null}function dl(r,e){return RE(r)?async function*(){let t=0;if(!(e<1)){for await(const n of r)if(yield n,t++,t===e)return}}():function*(){let t=0;if(!(e<1)){for(const n of r)if(yield n,t++,t===e)return}}()}class OE{put(e,t,n){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:n,value:s}of e)await this.put(n,s,t),yield n}async*getMany(e,t={}){for await(const n of e)yield{key:n,value:await this.get(n,t)}}async*deleteMany(e,t={}){for await(const n of e)await this.delete(n,t),yield n}batch(){let e=[],t=[];return{put(n,s){e.push({key:n,value:s})},delete(n){t.push(n)},commit:async n=>{await mo(this.putMany(e,n)),e=[],await mo(this.deleteMany(t,n)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let n=this._all(e,t);if(e.prefix!=null){const s=e.prefix;n=lr(n,i=>i.key.toString().startsWith(s))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((s,i)=>lr(s,i),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((s,i)=>ul(s,i),n)),e.offset!=null){let s=0;const i=e.offset;n=lr(n,()=>s++>=i)}return e.limit!=null&&(n=dl(n,e.limit)),n}queryKeys(e,t){let n=this._allKeys(e,t);if(e.prefix!=null){const s=e.prefix;n=lr(n,i=>i.toString().startsWith(s))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((s,i)=>lr(s,i),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((s,i)=>ul(s,i),n)),e.offset!=null){const s=e.offset;let i=0;n=lr(n,()=>i++>=s)}return e.limit!=null&&(n=dl(n,e.limit)),n}}class NE extends OE{data;constructor(){super(),this.data=new Map}put(e,t,n){return n?.signal?.throwIfAborted(),this.data.set(e.toString(),t),e}get(e,t){t?.signal?.throwIfAborted();const n=this.data.get(e.toString());if(n==null)throw new Ds;return n}has(e,t){return t?.signal?.throwIfAborted(),this.data.has(e.toString())}delete(e,t){t?.signal?.throwIfAborted(),this.data.delete(e.toString())}*_all(e,t){t?.signal?.throwIfAborted();for(const[n,s]of this.data.entries())yield{key:new Fe(n),value:s},t?.signal?.throwIfAborted()}*_allKeys(e,t){t?.signal?.throwIfAborted();for(const n of this.data.keys())yield new Fe(n),t?.signal?.throwIfAborted()}}const hl=864e13,FE=448,Ti=449,UE=53,BE=54,$E=55,zE=56;class KE{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=new Map}has(e){const t=this.findHost(e);for(const n of this.mappings.values())if(n.domain===t)return!0;return!1}add(e,t){t.forEach(n=>{this.log("add DNS mapping %s to %s",n,e);const s=Ys(n)===!0;this.mappings.set(n,{domain:e,verified:s,expires:s?hl-Date.now():0,lastVerified:s?hl-Date.now():void 0})})}remove(e){const t=this.findHost(e);let n=!1;for(const[s,i]of this.mappings.entries())i.domain===t&&(this.log("removing %s to %s DNS mapping %e",s,i.domain,new Error("where")),this.mappings.delete(s),n=n||i.verified);return n}getAll(e){const t=[];for(let n=0;n<e.length;n++){const i=e[n].multiaddr.stringTuples(),o=i[0][1];if(o!=null)for(const[a,c]of this.mappings.entries()){if(o!==a)continue;this.maybeAddSNITuple(i,c.domain)&&(e.splice(n,1),n--,t.push({multiaddr:X(`/${i.map(u=>[G(u[0]).name,u[1]].join("/")).join("/")}`),verified:c.verified,type:"dns-mapping",expires:c.expires,lastVerified:c.lastVerified}))}}return t}maybeAddSNITuple(e,t){for(let n=0;n<e.length;n++)if(e[n][0]===FE&&e[n+1]?.[0]!==Ti)return e.splice(n+1,0,[Ti,t]),!0;return!1}confirm(e,t){const n=this.findHost(e);let s=!1;for(const[i,o]of this.mappings.entries())o.domain===n&&(this.log("marking %s to %s DNS mapping as verified",i,o.domain),s=o.verified,o.verified=!0,o.expires=Date.now()+t,o.lastVerified=Date.now());return s}unconfirm(e,t){const n=this.findHost(e);let s=!1;for(const[i,o]of this.mappings.entries())o.domain===n&&(this.log("removing verification of %s to %s DNS mapping",i,o.domain),s=s||o.verified,o.verified=!1,o.expires=Date.now()+t);return s}findHost(e){for(const t of e.stringTuples())if(t[0]===Ti||t[0]===UE||t[0]===BE||t[0]===$E||t[0]===zE)return t[1]}}const ki=4,_i=41,Pi=6,qE=273;class WE{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=new Map}has(e){const t=e.stringTuples();for(const n of this.mappings.values())for(const s of n)if(s.externalIp===t[0][1])return!0;return!1}add(e,t,n,s=t,i="tcp"){const o=`${e}-${t}-${i}`,a=this.mappings.get(o)??[],c={internalIp:e,internalPort:t,externalIp:n,externalPort:s,externalFamily:Sr(n)?4:6,protocol:i,verified:!1,expires:0};a.push(c),this.mappings.set(o,a)}remove(e){const t=e.stringTuples(),n=t[0][1]??"",s=t[1][0]===Pi?"tcp":"udp",i=parseInt(t[1][1]??"0");let o=!1;for(const[a,c]of this.mappings.entries()){for(let l=0;l<c.length;l++){const u=c[l];u.externalIp===n&&u.externalPort===i&&u.protocol===s&&(this.log("removing %s:%s to %s:%s %s IP mapping",u.externalIp,u.externalPort,n,i,s),o=o||u.verified,c.splice(l,1),l--)}c.length===0&&this.mappings.delete(a)}return o}getAll(e){const t=[];for(const{multiaddr:n}of e){const s=n.stringTuples();let i;if((s[0][0]===ki||s[0][0]===_i)&&s[1][0]===Pi?i=`${s[0][1]}-${s[1][1]}-tcp`:(s[0][0]===ki||s[0][0]===_i)&&s[1][0]===qE&&(i=`${s[0][1]}-${s[1][1]}-udp`),i==null)continue;const o=this.mappings.get(i);if(o!=null)for(const a of o)s[0][0]=a.externalFamily===4?ki:_i,s[0][1]=a.externalIp,s[1][1]=`${a.externalPort}`,t.push({multiaddr:X(`/${s.map(c=>[G(c[0]).name,c[1]].join("/")).join("/")}`),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return t}confirm(e,t){const s=e.stringTuples()[0][1];let i=!1;for(const o of this.mappings.values())for(const a of o)a.externalIp===s&&(this.log("marking %s to %s IP mapping as verified",a.internalIp,a.externalIp),i=a.verified,a.verified=!0,a.expires=Date.now()+t,a.lastVerified=Date.now());return i}unconfirm(e,t){const n=e.stringTuples(),s=n[0][1]??"",i=n[1][0]===Pi?"tcp":"udp",o=parseInt(n[1][1]??"0");let a=!1;for(const c of this.mappings.values())for(let l=0;l<c.length;l++){const u=c[l];u.externalIp===s&&u.externalPort===o&&u.protocol===i&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",u.externalIp,u.externalPort,s,o,i),a=a||u.verified,u.verified=!1,u.expires=Date.now()+t)}return a}}const VE=4,HE=41;function GE(r){try{const[[e,t]]=r.stringTuples();if(t==null)return!1;if(e===VE)return t.startsWith("169.254.");if(e===HE)return t.toLowerCase().startsWith("fe80")}catch{}return!1}const YE={maxObservedAddresses:10};class XE{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=new Map,this.maxObservedAddresses=t.maxObservedAddresses??YE.maxObservedAddresses}has(e){return this.addresses.has(e.toString())}removePrefixed(e){for(const t of this.addresses.keys())t.toString().startsWith(e)&&this.addresses.delete(t)}add(e){this.addresses.size!==this.maxObservedAddresses&&(hn(e)||GE(e)||(this.log("adding observed address %a",e),this.addresses.set(e.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([e,t])=>({multiaddr:X(e),verified:t.verified,type:"observed",expires:t.expires,lastVerified:t.lastVerified}))}remove(e){const t=this.addresses.get(e.toString())?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(e.toString()),t}confirm(e,t){const n=e.toString(),s=this.addresses.get(n)??{verified:!1,expires:Date.now()+t,lastVerified:Date.now()},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.log("marking observed address %a as verified",n),this.addresses.set(n,s),i}}const QE=4,jE=41,ZE=53,JE=54,e1=55,t1=56,r1=[QE,jE,ZE,JE,e1,t1];function fl(r){try{const[[e]]=r.stringTuples();return r1.includes(e)}catch{}return!1}const n1={maxObservedAddresses:10};class s1{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=new Map,this.maxObservedAddresses=t.maxObservedAddresses??n1.maxObservedAddresses}get(e,t){if(hn(e))return{multiaddr:e,verified:!0,type:"transport",expires:Date.now()+t,lastVerified:Date.now()};const n=this.toKey(e);let s=this.addresses.get(n);return s==null&&(s={verified:!fl(e),expires:0},this.addresses.set(n,s)),{multiaddr:e,verified:s.verified,type:"transport",expires:s.expires,lastVerified:s.lastVerified}}has(e){const t=this.toKey(e);return this.addresses.has(t)}remove(e){const t=this.toKey(e),n=this.addresses.get(t)?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(t),n}confirm(e,t){const n=this.toKey(e),s=this.addresses.get(n)??{verified:!1,expires:0,lastVerified:0},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.addresses.set(n,s),i}unconfirm(e,t){const n=this.toKey(e),s=this.addresses.get(n)??{verified:!1,expires:0},i=s.verified;return s.verified=!1,s.expires=Date.now()+t,this.addresses.set(n,s),i}toKey(e){if(fl(e)){const t=e.toOptions();return`${t.host}-${t.port}-${t.transport}`}return e.toString()}}const pl=6e4,gl={addressVerificationTTL:pl*10,addressVerificationRetry:pl*5},i1=r=>r;function Li(r,e){const t=r.getPeerId();return t!=null&&pt(t).equals(e)&&(r=r.decapsulate(X(`/p2p/${e.toString()}`))),r}class o1{log;components;listen;announce;appendAnnounce;announceFilter;observed;dnsMappings;ipMappings;transportAddresses;observedAddressFilter;addressVerificationTTL;addressVerificationRetry;constructor(e,t={}){const{listen:n=[],announce:s=[],appendAnnounce:i=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=n.map(o=>o.toString()),this.announce=new Set(s.map(o=>o.toString())),this.appendAnnounce=new Set(i.map(o=>o.toString())),this.observed=new XE(e,t),this.dnsMappings=new KE(e,t),this.ipMappings=new WE(e,t),this.transportAddresses=new s1(e,t),this.announceFilter=t.announceFilter??i1,this.observedAddressFilter=dn(1024),this.addressVerificationTTL=t.addressVerificationTTL??gl.addressVerificationTTL,this.addressVerificationRetry=t.addressVerificationRetry??gl.addressVerificationRetry,this._updatePeerStoreAddresses=go(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),e.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}[Symbol.toStringTag]="@libp2p/address-manager";_updatePeerStoreAddresses(){const e=this.getAddresses().map(t=>t.getPeerId()===this.components.peerId.toString()?t.decapsulate(`/p2p/${this.components.peerId.toString()}`):t);this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch(t=>{this.log.error("error updating addresses",t)})}getListenAddrs(){return Array.from(this.listen).map(e=>X(e))}getAnnounceAddrs(){return Array.from(this.announce).map(e=>X(e))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(e=>X(e))}getObservedAddrs(){return this.observed.getAll().map(e=>e.multiaddr)}addObservedAddr(e){const t=e.stringTuples(),n=`${t[0][1]}:${t[1][1]}`;this.observedAddressFilter.has(n)||(this.observedAddressFilter.add(n),e=Li(e,this.components.peerId),!this.ipMappings.has(e)&&(this.dnsMappings.has(e)||this.observed.add(e)))}confirmObservedAddr(e,t){e=Li(e,this.components.peerId);let n=!0;(t?.type==="transport"||this.transportAddresses.has(e))&&!this.transportAddresses.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="dns-mapping"||this.dnsMappings.has(e))&&!this.dnsMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="ip-mapping"||this.ipMappings.has(e))&&!this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="observed"||this.observed.has(e))&&(this.maybeUpgradeToIPMapping(e)?(this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL),n=!1):!this.observed.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1)),n||this._updatePeerStoreAddresses()}removeObservedAddr(e,t){e=Li(e,this.components.peerId),this.observed.has(e)&&this.observed.remove(e),this.transportAddresses.has(e)&&this.transportAddresses.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.dnsMappings.has(e)&&this.dnsMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.ipMappings.has(e)&&this.ipMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry)}getAddresses(){const e=new Set,t=this.getAddressesWithMetadata().filter(n=>{if(!n.verified)return!1;const s=n.multiaddr.toString();return e.has(s)?!1:(e.add(s),!0)}).map(n=>n.multiaddr);return this.announceFilter(t.map(n=>{const s=X(n);return s.protos().pop()?.path===!0||s.getPeerId()===this.components.peerId.toString()?s:s.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const e=this.getAnnounceAddrs();if(e.length>0)return this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(e)}),e.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let t=[];t=t.concat(this.components.transportManager.getAddrs().map(s=>this.transportAddresses.get(s,this.addressVerificationTTL)));const n=this.getAppendAnnounceAddrs();return n.length>0&&(this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(n)}),t=t.concat(n.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),t=t.concat(this.observed.getAll()),t=t.concat(this.ipMappings.getAll(t)),t=t.concat(this.dnsMappings.getAll(t)),t}addDNSMapping(e,t){this.dnsMappings.add(e,t)}removeDNSMapping(e){this.dnsMappings.remove(X(`/dns/${e}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(e,t,n,s=t,i="tcp"){this.ipMappings.add(e,t,n,s,i),this.observed.removePrefixed(`/ip${Sr(n)?4:6}/${n}/${i}/${s}`)}removePublicAddressMapping(e,t,n,s=t,i="tcp"){this.ipMappings.remove(X(`/ip${Sr(n)?4:6}/${n}/${i}/${s}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(e){if(this.ipMappings.has(e))return!1;const t=e.toOptions();if(t.family===6||t.host==="127.0.0.1"||Ys(t.host)===!0)return!1;const n=this.components.transportManager.getListeners(),s=[i=>ln.exactMatch(i)||Cs.exactMatch(i),i=>As.exactMatch(i),i=>eb.exactMatch(i)];for(const i of s){if(!i(e))continue;const o=n.filter(l=>l.getAddrs().filter(u=>u.toOptions().family===4&&i(u)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(l=>l.toOptions().host!=="127.0.0.1").pop();if(a==null)continue;const c=a.toOptions();return this.observed.remove(e),this.ipMappings.add(c.host,c.port,t.host,t.port,t.transport),!0}return!1}}var ml;(function(r){r.NOT_STARTED_YET="The libp2p node is not started yet",r.NOT_FOUND="Not found"})(ml||(ml={}));class a1 extends Error{constructor(e="Missing service"){super(e),this.name="MissingServiceError"}}class c1 extends Error{constructor(e="Unmet service dependencies"){super(e),this.name="UnmetServiceDependenciesError"}}class Di extends Error{constructor(e="No content routers available"){super(e),this.name="NoContentRoutersError"}}class yl extends Error{constructor(e="No peer routers available"){super(e),this.name="NoPeerRoutersError"}}class l1 extends Error{constructor(e="Should not try to find self"){super(e),this.name="QueriedForSelfError"}}class u1 extends Error{constructor(e="Unhandled protocol error"){super(e),this.name="UnhandledProtocolError"}}class d1 extends Error{constructor(e="Duplicate protocol handler error"){super(e),this.name="DuplicateProtocolHandlerError"}}class wl extends Error{constructor(e="Dial denied error"){super(e),this.name="DialDeniedError"}}class h1 extends Error{constructor(e="No transport was configured to listen on this address"){super(e),this.name="UnsupportedListenAddressError"}}class f1 extends Error{constructor(e="Configured listen addresses could not be listened on"){super(e),this.name="UnsupportedListenAddressesError"}}class p1 extends Error{constructor(e="No valid addresses"){super(e),this.name="NoValidAddressesError"}}class g1 extends Error{constructor(e="Connection intercepted"){super(e),this.name="ConnectionInterceptedError"}}class m1 extends Error{constructor(e="Connection denied"){super(e),this.name="ConnectionDeniedError"}}class Wn extends Error{constructor(e="Stream is not multiplexed"){super(e),this.name="MuxerUnavailableError"}}class Vn extends Error{constructor(e="Encryption failed"){super(e),this.name="EncryptionFailedError"}}class y1 extends Error{constructor(e="Transport unavailable"){super(e),this.name="TransportUnavailableError"}}class w1{components={};_started=!1;constructor(e={}){this.components={};for(const[t,n]of Object.entries(e))this.components[t]=n;this.components.logger==null&&(this.components.logger=dh())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter(t=>Do(t)).map(async t=>{await t[e]?.()}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const b1=["metrics","connectionProtector","dns"],v1=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function E1(r={}){const e=new w1(r);return new Proxy(e,{get(n,s,i){if(typeof s=="string"&&!v1.includes(s)){const o=e.components[s];if(o==null&&!b1.includes(s))throw new a1(`${s} not set`);return o}return Reflect.get(n,s,i)},set(n,s,i){return typeof s=="string"?e.components[s]=i:Reflect.set(n,s,i),!0}})}function S1(r){const e={};for(const t of Object.values(r.components))for(const n of x1(t))e[n]=!0;for(const t of Object.values(r.components))for(const n of A1(t))if(e[n]!==!0)throw new c1(`Service "${C1(t)}" required capability "${n}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function x1(r){return Array.isArray(r?.[it])?r[it]:[]}function A1(r){return Array.isArray(r?.[Zn])?r[Zn]:[]}function C1(r){return r?.[Symbol.toStringTag]??r?.toString()??"unknown"}const I1=4,T1=41;function k1(r={}){return{denyDialPeer:async()=>!1,denyDialMultiaddr:async e=>{if(ln.matches(e))return!1;const t=e.stringTuples();return t[0][0]===I1||t[0][0]===T1?!!Ys(`${t[0][1]}`):!1},denyInboundConnection:async()=>!1,denyOutboundConnection:async()=>!1,denyInboundEncryptedConnection:async()=>!1,denyOutboundEncryptedConnection:async()=>!1,denyInboundUpgradedConnection:async()=>!1,denyOutboundUpgradedConnection:async()=>!1,filterMultiaddrForPeer:async()=>!0,...r}}const bl=()=>{const r=new Error("Delay aborted");return r.name="AbortError",r},_1=new WeakMap;function P1({clearTimeout:r,setTimeout:e}={}){return(t,{value:n,signal:s}={})=>{if(s?.aborted)return Promise.reject(bl());let i,o,a;const c=r??clearTimeout,l=()=>{c(i),a(bl())},u=()=>{s&&s.removeEventListener("abort",l)},d=new Promise((h,p)=>{o=()=>{u(),h(n)},a=p,i=(e??setTimeout)(o,t)});return s&&s.addEventListener("abort",l,{once:!0}),_1.set(d,()=>{c(i),i=null,o()}),d}}const L1=P1();class D1{memoryStorage;points;duration;blockDuration;execEvenly;execEvenlyMinDelayMs;keyPrefix;constructor(e={}){this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.execEvenly=e.execEvenly??!1,this.execEvenlyMinDelayMs=e.execEvenlyMinDelayMs??this.duration*1e3/this.points,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new M1}async consume(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n);let o=this.memoryStorage.incrby(s,t,i);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+t&&(o=this.memoryStorage.set(s,o.consumedPoints,this.blockDuration)),new vb("Rate limit exceeded",o);if(this.execEvenly&&o.msBeforeNext>0&&!o.isFirstInDuration){let a=Math.ceil(o.msBeforeNext/(o.remainingPoints+2));a<this.execEvenlyMinDelayMs&&(a=o.consumedPoints*this.execEvenlyMinDelayMs),await L1(a)}return o}penalty(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,-t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(e,t){const n=t*1e3,s=this.points+1;return this.memoryStorage.set(this.getKey(e),s,t),{remainingPoints:0,msBeforeNext:n===0?-1:n,consumedPoints:s,isFirstInDuration:!1}}set(e,t,n=0){const s=(n>=0?n:this.duration)*1e3;return this.memoryStorage.set(this.getKey(e),t,n),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return t!=null&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return e?.customDuration!=null&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class M1{storage;constructor(){this.storage=new Map}incrby(e,t,n){const s=this.storage.get(e);if(s!=null){const i=s.expiresAt!=null?s.expiresAt.getTime()-new Date().getTime():-1;return s.expiresAt==null||i>0?(s.value+=t,{remainingPoints:0,msBeforeNext:i,consumedPoints:s.value,isFirstInDuration:!1}):this.set(e,t,n)}return this.set(e,t,n)}set(e,t,n){const s=n*1e3,i=this.storage.get(e);i!=null&&clearTimeout(i.timeoutId);const o={value:t,expiresAt:s>0?new Date(Date.now()+s):void 0};return this.storage.set(e,o),s>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(e)},s),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:o.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(t!=null)return{remainingPoints:0,msBeforeNext:t.expiresAt!=null?t.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}delete(e){const t=this.storage.get(e);return t!=null?(t.timeoutId!=null&&clearTimeout(t.timeoutId),this.storage.delete(e),!0):!1}}function wh(r){if(Ol(r))return{peerId:r,multiaddrs:[]};let e=Array.isArray(r)?r:[r],t;if(e.length>0){const n=e[0].getPeerId();t=n==null?void 0:pt(n),e.forEach(s=>{if(!zs(s))throw new ko("Invalid multiaddr");const i=s.getPeerId();if(i==null){if(t!=null)throw new V("Multiaddrs must all have the same peer id or have no peer id")}else{const o=pt(i);if(t?.equals(o)!==!0)throw new V("Multiaddrs must all have the same peer id or have no peer id")}})}return e=e.filter(n=>!jw.exactMatch(n)),{peerId:t,multiaddrs:e}}const R1=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function O1(r,e){const t=r?.streams?.map(s=>s.protocol)??[],n=e?.closableProtocols??R1;if(!(t.filter(s=>s!=null&&!n.includes(s)).length>0))try{await r?.close(e)}catch(s){r?.abort(s)}}const bh=1e4,N1=1e4,vl=1e4,vh=25,F1=5,U1=10,B1=5,$1="last-dial-failure",z1="last-dial-success",Eh=500,Sh=100,xh=50;async function K1(r,e){let t=!1;for(const s of ta.keys())if(t=r.protoNames().includes(s),t)break;if(!t)return[r];const n=await r.resolve(e);return e.log("resolved %s to",r,n.map(s=>s.toString())),n}function Ao(r){try{let e;if(typeof r=="string"?e=X(r):e=r,!e.protoNames().includes("ipcidr")){const n=e.protoNames().includes("ip6")?"/ipcidr/128":"/ipcidr/32";e=e.encapsulate(n)}return kw(e)}catch{throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${r}`)}}const q1={maxConnections:Sh};class W1{maxConnections;connectionManager;peerStore;allow;events;log;constructor(e,t={}){this.maxConnections=t.maxConnections??q1.maxConnections,this.allow=(t.allow??[]).map(n=>Ao(n)),this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(e=>{this.log.error("error while pruning connections %e",e)})}async _maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length;if(this.log("checking max connections limit %d/%d",t,this.maxConnections),t<=this.maxConnections)return;const n=new Hs;for(const a of e){const c=a.remotePeer;if(!n.has(c)){n.set(c,0);try{const l=await this.peerStore.get(c);n.set(c,[...l.tags.values()].reduce((u,d)=>u+d.value,0))}catch(l){l.name!=="NotFoundError"&&this.log.error("error loading peer tags",l)}}}const s=this.sortConnections(e,n),i=Math.max(t-this.maxConnections,0),o=[];for(const a of s)if(this.log("too many connections open - closing a connection to %p",a.remotePeer),this.allow.some(l=>l.contains(a.remoteAddr.nodeAddress().address))||o.push(a),o.length===i)break;await Promise.all(o.map(async a=>{await O1(a,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:o})}sortConnections(e,t){return e.sort((n,s)=>{const i=n.timeline.open,o=s.timeline.open;return i<o?1:i>o?-1:0}).sort((n,s)=>n.direction==="outbound"&&s.direction==="inbound"?1:n.direction==="inbound"&&s.direction==="outbound"?-1:0).sort((n,s)=>n.streams.length>s.streams.length?1:n.streams.length<s.streams.length?-1:0).sort((n,s)=>{const i=t.get(n.remotePeer)??0,o=t.get(s.remotePeer)??0;return i>o?1:i<o?-1:0})}}class V1 extends Ud{constructor(e={}){super({...e,sort:(t,n)=>t.options.priority>n.options.priority?-1:t.options.priority<n.options.priority?1:0})}}function H1(r){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(r)||/^::1$/.test(r)}function El(r){if(!Kd(r))return!1;const{address:e}=r.nodeAddress();return H1(e)}function G1(r,e){const t=As.exactMatch(r.multiaddr),n=As.exactMatch(e.multiaddr);if(t&&!n)return-1;if(!t&&n)return 1;const s=Cs.exactMatch(r.multiaddr),i=Cs.exactMatch(e.multiaddr);if(s&&!i)return-1;if(!s&&i)return 1;const o=ln.exactMatch(r.multiaddr),a=ln.exactMatch(e.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=po.exactMatch(r.multiaddr),l=po.exactMatch(e.multiaddr);if(c&&!l)return-1;if(!c&&l)return 1;const u=vc.exactMatch(r.multiaddr),d=vc.exactMatch(e.multiaddr);if(u&&!d)return-1;if(!u&&d)return 1;const h=Ec.exactMatch(r.multiaddr),p=Ec.exactMatch(e.multiaddr);return h&&!p?-1:!h&&p?1:0}function Y1(r,e){const t=El(r.multiaddr),n=El(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function X1(r,e){const t=hn(r.multiaddr),n=hn(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function Q1(r,e){return r.isCertified&&!e.isCertified?-1:!r.isCertified&&e.isCertified?1:0}function j1(r,e){const t=un.exactMatch(r.multiaddr),n=un.exactMatch(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function Z1(r){return r.sort(G1).sort(Q1).sort(j1).sort(X1).sort(Y1)}const Hn={maxParallelDials:xh,maxDialQueueLength:Eh,maxPeerAddrsToDial:vh,dialTimeout:bh};class J1{queue;components;addressSorter;maxPeerAddrsToDial;maxDialQueueLength;dialTimeout;shutDownController;connections;log;constructor(e,t={}){this.addressSorter=t.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??Hn.maxPeerAddrsToDial,this.maxDialQueueLength=t.maxDialQueueLength??Hn.maxDialQueueLength,this.dialTimeout=t.dialTimeout??Hn.dialTimeout,this.connections=t.connections??new Hs,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.shutDownController=new AbortController,this.shutDownController.signal;for(const[n,s]of Object.entries(t.resolvers??{}))ta.set(n,s);this.queue=new V1({concurrency:t.maxParallelDials??Hn.maxParallelDials,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("error",n=>{n.detail?.name!==jt.name&&this.log.error("error in dial queue - %e",n.detail)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){const{peerId:n,multiaddrs:s}=wh(e),i=Array.from(this.connections.values()).flat().find(a=>t.force===!0?!1:a.remotePeer.equals(n)?!0:s.find(c=>c.equals(a.remoteAddr)));if(i?.status==="open")return this.log("already connected to %a",i.remoteAddr),t.onProgress?.(new ie("dial-queue:already-connected")),i;const o=this.queue.queue.find(a=>{if(n?.equals(a.options.peerId)===!0)return!0;const c=a.options.multiaddrs;if(c==null)return!1;for(const l of s)if(c.has(l.toString()))return!0;return!1});if(o!=null){this.log("joining existing dial target for %p",n);for(const a of s)o.options.multiaddrs.add(a.toString());return t.onProgress?.(new ie("dial-queue:already-in-dial-queue")),o.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new Vr("Dial queue is full");return this.log("creating dial target for %p",n,s.map(a=>a.toString())),t.onProgress?.(new ie("dial-queue:add-to-dial-queue")),this.queue.add(async a=>{a.onProgress?.(new ie("dial-queue:start-dial"));const c=$t([this.shutDownController.signal,a.signal]);try{return await this.dialPeer(a,c)}finally{c.clear()}},{peerId:n,priority:t.priority??Ah,multiaddrs:new Set(s.map(a=>a.toString())),signal:t.signal??AbortSignal.timeout(this.dialTimeout),onProgress:t.onProgress})}async dialPeer(e,t){const n=e.peerId,s=e.multiaddrs,i=new Set;let o=e.multiaddrs.size===0,a=0,c=0;const l=[];for(this.log("starting dial to %p",n);o||s.size>0;){c++,o=!1;const u=[],d=new Set(e.multiaddrs);s.clear(),this.log("calculating addrs to dial %p from %s",n,[...d]);const h=await this.calculateMultiaddrs(n,d,{...e,signal:t});for(const p of h){if(i.has(p.multiaddr.toString())){this.log.trace("skipping previously failed multiaddr %a while dialing %p",p.multiaddr,n);continue}u.push(p)}this.log("%s dial to %p with %s",c===1?"starting":"continuing",n,u.map(p=>p.multiaddr.toString())),e?.onProgress?.(new ie("dial-queue:calculated-addresses",u));for(const p of u){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,e.peerId),new Vr("Peer had more than maxPeerAddrsToDial");a++;try{const f=await this.components.transportManager.dial(p.multiaddr,{...e,signal:t});this.log("dial to %a succeeded",p.multiaddr);try{await this.components.peerStore.merge(f.remotePeer,{multiaddrs:[f.remoteAddr],metadata:{[z1]:q(Date.now().toString())}})}catch(g){this.log.error("could not update last dial failure key for %p",n,g)}return f}catch(f){if(this.log.error("dial failed to %a",p.multiaddr,f),i.add(p.multiaddr.toString()),n!=null)try{await this.components.peerStore.merge(n,{metadata:{[$1]:q(Date.now().toString())}})}catch(g){this.log.error("could not update last dial failure key for %p",n,g)}if(t.aborted)throw new Po(f.message);l.push(f)}}}throw l.length===1?l[0]:new AggregateError(l,"All multiaddr dials failed")}async calculateMultiaddrs(e,t=new Set,n={}){const s=[...t].map(d=>({multiaddr:X(d),isCertified:!1}));if(e!=null){if(this.components.peerId.equals(e))throw new Vr("Tried to dial self");if(await this.components.connectionGater.denyDialPeer?.(e)===!0)throw new wl("The dial request is blocked by gater.allowDialPeer");if(s.length===0){this.log("loading multiaddrs for %p",e);try{const d=await this.components.peerStore.get(e);s.push(...d.addresses),this.log("loaded multiaddrs for %p",e,s.map(({multiaddr:h})=>h.toString()))}catch(d){if(d.name!=="NotFoundError")throw d}}if(s.length===0){this.log("looking up multiaddrs for %p in the peer routing",e);try{const d=await this.components.peerRouting.findPeer(e,n);this.log("found multiaddrs for %p in the peer routing",e,s.map(({multiaddr:h})=>h.toString())),s.push(...d.multiaddrs.map(h=>({multiaddr:h,isCertified:!1})))}catch(d){d.name==="NoPeerRoutersError"?this.log("no peer routers configured",e):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",e,d)}}}let i=(await Promise.all(s.map(async d=>{const h=await K1(d.multiaddr,{dns:this.components.dns,...n,log:this.log});return h.length===1&&h[0].equals(d.multiaddr)?d:h.map(p=>({multiaddr:p,isCertified:!1}))}))).flat();if(e!=null){const d=`/p2p/${e.toString()}`;i=i.map(h=>h.multiaddr.protos().pop()?.path===!0?h:h.multiaddr.getPeerId()==null?{multiaddr:h.multiaddr.encapsulate(d),isCertified:h.isCertified}:h)}const o=i.filter(d=>{if(this.components.transportManager.dialTransportForMultiaddr(d.multiaddr)==null)return!1;const h=d.multiaddr.getPeerId();return e!=null&&h!=null?e.equals(h):!0}),a=new Map;for(const d of o){const h=d.multiaddr.toString(),p=a.get(h);if(p!=null){p.isCertified=p.isCertified||d.isCertified||!1;continue}a.set(h,d)}const c=[...a.values()];if(c.length===0)throw new p1("The dial request has no valid addresses");const l=[];for(const d of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(d.multiaddr)||l.push(d);const u=this.addressSorter==null?Z1(l):l.sort(this.addressSorter);if(u.length===0)throw new wl("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",e??"unknown peer",i.map(({multiaddr:d})=>d.toString())),this.log.trace("addresses for %p after filtering",e??"unknown peer",u.map(({multiaddr:d})=>d.toString())),u}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const n=await this.calculateMultiaddrs(void 0,new Set(e.map(s=>s.toString())),t);return t.runOnLimitedConnection===!1?n.find(s=>!un.matches(s.multiaddr))!=null:!0}catch(n){this.log.trace("error calculating if multiaddr(s) were dialable",n)}return!1}}var Mi={},Ri,Sl;function eS(){if(Sl)return Ri;Sl=1;function r(e,t){typeof t=="boolean"&&(t={forever:t}),this._originalTimeouts=JSON.parse(JSON.stringify(e)),this._timeouts=e,this._options=t||{},this._maxRetryTime=t&&t.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}return Ri=r,r.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},r.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},r.prototype.retry=function(e){if(this._timeout&&clearTimeout(this._timeout),!e)return!1;var t=new Date().getTime();if(e&&t-this._operationStart>=this._maxRetryTime)return this._errors.push(e),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(e);var n=this._timeouts.shift();if(n===void 0)if(this._cachedTimeouts)this._errors.splice(0,this._errors.length-1),n=this._cachedTimeouts.slice(-1);else return!1;var s=this;return this._timer=setTimeout(function(){s._attempts++,s._operationTimeoutCb&&(s._timeout=setTimeout(function(){s._operationTimeoutCb(s._attempts)},s._operationTimeout),s._options.unref&&s._timeout.unref()),s._fn(s._attempts)},n),this._options.unref&&this._timer.unref(),!0},r.prototype.attempt=function(e,t){this._fn=e,t&&(t.timeout&&(this._operationTimeout=t.timeout),t.cb&&(this._operationTimeoutCb=t.cb));var n=this;this._operationTimeoutCb&&(this._timeout=setTimeout(function(){n._operationTimeoutCb()},n._operationTimeout)),this._operationStart=new Date().getTime(),this._fn(this._attempts)},r.prototype.try=function(e){console.log("Using RetryOperation.try() is deprecated"),this.attempt(e)},r.prototype.start=function(e){console.log("Using RetryOperation.start() is deprecated"),this.attempt(e)},r.prototype.start=r.prototype.try,r.prototype.errors=function(){return this._errors},r.prototype.attempts=function(){return this._attempts},r.prototype.mainError=function(){if(this._errors.length===0)return null;for(var e={},t=null,n=0,s=0;s<this._errors.length;s++){var i=this._errors[s],o=i.message,a=(e[o]||0)+1;e[o]=a,a>=n&&(t=i,n=a)}return t},Ri}var xl;function tS(){return xl||(xl=1,function(r){var e=eS();r.operation=function(t){var n=r.timeouts(t);return new e(n,{forever:t&&(t.forever||t.retries===1/0),unref:t&&t.unref,maxRetryTime:t&&t.maxRetryTime})},r.timeouts=function(t){if(t instanceof Array)return[].concat(t);var n={retries:10,factor:2,minTimeout:1*1e3,maxTimeout:1/0,randomize:!1};for(var s in t)n[s]=t[s];if(n.minTimeout>n.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var i=[],o=0;o<n.retries;o++)i.push(this.createTimeout(o,n));return t&&t.forever&&!i.length&&i.push(this.createTimeout(o,n)),i.sort(function(a,c){return a-c}),i},r.createTimeout=function(t,n){var s=n.randomize?Math.random()+1:1,i=Math.round(s*Math.max(n.minTimeout,1)*Math.pow(n.factor,t));return i=Math.min(i,n.maxTimeout),i},r.wrap=function(t,n,s){if(n instanceof Array&&(s=n,n=null),!s){s=[];for(var i in t)typeof t[i]=="function"&&s.push(i)}for(var o=0;o<s.length;o++){var a=s[o],c=t[a];t[a]=function(u){var d=r.operation(n),h=Array.prototype.slice.call(arguments,1),p=h.pop();h.push(function(f){d.retry(f)||(f&&(arguments[0]=d.mainError()),p.apply(this,arguments))}),d.attempt(function(){u.apply(t,h)})}.bind(t,c),t[a].options=n}}}(Mi)),Mi}var Oi,Al;function rS(){return Al||(Al=1,Oi=tS()),Oi}var nS=rS();const sS=Gs(nS),iS=Object.prototype.toString,oS=r=>iS.call(r)==="[object Error]",aS=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Load failed","Network request failed","fetch failed","terminated"]);function cS(r){return r&&oS(r)&&r.name==="TypeError"&&typeof r.message=="string"?r.message==="Load failed"?r.stack===void 0:aS.has(r.message):!1}class lS extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,{message:e}=e):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}const Cl=(r,e,t)=>{const n=t.retries-(e-1);return r.attemptNumber=e,r.retriesLeft=n,r};async function uS(r,e){return new Promise((t,n)=>{e={...e},e.onFailedAttempt??=()=>{},e.shouldRetry??=()=>!0,e.retries??=10;const s=sS.operation(e),i=()=>{s.stop(),n(e.signal?.reason)};e.signal&&!e.signal.aborted&&e.signal.addEventListener("abort",i,{once:!0});const o=()=>{e.signal?.removeEventListener("abort",i),s.stop()};s.attempt(async a=>{try{const c=await r(a);o(),t(c)}catch(c){try{if(!(c instanceof Error))throw new TypeError(`Non-error was thrown: "${c}". You should only throw errors.`);if(c instanceof lS)throw c.originalError;if(c instanceof TypeError&&!cS(c))throw c;if(Cl(c,a,e),await e.shouldRetry(c)||(s.stop(),n(c)),await e.onFailedAttempt(c),!s.retry(c))throw s.mainError()}catch(l){Cl(l,a,e),o(),n(l)}}})})}class dS{log;queue;started;peerStore;retries;retryInterval;backoffFactor;connectionManager;events;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.queue=new ca({concurrency:t.maxParallelReconnects??B1,metricName:"libp2p_reconnect_queue",metrics:e.metrics}),this.started=!1,this.retries=t.retries??5,this.backoffFactor=t.backoffFactor,this.retryInterval=t.retryInterval,this.events=e.events,e.events.addEventListener("peer:disconnect",n=>{this.maybeReconnect(n.detail).catch(s=>{this.log.error("failed to maybe reconnect to %p - %e",n.detail,s)})})}async maybeReconnect(e){if(!this.started)return;const t=await this.peerStore.get(e);Il(t)&&(this.queue.has(e)||this.queue.add(async n=>{await uS(async s=>{if(this.started)try{await this.connectionManager.openConnection(e,{signal:n?.signal})}catch(i){throw this.log("reconnecting to %p attempt %d of %d failed - %e",e,s,this.retries,i),i}},{signal:n?.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:e}).catch(async n=>{this.log.error("failed to reconnect to %p - %e",e,n);const s={};[...t.tags.keys()].forEach(i=>{i.startsWith(Io)&&(s[i]=void 0)}),await this.peerStore.merge(e,{tags:s}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:e})}).catch(async n=>{this.log.error("failed to remove keep-alive tag from %p - %e",e,n)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>Il(t)]});await Promise.all(e.map(async t=>{await this.connectionManager.openConnection(t.id).catch(n=>{this.log.error(n)})}))}).catch(e=>{this.log.error(e)})}stop(){this.started=!1,this.queue.abort()}}function Il(r){for(const e of r.tags.keys())if(e.startsWith(Io))return!0;return!1}const Ah=50,Ni={maxConnections:Sh,inboundConnectionThreshold:F1,maxIncomingPendingConnections:U1};class hS{started;connections;allow;deny;maxIncomingPendingConnections;incomingPendingConnections;outboundPendingConnections;maxConnections;dialQueue;reconnectQueue;connectionPruner;inboundConnectionRateLimiter;peerStore;metrics;events;log;peerId;constructor(e,t={}){if(this.maxConnections=t.maxConnections??Ni.maxConnections,this.maxConnections<1)throw new V("Connection Manager maxConnections must be greater than 0");this.connections=new Hs,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(t.allow??[]).map(n=>Ao(n)),this.deny=(t.deny??[]).map(n=>Ao(n)),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??Ni.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new D1({points:t.inboundConnectionThreshold??Ni.inboundConnectionThreshold,duration:1}),this.connectionPruner=new W1({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{maxConnections:this.maxConnections,allow:t.allow?.map(n=>X(n))}),this.dialQueue=new J1(e,{addressSorter:t.addressSorter,maxParallelDials:t.maxParallelDials??xh,maxDialQueueLength:t.maxDialQueueLength??Eh,maxPeerAddrsToDial:t.maxPeerAddrsToDial??vh,dialTimeout:t.dialTimeout??bh,resolvers:t.resolvers??{dnsaddr:lh},connections:this.connections}),this.reconnectQueue=new dS({events:e.events,peerStore:e.peerStore,logger:e.logger,connectionManager:this},{retries:t.reconnectRetries,retryInterval:t.reconnectRetryInterval,backoffFactor:t.reconnectBackoffFactor,maxParallelReconnects:t.maxParallelReconnects})}[Symbol.toStringTag]="@libp2p/connection-manager";async start(){this.metrics?.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const e={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const t of this.connections.values())for(const n of t)e[n.direction]++;return e}}),this.metrics?.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const e={};for(const t of this.connections.values())for(const n of t)for(const s of n.streams){const i=`${s.direction} ${s.protocol??"unnegotiated"}`;e[i]=(e[i]??0)+1}return e}}),this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const e={};for(const n of this.connections.values())for(const s of n){const i={};for(const o of s.streams){const a=`${o.direction} ${o.protocol??"unnegotiated"}`;i[a]=(i[a]??0)+1}for(const[o,a]of Object.entries(i))e[o]=e[o]??[],e[o].push(a)}const t={};for(let[n,s]of Object.entries(e)){s=s.sort((o,a)=>o-a);const i=Math.floor(s.length*.9);t[n]=s[i]}return t}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await Kl(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await ql(this.reconnectQueue,this.dialQueue,this.connectionPruner);const e=[];for(const t of this.connections.values())for(const n of t)e.push((async()=>{try{await n.close()}catch(s){this.log.error(s)}})());this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}onConnect(e){this._onConnect(e).catch(t=>{this.log.error(t)})}async _onConnect(e){const{detail:t}=e;if(!this.started){await t.close();return}if(t.status!=="open")return;const n=t.remotePeer,s=!this.connections.has(n),i=this.connections.get(n)??[];i.push(t),this.connections.set(n,i),n.publicKey!=null&&n.type==="RSA"&&await this.peerStore.patch(n,{publicKey:n.publicKey}),s&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e,n=t.remotePeer,i=(this.connections.get(n)??[]).filter(o=>o.id!==t.id);this.connections.set(n,i),i.length===0&&(this.log("onDisconnect remove all connections for peer %p",n),this.connections.delete(n),this.events.safeDispatchEvent("peer:disconnect",{detail:t.remotePeer}))}getConnections(e){if(e!=null)return this.connections.get(e)??[];let t=[];for(const n of this.connections.values())t=t.concat(n);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){if(!this.started)throw new jn("Not started");this.outboundPendingConnections++;try{t.signal?.throwIfAborted();const{peerId:n}=wh(e);if(this.peerId.equals(n))throw new Bl("Can not dial self");if(n!=null&&t.force!==!0){this.log("dial %p",n);const a=this.getConnections(n).find(c=>c.limits==null);if(a!=null)return this.log("had an existing non-limited connection to %p",n),t.onProgress?.(new ie("dial-queue:already-connected")),a}const s=await this.dialQueue.dial(e,{...t,priority:t.priority??Ah});if(s.status!=="open")throw new Fl("Remote closed connection during opening");let i=this.connections.get(s.remotePeer);i==null&&(i=[],this.connections.set(s.remotePeer,i));let o=!1;for(const a of i)if(a.id===s.id&&(o=!0),t.force!==!0&&a.id!==s.id&&a.remoteAddr.equals(s.remoteAddr))return s.abort(new ko("Duplicate multiaddr connection")),a;return o||i.push(s),s}finally{this.outboundPendingConnections--}}async closeConnections(e,t={}){const n=this.connections.get(e)??[];await Promise.all(n.map(async s=>{try{await s.close(t)}catch(i){s.abort(i)}}))}async acceptIncomingConnection(e){if(this.deny.some(s=>s.contains(e.remoteAddr.nodeAddress().address)))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some(s=>s.contains(e.remoteAddr.nodeAddress().address)))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(e.remoteAddr.isThinWaistAddress()){const s=e.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(s,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,s),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map(n=>X(n))}))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}class Fi{movingAverage;variance;deviation;forecast;timeSpan;previousTime;constructor(e){this.timeSpan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timeSpan)}push(e,t=Date.now()){if(this.previousTime!=null){const n=this.alpha(t,this.previousTime),s=e-this.movingAverage,i=n*s;this.movingAverage=n*e+(1-n)*this.movingAverage,this.variance=(1-n)*(this.variance+s*i),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+n*s}else this.movingAverage=e;this.previousTime=t}}const fS=1.2,pS=2,gS=5e3;class mS{success;failure;next;metric;timeoutMultiplier;failureMultiplier;minTimeout;constructor(e={}){this.success=new Fi(e.interval??5e3),this.failure=new Fi(e.interval??5e3),this.next=new Fi(e.interval??5e3),this.failureMultiplier=e.failureMultiplier??pS,this.timeoutMultiplier=e.timeoutMultiplier??fS,this.minTimeout=e.minTimeout??gS,e.metricName!=null&&(this.metric=e.metrics?.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){const t=Math.max(Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier)),this.minTimeout),n=AbortSignal.timeout(t),s=$t([e.signal,n]);return s.start=Date.now(),s.timeout=t,s}cleanUp(e){const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),this.metric?.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),this.metric?.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}const yS=1e4,wS="1.0.0",bS="ping",vS="ipfs",Tl=32,ES=!0;class SS{protocol;components;log;heartbeatInterval;pingIntervalMs;abortController;timeout;abortConnectionOnPingFailure;constructor(e,t={}){this.components=e,this.protocol=`/${t.protocolPrefix??vS}/${bS}/${wS}`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??yS,this.abortConnectionOnPingFailure=t.abortConnectionOnPingFailure??ES,this.timeout=new mS({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}[Symbol.toStringTag]="@libp2p/connection-monitor";[it]=["@libp2p/connection-monitor"];start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(e=>{Promise.resolve().then(async()=>{let t=Date.now();try{const n=this.timeout.getTimeoutSignal({signal:this.abortController?.signal}),s=await e.newStream(this.protocol,{signal:n,runOnLimitedConnection:!0}),i=ds(s);t=Date.now(),await Promise.all([i.write(Yo(Tl),{signal:n}),i.read({bytes:Tl,signal:n})]),e.rtt=Date.now()-t,await i.unwrap().close({signal:n})}catch(n){if(n.name!=="UnsupportedProtocolError")throw n;e.rtt=(Date.now()-t)/2}}).catch(t=>{this.log.error("error during heartbeat",t),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),e.abort(t)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){this.abortController?.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}class xS{routers;started;components;constructor(e,t){this.routers=t.routers??[],this.started=!1,this.components=e,this.findProviders=e.metrics?.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,cid:n.toString()}),getAttributesFromYieldedValue:(n,s)=>({...s,providers:[...Array.isArray(s.providers)?s.providers:[],n.id.toString()]})})??this.findProviders,this.provide=e.metrics?.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,cid:n.toString()})})??this.provide,this.cancelReprovide=e.metrics?.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,cid:n.toString()})})??this.cancelReprovide,this.put=e.metrics?.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([n])=>({key:Y(n,"base36")})})??this.put,this.get=e.metrics?.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([n])=>({key:Y(n,"base36")})})??this.get}[Symbol.toStringTag]="@libp2p/content-routing";isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(this.routers.length===0)throw new Di("No content routers available");const n=this,s=new fr;for await(const i of hs(...n.routers.filter(o=>o.findProviders instanceof Function).map(o=>o.findProviders(e,t))))i!=null&&(i.multiaddrs.length>0&&await this.components.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),!s.has(i.id)&&(s.add(i.id),yield i))}async provide(e,t={}){if(this.routers.length===0)throw new Di("No content routers available");await Promise.all(this.routers.filter(n=>n.provide instanceof Function).map(async n=>{await n.provide(e,t)}))}async cancelReprovide(e,t={}){if(this.routers.length===0)throw new Di("No content routers available");await Promise.all(this.routers.filter(n=>n.cancelReprovide instanceof Function).map(async n=>{await n.cancelReprovide(e,t)}))}async put(e,t,n){if(!this.isStarted())throw new jn;await Promise.all(this.routers.filter(s=>s.put instanceof Function).map(async s=>{await s.put(e,t,n)}))}async get(e,t){if(!this.isStarted())throw new jn;return Promise.any(this.routers.filter(n=>n.get instanceof Function).map(async n=>n.get(e,t)))}}class AS{log;peerId;peerStore;routers;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[],this.findPeer=e.metrics?.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,peer:n.toString()})})??this.findPeer,this.getClosestPeers=e.metrics?.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,key:Y(n,"base36")}),getAttributesFromYieldedValue:(n,s)=>({...s,peers:[...Array.isArray(s.peers)?s.peers:[],n.id.toString()]})})??this.getClosestPeers}[Symbol.toStringTag]="@libp2p/peer-routing";async findPeer(e,t){if(this.routers.length===0)throw new yl("No peer routers available");if(e.toString()===this.peerId.toString())throw new l1("Should not try to find self");const n=this,s=hs(...this.routers.filter(i=>i.findPeer instanceof Function).map(i=>async function*(){try{yield await i.findPeer(e,t)}catch(o){n.log.error(o)}}()));for await(const i of s)if(i!=null)return i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),i;throw new qi}async*getClosestPeers(e,t={}){if(this.routers.length===0)throw new yl("No peer routers available");const n=this,s=dn(1024);for await(const i of Bd(async function*(){const o=hs(...n.routers.filter(a=>a.getClosestPeers instanceof Function).map(a=>a.getClosestPeers(e,t)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await n.findPeer(a.id,{...t,useCache:!1})}catch(c){n.log.error("could not find peer multiaddrs",c);return}return a}}()))i!=null&&(i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),!s.has(i.id.toMultihash().bytes)&&(s.add(i.id.toMultihash().bytes),yield i))}}class CS extends Ut{peerRouting;log;walking;walkers;shutdownController;walkController;needNext;constructor(e){super(),this.log=e.logger.forComponent("libp2p:random-walk"),this.peerRouting=e.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}[Symbol.toStringTag]="@libp2p/random-walk";start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(e){this.walking||this.startWalk(),this.walkers++;const t=$t([this.shutdownController.signal,e?.signal]);try{for(;;)this.needNext?.resolve(),this.needNext=he(),yield(await pr(this,"walk:peer",t,{errorEvent:"walk:error"})).detail}finally{t.clear(),this.walkers--,this.walkers===0&&(this.walkController?.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const e=$t([this.walkController.signal,this.shutdownController.signal]),t=Date.now();let n=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const s=Yo(32);let i=Date.now();for await(const o of this.peerRouting.getClosestPeers(s,{signal:e}))e.aborted&&this.log("aborting walk"),e.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",o.id,Date.now()-i,this.walkers),n++,this.safeDispatchEvent("walk:peer",{detail:o}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await Je(this.needNext.promise,e)),i=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",s,this.walkers,n)}catch(s){this.log.error("random walk errored",s),this.safeDispatchEvent("walk:error",{detail:s})}this.log("no walkers left, ended walk")}).catch(s=>{this.log.error("random walk errored",s)}).finally(()=>{this.log("finished walk, found %d peers after %dms",n,Date.now()-t),this.walking=!1})}}const Ch=32,Ih=64;class IS{log;topologies;handlers;components;constructor(e){this.log=e.logger.forComponent("libp2p:registrar"),this.topologies=new Map,this.handlers=new Map,this.components=e,this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}[Symbol.toStringTag]="@libp2p/registrar";getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(t==null)throw new u1(`No handler registered for protocol ${e}`);return t}getTopologies(e){const t=this.topologies.get(e);return t==null?[]:[...t.values()]}async handle(e,t,n){if(this.handlers.has(e)&&n?.force!==!0)throw new d1(`Handler already registered for protocol ${e}`);const s=ih.bind({ignoreUndefined:!0})({maxInboundStreams:Ch,maxOutboundStreams:Ih},n);this.handlers.set(e,{handler:t,options:s}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]})}async unhandle(e){(Array.isArray(e)?e:[e]).forEach(n=>{this.handlers.delete(n)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()})}async register(e,t){if(t==null)throw new V("invalid topology");const n=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let s=this.topologies.get(e);return s==null&&(s=new Map,this.topologies.set(e,s)),s.set(n,t),n}unregister(e){for(const[t,n]of this.topologies.entries())n.has(e)&&(n.delete(e),n.size===0&&this.topologies.delete(t))}_onDisconnect(e){const t=e.detail;this.components.peerStore.get(t).then(n=>{for(const s of n.protocols){const i=this.topologies.get(s);if(i!=null)for(const o of i.values())o.filter?.has(t)!==!1&&(o.filter?.remove(t),o.onDisconnect?.(t))}}).catch(n=>{n.name!=="NotFoundError"&&this.log.error("could not inform topologies of disconnecting peer %p",t,n)})}_onPeerUpdate(e){const{peer:t,previous:n}=e.detail,s=(n?.protocols??[]).filter(i=>!t.protocols.includes(i));for(const i of s){const o=this.topologies.get(i);if(o!=null)for(const a of o.values())a.filter?.has(t.id)!==!1&&(a.filter?.remove(t.id),a.onDisconnect?.(t.id))}}_onPeerIdentify(e){const t=e.detail.protocols,n=e.detail.connection,s=e.detail.peerId;for(const i of t){const o=this.topologies.get(i);if(o!=null)for(const a of o.values())n.limits!=null&&a.notifyOnLimitedConnection!==!0||a.filter?.has(s)!==!0&&(a.filter?.add(s),a.onConnect?.(s,n))}}}class TS extends Map{metric;constructor(e){super();const{name:t,metrics:n}=e;this.metric=n.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function kS(r){const{name:e,metrics:t}=r;let n;return t!=null?n=new TS({name:e,metrics:t}):n=new Map,n}class _S{log;components;transports;listeners;faultTolerance;started;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=new Map,this.listeners=kS({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??jr.FATAL_ALL}[Symbol.toStringTag]="@libp2p/transport-manager";add(e){const t=e[Symbol.toStringTag];if(t==null)throw new V("Transport must have a valid tag");if(this.transports.has(t))throw new V(`There is already a transport with the tag ${t}`);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,n]of this.listeners)for(this.log("closing listeners for %s",t);n.length>0;){const s=n.pop();s!=null&&e.push(s.close())}await Promise.all(e),this.log("all listeners closed");for(const t of this.listeners.keys())this.listeners.set(t,[]);this.started=!1}async dial(e,t){const n=this.dialTransportForMultiaddr(e);if(n==null)throw new y1(`No transport available for address ${String(e)}`);return t?.onProgress?.(new ie("transport-manager:selected-transport",n[Symbol.toStringTag])),n.dial(e,{...t,upgrader:this.components.upgrader})}getAddrs(){let e=[];for(const t of this.listeners.values())for(const n of t)e=[...e,...n.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values())if(t.dialFilter([e]).length>0)return t}listenTransportForMultiaddr(e){for(const t of this.transports.values())if(t.listenFilter([e]).length>0)return t}async listen(e){if(!this.isStarted())throw new jn("Not started");if(e==null||e.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const t={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};e.forEach(i=>{t.errors.set(i.toString(),new h1)});const n=[];for(const[i,o]of this.transports.entries()){const a=o.listenFilter(e);for(const c of a){this.log("creating listener for %s on %a",i,c);const l=o.createListener({upgrader:this.components.upgrader});let u=this.listeners.get(i)??[];u==null&&(u=[],this.listeners.set(i,u)),u.push(l),l.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:l})}),l.addEventListener("close",()=>{const d=u.findIndex(h=>h===l);u.splice(d,1),this.components.events.safeDispatchEvent("transport:close",{detail:l})}),wc.matches(c)?t.ipv4.attempts++:bc.matches(c)&&t.ipv6.attempts++,n.push(l.listen(c).then(()=>{t.errors.delete(c.toString()),wc.matches(c)&&t.ipv4.success++,bc.matches(c)&&t.ipv6.success++},d=>{throw this.log.error("transport %s could not listen on address %a - %e",i,c,d),t.errors.set(c.toString(),d),d}))}}const s=await Promise.allSettled(n);if(!(s.length>0&&s.every(i=>i.status==="fulfilled"))){if(this.ipv6Unsupported(t)){this.log("all IPv4 addresses succeed but all IPv6 failed");return}if(this.faultTolerance===jr.NO_FATAL){this.log("failed to listen on any address but fault tolerance allows this");return}throw new f1(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...t.errors.entries()].map(([i,o])=>`
  ${i}: ${`${o.stack??o}`.split(`
`).join(`
  `)}
`).join("")}`)}}ipv6Unsupported(e){if(e.ipv4.attempts===0||e.ipv6.attempts===0)return!1;const t=e.ipv4.attempts===e.ipv4.success,n=e.ipv6.success===0;return t&&n}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const n=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const s=t.pop();s!=null&&n.push(s.close())}await Promise.all(n),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}const qe="/multistream/1.0.0",fa=1024,PS=q(`
`);async function Wr(r,e,t){await r.write(e,t)}async function LS(r,e,t){await r.writeV(e,t)}async function DS(r,e){const t=await r.read(e);if(t.byteLength===0||t.get(t.byteLength-1)!==PS[0])throw e.log.error("Invalid mss message - missing newline",t),new ut("Missing newline");return t.sublist(0,-1)}async function gr(r,e){const t=await DS(r,e);return Y(t.subarray())}async function Ui(r,e,t){if(e=Array.isArray(e)?[...e]:[e],e.length===1&&t.negotiateFully===!1)return MS(r,e[0],t);const n=br(r,{...t,maxDataLength:fa}),s=e.shift();if(s==null)throw new Error("At least one protocol must be specified");t.log.trace('select: write ["%s", "%s"]',qe,s);const i=q(`${qe}
`),o=q(`${s}
`);await LS(n,[i,o],t),t.log.trace("select: reading multistream-select header");let a=await gr(n,t);if(t.log.trace('select: read "%s"',a),a===qe&&(t.log.trace("select: reading protocol response"),a=await gr(n,t),t.log.trace('select: read "%s"',a)),a===s)return{stream:n.unwrap(),protocol:s};for(const c of e){t.log.trace('select: write "%s"',c),await Wr(n,q(`${c}
`),t),t.log.trace("select: reading protocol response");const l=await gr(n,t);if(t.log.trace('select: read "%s" for "%s"',l,c),l===c)return{stream:n.unwrap(),protocol:c}}throw new _o("protocol selection failed")}function MS(r,e,t){const n=r.sink.bind(r),s=r.source;let i=!1,o=!1;const a=he();let c=!1,l=!1;const u=he();let d=!1,h=!1;const p=he(),f=br({sink:n,source:s},{...t,maxDataLength:fa});r.sink=async k=>{const{sink:b}=f.unwrap();await b(async function*(){let w=!1;for await(const E of k){if(l&&await u.promise,c)yield E;else{l=!0,t.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink',qe,e,E.byteLength);const P=`${e}
`;yield new Z(Uint8Array.from([19]),q(`${qe}
`),dt(P.length),q(P),E).subarray(),t.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink',qe,e,E.byteLength),c=!0,l=!1,u.resolve(),g().catch(x=>{t.log.error("could not finish optimistic protocol negotiation of %s",e,x)})}w=!0}w||await g()}())};async function g(){if(o){t.log.trace("optimistic: already negotiating %s stream",e),await a.promise;return}o=!0;try{c||(t.log.trace("optimistic: doing send protocol for %s stream",e),await m()),d||(t.log.trace("optimistic: doing read protocol for %s stream",e),await v())}finally{o=!1,i=!0,a.resolve()}}async function m(){if(l){await u.promise;return}l=!0;try{t.log.trace('optimistic: write ["%s", "%s", data] in source',qe,e),await f.writeV([q(`${qe}
`),q(`${e}
`)]),t.log.trace('optimistic: wrote ["%s", "%s", data] in source',qe,e)}finally{c=!0,l=!1,u.resolve()}}async function v(){if(h){await p.promise;return}h=!0;try{t.log.trace("optimistic: reading multistream select header");let k=await gr(f,t);if(t.log.trace('optimistic: read multistream select header "%s"',k),k===qe&&(k=await gr(f,t)),t.log.trace('optimistic: read protocol "%s", expecting "%s"',k,e),k!==e)throw new _o("protocol selection failed")}finally{d=!0,h=!1,p.resolve()}}if(r.source=async function*(){await g(),t.log.trace('optimistic: reading data from "%s" stream',e),yield*f.unwrap().source}(),r.closeRead!=null){const k=r.closeRead.bind(r);r.closeRead=async b=>{i||await g().catch(w=>{t.log.error("could not negotiate protocol before close read",w)}),await k(b)}}if(r.closeWrite!=null){const k=r.closeWrite.bind(r);r.closeWrite=async b=>{i||await g().catch(w=>{t.log.error("could not negotiate protocol before close write",w)}),await k(b)}}if(r.close!=null){const k=r.close.bind(r);r.close=async b=>{const w=[];l&&w.push(u.promise),h&&w.push(p.promise),w.length>0?await Je(Promise.all(w),b?.signal):(i=!0,o=!1,a.resolve()),await k(b)}}return{stream:r,protocol:e}}async function Bi(r,e,t){e=Array.isArray(e)?e:[e],t.log.trace("handle: available protocols %s",e);const n=br(r,{...t,maxDataLength:fa,maxLengthLength:2});for(;;){t.log.trace("handle: reading incoming string");const s=await gr(n,t);if(t.log.trace('handle: read "%s"',s),s===qe){t.log.trace('handle: respond with "%s" for "%s"',qe,s),await Wr(n,q(`${qe}
`),t),t.log.trace('handle: responded with "%s" for "%s"',qe,s);continue}if(e.includes(s))return t.log.trace('handle: respond with "%s" for "%s"',s,s),await Wr(n,q(`${s}
`),t),t.log.trace('handle: responded with "%s" for "%s"',s,s),{stream:n.unwrap(),protocol:s};if(s==="ls"){const i=new Z(...e.map(o=>ls.single(q(`${o}
`))),q(`
`));t.log.trace('handle: respond with "%s" for %s',e,s),await Wr(n,i,t),t.log.trace('handle: responded with "%s" for %s',e,s);continue}t.log.trace('handle: respond with "na" for "%s"',s),await Wr(n,q(`na
`),t),t.log('handle: responded with "na" for "%s"',s)}}const RS=500;class OS{id;remoteAddr;remotePeer;direction;timeline;multiplexer;encryption;status;limits;log;tags;_newStream;_close;_abort;_getStreams;constructor(e){const{remoteAddr:t,remotePeer:n,newStream:s,close:i,abort:o,getStreams:a}=e;this.id=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`,this.remoteAddr=t,this.remotePeer=n,this.direction=e.direction,this.status="open",this.timeline=e.timeline,this.multiplexer=e.multiplexer,this.encryption=e.encryption,this.limits=e.limits,this.log=e.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`),this.remoteAddr.getPeerId()==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),this._newStream=s,this._close=i,this._abort=o,this._getStreams=a,this.tags=[]}[Symbol.toStringTag]="Connection";[Rh]=!0;get streams(){return this._getStreams()}async newStream(e,t){if(this.status==="closing")throw new Fh("the connection is being closed");if(this.status==="closed")throw new Fl("the connection is closed");if(Array.isArray(e)||(e=[e]),this.limits!=null&&t?.runOnLimitedConnection!==!0)throw new $l("Cannot open protocol stream on limited connection");const n=await this._newStream(e,t);return n.direction="outbound",n}async close(e={}){if(!(this.status==="closed"||this.status==="closing")){if(this.log("closing connection to %a",this.remoteAddr),this.status="closing",e.signal==null){const t=AbortSignal.timeout(RS);e={...e,signal:t}}try{this.log.trace("closing underlying transport"),await this._close(e),this.log.trace("updating timeline with close time"),this.status="closed",this.timeline.close=Date.now()}catch(t){this.log.error("error encountered during graceful close of connection to %a",this.remoteAddr,t),this.abort(t)}}}abort(e){this.status!=="closed"&&(this.log.error("aborting connection to %a due to error",this.remoteAddr,e),this.status="closing",this._abort(e),this.status="closed",this.timeline.close=Date.now())}}function NS(r){return new OS(r)}function FS(r,e){try{const{options:t}=e.getHandler(r);return t.maxInboundStreams}catch(t){if(t.name!=="UnhandledProtocolError")throw t}return Ch}function US(r,e,t={}){try{const{options:n}=e.getHandler(r);if(n.maxOutboundStreams!=null)return n.maxOutboundStreams}catch(n){if(n.name!=="UnhandledProtocolError")throw n}return t.maxOutboundStreams??Ih}function kl(r,e,t){let n=0;return t.streams.forEach(s=>{s.direction===e&&s.protocol===r&&n++}),n}class BS{components;connectionEncrypters;streamMuxers;inboundUpgradeTimeout;inboundStreamProtocolNegotiationTimeout;outboundStreamProtocolNegotiationTimeout;events;metrics;constructor(e,t){this.components=e,this.connectionEncrypters=new Map,t.connectionEncrypters.forEach(n=>{this.connectionEncrypters.set(n.protocol,n)}),this.streamMuxers=new Map,t.streamMuxers.forEach(n=>{this.streamMuxers.set(n.protocol,n)}),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??N1,this.inboundStreamProtocolNegotiationTimeout=t.inboundStreamProtocolNegotiationTimeout??vl,this.outboundStreamProtocolNegotiationTimeout=t.outboundStreamProtocolNegotiationTimeout??vl,this.events=e.events,this.metrics={dials:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total")}}[Symbol.toStringTag]="@libp2p/upgrader";async shouldBlockConnection(e,...t){const n=this.components.connectionGater[e];if(n==null)return;if(await n.apply(this.components.connectionGater,t)===!0)throw new g1(`The multiaddr connection is blocked by gater.${e}`)}createInboundAbortSignal(e){return $t([AbortSignal.timeout(this.inboundUpgradeTimeout),e])}async upgradeInbound(e,t){let n=!1;const s=this.createInboundAbortSignal(t.signal);try{if(this.metrics.dials?.increment({inbound:!0}),n=await this.components.connectionManager.acceptIncomingConnection(e),!n)throw new m1("Connection denied");await this.shouldBlockConnection("denyInboundConnection",e),await this._performUpgrade(e,"inbound",{...t,signal:s})}catch(i){throw this.metrics.errors?.increment({inbound:!0}),i}finally{s.clear(),n&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t){try{this.metrics.dials?.increment({outbound:!0});const n=e.remoteAddr.getPeerId();let s;n!=null&&(s=pt(n),await this.shouldBlockConnection("denyOutboundConnection",s,e));let i="outbound";return t.initiator===!1&&(i="inbound"),await this._performUpgrade(e,i,t)}catch(n){throw this.metrics.errors?.increment({outbound:!0}),n}}async _performUpgrade(e,t,n){let s,i,o,a,c;this.components.metrics?.trackMultiaddrConnection(e),e.log.trace("starting the %s connection upgrade",t);let l=e;if(n?.skipProtection!==!0){const u=this.components.connectionProtector;u!=null&&(e.log("protecting the %s connection",t),l=await u.protect(e,n))}try{if(s=l,n?.skipEncryption!==!0){n?.onProgress?.(new ie(`upgrader:encrypt-${t}-connection`)),{conn:s,remotePeer:i,protocol:c,streamMuxer:a}=await(t==="inbound"?this._encryptInbound(l,n):this._encryptOutbound(l,n));const u={...l,...s};await this.shouldBlockConnection(t==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",i,u)}else{const u=e.remoteAddr.getPeerId();if(u==null)throw new ko(`${t} connection that skipped encryption must have a peer id`);const d=pt(u);c="native",i=d}if(i.equals(this.components.peerId)){const u=new Bl("Can not dial self");throw e.abort(u),u}if(o=s,n?.muxerFactory!=null)a=n.muxerFactory;else if(a==null&&this.streamMuxers.size>0){n?.onProgress?.(new ie(`upgrader:multiplex-${t}-connection`));const u=await(t==="inbound"?this._multiplexInbound({...l,...s},this.streamMuxers,n):this._multiplexOutbound({...l,...s},this.streamMuxers,n));a=u.muxerFactory,o=u.stream}}catch(u){throw e.log.error("failed to upgrade inbound connection %s %a - %e",t==="inbound"?"from":"to",e.remoteAddr,u),u}return await this.shouldBlockConnection(t==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",i,e),e.log("successfully upgraded %s connection",t),this._createConnection({cryptoProtocol:c,direction:t,maConn:e,upgradedConn:o,muxerFactory:a,remotePeer:i,limits:n?.limits})}_createConnection(e){const{cryptoProtocol:t,direction:n,maConn:s,upgradedConn:i,remotePeer:o,muxerFactory:a,limits:c}=e;let l,u,d;a!=null&&(l=a.createStreamMuxer({direction:n,onIncomingStream:f=>{d!=null&&Promise.resolve().then(async()=>{const g=this.components.registrar.getProtocols(),m=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout),{stream:v,protocol:k}=await Bi(f,g,{signal:m,log:f.log,yieldBytes:!1});if(d==null)return;d.log("incoming stream opened on %s",k);const b=FS(k,this.components.registrar);if(kl(k,"inbound",d)===b){const E=new Kh(`Too many inbound protocol streams for protocol "${k}" - limit ${b}`);throw f.abort(E),E}f.source=v.source,f.sink=v.sink,f.protocol=k,v.closeWrite!=null&&(f.closeWrite=v.closeWrite),v.closeRead!=null&&(f.closeRead=v.closeRead),v.close!=null&&(f.close=v.close),await this.components.peerStore.merge(o,{protocols:[k]}),this.components.metrics?.trackProtocolStream(f,d),this._onStream({connection:d,stream:f,protocol:k})}).catch(async g=>{d.log.error("error handling incoming stream id %s - %e",f.id,g),f.timeline.close==null&&await f.close()})}}),u=async(f,g={})=>{if(l==null)throw new Wn("Connection is not multiplexed");d.log.trace("starting new stream for protocols %s",f);const m=await l.newStream();d.log.trace("started new stream %s for protocols %s",m.id,f);try{if(g.signal==null){m.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",f);const E=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);g={...g,signal:E}}m.log.trace("selecting protocol from protocols %s",f);const{stream:v,protocol:k}=await Ui(m,f,{...g,log:m.log,yieldBytes:!0});m.log.trace("selected protocol %s",k);const b=US(k,this.components.registrar,g),w=kl(k,"outbound",d);if(w>=b){const E=new zl(`Too many outbound protocol streams for protocol "${k}" - ${w}/${b}`);throw m.abort(E),E}return await this.components.peerStore.merge(o,{protocols:[k]}),m.source=v.source,m.sink=v.sink,m.protocol=k,v.closeWrite!=null&&(m.closeWrite=v.closeWrite),v.closeRead!=null&&(m.closeRead=v.closeRead),v.close!=null&&(m.close=v.close),this.components.metrics?.trackProtocolStream(m,d),m}catch(v){throw d.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",n==="inbound"?"from":"to",e.maConn.remoteAddr,f,v),m.timeline.close==null&&m.abort(v),v}},Promise.all([l.sink(i.source),i.sink(l.source)]).catch(f=>{d.log.error("error piping data through muxer - %e",f)}));const h=s.timeline;s.timeline=new Proxy(h,{set:(...f)=>(f[1]==="close"&&f[2]!=null&&h.close==null&&(async()=>{try{d.status==="open"&&await d.close()}catch(g){d.log.error("error closing connection after timeline close %e",g)}finally{this.events.safeDispatchEvent("connection:close",{detail:d})}})().catch(g=>{d.log.error("error thrown while dispatching connection:close event %e",g)}),Reflect.set(...f))}),s.timeline.upgraded=Date.now();const p=()=>{throw new Wn("Connection is not multiplexed")};return d=NS({remoteAddr:s.remoteAddr,remotePeer:o,status:"open",direction:n,timeline:s.timeline,multiplexer:l?.protocol,encryption:t,limits:c,logger:this.components.logger,newStream:u??p,getStreams:()=>l?.streams??[],close:async f=>{await l?.close(f),await s.close(f)},abort:f=>{s.abort(f),l?.abort(f)}}),this.events.safeDispatchEvent("connection:open",{detail:d}),d.__maConnTimeline=h,d}_onStream(e){const{connection:t,stream:n,protocol:s}=e,{handler:i,options:o}=this.components.registrar.getHandler(s);if(t.limits!=null&&o.runOnLimitedConnection!==!0)throw new $l("Cannot open protocol stream on limited connection");i({connection:t,stream:n})}async _encryptInbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{const{stream:s,protocol:i}=await Bi(e,n,{...t,log:e.log}),o=this.connectionEncrypters.get(i);if(o==null)throw new Vn(`no crypto module found for ${i}`);return e.log("encrypting inbound connection to %a using %s",e.remoteAddr,i),{...await o.secureInbound(s,t),protocol:i}}catch(s){throw e.log.error("encrypting inbound connection from %a failed",e.remoteAddr,s),new Vn(s.message)}}async _encryptOutbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{e.log.trace("selecting encrypter from %s",n);const{stream:s,protocol:i}=await Ui(e,n,{...t,log:e.log,yieldBytes:!0}),o=this.connectionEncrypters.get(i);if(o==null)throw new Vn(`no crypto module found for ${i}`);return e.log("encrypting outbound connection to %a using %s",e.remoteAddr,i),{...await o.secureOutbound(s,t),protocol:i}}catch(s){throw e.log.error("encrypting outbound connection to %a failed",e.remoteAddr,s),new Vn(s.message)}}async _multiplexOutbound(e,t,n){const s=Array.from(t.keys());e.log("outbound selecting muxer %s",s);try{e.log.trace("selecting stream muxer from %s",s);const{stream:i,protocol:o}=await Ui(e,s,{...n,log:e.log,yieldBytes:!0});e.log("selected %s as muxer protocol",o);const a=t.get(o);return{stream:i,muxerFactory:a}}catch(i){throw e.log.error("error multiplexing outbound connection",i),new Wn(String(i))}}async _multiplexInbound(e,t,n){const s=Array.from(t.keys());e.log("inbound handling muxers %s",s);try{const{stream:i,protocol:o}=await Bi(e,s,{...n,log:e.log}),a=t.get(o);return{stream:i,muxerFactory:a}}catch(i){throw e.log.error("error multiplexing inbound connection",i),new Wn(String(i))}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}const Th="2.8.8",kh="js-libp2p";function $S(r,e){return`${r??kh}/${e??Th} browser/${globalThis.navigator.userAgent}`}class zS extends Ut{peerId;peerStore;contentRouting;peerRouting;metrics;services;logger;status;components;log;constructor(e){super(),this.status="stopped";const t=new Ut,n=t.dispatchEvent.bind(t);t.dispatchEvent=l=>{const u=n(l),d=this.dispatchEvent(new CustomEvent(l.type,{detail:l.detail}));return u||d},this.peerId=e.peerId,this.logger=e.logger??dh(),this.log=this.logger.forComponent("libp2p"),this.services={};const s=e.nodeInfo?.name??kh,i=e.nodeInfo?.version??Th,o=this.components=E1({peerId:e.peerId,privateKey:e.privateKey,nodeInfo:{name:s,version:i,userAgent:e.nodeInfo?.userAgent??$S(s,i)},logger:this.logger,events:t,datastore:e.datastore??new NE,connectionGater:k1(e.connectionGater),dns:e.dns});this.peerStore=this.configureComponent("peerStore",LE(o,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),e.metrics!=null&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),o.events.addEventListener("peer:update",l=>{if(l.detail.previous==null){const u={id:l.detail.peer.id,multiaddrs:l.detail.peer.addresses.map(d=>d.multiaddr)};o.events.safeDispatchEvent("peer:discovery",{detail:u})}}),e.connectionProtector!=null&&this.configureComponent("connectionProtector",e.connectionProtector(o)),this.components.upgrader=new BS(this.components,{connectionEncrypters:(e.connectionEncrypters??[]).map((l,u)=>this.configureComponent(`connection-encryption-${u}`,l(this.components))),streamMuxers:(e.streamMuxers??[]).map((l,u)=>this.configureComponent(`stream-muxers-${u}`,l(this.components))),inboundUpgradeTimeout:e.connectionManager?.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:e.connectionManager?.inboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:e.connectionManager?.outboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout}),this.configureComponent("transportManager",new _S(this.components,e.transportManager)),this.configureComponent("connectionManager",new hS(this.components,e.connectionManager)),e.connectionMonitor?.enabled!==!1&&this.configureComponent("connectionMonitor",new SS(this.components,e.connectionMonitor)),this.configureComponent("registrar",new IS(this.components)),this.configureComponent("addressManager",new o1(this.components,e.addresses));const a=(e.peerRouters??[]).map((l,u)=>this.configureComponent(`peer-router-${u}`,l(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new AS(this.components,{routers:a}));const c=(e.contentRouters??[]).map((l,u)=>this.configureComponent(`content-router-${u}`,l(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new xS(this.components,{routers:c})),this.configureComponent("randomWalk",new CS(this.components)),(e.peerDiscovery??[]).forEach((l,u)=>{this.configureComponent(`peer-discovery-${u}`,l(this.components)).addEventListener("peer",h=>{this.#e(h)})}),e.transports?.forEach((l,u)=>{this.components.transportManager.add(this.configureComponent(`transport-${u}`,l(this.components)))}),e.services!=null)for(const l of Object.keys(e.services)){const u=e.services[l],d=u(this.components);if(d==null){this.log.error("service factory %s returned null or undefined instance",l);continue}this.services[l]=d,this.configureComponent(l,d),d[ga]!=null&&(this.log("registering service %s for content routing",l),c.push(d[ga])),d[ya]!=null&&(this.log("registering service %s for peer routing",l),a.push(d[ya])),d[ma]!=null&&(this.log("registering service %s for peer discovery",l),d[ma].addEventListener?.("peer",h=>{this.#e(h)}))}S1(o)}configureComponent(e,t){return t==null&&this.log.error("component %s was null or undefined",e),this.components[e]=t,t}async start(){if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await this.components.beforeStart?.(),await this.components.start(),await this.components.afterStart?.(),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started")}catch(e){throw this.log.error("An error occurred starting libp2p",e),this.status="started",await this.stop(),e}}}async stop(){this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await this.components.beforeStop?.(),await this.components.stop(),await this.components.afterStop?.(),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new fr;for(const t of this.components.connectionManager.getConnections())e.add(t.remotePeer);return Array.from(e)}async dial(e,t={}){return this.components.connectionManager.openConnection(e,{priority:75,...t})}async dialProtocol(e,t,n={}){if(t==null)throw new V("no protocols were provided to open a stream");if(t=Array.isArray(t)?t:[t],t.length===0)throw new V("no protocols were provided to open a stream");return(await this.dial(e,n)).newStream(t,n)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e,t={}){zs(e)&&(e=pt(e.getPeerId()??"")),await this.components.connectionManager.closeConnections(e,t)}async getPublicKey(e,t={}){if(this.log("getPublicKey %p",e),e.publicKey!=null)return e.publicKey;try{const o=await this.peerStore.get(e);if(o.id.publicKey!=null)return o.id.publicKey}catch(o){if(o.name!=="NotFoundError")throw o}const n=ot([q("/pk/"),e.toMultihash().bytes]),s=await this.contentRouting.get(n,t),i=Bt(s);return await this.peerStore.patch(e,{publicKey:i}),i}async handle(e,t,n){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async s=>{await this.components.registrar.handle(s,t,n)}))}async unhandle(e){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async t=>{await this.components.registrar.unhandle(t)}))}async register(e,t){return this.components.registrar.register(e,t)}unregister(e){this.components.registrar.unregister(e)}async isDialable(e,t={}){return this.components.connectionManager.isDialable(e,t)}#e(e){const{detail:t}=e;if(t.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(t.id,{multiaddrs:t.multiaddrs}).catch(n=>{this.log.error(n)})}}async function KS(r={}){r.privateKey??=await Am();const e=new zS({...await Vv(r),peerId:_m(r.privateKey)});return r.start!==!1&&await e.start(),e}var Gn={exports:{}},_l;function qS(){return _l||(_l=1,function(r,e){var t=globalThis.require&&e||{};(function(n,s){let i=globalThis.crypto;s._sep=/[\s,:-]+/,s._mword="mnemonic",s._normalize=function(o){return o.normalize("NFKD").trim().toLowerCase()},s.generate=async function(o=128){let a=o/8,c=i.getRandomValues(new Uint8Array(a));return await s.encode(c)},s.encode=async function(o){let a=8*o.length,c=a/32;o=new Uint8Array(o);let l=await i.subtle.digest("SHA-256",o),u=new Uint8Array(l),d="";o.forEach(function(v){let k=v.toString(2).padStart(8,"0");d+=k});let p=u[0].toString(2);p=p.padStart(8,"0");let f=p.slice(0,c);d+=f;let g=[];for(let v=0;v<a+c;v+=11){let k=parseInt(d.slice(v,v+11).padStart(8,"0"),2);g.push(k)}return g.map(function(v){return s.base2048[v]}).join(" ")},s.verify=async function(o){return await s.decode(o),!0},s.checksum=s.verify,s.decode=async function(o,a){o=s._normalize(o);let c=[];o.split(s._sep).forEach(function(b){let w=s.base2048.indexOf(b);if(w<0){let E=new Error(`dashphrase.js: decode failed: unknown word '${b}'`);throw E.code="E_UNKNOWN_WORD",E}c.push(w)});let u=c.map(function(b){return b.toString(2).padStart(11,"0")}).join(""),d=Math.floor(u.length/32),h=u.length-d,p=u.slice(-d),f=[];for(let b=0;b<h;b+=8){let w=u.slice(b,b+8),E=parseInt(w,2);E>=0&&f.push(E)}let g=Uint8Array.from(f),m=await i.subtle.digest("SHA-256",g),k=new Uint8Array(m)[0].toString(2).padStart(8,"0").slice(0,d);if(k!==p&&a?.verify!==!1){let b=new Error(`dashphrase.js: bad checksum: expected '${k}' but got '${p}'`);throw b.code="E_BAD_CHECKSUM",b}return g},s.toSeed=async function(o,a="",c={}){c.verify!==!1&&await s.verify(o),o=s._normalize(o),a=a.normalize("NFKD");let u=new TextEncoder().encode(o),d=new TextEncoder().encode(s._mword+a),g=await s._pbkdf2(u,d,2048,512,"SHA-512");return new Uint8Array(g)},s.pbkdf2=s.toSeed,s._pbkdf2=async function(a,c,l,u,d){let h=!1,p=await i.subtle.importKey("raw",a,{name:"PBKDF2"},h,["deriveKey"]);h=!0;let f=await i.subtle.deriveKey({name:"PBKDF2",salt:c,iterations:l,hash:d},p,{name:"HMAC",hash:d,length:u},h,["sign","verify"]),g=await i.subtle.exportKey("raw",f);return new Uint8Array(g)},s._sha256=async function(o,a=""){o=s._normalize(o),a=a.normalize("NFKD");let c=new TextEncoder().encode(o),l=new TextEncoder().encode(a),u=new Uint8Array(c.length+l.length),d=0;for(let p=0;p<c.length;p+=1)u[d]=c[p],d+=1;for(let p=0;p<l.length;p+=1)u[d]=l[p],d+=1;let h=await i.subtle.digest("SHA-256",u);return new Uint8Array(h)},s.CATMONIC="cat swing flag economy stadium alone churn speed unique patch report train",s.ZOOMONIC="zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",s.ZECRET="TREZOR",s.ZEED="ac27495480225222079d7be181583751e86f571027b0497b5b5d11218e0a8a13332572917f0f8e5a589620c6f15b11c61dee327651a14c34e18231052e48c069",s.base2048="abandon ability able about above absent absorb abstract absurd abuse access accident account accuse achieve acid acoustic acquire across act action actor actress actual adapt add addict address adjust admit adult advance advice aerobic affair afford afraid again age agent agree ahead aim air airport aisle alarm album alcohol alert alien all alley allow almost alone alpha already also alter always amateur amazing among amount amused analyst anchor ancient anger angle angry animal ankle announce annual another answer antenna antique anxiety any apart apology appear apple approve april arch arctic area arena argue arm armed armor army around arrange arrest arrive arrow art artefact artist artwork ask aspect assault asset assist assume asthma athlete atom attack attend attitude attract auction audit august aunt author auto autumn average avocado avoid awake aware away awesome awful awkward axis baby bachelor bacon badge bag balance balcony ball bamboo banana banner bar barely bargain barrel base basic basket battle beach bean beauty because become beef before begin behave behind believe below belt bench benefit best betray better between beyond bicycle bid bike bind biology bird birth bitter black blade blame blanket blast bleak bless blind blood blossom blouse blue blur blush board boat body boil bomb bone bonus book boost border boring borrow boss bottom bounce box boy bracket brain brand brass brave bread breeze brick bridge brief bright bring brisk broccoli broken bronze broom brother brown brush bubble buddy budget buffalo build bulb bulk bullet bundle bunker burden burger burst bus business busy butter buyer buzz cabbage cabin cable cactus cage cake call calm camera camp can canal cancel candy cannon canoe canvas canyon capable capital captain car carbon card cargo carpet carry cart case cash casino castle casual cat catalog catch category cattle caught cause caution cave ceiling celery cement census century cereal certain chair chalk champion change chaos chapter charge chase chat cheap check cheese chef cherry chest chicken chief child chimney choice choose chronic chuckle chunk churn cigar cinnamon circle citizen city civil claim clap clarify claw clay clean clerk clever click client cliff climb clinic clip clock clog close cloth cloud clown club clump cluster clutch coach coast coconut code coffee coil coin collect color column combine come comfort comic common company concert conduct confirm congress connect consider control convince cook cool copper copy coral core corn correct cost cotton couch country couple course cousin cover coyote crack cradle craft cram crane crash crater crawl crazy cream credit creek crew cricket crime crisp critic crop cross crouch crowd crucial cruel cruise crumble crunch crush cry crystal cube culture cup cupboard curious current curtain curve cushion custom cute cycle dad damage damp dance danger daring dash daughter dawn day deal debate debris decade december decide decline decorate decrease deer defense define defy degree delay deliver demand demise denial dentist deny depart depend deposit depth deputy derive describe desert design desk despair destroy detail detect develop device devote diagram dial diamond diary dice diesel diet differ digital dignity dilemma dinner dinosaur direct dirt disagree discover disease dish dismiss disorder display distance divert divide divorce dizzy doctor document dog doll dolphin domain donate donkey donor door dose double dove draft dragon drama drastic draw dream dress drift drill drink drip drive drop drum dry duck dumb dune during dust dutch duty dwarf dynamic eager eagle early earn earth easily east easy echo ecology economy edge edit educate effort egg eight either elbow elder electric elegant element elephant elevator elite else embark embody embrace emerge emotion employ empower empty enable enact end endless endorse enemy energy enforce engage engine enhance enjoy enlist enough enrich enroll ensure enter entire entry envelope episode equal equip era erase erode erosion error erupt escape essay essence estate eternal ethics evidence evil evoke evolve exact example excess exchange excite exclude excuse execute exercise exhaust exhibit exile exist exit exotic expand expect expire explain expose express extend extra eye eyebrow fabric face faculty fade faint faith fall false fame family famous fan fancy fantasy farm fashion fat fatal father fatigue fault favorite feature february federal fee feed feel female fence festival fetch fever few fiber fiction field figure file film filter final find fine finger finish fire firm first fiscal fish fit fitness fix flag flame flash flat flavor flee flight flip float flock floor flower fluid flush fly foam focus fog foil fold follow food foot force forest forget fork fortune forum forward fossil foster found fox fragile frame frequent fresh friend fringe frog front frost frown frozen fruit fuel fun funny furnace fury future gadget gain galaxy gallery game gap garage garbage garden garlic garment gas gasp gate gather gauge gaze general genius genre gentle genuine gesture ghost giant gift giggle ginger giraffe girl give glad glance glare glass glide glimpse globe gloom glory glove glow glue goat goddess gold good goose gorilla gospel gossip govern gown grab grace grain grant grape grass gravity great green grid grief grit grocery group grow grunt guard guess guide guilt guitar gun gym habit hair half hammer hamster hand happy harbor hard harsh harvest hat have hawk hazard head health heart heavy hedgehog height hello helmet help hen hero hidden high hill hint hip hire history hobby hockey hold hole holiday hollow home honey hood hope horn horror horse hospital host hotel hour hover hub huge human humble humor hundred hungry hunt hurdle hurry hurt husband hybrid ice icon idea identify idle ignore ill illegal illness image imitate immense immune impact impose improve impulse inch include income increase index indicate indoor industry infant inflict inform inhale inherit initial inject injury inmate inner innocent input inquiry insane insect inside inspire install intact interest into invest invite involve iron island isolate issue item ivory jacket jaguar jar jazz jealous jeans jelly jewel job join joke journey joy judge juice jump jungle junior junk just kangaroo keen keep ketchup key kick kid kidney kind kingdom kiss kit kitchen kite kitten kiwi knee knife knock know lab label labor ladder lady lake lamp language laptop large later latin laugh laundry lava law lawn lawsuit layer lazy leader leaf learn leave lecture left leg legal legend leisure lemon lend length lens leopard lesson letter level liar liberty library license life lift light like limb limit link lion liquid list little live lizard load loan lobster local lock logic lonely long loop lottery loud lounge love loyal lucky luggage lumber lunar lunch luxury lyrics machine mad magic magnet maid mail main major make mammal man manage mandate mango mansion manual maple marble march margin marine market marriage mask mass master match material math matrix matter maximum maze meadow mean measure meat mechanic medal media melody melt member memory mention menu mercy merge merit merry mesh message metal method middle midnight milk million mimic mind minimum minor minute miracle mirror misery miss mistake mix mixed mixture mobile model modify mom moment monitor monkey monster month moon moral more morning mosquito mother motion motor mountain mouse move movie much muffin mule multiply muscle museum mushroom music must mutual myself mystery myth naive name napkin narrow nasty nation nature near neck need negative neglect neither nephew nerve nest net network neutral never news next nice night noble noise nominee noodle normal north nose notable note nothing notice novel now nuclear number nurse nut oak obey object oblige obscure observe obtain obvious occur ocean october odor off offer office often oil okay old olive olympic omit once one onion online only open opera opinion oppose option orange orbit orchard order ordinary organ orient original orphan ostrich other outdoor outer output outside oval oven over own owner oxygen oyster ozone pact paddle page pair palace palm panda panel panic panther paper parade parent park parrot party pass patch path patient patrol pattern pause pave payment peace peanut pear peasant pelican pen penalty pencil people pepper perfect permit person pet phone photo phrase physical piano picnic picture piece pig pigeon pill pilot pink pioneer pipe pistol pitch pizza place planet plastic plate play please pledge pluck plug plunge poem poet point polar pole police pond pony pool popular portion position possible post potato pottery poverty powder power practice praise predict prefer prepare present pretty prevent price pride primary print priority prison private prize problem process produce profit program project promote proof property prosper protect proud provide public pudding pull pulp pulse pumpkin punch pupil puppy purchase purity purpose purse push put puzzle pyramid quality quantum quarter question quick quit quiz quote rabbit raccoon race rack radar radio rail rain raise rally ramp ranch random range rapid rare rate rather raven raw razor ready real reason rebel rebuild recall receive recipe record recycle reduce reflect reform refuse region regret regular reject relax release relief rely remain remember remind remove render renew rent reopen repair repeat replace report require rescue resemble resist resource response result retire retreat return reunion reveal review reward rhythm rib ribbon rice rich ride ridge rifle right rigid ring riot ripple risk ritual rival river road roast robot robust rocket romance roof rookie room rose rotate rough round route royal rubber rude rug rule run runway rural sad saddle sadness safe sail salad salmon salon salt salute same sample sand satisfy satoshi sauce sausage save say scale scan scare scatter scene scheme school science scissors scorpion scout scrap screen script scrub sea search season seat second secret section security seed seek segment select sell seminar senior sense sentence series service session settle setup seven shadow shaft shallow share shed shell sheriff shield shift shine ship shiver shock shoe shoot shop short shoulder shove shrimp shrug shuffle shy sibling sick side siege sight sign silent silk silly silver similar simple since sing siren sister situate six size skate sketch ski skill skin skirt skull slab slam sleep slender slice slide slight slim slogan slot slow slush small smart smile smoke smooth snack snake snap sniff snow soap soccer social sock soda soft solar soldier solid solution solve someone song soon sorry sort soul sound soup source south space spare spatial spawn speak special speed spell spend sphere spice spider spike spin spirit split spoil sponsor spoon sport spot spray spread spring spy square squeeze squirrel stable stadium staff stage stairs stamp stand start state stay steak steel stem step stereo stick still sting stock stomach stone stool story stove strategy street strike strong struggle student stuff stumble style subject submit subway success such sudden suffer sugar suggest suit summer sun sunny sunset super supply supreme sure surface surge surprise surround survey suspect sustain swallow swamp swap swarm swear sweet swift swim swing switch sword symbol symptom syrup system table tackle tag tail talent talk tank tape target task taste tattoo taxi teach team tell ten tenant tennis tent term test text thank that theme then theory there they thing this thought three thrive throw thumb thunder ticket tide tiger tilt timber time tiny tip tired tissue title toast tobacco today toddler toe together toilet token tomato tomorrow tone tongue tonight tool tooth top topic topple torch tornado tortoise toss total tourist toward tower town toy track trade traffic tragic train transfer trap trash travel tray treat tree trend trial tribe trick trigger trim trip trophy trouble truck true truly trumpet trust truth try tube tuition tumble tuna tunnel turkey turn turtle twelve twenty twice twin twist two type typical ugly umbrella unable unaware uncle uncover under undo unfair unfold unhappy uniform unique unit universe unknown unlock until unusual unveil update upgrade uphold upon upper upset urban urge usage use used useful useless usual utility vacant vacuum vague valid valley valve van vanish vapor various vast vault vehicle velvet vendor venture venue verb verify version very vessel veteran viable vibrant vicious victory video view village vintage violin virtual virus visa visit visual vital vivid vocal voice void volcano volume vote voyage wage wagon wait walk wall walnut want warfare warm warrior wash wasp waste water wave way wealth weapon wear weasel weather web wedding weekend weird welcome west wet whale what wheat wheel when where whip whisper wide width wife wild will win window wine wing wink winner winter wire wisdom wise wish witness wolf woman wonder wood wool word work world worry worth wrap wreck wrestle wrist write wrong yard year yellow you young youth zebra zero zone zoo".normalize("NFKD").split(" "),n.DashPhrase=s})(globalThis.window||{},t),r.exports=t}(Gn,Gn.exports)),Gn.exports}var WS=qS();const VS=Gs(WS),HS=document.getElementById("output"),Ge=document.getElementById("outputSend"),Dt=document.getElementById("outputReceive"),F=(r,e)=>{console.log(r)};let $i=[];const Ms="/dns4/relay.smp46.me/tcp/443/tls/ws/p2p/12D3KooWPUXghsjtba2yaKbxJAPUpCgZ1UzciEdCPzohBQi7wiPg",_h="https://exchange.smp46.me";let Pe,zi=null;const Pl="/fileferry/filetransfer/1.0.0";let Qr="",Me=null,ve=null,yt=null,Ll=new Map,Et=!1,qt=!1,Kr=!1;function GS(r,e=3e4){return new Promise((t,n)=>{let s;const i=()=>{const c=r.getMultiaddrs().find(l=>l.toString().includes("/p2p-circuit"));c&&(r.removeEventListener("self:peer:update",i),clearTimeout(s),t(c))},o=r.getMultiaddrs().find(a=>a.toString().includes("/p2p-circuit"));if(o){t(o);return}s=setTimeout(()=>{r.removeEventListener("self:peer:update",i),n(new Error("Timeout: Could not obtain a circuit address via relay."))},e),r.addEventListener("self:peer:update",i)})}async function YS(){const r="https://raw.githubusercontent.com/pradt2/always-online-stun/master/geoip_cache.txt",e="https://raw.githubusercontent.com/pradt2/always-online-stun/master/valid_hosts.txt",t="https://ip-api.com/json/",n="userGeoData";let i;try{const o=await(await fetch(r)).json(),a=localStorage.getItem(n);if(a){const p=JSON.parse(a);p.expiry&&p.expiry>Date.now()?(i=p.data,F("Using cached user geo data.")):(localStorage.removeItem(n),F("User geo cache expired or invalid."))}if(!i){F("Fetching user geo data from API.");const p=await fetch(t);if(!p.ok)throw new Error(`Failed to fetch user geo data: ${p.status} ${p.statusText}`);i=await p.json();const f={data:i,expiry:Date.now()+1728e5};localStorage.setItem(n,JSON.stringify(f)),F("User geo data fetched and cached.")}const c=i.lat,l=i.lon,h=(await(await fetch(e)).text()).trim().split(`
`).map(p=>{const f=p.split(":")[0];if(!o[f])return[p,1/0];const[g,m]=o[f];if(typeof g!="number"||typeof m!="number")return[p,1/0];const v=((c-g)**2+(l-m)**2)**.5;return[p,v]}).reduce(([p,f],[g,m])=>f<=m?[p,f]:[g,m])[0];return F("Closest STUN server found: "+h,HS),h}catch{F("Error in getClosestStunServer:"),localStorage.removeItem(n);return}}async function XS(r,e,t=1024*1024){try{const n=JSON.stringify({name:e.name,size:e.size,type:e.type||"application/octet-stream"}),s=new TextEncoder().encode(n+`
`);let i=0;async function*o(){yield new Z(s);for(let a=0;a<e.size;a+=t){const c=e.slice(a,Math.min(a+t,e.size)),l=new Uint8Array(await c.arrayBuffer());yield new Z(l),i+=l.length;const u=(i/e.size*100).toFixed(1);F(`Progress: ${u}% (${i}/${e.size} bytes)`,Ge)}}return await r.sink(o()),await r.close(),F("File sent completely.",Ge),!0}catch(n){F(`Error sending file: ${n.message}`);try{await r.abort(n)}catch(s){F(`Error aborting stream: ${s.message}`)}throw n}}async function QS(){let r="";const e=await YS().catch(n=>{F("Could not fetch closest STUN server: "+n.message)}),t=e!=null?`stun:${e}`:"stun:l.google.com:19302";Pe=await KS({addresses:{listen:["/p2p-circuit","/webrtc"]},transports:[bv({filter:rh}),tv({rtcConfiguration:{iceServers:[{urls:t},{urls:"turn:relay.smp46.me:3478?transport=udp",username:"ferryCaptain",credential:"i^YV13eTPOHdVzWm#2t5"},{urls:"turn:relay.smp46.me:3478?transport=tcp",username:"ferryCaptain",credential:"i^YV13eTPOHdVzWm#2t5"}]}}),Nb({discoverRelays:0})],connectionEncrypters:[By()],streamMuxers:[aw()],connectionGater:{denyDialMultiaddr:()=>!1},services:{identify:l0(),identifyPush:u0(),ping:w0()},connectionManager:{maxConnections:1/0,minConnections:0,pollInterval:5e3}}),await Pe.start(),F(`Node started with Peer ID: ${Pe.peerId.toString()}`),$i=Pe.getMultiaddrs().map(n=>n.toString()),F("My addresses:"),$i.forEach(n=>F(`  - ${n}`));try{zi=X(Ms).getPeerId()}catch(n){F(`Warning: Could not parse Peer ID from VITE_RELAY_MADDR: ${Ms}.`),console.warn("Error parsing relay PeerID:",n)}Pe.addEventListener("connection:open",async n=>{const s=n.detail,i=s.remotePeer,o=i.toString(),a=s.remoteAddr.toString(),c=Et?Ge:Dt;let l="";if(F(`Connection OPENED with: ${o} on ${a}`),Ll.set(o,s),o===zi){if(F("INFO: Connection to the relay server confirmed."),Et&&!ve)try{const u=await GS(Pe);F(`Obtained listen address: ${u.toString()}`,Ge),F(`Registering passphrase '${Qr}'...`,Ge);const d=`${_h}/phrase`,h=await fetch(d,{method:"POST",body:JSON.stringify({Maddr:u.toString(),Phrase:Qr}),headers:{"Content-type":"application/json; charset=UTF-8"}});if(h.ok)F("Passphrase registered. Waiting for peer to connect...",Ge);else{const p=await`Failed to register passphrase. Status: ${h.status}. Error: ${await h.text()}`;F(p,Ge),l=p,Et=!1}}catch(u){const d=`Error during sender setup after relay connect: ${u.message}`;F(d),l=d,Et=!1}l!=""&&(Dl(l),l="");return}if(!ve||ve.toString()!==o?(F(`Peer connected: ${o}. Old activePeerId: ${ve?.toString()}`),ve=i):F(`Re-established or additional connection to existing peer: ${o}`),Et&&ve&&ve.toString()===o&&Me&&!Kr)if(a.includes("/webrtc")&&!a.includes("/p2p-circuit")){F(`Sender: Direct WebRTC connection to Peer ${ve.toString()} active. Attempting file transfer.`);try{document.getElementById("fileInfoArea").style.display="none",document.getElementById("loadingIndicator").style.display="block";const u=await Pe.services.ping.ping(ve);F("Successfully pinged peer: "+ve.toString()+" with RTT: "+u+"ms",c);const d=await Pe.dialProtocol(ve,Pl,{signal:AbortSignal.timeout(3e4)});yt=d,F("File transfer stream opened to peer (via WebRTC).",Ge),F(`Sending file '${Me.name}' (${Me.size} bytes)...`,Ge),Kr=!0,await XS(d,Me),F("File sent completely.",Ge),Me=null,yt=null,Kr=!1,Et=!1,document.getElementById("loadingIndicator").style.display="none",document.getElementById("completionMessage").style.display="block"}catch(u){l=`File transfer failed: ${u.message}`,F(l),yt=null,Kr=!1,document.getElementById("loadingIndicator").style.display="none",document.getElementById("errorMessage").style.display="block"}}else a.includes("/p2p-circuit")?F(`Sender: Relayed connection to Peer ${ve.toString()} established (${a}). Waiting for potential direct WebRTC upgrade before transferring.`):F(`Sender: Peer connection via other transport (${a}). File transfer logic currently prioritizes direct WebRTC.`);else qt&&ve&&ve.toString()===o&&F(`Receiver: Connected to sender peer (${a}). Waiting for incoming file stream.`);l!=""&&(Dl(l),l="")}),Pe.addEventListener("connection:close",n=>{const s=n.detail.remotePeer.toString();F(`Connection CLOSED with: ${s}`),Ll.delete(s),ve&&s===ve.toString()&&!Kr?(F("Active peer connection closed."),ve=null,yt=null):s===zi&&F("Connection to relay closed.")}),Pe.addEventListener("self:peer:update",()=>{$i=Pe.getMultiaddrs().map(n=>n.toString())}),Pe.handle(Pl,async({stream:n,connection:s})=>{const i=Dt;F(`Incoming file transfer stream from ${s.remotePeer.toString()}`),yt&&yt!==n&&F("Warning: A new stream is replacing an existing activeStream in receiver."),yt=n,ve=s.remotePeer;let o=[],a="downloaded_file",c=0,l="application/octet-stream",u=!1,d=0;try{for await(const h of yt.source){if(!h||h.length===0){F("Received an empty or null chunk.",i);continue}const p=h.subarray();if(u)o.push(p),d+=p.length,F(`Received ${d} bytes... (Expected: ${c>0?c:"N/A"})`,i);else{let f="",g=0;try{const m=new TextDecoder("utf-8",{fatal:!1}).decode(p),v=m.indexOf(`
`);if(v!==-1){f=m.substring(0,v),g=new TextEncoder().encode(f+`
`).byteLength;try{const b=JSON.parse(f);a=b.name||a,c=b.size||c,l=b.type||l,F(`Receiving file: ${a} (Size: ${c} bytes, Type: ${l})`,i),u=!0}catch(b){F(`Could not parse file header JSON: "${f}". Error: ${b.message}. Treating chunk as data.`,i),u=!0,g=0}}else F("No newline for header in this chunk. Assuming no header or all data.",i),u=!0,g=0}catch(m){F(`Error decoding chunk for header: ${m.message}. Treating as raw data.`,i),u=!0,g=0}if(g<p.byteLength){const m=p.subarray(g);m.length>0&&(o.push(m),d+=m.length,F(`Received ${d} bytes (from first chunk's body)...`,i))}}}if(F(`File stream source ended. Total bytes received in buffer: ${d}`,i),d>0){const h=new Blob(o,{type:l}),p=URL.createObjectURL(h),f=document.createElement("a");f.href=p,f.download=a;const g=`${(d/1024/1024).toFixed(2)}`;f.textContent=`Download ${g} MB)`,f.style.display="hidden",document.getElementById("receivingLoadingIndicator").style.display="none",document.getElementById("receivedFileName").innerText=a,document.getElementById("receivedFileSize").innerText=`${g} MB`,document.getElementById("downloadReadyMessage").style.display="block",document.body.appendChild(f),f.click(),document.body.removeChild(f),setTimeout(()=>URL.revokeObjectURL(p),100)}else r="No data received in file buffer. Download will be empty.",F(r,i)}catch(h){r=`Error reading from file stream: ${h.message}`,F(r)}finally{F("Closing incoming file stream processing."),yt=null}}),r!=""&&F(r)}function jS(r){r.preventDefault()}function ZS(r){if(r.preventDefault(),r.dataTransfer.items){const e=[...r.dataTransfer.items].find(t=>t.kind==="file");e&&(Me=e.getAsFile())}else r.dataTransfer.files&&r.dataTransfer.files.length>0&&(Me=r.dataTransfer.files[0]);Me?(F(`Selected file: ${Me.name} (Size: ${Me.size} bytes)`),document.getElementById("fileNameDisplay").textContent=Me.name,document.getElementById("fileSizeDisplay").textContent=`${(Me.size/1024/1024).toFixed(2)} MB`,window.actions.startSendProcess()):F("No file selected from drop.")}function JS(){var r=document.getElementById("generatedPhraseDisplay");navigator.clipboard.writeText(r.innerText)}document.addEventListener("DOMContentLoaded",()=>{document.getElementById("phraseInput").value="";const r=document.getElementById("drop_zone");r.addEventListener("dragover",jS),r.addEventListener("drop",ZS),document.getElementById("fileInput").addEventListener("change",a=>{a.target.files&&a.target.files[0]?(Me=a.target.files[0],document.getElementById("fileNameDisplay").textContent=Me.name,document.getElementById("fileSizeDisplay").textContent=`${(Me.size/1024/1024).toFixed(2)} MB`,window.actions.startSendProcess()):console.log("No file selected.")}),document.getElementById("copyPhraseButton").addEventListener("click",JS),F("handlers attached.");const n=document.getElementById("receiveModeButton");n.onclick=window.actions.startReceiveProcess;const s=document.getElementById("errorWindow"),i=document.getElementById("errorMessageContainer"),o=document.getElementById("closeErrorButton");s.addEventListener("click",function(a){a.target===s&&(Rl(),Ml())}),i.addEventListener("click",function(a){a.stopPropagation()}),o.addEventListener("click",function(){Ml(),Rl()})});window.actions={startSendProcess:async()=>{if(!Pe){F("Libp2p node not initialized yet.");return}if(!Me){F("Please select a file to send first.");return}Et=!0,qt=!1,Ge&&(Ge.innerHTML=""),F("Sender Mode Activated. Generating passphrase...");const r=await VS.generate(16);Qr=[Math.floor(Math.random()*100)+1,...r.split(" ")].join("-"),document.getElementById("generatedPhraseDisplay").textContent=Qr,F(`Your passphrase: ${Qr}`),F(`Attempting to connect to relay: ${Ms}...`),document.getElementById("initialDropUI").style.display="none",document.getElementById("fileInfoArea").style.display="block";const t=X(Ms);try{await Pe.dial(t,{signal:AbortSignal.timeout(5e3)}),F("Dialing relay initiated. Waiting for connection...",Ge)}catch(n){F(`Error dialing relay: ${n.message||n}`),console.error("Relay dial error:",n),Et=!1}},startReceiveProcess:async()=>{if(!Pe){F("Libp2p node not initialized yet.");return}document.getElementById("initialReceiveUI").style.display="none",document.getElementById("receivingLoadingIndicator").style.display="block",qt=!0,Et=!1,Dt&&(Dt.innerHTML=""),F("Receiver Mode Activated. Enter passphrase to connect.");const e=document.getElementById("phraseInput").value.trim();if(!e){F("Please enter a phrase to lookup."),qt=!1;return}F(`Looking up passphrase '${e}'...`);try{const t=`${_h}/phrase/${encodeURIComponent(e)}`,n=await fetch(t);if(!n.ok){let a=`Failed to lookup phrase '${e}'. Status: ${n.status}`;try{const c=await n.json();a+=` - ${c.message||n.statusText}`}catch{a+=` - ${n.statusText}`}F(a,Dt),qt=!1;return}const i=(await n.json()).maddr;if(!i){F("Phrase found, but no multiaddress provided.",Dt),qt=!1;return}const o=X(i);F(`Retrieved sender address: '${o.toString()}'. Attempting to connect...`,Dt),await Pe.dial(o,{signal:AbortSignal.timeout(1e4)}),F("Dialing sender initiated. Waiting for connection...",Dt)}catch(t){F(`Error in receive process: ${t.message||t}`),qt=!1}}};QS().catch(r=>{console.error("Failed to initialize libp2p node:",r),F(`Critical Error: Failed to initialize libp2p node - ${r.message}`)});function Dl(r){document.getElementById("errorMessageText").textContent=r,document.getElementById("errorWindow").classList.remove("hidden")}function Ml(){document.getElementById("errorWindow").classList.add("hidden")}function Rl(){document.getElementById("sendWindow").style.display="none",document.getElementById("receiveWindow").style.display="none",document.getElementById("returnButton").style.display="none",document.getElementById("goSendButton").style.display="flex",document.getElementById("goReceiveButton").style.display="flex",window.location.reload()}
