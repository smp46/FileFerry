(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function t(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(s){if(s.ep)return;s.ep=!0;const i=t(s);fetch(s.href,i)}})();const Lh=Symbol.for("@libp2p/connection"),ha=Symbol.for("@libp2p/content-routing"),fa=Symbol.for("@libp2p/peer-discovery"),Eo=Symbol.for("@libp2p/peer-id");function Dl(r){return!!r?.[Eo]}const pa=Symbol.for("@libp2p/peer-routing"),So="keep-alive",xo=Symbol.for("@libp2p/transport");var Qr;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(Qr||(Qr={}));let Qt=class extends Error{static name="AbortError";constructor(e="The operation was aborted"){super(e),this.name="AbortError"}};class Dh extends Error{static name="UnexpectedPeerError";constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}}let Rh=class extends Error{static name="InvalidCryptoExchangeError";constructor(e="Invalid crypto exchange"){super(e),this.name="InvalidCryptoExchangeError"}};class V extends Error{static name="InvalidParametersError";constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}}class Rl extends Error{static name="InvalidPublicKeyError";constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}}class Mh extends Error{static name="ConnectionClosingError";constructor(e="The connection is closing"){super(e),this.name="ConnectionClosingError"}}class Ml extends Error{static name="ConnectionClosedError";constructor(e="The connection is closed"){super(e),this.name="ConnectionClosedError"}}class Ol extends Error{static name="ConnectionFailedError";constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}}class Nr extends Error{static name="MuxerClosedError";constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}}class Oh extends Error{static name="StreamResetError";constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}}class Ui extends Error{static name="StreamStateError";constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}}let Bi=class extends Error{static name="NotFoundError";constructor(e="Not found"){super(e),this.name="NotFoundError"}};class Nl extends Error{static name="InvalidPeerIdError";constructor(e="Invalid PeerID"){super(e),this.name="InvalidPeerIdError"}}class Ao extends Error{static name="InvalidMultiaddrError";constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}}class Nh extends Error{static name="InvalidCIDError";constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}}class Fh extends Error{static name="InvalidMultihashError";constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}}class Co extends Error{static name="UnsupportedProtocolError";constructor(e="Unsupported protocol error"){super(e),this.name="UnsupportedProtocolError"}}class ut extends Error{static name="InvalidMessageError";constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}}class Uh extends Error{static name="ProtocolError";constructor(e="Protocol error"){super(e),this.name="ProtocolError"}}let Io=class extends Error{static name="TimeoutError";constructor(e="Timed out"){super(e),this.name="TimeoutError"}};class Qn extends Error{static name="NotStartedError";constructor(e="Not started"){super(e),this.name="NotStartedError"}}class Vr extends Error{static name="DialError";constructor(e="Dial error"){super(e),this.name="DialError"}}class $i extends Error{static name="ListenError";constructor(e="Listen error"){super(e),this.name="ListenError"}}class Fl extends Error{static name="LimitedConnectionError";constructor(e="Limited connection"){super(e),this.name="LimitedConnectionError"}}class Bh extends Error{static name="TooManyInboundProtocolStreamsError";constructor(e="Too many inbound protocol streams"){super(e),this.name="TooManyInboundProtocolStreamsError"}}class Ul extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}}class To extends Error{static name="UnsupportedKeyTypeError";constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}}class Ut extends EventTarget{#e=new Map;constructor(){super()}listenerCount(e){const t=this.#e.get(e);return t==null?0:t.length}addEventListener(e,t,n){super.addEventListener(e,t,n);let s=this.#e.get(e);s==null&&(s=[],this.#e.set(e,s)),s.push({callback:t,once:(n!==!0&&n!==!1&&n?.once)??!1})}removeEventListener(e,t,n){super.removeEventListener(e.toString(),t??null,n);let s=this.#e.get(e);s!=null&&(s=s.filter(({callback:i})=>i!==t),this.#e.set(e,s))}dispatchEvent(e){const t=super.dispatchEvent(e);let n=this.#e.get(e.type);return n==null||(n=n.filter(({once:s})=>!s),this.#e.set(e.type,n)),t}safeDispatchEvent(e,t={}){return this.dispatchEvent(new CustomEvent(e,t))}}function ko(r){return r!=null&&typeof r.start=="function"&&typeof r.stop=="function"}async function Bl(...r){const e=[];for(const t of r)ko(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStart!=null&&await t.beforeStart()})),await Promise.all(e.map(async t=>{await t.start()})),await Promise.all(e.map(async t=>{t.afterStart!=null&&await t.afterStart()}))}async function $l(...r){const e=[];for(const t of r)ko(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStop!=null&&await t.beforeStop()})),await Promise.all(e.map(async t=>{await t.stop()})),await Promise.all(e.map(async t=>{t.afterStop!=null&&await t.afterStop()}))}const it=Symbol.for("@libp2p/service-capabilities"),jn=Symbol.for("@libp2p/service-dependencies");function $h(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function Ds(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function zh(r){return new TextEncoder().encode(r)}function Kh(r){return new TextDecoder().decode(r)}function qh(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var s=0;s<r.length;s++){var i=r.charAt(s),o=i.charCodeAt(0);if(t[o]!==255)throw new TypeError(i+" is ambiguous");t[o]=s}var a=r.length,c=r.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function d(f){if(f instanceof Uint8Array||(ArrayBuffer.isView(f)?f=new Uint8Array(f.buffer,f.byteOffset,f.byteLength):Array.isArray(f)&&(f=Uint8Array.from(f))),!(f instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(f.length===0)return"";for(var g=0,m=0,v=0,k=f.length;v!==k&&f[v]===0;)v++,g++;for(var b=(k-v)*u+1>>>0,w=new Uint8Array(b);v!==k;){for(var E=f[v],P=0,x=b-1;(E!==0||P<m)&&x!==-1;x--,P++)E+=256*w[x]>>>0,w[x]=E%a>>>0,E=E/a>>>0;if(E!==0)throw new Error("Non-zero carry");m=P,v++}for(var _=b-m;_!==b&&w[_]===0;)_++;for(var D=c.repeat(g);_<b;++_)D+=r.charAt(w[_]);return D}function h(f){if(typeof f!="string")throw new TypeError("Expected String");if(f.length===0)return new Uint8Array;var g=0;if(f[g]!==" "){for(var m=0,v=0;f[g]===c;)m++,g++;for(var k=(f.length-g)*l+1>>>0,b=new Uint8Array(k);f[g];){var w=t[f.charCodeAt(g)];if(w===255)return;for(var E=0,P=k-1;(w!==0||E<v)&&P!==-1;P--,E++)w+=a*b[P]>>>0,b[P]=w%256>>>0,w=w/256>>>0;if(w!==0)throw new Error("Non-zero carry");v=E,g++}if(f[g]!==" "){for(var x=k-v;x!==k&&b[x]===0;)x++;for(var _=new Uint8Array(m+(k-x)),D=m;x!==k;)_[D++]=b[x++];return _}}}function p(f){var g=h(f);if(g)return g;throw new Error(`Non-${e} character`)}return{encode:d,decodeUnsafe:h,decode:p}}var Wh=qh,Vh=Wh;class Hh{name;prefix;baseEncode;constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}let Gh=class{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,n){this.name=e,this.prefix=t;const s=t.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return zl(this,e)}};class Yh{decoders;constructor(e){this.decoders=e}or(e){return zl(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n!=null)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function zl(r,e){return new Yh({...r.decoders??{[r.prefix]:r},...e.decoders??{[e.prefix]:e}})}class Xh{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,n,s){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=s,this.encoder=new Hh(e,t,n),this.decoder=new Gh(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function Rs({name:r,prefix:e,encode:t,decode:n}){return new Xh(r,e,t,n)}function hn({name:r,prefix:e,alphabet:t}){const{encode:n,decode:s}=Vh(t,r);return Rs({prefix:e,name:r,encode:n,decode:i=>Ds(s(i))})}function Qh(r,e,t,n){let s=r.length;for(;r[s-1]==="=";)--s;const i=new Uint8Array(s*t/8|0);let o=0,a=0,c=0;for(let l=0;l<s;++l){const u=e[r[l]];if(u===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<t|u,o+=t,o>=8&&(o-=8,i[c++]=255&a>>o)}if(o>=t||(255&a<<8-o)!==0)throw new SyntaxError("Unexpected end of data");return i}function jh(r,e,t){const n=e[e.length-1]==="=",s=(1<<t)-1;let i="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>t;)o-=t,i+=e[s&a>>o];if(o!==0&&(i+=e[s&a<<t-o]),n)for(;(i.length*t&7)!==0;)i+="=";return i}function Zh(r){const e={};for(let t=0;t<r.length;++t)e[r[t]]=t;return e}function _e({name:r,prefix:e,bitsPerChar:t,alphabet:n}){const s=Zh(n);return Rs({prefix:e,name:r,encode(i){return jh(i,n,t)},decode(i){return Qh(i,s,t,r)}})}const ye=hn({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Jh=hn({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),ef=Object.freeze(Object.defineProperty({__proto__:null,base58btc:ye,base58flickr:Jh},Symbol.toStringTag,{value:"Module"})),St=_e({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),tf=_e({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),rf=_e({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),nf=_e({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),sf=_e({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),of=_e({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),af=_e({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),cf=_e({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),lf=_e({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),uf=Object.freeze(Object.defineProperty({__proto__:null,base32:St,base32hex:sf,base32hexpad:af,base32hexpadupper:cf,base32hexupper:of,base32pad:rf,base32padupper:nf,base32upper:tf,base32z:lf},Symbol.toStringTag,{value:"Module"})),Gn=hn({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),df=hn({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),hf=Object.freeze(Object.defineProperty({__proto__:null,base36:Gn,base36upper:df},Symbol.toStringTag,{value:"Module"}));var ff=Kl,ga=128,pf=-128,gf=Math.pow(2,31);function Kl(r,e,t){e=e||[],t=t||0;for(var n=t;r>=gf;)e[t++]=r&255|ga,r/=128;for(;r&pf;)e[t++]=r&255|ga,r>>>=7;return e[t]=r|0,Kl.bytes=t-n+1,e}var mf=zi,yf=128,ma=127;function zi(r,n){var t=0,n=n||0,s=0,i=n,o,a=r.length;do{if(i>=a)throw zi.bytes=0,new RangeError("Could not decode varint");o=r[i++],t+=s<28?(o&ma)<<s:(o&ma)*Math.pow(2,s),s+=7}while(o>=yf);return zi.bytes=i-n,t}var wf=Math.pow(2,7),bf=Math.pow(2,14),vf=Math.pow(2,21),Ef=Math.pow(2,28),Sf=Math.pow(2,35),xf=Math.pow(2,42),Af=Math.pow(2,49),Cf=Math.pow(2,56),If=Math.pow(2,63),Tf=function(r){return r<wf?1:r<bf?2:r<vf?3:r<Ef?4:r<Sf?5:r<xf?6:r<Af?7:r<Cf?8:r<If?9:10},kf={encode:ff,decode:mf,encodingLength:Tf},Zn=kf;function Ki(r,e=0){return[Zn.decode(r,e),Zn.decode.bytes]}function Jn(r,e,t=0){return Zn.encode(r,e,t),e}function es(r){return Zn.encodingLength(r)}function jr(r,e){const t=e.byteLength,n=es(r),s=n+es(t),i=new Uint8Array(s+t);return Jn(r,i,0),Jn(t,i,n),i.set(e,s),new _o(r,t,e,i)}function er(r){const e=Ds(r),[t,n]=Ki(e),[s,i]=Ki(e.subarray(n)),o=e.subarray(n+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new _o(t,s,o,e)}function _f(r,e){if(r===e)return!0;{const t=e;return r.code===t.code&&r.size===t.size&&t.bytes instanceof Uint8Array&&$h(r.bytes,t.bytes)}}class _o{code;size;digest;bytes;constructor(e,t,n,s){this.code=e,this.size=t,this.digest=n,this.bytes=s}}function ya(r,e){const{bytes:t,version:n}=r;switch(n){case 0:return Lf(t,qi(r),e??ye.encoder);default:return Df(t,qi(r),e??St.encoder)}}const wa=new WeakMap;function qi(r){const e=wa.get(r);if(e==null){const t=new Map;return wa.set(r,t),t}return e}class ae{code;version;multihash;bytes;"/";constructor(e,t,n,s){this.code=t,this.version=e,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==Fr)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Rf)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return ae.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=jr(e,t);return ae.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return ae.equals(this,e)}static equals(e,t){const n=t;return n!=null&&e.code===n.code&&e.version===n.version&&_f(e.multihash,n.multihash)}toString(e){return ya(this,e)}toJSON(){return{"/":ya(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof ae)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:n,code:s,multihash:i,bytes:o}=t;return new ae(n,s,i,o??ba(n,s,i.bytes))}else if(t[Mf]===!0){const{version:n,multihash:s,code:i}=t,o=er(s);return ae.create(n,i,o)}else return null}static create(e,t,n){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==Fr)throw new Error(`Version 0 CID must use dag-pb (code: ${Fr}) block encoding`);return new ae(e,t,n,n.bytes)}case 1:{const s=ba(e,t,n.bytes);return new ae(e,t,n,s)}default:throw new Error("Invalid version")}}static createV0(e){return ae.create(0,Fr,e)}static createV1(e,t){return ae.create(1,e,t)}static decode(e){const[t,n]=ae.decodeFirst(e);if(n.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=ae.inspectBytes(e),n=t.size-t.multihashSize,s=Ds(e.subarray(n,n+t.multihashSize));if(s.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=s.subarray(t.multihashSize-t.digestSize),o=new _o(t.multihashCode,t.digestSize,i,s);return[t.version===0?ae.createV0(o):ae.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[d,h]=Ki(e.subarray(t));return t+=h,d};let s=n(),i=Fr;if(s===18?(s=0,t=0):i=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=t,a=n(),c=n(),l=t+c,u=l-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:u,size:l}}static parse(e,t){const[n,s]=Pf(e,t),i=ae.decode(s);if(i.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return qi(i).set(n,e),i}}function Pf(r,e){switch(r[0]){case"Q":{const t=e??ye;return[ye.prefix,t.decode(`${ye.prefix}${r}`)]}case ye.prefix:{const t=e??ye;return[ye.prefix,t.decode(r)]}case St.prefix:{const t=e??St;return[St.prefix,t.decode(r)]}case Gn.prefix:{const t=e??Gn;return[Gn.prefix,t.decode(r)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],e.decode(r)]}}}function Lf(r,e,t){const{prefix:n}=t;if(n!==ye.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const s=e.get(n);if(s==null){const i=t.encode(r).slice(1);return e.set(n,i),i}else return s}function Df(r,e,t){const{prefix:n}=t,s=e.get(n);if(s==null){const i=t.encode(r);return e.set(n,i),i}else return s}const Fr=112,Rf=18;function ba(r,e,t){const n=es(r),s=n+es(e),i=new Uint8Array(s+t.byteLength);return Jn(r,i,0),Jn(e,i,n),i.set(t,s),i}const Mf=Symbol.for("@ipld/js-cid/CID"),ql=0,Of="identity",Wl=Ds;function Nf(r){return jr(ql,Wl(r))}const fn={code:ql,name:Of,encode:Wl,digest:Nf};function Oe(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function se(r=0){return new Uint8Array(r)}function ft(r=0){return new Uint8Array(r)}function ot(r,e){e==null&&(e=r.reduce((s,i)=>s+i.length,0));const t=ft(e);let n=0;for(const s of r)t.set(s,n),n+=s.length;return t}const Vl=Symbol.for("@achingbrain/uint8arraylist");function va(r,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(const n of r){const s=t+n.byteLength;if(e<s)return{buf:n,index:e-t};t=s}throw new RangeError("index is out of bounds")}function Cn(r){return!!r?.[Vl]}class J{bufs;length;[Vl]=!0;constructor(...e){this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const n of e)if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.push(n);else if(Cn(n))t+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const n of e.reverse())if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.unshift(n);else if(Cn(n))t+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){const t=va(this.bufs,e);return t.buf[t.index]}set(e,t){const n=va(this.bufs,e);n.buf[n.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let n=0;n<e.length;n++)this.set(t+n,e[n]);else if(Cn(e))for(let n=0;n<e.length;n++)this.set(t+n,e.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){const{bufs:n,length:s}=this._subList(e,t);return ot(n,s)}subarray(e,t){const{bufs:n,length:s}=this._subList(e,t);return n.length===1?n[0]:ot(n,s)}sublist(e,t){const{bufs:n,length:s}=this._subList(e,t),i=new J;return i.length=s,i.bufs=[...n],i}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};const n=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],a=s,c=a+o.byteLength;if(s=c,e>=c)continue;const l=e>=a&&e<c,u=t>a&&t<=c;if(l&&u){if(e===a&&t===c){n.push(o);break}const d=e-a;n.push(o.subarray(d,d+(t-e)));break}if(l){if(e===0){n.push(o);continue}n.push(o.subarray(e-a));continue}if(u){if(t===c){n.push(o);break}n.push(o.subarray(0,t-a));break}n.push(o)}return{bufs:n,length:t-e}}indexOf(e,t=0){if(!Cn(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const n=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const s=n.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let d=0;d<i;d++)o[d]=-1;for(let d=0;d<s;d++)o[n[d]]=d;const a=o,c=this.byteLength-n.byteLength,l=n.byteLength-1;let u;for(let d=t;d<=c;d+=u){u=0;for(let h=l;h>=0;h--){const p=this.get(d+h);if(n[h]!==p){u=Math.max(1,h-a[p]);break}}if(u===0)return d}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const n=ft(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,t),this.write(n,e)}getInt16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,t)}setInt16(e,t,n){const s=se(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,t,n),this.write(s,e)}getInt32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,t)}setInt32(e,t,n){const s=se(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,t,n),this.write(s,e)}getBigInt64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,t)}setBigInt64(e,t,n){const s=se(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,t,n),this.write(s,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const n=ft(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,t),this.write(n,e)}getUint16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,t)}setUint16(e,t,n){const s=se(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,t,n),this.write(s,e)}getUint32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,t)}setUint32(e,t,n){const s=se(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,t,n),this.write(s,e)}getBigUint64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,t)}setBigUint64(e,t,n){const s=se(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,t,n),this.write(s,e)}getFloat32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,t)}setFloat32(e,t,n){const s=se(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,t,n),this.write(s,e)}getFloat64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,t)}setFloat64(e,t,n){const s=se(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,t,n),this.write(s,e)}equals(e){if(e==null||!(e instanceof J)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!Oe(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const n=new J;return n.bufs=e,t==null&&(t=e.reduce((s,i)=>s+i.byteLength,0)),n.length=t,n}}const Ff=hn({prefix:"9",name:"base10",alphabet:"0123456789"}),Uf=Object.freeze(Object.defineProperty({__proto__:null,base10:Ff},Symbol.toStringTag,{value:"Module"})),Bf=_e({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),$f=_e({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),zf=Object.freeze(Object.defineProperty({__proto__:null,base16:Bf,base16upper:$f},Symbol.toStringTag,{value:"Module"})),Kf=_e({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),qf=Object.freeze(Object.defineProperty({__proto__:null,base2:Kf},Symbol.toStringTag,{value:"Module"})),Hl=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),Wf=Hl.reduce((r,e,t)=>(r[t]=e,r),[]),Vf=Hl.reduce((r,e,t)=>{const n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);return r[n]=t,r},[]);function Hf(r){return r.reduce((e,t)=>(e+=Wf[t],e),"")}function Gf(r){const e=[];for(const t of r){const n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);const s=Vf[n];if(s==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(s)}return new Uint8Array(e)}const Yf=Rs({prefix:"ðŸš€",name:"base256emoji",encode:Hf,decode:Gf}),Xf=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:Yf},Symbol.toStringTag,{value:"Module"})),Gl=_e({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Qf=_e({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Yl=_e({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),jf=_e({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),Zf=Object.freeze(Object.defineProperty({__proto__:null,base64:Gl,base64pad:Qf,base64url:Yl,base64urlpad:jf},Symbol.toStringTag,{value:"Module"})),Jf=_e({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),ep=Object.freeze(Object.defineProperty({__proto__:null,base8:Jf},Symbol.toStringTag,{value:"Module"})),tp=Rs({prefix:"\0",name:"identity",encode:r=>Kh(r),decode:r=>zh(r)}),rp=Object.freeze(Object.defineProperty({__proto__:null,identity:tp},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;function np({name:r,code:e,encode:t}){return new sp(r,e,t)}class sp{name;code;encode;constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?jr(this.code,t):t.then(n=>jr(this.code,n))}else throw Error("Unknown type, must be binary type")}}function ip(r){return async e=>new Uint8Array(await crypto.subtle.digest(r,e))}const Xl=np({name:"sha2-256",code:18,encode:ip("SHA-256")}),Wi={...rp,...qf,...ep,...Uf,...zf,...uf,...hf,...ef,...Zf,...Xf};function Ql(r,e,t,n){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:n}}}const Ea=Ql("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),Gs=Ql("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);const e=ft(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),jl={utf8:Ea,"utf-8":Ea,hex:Wi.base16,latin1:Gs,ascii:Gs,binary:Gs,...Wi};function q(r,e="utf8"){const t=jl[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${r}`)}function Y(r,e="utf8"){const t=jl[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(r).substring(1)}const op=parseInt("11111",2),Vi=parseInt("10000000",2),ap=parseInt("01111111",2),Sa={0:Ur,1:Ur,2:cp,3:dp,4:hp,5:up,6:lp,16:Ur,22:Ur,48:Ur};function Ms(r,e={offset:0}){const t=r[e.offset]&op;if(e.offset++,Sa[t]!=null)return Sa[t](r,e);throw new Error("No decoder for tag "+t)}function pn(r,e){let t=0;if((r[e.offset]&Vi)===Vi){const n=r[e.offset]&ap;let s="0x";e.offset++;for(let i=0;i<n;i++,e.offset++)s+=r[e.offset].toString(16).padStart(2,"0");t=parseInt(s,16)}else t=r[e.offset],e.offset++;return t}function Ur(r,e){pn(r,e);const t=[];for(;!(e.offset>=r.byteLength);){const n=Ms(r,e);if(n===null)break;t.push(n)}return t}function cp(r,e){const t=pn(r,e),n=e.offset,s=e.offset+t,i=[];for(let o=n;o<s;o++)o===n&&r[o]===0||i.push(r[o]);return e.offset+=t,Uint8Array.from(i)}function lp(r,e){const t=pn(r,e),n=e.offset+t,s=r[e.offset];e.offset++;let i=0,o=0;s<40?(i=0,o=s):s<80?(i=1,o=s-40):(i=2,o=s-80);let a=`${i}.${o}`,c=[];for(;e.offset<n;){const l=r[e.offset];if(e.offset++,c.push(l&127),l<128){c.reverse();let u=0;for(let d=0;d<c.length;d++)u+=c[d]<<d*7;a+=`.${u}`,c=[]}}return a}function up(r,e){return e.offset++,null}function dp(r,e){const t=pn(r,e),n=r[e.offset];e.offset++;const s=r.subarray(e.offset,e.offset+t-1);if(e.offset+=t,n!==0)throw new Error("Unused bits in bit string is unimplemented");return s}function hp(r,e){const t=pn(r,e),n=r.subarray(e.offset,e.offset+t);return e.offset+=t,n}function fp(r){let e=r.toString(16);e.length%2===1&&(e="0"+e);const t=new J;for(let n=0;n<e.length;n+=2)t.append(Uint8Array.from([parseInt(`${e[n]}${e[n+1]}`,16)]));return t}function Po(r){if(r.byteLength<128)return Uint8Array.from([r.byteLength]);const e=fp(r.byteLength);return new J(Uint8Array.from([e.byteLength|Vi]),e)}function Hi(r){const e=new J,t=128;return(r.subarray()[0]&t)===t&&e.append(Uint8Array.from([0])),e.append(r),new J(Uint8Array.from([2]),Po(e),e)}function Zl(r){const e=Uint8Array.from([0]),t=new J(e,r);return new J(Uint8Array.from([3]),Po(t),t)}function Hr(r,e=48){const t=new J;for(const n of r)t.append(n);return new J(Uint8Array.from([e]),Po(t),t)}async function pp(r,e,t){const n=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv??"P-256"},!1,["verify"]);return crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},n,e,t.subarray())}const gp=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),mp=Uint8Array.from([6,5,43,129,4,0,34]),yp=Uint8Array.from([6,5,43,129,4,0,35]),wp={ext:!0,kty:"EC",crv:"P-256"},bp={ext:!0,kty:"EC",crv:"P-384"},vp={ext:!0,kty:"EC",crv:"P-521"},Ys=32,Xs=48,Qs=66;function Jl(r){const e=Ms(r);return Ep(e)}function Ep(r){const e=r[1][1][0],t=1;let n,s;if(e.byteLength===Ys*2+1)return n=Y(e.subarray(t,t+Ys),"base64url"),s=Y(e.subarray(t+Ys),"base64url"),new js({...wp,key_ops:["verify"],x:n,y:s});if(e.byteLength===Xs*2+1)return n=Y(e.subarray(t,t+Xs),"base64url"),s=Y(e.subarray(t+Xs),"base64url"),new js({...bp,key_ops:["verify"],x:n,y:s});if(e.byteLength===Qs*2+1)return n=Y(e.subarray(t,t+Qs),"base64url"),s=Y(e.subarray(t+Qs),"base64url"),new js({...vp,key_ops:["verify"],x:n,y:s});throw new V(`coordinates were wrong length, got ${e.byteLength}, expected 65, 97 or 133`)}function Sp(r){return Hr([Hi(Uint8Array.from([1])),Hr([xp(r.crv)],160),Hr([Zl(new J(Uint8Array.from([4]),q(r.x??"","base64url"),q(r.y??"","base64url")))],161)]).subarray()}function xp(r){if(r==="P-256")return gp;if(r==="P-384")return mp;if(r==="P-521")return yp;throw new V(`Invalid curve ${r}`)}class js{type="ECDSA";jwk;_raw;constructor(e){this.jwk=e}get raw(){return this._raw==null&&(this._raw=Sp(this.jwk)),this._raw}toMultihash(){return fn.digest(xt(this))}toCID(){return ae.createV1(114,this.toMultihash())}toString(){return ye.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Oe(this.raw,e.raw)}async verify(e,t){return pp(this.jwk,t,e)}}const rr=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ap(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function ts(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function gn(r,...e){if(!Ap(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function Lo(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");ts(r.outputLen),ts(r.blockLen)}function rs(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Cp(r,e){gn(r);const t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function jt(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function Zs(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function at(r,e){return r<<32-e|r>>>e}function Ip(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}function Zr(r){return typeof r=="string"&&(r=Ip(r)),gn(r),r}function Tp(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];gn(s),e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const i=r[n];t.set(i,s),s+=i.length}return t}class eu{}function tu(r){const e=n=>r().update(Zr(n)).digest(),t=r();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>r(),e}function Os(r=32){if(rr&&typeof rr.getRandomValues=="function")return rr.getRandomValues(new Uint8Array(r));if(rr&&typeof rr.randomBytes=="function")return Uint8Array.from(rr.randomBytes(r));throw new Error("crypto.getRandomValues must be defined")}function kp(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const s=BigInt(32),i=BigInt(4294967295),o=Number(t>>s&i),a=Number(t&i),c=n?4:0,l=n?0:4;r.setUint32(e+c,o,n),r.setUint32(e+l,a,n)}function _p(r,e,t){return r&e^~r&t}function Pp(r,e,t){return r&e^r&t^e&t}class ru extends eu{constructor(e,t,n,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=s,this.buffer=new Uint8Array(e),this.view=Zs(this.buffer)}update(e){rs(this),e=Zr(e),gn(e);const{view:t,buffer:n,blockLen:s}=this,i=e.length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a===s){const c=Zs(e);for(;s<=i-o;o+=s)this.process(c,o);continue}n.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){rs(this),Cp(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:s,isLE:i}=this;let{pos:o}=this;t[o++]=128,jt(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(n,0),o=0);for(let d=o;d<s;d++)t[d]=0;kp(n,s-8,BigInt(this.length*8),i),this.process(n,0);const a=Zs(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=c/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<l;d++)a.setUint32(4*d,u[d],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:s,finished:i,destroyed:o,pos:a}=this;return e.destroyed=o,e.finished=i,e.length=s,e.pos=a,s%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}}const Tt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Le=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),In=BigInt(2**32-1),xa=BigInt(32);function Lp(r,e=!1){return e?{h:Number(r&In),l:Number(r>>xa&In)}:{h:Number(r>>xa&In)|0,l:Number(r&In)|0}}function Dp(r,e=!1){const t=r.length;let n=new Uint32Array(t),s=new Uint32Array(t);for(let i=0;i<t;i++){const{h:o,l:a}=Lp(r[i],e);[n[i],s[i]]=[o,a]}return[n,s]}const Aa=(r,e,t)=>r>>>t,Ca=(r,e,t)=>r<<32-t|e>>>t,nr=(r,e,t)=>r>>>t|e<<32-t,sr=(r,e,t)=>r<<32-t|e>>>t,Tn=(r,e,t)=>r<<64-t|e>>>t-32,kn=(r,e,t)=>r>>>t-32|e<<64-t;function gt(r,e,t,n){const s=(e>>>0)+(n>>>0);return{h:r+t+(s/2**32|0)|0,l:s|0}}const Rp=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),Mp=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,Op=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),Np=(r,e,t,n,s)=>e+t+n+s+(r/2**32|0)|0,Fp=(r,e,t,n,s)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(s>>>0),Up=(r,e,t,n,s,i)=>e+t+n+s+i+(r/2**32|0)|0,Bp=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),kt=new Uint32Array(64);class $p extends ru{constructor(e=32){super(64,e,8,!1),this.A=Tt[0]|0,this.B=Tt[1]|0,this.C=Tt[2]|0,this.D=Tt[3]|0,this.E=Tt[4]|0,this.F=Tt[5]|0,this.G=Tt[6]|0,this.H=Tt[7]|0}get(){const{A:e,B:t,C:n,D:s,E:i,F:o,G:a,H:c}=this;return[e,t,n,s,i,o,a,c]}set(e,t,n,s,i,o,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let d=0;d<16;d++,t+=4)kt[d]=e.getUint32(t,!1);for(let d=16;d<64;d++){const h=kt[d-15],p=kt[d-2],f=at(h,7)^at(h,18)^h>>>3,g=at(p,17)^at(p,19)^p>>>10;kt[d]=g+kt[d-7]+f+kt[d-16]|0}let{A:n,B:s,C:i,D:o,E:a,F:c,G:l,H:u}=this;for(let d=0;d<64;d++){const h=at(a,6)^at(a,11)^at(a,25),p=u+h+_p(a,c,l)+Bp[d]+kt[d]|0,g=(at(n,2)^at(n,13)^at(n,22))+Pp(n,s,i)|0;u=l,l=c,c=a,a=o+p|0,o=i,i=s,s=n,n=p+g|0}n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(n,s,i,o,a,c,l,u)}roundClean(){jt(kt)}destroy(){this.set(0,0,0,0,0,0,0,0),jt(this.buffer)}}const nu=Dp(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),zp=nu[0],Kp=nu[1],_t=new Uint32Array(80),Pt=new Uint32Array(80);class qp extends ru{constructor(e=64){super(128,e,16,!1),this.Ah=Le[0]|0,this.Al=Le[1]|0,this.Bh=Le[2]|0,this.Bl=Le[3]|0,this.Ch=Le[4]|0,this.Cl=Le[5]|0,this.Dh=Le[6]|0,this.Dl=Le[7]|0,this.Eh=Le[8]|0,this.El=Le[9]|0,this.Fh=Le[10]|0,this.Fl=Le[11]|0,this.Gh=Le[12]|0,this.Gl=Le[13]|0,this.Hh=Le[14]|0,this.Hl=Le[15]|0}get(){const{Ah:e,Al:t,Bh:n,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:l,El:u,Fh:d,Fl:h,Gh:p,Gl:f,Hh:g,Hl:m}=this;return[e,t,n,s,i,o,a,c,l,u,d,h,p,f,g,m]}set(e,t,n,s,i,o,a,c,l,u,d,h,p,f,g,m){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=d|0,this.Fl=h|0,this.Gh=p|0,this.Gl=f|0,this.Hh=g|0,this.Hl=m|0}process(e,t){for(let b=0;b<16;b++,t+=4)_t[b]=e.getUint32(t),Pt[b]=e.getUint32(t+=4);for(let b=16;b<80;b++){const w=_t[b-15]|0,E=Pt[b-15]|0,P=nr(w,E,1)^nr(w,E,8)^Aa(w,E,7),x=sr(w,E,1)^sr(w,E,8)^Ca(w,E,7),_=_t[b-2]|0,D=Pt[b-2]|0,F=nr(_,D,19)^Tn(_,D,61)^Aa(_,D,6),L=sr(_,D,19)^kn(_,D,61)^Ca(_,D,6),N=Op(x,L,Pt[b-7],Pt[b-16]),R=Np(N,P,F,_t[b-7],_t[b-16]);_t[b]=R|0,Pt[b]=N|0}let{Ah:n,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:l,Dl:u,Eh:d,El:h,Fh:p,Fl:f,Gh:g,Gl:m,Hh:v,Hl:k}=this;for(let b=0;b<80;b++){const w=nr(d,h,14)^nr(d,h,18)^Tn(d,h,41),E=sr(d,h,14)^sr(d,h,18)^kn(d,h,41),P=d&p^~d&g,x=h&f^~h&m,_=Fp(k,E,x,Kp[b],Pt[b]),D=Up(_,v,w,P,zp[b],_t[b]),F=_|0,L=nr(n,s,28)^Tn(n,s,34)^Tn(n,s,39),N=sr(n,s,28)^kn(n,s,34)^kn(n,s,39),R=n&i^n&a^i&a,$=s&o^s&c^o&c;v=g|0,k=m|0,g=p|0,m=f|0,p=d|0,f=h|0,{h:d,l:h}=gt(l|0,u|0,D|0,F|0),l=a|0,u=c|0,a=i|0,c=o|0,i=n|0,o=s|0;const C=Rp(F,N,$);n=Mp(C,D,L,R),s=C|0}({h:n,l:s}=gt(this.Ah|0,this.Al|0,n|0,s|0)),{h:i,l:o}=gt(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=gt(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:u}=gt(this.Dh|0,this.Dl|0,l|0,u|0),{h:d,l:h}=gt(this.Eh|0,this.El|0,d|0,h|0),{h:p,l:f}=gt(this.Fh|0,this.Fl|0,p|0,f|0),{h:g,l:m}=gt(this.Gh|0,this.Gl|0,g|0,m|0),{h:v,l:k}=gt(this.Hh|0,this.Hl|0,v|0,k|0),this.set(n,s,i,o,a,c,l,u,d,h,p,f,g,m,v,k)}roundClean(){jt(_t,Pt)}destroy(){jt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const su=tu(()=>new $p),Wp=tu(()=>new qp);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Do=BigInt(0),Gi=BigInt(1);function mn(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Ro(r){if(!mn(r))throw new Error("Uint8Array expected")}function Ot(r,e){if(typeof e!="boolean")throw new Error(r+" boolean expected, got "+e)}function _n(r){const e=r.toString(16);return e.length&1?"0"+e:e}function iu(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Do:BigInt("0x"+r)}const ou=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Vp=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function mr(r){if(Ro(r),ou)return r.toHex();let e="";for(let t=0;t<r.length;t++)e+=Vp[r[t]];return e}const mt={_0:48,_9:57,A:65,F:70,a:97,f:102};function Ia(r){if(r>=mt._0&&r<=mt._9)return r-mt._0;if(r>=mt.A&&r<=mt.F)return r-(mt.A-10);if(r>=mt.a&&r<=mt.f)return r-(mt.a-10)}function ns(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(ou)return Uint8Array.fromHex(r);const e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let s=0,i=0;s<t;s++,i+=2){const o=Ia(r.charCodeAt(i)),a=Ia(r.charCodeAt(i+1));if(o===void 0||a===void 0){const c=r[i]+r[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}n[s]=o*16+a}return n}function Gt(r){return iu(mr(r))}function Yt(r){return Ro(r),iu(mr(Uint8Array.from(r).reverse()))}function yn(r,e){return ns(r.toString(16).padStart(e*2,"0"))}function Jr(r,e){return yn(r,e).reverse()}function de(r,e,t){let n;if(typeof e=="string")try{n=ns(e)}catch(i){throw new Error(r+" must be hex string or Uint8Array, cause: "+i)}else if(mn(e))n=Uint8Array.from(e);else throw new Error(r+" must be hex string or Uint8Array");const s=n.length;if(typeof t=="number"&&s!==t)throw new Error(r+" of length "+t+" expected, got "+s);return n}function yr(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];Ro(s),e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const i=r[n];t.set(i,s),s+=i.length}return t}const Js=r=>typeof r=="bigint"&&Do<=r;function Mo(r,e,t){return Js(r)&&Js(e)&&Js(t)&&e<=r&&r<t}function Ye(r,e,t,n){if(!Mo(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function Hp(r){let e;for(e=0;r>Do;r>>=Gi,e+=1);return e}const Ns=r=>(Gi<<BigInt(r))-Gi,ei=r=>new Uint8Array(r),Ta=r=>Uint8Array.from(r);function Gp(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=ei(r),s=ei(r),i=0;const o=()=>{n.fill(1),s.fill(0),i=0},a=(...d)=>t(s,n,...d),c=(d=ei(0))=>{s=a(Ta([0]),d),n=a(),d.length!==0&&(s=a(Ta([1]),d),n=a())},l=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let d=0;const h=[];for(;d<e;){n=a();const p=n.slice();h.push(p),d+=n.length}return yr(...h)};return(d,h)=>{o(),c(d);let p;for(;!(p=h(l()));)c();return o(),p}}const Yp={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||mn(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function Lr(r,e,t={}){const n=(s,i,o)=>{const a=Yp[i];if(typeof a!="function")throw new Error("invalid validator function");const c=r[s];if(!(o&&c===void 0)&&!a(c,r))throw new Error("param "+String(s)+" is invalid. Expected "+i+", got "+c)};for(const[s,i]of Object.entries(e))n(s,i,!1);for(const[s,i]of Object.entries(t))n(s,i,!0);return r}function ss(r){const e=new WeakMap;return(t,...n)=>{const s=e.get(t);if(s!==void 0)return s;const i=r(t,...n);return e.set(t,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ve=BigInt(0),ke=BigInt(1),Wt=BigInt(2),Xp=BigInt(3),au=BigInt(4),cu=BigInt(5),lu=BigInt(8);function ce(r,e){const t=r%e;return t>=Ve?t:e+t}function ue(r,e,t){let n=r;for(;e-- >Ve;)n*=n,n%=t;return n}function Yi(r,e){if(r===Ve)throw new Error("invert: expected non-zero number");if(e<=Ve)throw new Error("invert: expected positive modulus, got "+e);let t=ce(r,e),n=e,s=Ve,i=ke;for(;t!==Ve;){const a=n/t,c=n%t,l=s-i*a;n=t,t=c,s=i,i=l}if(n!==ke)throw new Error("invert: does not exist");return ce(s,e)}function uu(r,e){const t=(r.ORDER+ke)/au,n=r.pow(e,t);if(!r.eql(r.sqr(n),e))throw new Error("Cannot find square root");return n}function Qp(r,e){const t=(r.ORDER-cu)/lu,n=r.mul(e,Wt),s=r.pow(n,t),i=r.mul(e,s),o=r.mul(r.mul(i,Wt),s),a=r.mul(i,r.sub(o,r.ONE));if(!r.eql(r.sqr(a),e))throw new Error("Cannot find square root");return a}function jp(r){if(r<BigInt(3))throw new Error("sqrt is not defined for small field");let e=r-ke,t=0;for(;e%Wt===Ve;)e/=Wt,t++;let n=Wt;const s=wn(r);for(;ka(s,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return uu;let i=s.pow(n,e);const o=(e+ke)/Wt;return function(c,l){if(c.is0(l))return l;if(ka(c,l)!==1)throw new Error("Cannot find square root");let u=t,d=c.mul(c.ONE,i),h=c.pow(l,e),p=c.pow(l,o);for(;!c.eql(h,c.ONE);){if(c.is0(h))return c.ZERO;let f=1,g=c.sqr(h);for(;!c.eql(g,c.ONE);)if(f++,g=c.sqr(g),f===u)throw new Error("Cannot find square root");const m=ke<<BigInt(u-f-1),v=c.pow(d,m);u=f,d=c.sqr(v),h=c.mul(h,d),p=c.mul(p,v)}return p}}function Zp(r){return r%au===Xp?uu:r%lu===cu?Qp:jp(r)}const Jp=(r,e)=>(ce(r,e)&ke)===ke,eg=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function tg(r){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=eg.reduce((n,s)=>(n[s]="function",n),e);return Lr(r,t)}function rg(r,e,t){if(t<Ve)throw new Error("invalid exponent, negatives unsupported");if(t===Ve)return r.ONE;if(t===ke)return e;let n=r.ONE,s=e;for(;t>Ve;)t&ke&&(n=r.mul(n,s)),s=r.sqr(s),t>>=ke;return n}function Oo(r,e,t=!1){const n=new Array(e.length).fill(t?r.ZERO:void 0),s=e.reduce((o,a,c)=>r.is0(a)?o:(n[c]=o,r.mul(o,a)),r.ONE),i=r.inv(s);return e.reduceRight((o,a,c)=>r.is0(a)?o:(n[c]=r.mul(o,n[c]),r.mul(o,a)),i),n}function ka(r,e){const t=(r.ORDER-ke)/Wt,n=r.pow(e,t),s=r.eql(n,r.ONE),i=r.eql(n,r.ZERO),o=r.eql(n,r.neg(r.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function du(r,e){e!==void 0&&ts(e);const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function wn(r,e,t=!1,n={}){if(r<=Ve)throw new Error("invalid field: expected ORDER > 0, got "+r);const{nBitLength:s,nByteLength:i}=du(r,e);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const a=Object.freeze({ORDER:r,isLE:t,BITS:s,BYTES:i,MASK:Ns(s),ZERO:Ve,ONE:ke,create:c=>ce(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return Ve<=c&&c<r},is0:c=>c===Ve,isOdd:c=>(c&ke)===ke,neg:c=>ce(-c,r),eql:(c,l)=>c===l,sqr:c=>ce(c*c,r),add:(c,l)=>ce(c+l,r),sub:(c,l)=>ce(c-l,r),mul:(c,l)=>ce(c*l,r),pow:(c,l)=>rg(a,c,l),div:(c,l)=>ce(c*Yi(l,r),r),sqrN:c=>c*c,addN:(c,l)=>c+l,subN:(c,l)=>c-l,mulN:(c,l)=>c*l,inv:c=>Yi(c,r),sqrt:n.sqrt||(c=>(o||(o=Zp(r)),o(a,c))),toBytes:c=>t?Jr(c,i):yn(c,i),fromBytes:c=>{if(c.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+c.length);return t?Yt(c):Gt(c)},invertBatch:c=>Oo(a,c),cmov:(c,l,u)=>u?l:c});return Object.freeze(a)}function hu(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function fu(r){const e=hu(r);return e+Math.ceil(e/2)}function ng(r,e,t=!1){const n=r.length,s=hu(e),i=fu(e);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);const o=t?Yt(r):Gt(r),a=ce(o,e-ke)+ke;return t?Jr(a,s):yn(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _a=BigInt(0),Xi=BigInt(1);function ti(r,e){const t=e.negate();return r?t:e}function pu(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function ri(r,e){pu(r,e);const t=Math.ceil(e/r)+1,n=2**(r-1),s=2**r,i=Ns(r),o=BigInt(r);return{windows:t,windowSize:n,mask:i,maxNumber:s,shiftBy:o}}function Pa(r,e,t){const{windowSize:n,mask:s,maxNumber:i,shiftBy:o}=t;let a=Number(r&s),c=r>>o;a>n&&(a-=i,c+=Xi);const l=e*n,u=l+Math.abs(a)-1,d=a===0,h=a<0,p=e%2!==0;return{nextN:c,offset:u,isZero:d,isNeg:h,isNegF:p,offsetF:l}}function sg(r,e){if(!Array.isArray(r))throw new Error("array expected");r.forEach((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)})}function ig(r,e){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)})}const ni=new WeakMap,gu=new WeakMap;function si(r){return gu.get(r)||1}function mu(r,e){return{constTimeNegate:ti,hasPrecomputes(t){return si(t)!==1},unsafeLadder(t,n,s=r.ZERO){let i=t;for(;n>_a;)n&Xi&&(s=s.add(i)),i=i.double(),n>>=Xi;return s},precomputeWindow(t,n){const{windows:s,windowSize:i}=ri(n,e),o=[];let a=t,c=a;for(let l=0;l<s;l++){c=a,o.push(c);for(let u=1;u<i;u++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(t,n,s){let i=r.ZERO,o=r.BASE;const a=ri(t,e);for(let c=0;c<a.windows;c++){const{nextN:l,offset:u,isZero:d,isNeg:h,isNegF:p,offsetF:f}=Pa(s,c,a);s=l,d?o=o.add(ti(p,n[f])):i=i.add(ti(h,n[u]))}return{p:i,f:o}},wNAFUnsafe(t,n,s,i=r.ZERO){const o=ri(t,e);for(let a=0;a<o.windows&&s!==_a;a++){const{nextN:c,offset:l,isZero:u,isNeg:d}=Pa(s,a,o);if(s=c,!u){const h=n[l];i=i.add(d?h.negate():h)}}return i},getPrecomputes(t,n,s){let i=ni.get(n);return i||(i=this.precomputeWindow(n,t),t!==1&&ni.set(n,s(i))),i},wNAFCached(t,n,s){const i=si(t);return this.wNAF(i,this.getPrecomputes(i,t,s),n)},wNAFCachedUnsafe(t,n,s,i){const o=si(t);return o===1?this.unsafeLadder(t,n,i):this.wNAFUnsafe(o,this.getPrecomputes(o,t,s),n,i)},setWindowSize(t,n){pu(n,e),gu.set(t,n),ni.delete(t)}}}function yu(r,e,t,n){sg(t,r),ig(n,e);const s=t.length,i=n.length;if(s!==i)throw new Error("arrays of points and scalars must have equal length");const o=r.ZERO,a=Hp(BigInt(s));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const l=Ns(c),u=new Array(Number(l)+1).fill(o),d=Math.floor((e.BITS-1)/c)*c;let h=o;for(let p=d;p>=0;p-=c){u.fill(o);for(let g=0;g<i;g++){const m=n[g],v=Number(m>>BigInt(p)&l);u[v]=u[v].add(t[g])}let f=o;for(let g=u.length-1,m=o;g>0;g--)m=m.add(u[g]),f=f.add(m);if(h=h.add(f),p!==0)for(let g=0;g<c;g++)h=h.double()}return h}function No(r){return tg(r.Fp),Lr(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...du(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ct=BigInt(0),Ne=BigInt(1),La=BigInt(2),og=BigInt(8),ag={zip215:!0};function cg(r){const e=No(r);return Lr(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function lg(r){const e=cg(r),{Fp:t,n,prehash:s,hash:i,randomBytes:o,nByteLength:a,h:c}=e,l=La<<BigInt(a*8)-Ne,u=t.create,d=wn(e.n,e.nBitLength);function h(A,y){const S=t.sqr(A),T=t.sqr(y),O=t.add(t.mul(e.a,S),T),B=t.add(t.ONE,t.mul(e.d,t.mul(S,T)));return t.eql(O,B)}if(!h(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const p=e.uvRatio||((A,y)=>{try{return{isValid:!0,value:t.sqrt(A*t.inv(y))}}catch{return{isValid:!1,value:ct}}}),f=e.adjustScalarBytes||(A=>A),g=e.domain||((A,y,S)=>{if(Ot("phflag",S),y.length||S)throw new Error("Contexts/pre-hash are not supported");return A});function m(A,y,S=!1){const T=S?Ne:ct;Ye("coordinate "+A,y,T,l)}function v(A){if(!(A instanceof w))throw new Error("ExtendedPoint expected")}const k=ss((A,y)=>{const{ex:S,ey:T,ez:O}=A,B=A.is0();y==null&&(y=B?og:t.inv(O));const z=u(S*y),K=u(T*y),W=u(O*y);if(B)return{x:ct,y:Ne};if(W!==Ne)throw new Error("invZ was invalid");return{x:z,y:K}}),b=ss(A=>{const{a:y,d:S}=e;if(A.is0())throw new Error("bad point: ZERO");const{ex:T,ey:O,ez:B,et:z}=A,K=u(T*T),W=u(O*O),H=u(B*B),te=u(H*H),ee=u(K*y),xe=u(H*u(ee+W)),ze=u(te+u(S*u(K*W)));if(xe!==ze)throw new Error("bad point: equation left != right (1)");const Ee=u(T*O),Pe=u(B*z);if(Ee!==Pe)throw new Error("bad point: equation left != right (2)");return!0});class w{constructor(y,S,T,O){m("x",y),m("y",S),m("z",T,!0),m("t",O),this.ex=y,this.ey=S,this.ez=T,this.et=O,Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(y){if(y instanceof w)throw new Error("extended point not allowed");const{x:S,y:T}=y||{};return m("x",S),m("y",T),new w(S,T,Ne,u(S*T))}static normalizeZ(y){const S=Oo(t,y.map(T=>T.ez));return y.map((T,O)=>T.toAffine(S[O])).map(w.fromAffine)}static msm(y,S){return yu(w,d,y,S)}_setWindowSize(y){x.setWindowSize(this,y)}assertValidity(){b(this)}equals(y){v(y);const{ex:S,ey:T,ez:O}=this,{ex:B,ey:z,ez:K}=y,W=u(S*K),H=u(B*O),te=u(T*K),ee=u(z*O);return W===H&&te===ee}is0(){return this.equals(w.ZERO)}negate(){return new w(u(-this.ex),this.ey,this.ez,u(-this.et))}double(){const{a:y}=e,{ex:S,ey:T,ez:O}=this,B=u(S*S),z=u(T*T),K=u(La*u(O*O)),W=u(y*B),H=S+T,te=u(u(H*H)-B-z),ee=W+z,xe=ee-K,ze=W-z,Ee=u(te*xe),Pe=u(ee*ze),He=u(te*ze),et=u(xe*ee);return new w(Ee,Pe,et,He)}add(y){v(y);const{a:S,d:T}=e,{ex:O,ey:B,ez:z,et:K}=this,{ex:W,ey:H,ez:te,et:ee}=y,xe=u(O*W),ze=u(B*H),Ee=u(K*T*ee),Pe=u(z*te),He=u((O+B)*(W+H)-xe-ze),et=Pe-Ee,Or=Pe+Ee,da=u(ze-S*xe),Th=u(He*et),kh=u(Or*da),_h=u(He*da),Ph=u(et*Or);return new w(Th,kh,Ph,_h)}subtract(y){return this.add(y.negate())}wNAF(y){return x.wNAFCached(this,y,w.normalizeZ)}multiply(y){const S=y;Ye("scalar",S,Ne,n);const{p:T,f:O}=this.wNAF(S);return w.normalizeZ([T,O])[0]}multiplyUnsafe(y,S=w.ZERO){const T=y;return Ye("scalar",T,ct,n),T===ct?P:this.is0()||T===Ne?this:x.wNAFCachedUnsafe(this,T,w.normalizeZ,S)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return x.unsafeLadder(this,n).is0()}toAffine(y){return k(this,y)}clearCofactor(){const{h:y}=e;return y===Ne?this:this.multiplyUnsafe(y)}static fromHex(y,S=!1){const{d:T,a:O}=e,B=t.BYTES;y=de("pointHex",y,B),Ot("zip215",S);const z=y.slice(),K=y[B-1];z[B-1]=K&-129;const W=Yt(z),H=S?l:t.ORDER;Ye("pointHex.y",W,ct,H);const te=u(W*W),ee=u(te-Ne),xe=u(T*te-O);let{isValid:ze,value:Ee}=p(ee,xe);if(!ze)throw new Error("Point.fromHex: invalid y coordinate");const Pe=(Ee&Ne)===Ne,He=(K&128)!==0;if(!S&&Ee===ct&&He)throw new Error("Point.fromHex: x=0 and x_0=1");return He!==Pe&&(Ee=u(-Ee)),w.fromAffine({x:Ee,y:W})}static fromPrivateKey(y){const{scalar:S}=F(y);return E.multiply(S)}toRawBytes(){const{x:y,y:S}=this.toAffine(),T=Jr(S,t.BYTES);return T[T.length-1]|=y&Ne?128:0,T}toHex(){return mr(this.toRawBytes())}}w.BASE=new w(e.Gx,e.Gy,Ne,u(e.Gx*e.Gy)),w.ZERO=new w(ct,Ne,Ne,ct);const{BASE:E,ZERO:P}=w,x=mu(w,a*8);function _(A){return ce(A,n)}function D(A){return _(Yt(A))}function F(A){const y=t.BYTES;A=de("private key",A,y);const S=de("hashed private key",i(A),2*y),T=f(S.slice(0,y)),O=S.slice(y,2*y),B=D(T);return{head:T,prefix:O,scalar:B}}function L(A){const{head:y,prefix:S,scalar:T}=F(A),O=E.multiply(T),B=O.toRawBytes();return{head:y,prefix:S,scalar:T,point:O,pointBytes:B}}function N(A){return L(A).pointBytes}function R(A=Uint8Array.of(),...y){const S=yr(...y);return D(i(g(S,de("context",A),!!s)))}function $(A,y,S={}){A=de("message",A),s&&(A=s(A));const{prefix:T,scalar:O,pointBytes:B}=L(y),z=R(S.context,T,A),K=E.multiply(z).toRawBytes(),W=R(S.context,K,B,A),H=_(z+W*O);Ye("signature.s",H,ct,n);const te=yr(K,Jr(H,t.BYTES));return de("result",te,t.BYTES*2)}const C=ag;function I(A,y,S,T=C){const{context:O,zip215:B}=T,z=t.BYTES;A=de("signature",A,2*z),y=de("message",y),S=de("publicKey",S,z),B!==void 0&&Ot("zip215",B),s&&(y=s(y));const K=Yt(A.slice(z,2*z));let W,H,te;try{W=w.fromHex(S,B),H=w.fromHex(A.slice(0,z),B),te=E.multiplyUnsafe(K)}catch{return!1}if(!B&&W.isSmallOrder())return!1;const ee=R(O,H.toRawBytes(),W.toRawBytes(),y);return H.add(W.multiplyUnsafe(ee)).subtract(te).clearCofactor().equals(w.ZERO)}return E._setWindowSize(8),{CURVE:e,getPublicKey:N,sign:$,verify:I,ExtendedPoint:w,utils:{getExtendedPublicKey:L,randomPrivateKey:()=>o(t.BYTES),precompute(A=8,y=w.BASE){return y._setWindowSize(A),y.multiply(BigInt(3)),y}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Br=BigInt(0),ir=BigInt(1),Pn=BigInt(2);function ug(r){return Lr(r,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...r})}function dg(r){const e=ug(r),{P:t,type:n,adjustScalarBytes:s,powPminus2:i}=e,o=n==="x25519";if(!o&&n!=="x448")throw new Error("invalid type");const a=o?255:448,c=o?32:56,l=BigInt(o?9:5),u=BigInt(o?121665:39081),d=o?Pn**BigInt(254):Pn**BigInt(447),h=o?BigInt(8)*Pn**BigInt(251)-ir:BigInt(4)*Pn**BigInt(445)-ir,p=d+h+ir,f=x=>ce(x,t),g=m(l);function m(x){return Jr(f(x),c)}function v(x){const _=de("u coordinate",x,c);return o&&(_[31]&=127),f(Yt(_))}function k(x){return Yt(s(de("scalar",x,c)))}function b(x,_){const D=P(v(_),k(x));if(D===Br)throw new Error("invalid private or public key received");return m(D)}function w(x){return b(x,g)}function E(x,_,D){const F=f(x*(_-D));return _=f(_-F),D=f(D+F),{x_2:_,x_3:D}}function P(x,_){Ye("u",x,Br,t),Ye("scalar",_,d,p);const D=_,F=x;let L=ir,N=Br,R=x,$=ir,C=Br;for(let M=BigInt(a-1);M>=Br;M--){const A=D>>M&ir;C^=A,{x_2:L,x_3:R}=E(C,L,R),{x_2:N,x_3:$}=E(C,N,$),C=A;const y=L+N,S=f(y*y),T=L-N,O=f(T*T),B=S-O,z=R+$,K=R-$,W=f(K*y),H=f(z*T),te=W+H,ee=W-H;R=f(te*te),$=f(F*f(ee*ee)),L=f(S*O),N=f(B*(S+f(u*B)))}({x_2:L,x_3:R}=E(C,L,R)),{x_2:N,x_3:$}=E(C,N,$);const I=i(N);return f(L*I)}return{scalarMult:b,scalarMultBase:w,getSharedSecret:(x,_)=>b(x,_),getPublicKey:x=>w(x),utils:{randomPrivateKey:()=>e.randomBytes(c)},GuBytes:g.slice()}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const en=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Da=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const hg=BigInt(1),Ra=BigInt(2),fg=BigInt(3),pg=BigInt(5),gg=BigInt(8);function wu(r){const e=BigInt(10),t=BigInt(20),n=BigInt(40),s=BigInt(80),i=en,a=r*r%i*r%i,c=ue(a,Ra,i)*a%i,l=ue(c,hg,i)*r%i,u=ue(l,pg,i)*l%i,d=ue(u,e,i)*u%i,h=ue(d,t,i)*d%i,p=ue(h,n,i)*h%i,f=ue(p,s,i)*p%i,g=ue(f,s,i)*p%i,m=ue(g,e,i)*u%i;return{pow_p_5_8:ue(m,Ra,i)*r%i,b2:a}}function bu(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function mg(r,e){const t=en,n=ce(e*e*e,t),s=ce(n*n*e,t),i=wu(r*s).pow_p_5_8;let o=ce(r*n*i,t);const a=ce(e*o*o,t),c=o,l=ce(o*Da,t),u=a===r,d=a===ce(-r,t),h=a===ce(-r*Da,t);return u&&(o=c),(d||h)&&(o=l),Jp(o,t)&&(o=ce(-o,t)),{isValid:u||d,value:o}}const Ma=wn(en,void 0,!0),yg={a:Ma.create(BigInt(-1)),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Ma,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:gg,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Wp,randomBytes:Os,adjustScalarBytes:bu,uvRatio:mg},is=lg(yg),Ln=dg({P:en,type:"x25519",powPminus2:r=>{const e=en,{pow_p_5_8:t,b2:n}=wu(r);return ce(ue(t,fg,e)*n,e)},adjustScalarBytes:bu,randomBytes:Os}),vu=32,Eu=64,Qi=32;function wg(){const r=is.utils.randomPrivateKey(),e=is.getPublicKey(r);return{privateKey:Eg(r,e),publicKey:e}}function bg(r,e){const t=r.subarray(0,Qi);return is.sign(e instanceof Uint8Array?e:e.subarray(),t)}function vg(r,e,t){return is.verify(e,t instanceof Uint8Array?t:t.subarray(),r)}function Eg(r,e){const t=new Uint8Array(Eu);for(let n=0;n<Qi;n++)t[n]=r[n],t[Qi+n]=e[n];return t}class Su{type="Ed25519";raw;constructor(e){this.raw=Fo(e,vu)}toMultihash(){return fn.digest(xt(this))}toCID(){return ae.createV1(114,this.toMultihash())}toString(){return ye.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Oe(this.raw,e.raw)}verify(e,t){return vg(this.raw,t,e)}}class Sg{type="Ed25519";raw;publicKey;constructor(e,t){this.raw=Fo(e,Eu),this.publicKey=new Su(t)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Oe(this.raw,e.raw)}sign(e){return bg(this.raw,e)}}function xu(r){return r=Fo(r,vu),new Su(r)}async function xg(){const{privateKey:r,publicKey:e}=wg();return new Sg(r,e)}function Fo(r,e){if(r=Uint8Array.from(r??[]),r.length!==e)throw new V(`Key must be a Uint8Array of length ${e}, got ${r.length}`);return r}const Ag=Math.pow(2,7),Cg=Math.pow(2,14),Ig=Math.pow(2,21),Uo=Math.pow(2,28),Bo=Math.pow(2,35),$o=Math.pow(2,42),zo=Math.pow(2,49),re=128,De=127;function Ie(r){if(r<Ag)return 1;if(r<Cg)return 2;if(r<Ig)return 3;if(r<Uo)return 4;if(r<Bo)return 5;if(r<$o)return 6;if(r<zo)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Au(r,e,t=0){switch(Ie(r)){case 8:e[t++]=r&255|re,r/=128;case 7:e[t++]=r&255|re,r/=128;case 6:e[t++]=r&255|re,r/=128;case 5:e[t++]=r&255|re,r/=128;case 4:e[t++]=r&255|re,r>>>=7;case 3:e[t++]=r&255|re,r>>>=7;case 2:e[t++]=r&255|re,r>>>=7;case 1:{e[t++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return e}function Tg(r,e,t=0){switch(Ie(r)){case 8:e.set(t++,r&255|re),r/=128;case 7:e.set(t++,r&255|re),r/=128;case 6:e.set(t++,r&255|re),r/=128;case 5:e.set(t++,r&255|re),r/=128;case 4:e.set(t++,r&255|re),r>>>=7;case 3:e.set(t++,r&255|re),r>>>=7;case 2:e.set(t++,r&255|re),r>>>=7;case 1:{e.set(t++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return e}function Cu(r,e){let t=r[e],n=0;if(n+=t&De,t<re||(t=r[e+1],n+=(t&De)<<7,t<re)||(t=r[e+2],n+=(t&De)<<14,t<re)||(t=r[e+3],n+=(t&De)<<21,t<re)||(t=r[e+4],n+=(t&De)*Uo,t<re)||(t=r[e+5],n+=(t&De)*Bo,t<re)||(t=r[e+6],n+=(t&De)*$o,t<re)||(t=r[e+7],n+=(t&De)*zo,t<re))return n;throw new RangeError("Could not decode varint")}function kg(r,e){let t=r.get(e),n=0;if(n+=t&De,t<re||(t=r.get(e+1),n+=(t&De)<<7,t<re)||(t=r.get(e+2),n+=(t&De)<<14,t<re)||(t=r.get(e+3),n+=(t&De)<<21,t<re)||(t=r.get(e+4),n+=(t&De)*Uo,t<re)||(t=r.get(e+5),n+=(t&De)*Bo,t<re)||(t=r.get(e+6),n+=(t&De)*$o,t<re)||(t=r.get(e+7),n+=(t&De)*zo,t<re))return n;throw new RangeError("Could not decode varint")}function dt(r,e,t=0){return e==null&&(e=ft(Ie(r))),e instanceof Uint8Array?Au(r,e,t):Tg(r,e,t)}function tr(r,e=0){return r instanceof Uint8Array?Cu(r,e):kg(r,e)}const Ko=new Float32Array([-0]),Rt=new Uint8Array(Ko.buffer);function _g(r,e,t){Ko[0]=r,e[t]=Rt[0],e[t+1]=Rt[1],e[t+2]=Rt[2],e[t+3]=Rt[3]}function Pg(r,e){return Rt[0]=r[e],Rt[1]=r[e+1],Rt[2]=r[e+2],Rt[3]=r[e+3],Ko[0]}const qo=new Float64Array([-0]),Re=new Uint8Array(qo.buffer);function Lg(r,e,t){qo[0]=r,e[t]=Re[0],e[t+1]=Re[1],e[t+2]=Re[2],e[t+3]=Re[3],e[t+4]=Re[4],e[t+5]=Re[5],e[t+6]=Re[6],e[t+7]=Re[7]}function Dg(r,e){return Re[0]=r[e],Re[1]=r[e+1],Re[2]=r[e+2],Re[3]=r[e+3],Re[4]=r[e+4],Re[5]=r[e+5],Re[6]=r[e+6],Re[7]=r[e+7],qo[0]}const Rg=BigInt(Number.MAX_SAFE_INTEGER),Mg=BigInt(Number.MIN_SAFE_INTEGER);class Me{lo;hi;constructor(e,t){this.lo=e|0,this.hi=t|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(t+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(BigInt(t)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?t===0?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:n<128?9:10}static fromBigInt(e){if(e===0n)return Xt;if(e<Rg&&e>Mg)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let n=e>>32n,s=e-(n<<32n);return t&&(n=~n|0n,s=~s|0n,++s>Oa&&(s=0n,++n>Oa&&(n=0n))),new Me(Number(s),Number(n))}static fromNumber(e){if(e===0)return Xt;const t=e<0;t&&(e=-e);let n=e>>>0,s=(e-n)/4294967296>>>0;return t&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new Me(n,s)}static from(e){return typeof e=="number"?Me.fromNumber(e):typeof e=="bigint"?Me.fromBigInt(e):typeof e=="string"?Me.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new Me(e.low>>>0,e.high>>>0):Xt}}const Xt=new Me(0,0);Xt.toBigInt=function(){return 0n};Xt.zzEncode=Xt.zzDecode=function(){return this};Xt.length=function(){return 1};const Oa=4294967296n;function Og(r){let e=0,t=0;for(let n=0;n<r.length;++n)t=r.charCodeAt(n),t<128?e+=1:t<2048?e+=2:(t&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,e+=4):e+=3;return e}function Ng(r,e,t){if(t-e<1)return"";let s;const i=[];let o=0,a;for(;e<t;)a=r[e++],a<128?i[o++]=a:a>191&&a<224?i[o++]=(a&31)<<6|r[e++]&63:a>239&&a<365?(a=((a&7)<<18|(r[e++]&63)<<12|(r[e++]&63)<<6|r[e++]&63)-65536,i[o++]=55296+(a>>10),i[o++]=56320+(a&1023)):i[o++]=(a&15)<<12|(r[e++]&63)<<6|r[e++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function Iu(r,e,t){const n=t;let s,i;for(let o=0;o<r.length;++o)s=r.charCodeAt(o),s<128?e[t++]=s:s<2048?(e[t++]=s>>6|192,e[t++]=s&63|128):(s&64512)===55296&&((i=r.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,e[t++]=s>>18|240,e[t++]=s>>12&63|128,e[t++]=s>>6&63|128,e[t++]=s&63|128):(e[t++]=s>>12|224,e[t++]=s>>6&63|128,e[t++]=s&63|128);return t-n}function tt(r,e){return RangeError(`index out of range: ${r.pos} + ${e??1} > ${r.len}`)}function Dn(r,e){return(r[e-4]|r[e-3]<<8|r[e-2]<<16|r[e-1]<<24)>>>0}class Fg{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(e){this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,tt(this,10);return e}int32(){return this.uint32()|0}sint32(){const e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw tt(this,4);return Dn(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw tt(this,4);return Dn(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw tt(this,4);const e=Pg(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw tt(this,4);const e=Dg(this.buf,this.pos);return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,n=this.pos+e;if(n>this.len)throw tt(this,e);return this.pos+=e,t===n?new Uint8Array(0):this.buf.subarray(t,n)}string(){const e=this.bytes();return Ng(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw tt(this,e);this.pos+=e}else do if(this.pos>=this.len)throw tt(this);while((this.buf[this.pos++]&128)!==0);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new Me(0,0);let t=0;if(this.len-this.pos>4){for(;t<4;++t)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw tt(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,e}if(this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw tt(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw tt(this,8);const e=Dn(this.buf,this.pos+=4),t=Dn(this.buf,this.pos+=4);return new Me(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=Cu(this.buf,this.pos);return this.pos+=Ie(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function Ug(r){return new Fg(r instanceof Uint8Array?r:r.subarray())}function pe(r,e,t){const n=Ug(r);return e.decode(n,void 0,t)}function Bg(r){let n,s=8192;return function(o){if(o<1||o>4096)return ft(o);s+o>8192&&(n=ft(8192),s=0);const a=n.subarray(s,s+=o);return(s&7)!==0&&(s=(s|7)+1),a}}class qr{fn;len;next;val;constructor(e,t,n){this.fn=e,this.len=t,this.next=void 0,this.val=n}}function ii(){}class $g{head;tail;len;next;constructor(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}}const zg=Bg();function Kg(r){return globalThis.Buffer!=null?ft(r):zg(r)}class ji{len;head;tail;states;constructor(){this.len=0,this.head=new qr(ii,0,0),this.tail=this.head,this.states=null}_push(e,t,n){return this.tail=this.tail.next=new qr(e,t,n),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new Wg((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(Rn,10,Me.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=Me.fromBigInt(e);return this._push(Rn,t.length(),t)}uint64Number(e){return this._push(Au,Ie(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=Me.fromBigInt(e).zzEncode();return this._push(Rn,t.length(),t)}sint64Number(e){const t=Me.fromNumber(e).zzEncode();return this._push(Rn,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(oi,1,e?1:0)}fixed32(e){return this._push($r,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=Me.fromBigInt(e);return this._push($r,4,t.lo)._push($r,4,t.hi)}fixed64Number(e){const t=Me.fromNumber(e);return this._push($r,4,t.lo)._push($r,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(_g,4,e)}double(e){return this._push(Lg,8,e)}bytes(e){const t=e.length>>>0;return t===0?this._push(oi,1,0):this.uint32(t)._push(Vg,t,e)}string(e){const t=Og(e);return t!==0?this.uint32(t)._push(Iu,t,e):this._push(oi,1,0)}fork(){return this.states=new $g(this),this.head=this.tail=new qr(ii,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new qr(ii,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=e.next,this.tail=t,this.len+=n),this}finish(){let e=this.head.next;const t=Kg(this.len);let n=0;for(;e!=null;)e.fn(e.val,t,n),n+=e.len,e=e.next;return t}}function oi(r,e,t){e[t]=r&255}function qg(r,e,t){for(;r>127;)e[t++]=r&127|128,r>>>=7;e[t]=r}class Wg extends qr{next;constructor(e,t){super(qg,e,t),this.next=void 0}}function Rn(r,e,t){for(;r.hi!==0;)e[t++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)e[t++]=r.lo&127|128,r.lo=r.lo>>>7;e[t++]=r.lo}function $r(r,e,t){e[t]=r&255,e[t+1]=r>>>8&255,e[t+2]=r>>>16&255,e[t+3]=r>>>24}function Vg(r,e,t){e.set(r,t)}globalThis.Buffer!=null&&(ji.prototype.bytes=function(r){const e=r.length>>>0;return this.uint32(e),e>0&&this._push(Hg,e,r),this},ji.prototype.string=function(r){const e=globalThis.Buffer.byteLength(r);return this.uint32(e),e>0&&this._push(Gg,e,r),this});function Hg(r,e,t){e.set(r,t)}function Gg(r,e,t){r.length<40?Iu(r,e,t):e.utf8Write!=null?e.utf8Write(r,t):e.set(q(r),t)}function Yg(){return new ji}function ge(r,e){const t=Yg();return e.encode(r,t,{lengthDelimited:!1}),t.finish()}var os;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(os||(os={}));function Tu(r,e,t,n){return{name:r,type:e,encode:t,decode:n}}function Dr(r){function e(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}const t=function(i,o){const a=e(i);o.int32(a)},n=function(i){const o=i.int32();return e(o)};return Tu("enum",os.VARINT,t,n)}function me(r,e){return Tu("message",os.LENGTH_DELIMITED,r,e)}class Ct extends Error{code="ERR_MAX_LENGTH";name="MaxLengthError"}class Na extends Error{code="ERR_MAX_SIZE";name="MaxSizeError"}var Te;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1",r.ECDSA="ECDSA"})(Te||(Te={}));var Zi;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1",r[r.ECDSA=3]="ECDSA"})(Zi||(Zi={}));(function(r){r.codec=()=>Dr(Zi)})(Te||(Te={}));var wr;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),Te.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.Type=Te.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(wr||(wr={}));var Fa;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),Te.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.Type=Te.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(Fa||(Fa={}));function Wo(r){if(isNaN(r)||r<=0)throw new V("random bytes length must be a Number bigger than 0");return Os(r)}class Ua extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}}class Xg extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}}const Ba={get(r=globalThis){const e=r.crypto;if(e?.subtle==null)throw new Xg("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return e}},Yn=su;class Qg{type="RSA";jwk;_raw;_multihash;constructor(e,t){this.jwk=e,this._multihash=t}get raw(){return this._raw==null&&(this._raw=tm(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return ae.createV1(114,this._multihash)}toString(){return ye.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Oe(this.raw,e.raw)}verify(e,t){return sm(this.jwk,t,e)}}const jg=18,Zg=1062,Jg=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function em(r){const e=Ms(r[1],{offset:0});return{kty:"RSA",n:Y(e[0],"base64url"),e:Y(e[1],"base64url")}}function tm(r){if(r.n==null||r.e==null)throw new V("JWK was missing components");return Hr([Jg,Zl(Hr([Hi(q(r.n,"base64url")),Hi(q(r.e,"base64url"))]))]).subarray()}function rm(r,e){if(r.byteLength>=Zg)throw new Rl("Key size is too large");const t=Ms(r,{offset:0});return nm(t,r,e)}function nm(r,e,t){const n=em(r);if(t==null){const s=Yn(wr.encode({Type:Te.RSA,Data:e}));t=jr(jg,s)}return new Qg(n,t)}async function sm(r,e,t){const n=await Ba.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);return Ba.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},n,e,t instanceof Uint8Array?t:t.subarray())}class ku extends eu{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Lo(e);const n=Zr(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(n.length>s?e.create().update(n).digest():n);for(let o=0;o<i.length;o++)i[o]^=54;this.iHash.update(i),this.oHash=e.create();for(let o=0;o<i.length;o++)i[o]^=106;this.oHash.update(i),jt(i)}update(e){return rs(this),this.iHash.update(e),this}digestInto(e){rs(this),gn(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=i,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Fs=(r,e,t)=>new ku(r,e).update(t).digest();Fs.create=(r,e)=>new ku(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function $a(r){r.lowS!==void 0&&Ot("lowS",r.lowS),r.prehash!==void 0&&Ot("prehash",r.prehash)}function im(r){const e=No(r);Lr(e,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:t,Fp:n,a:s}=e;if(t){if(!n.eql(s,n.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...e})}class om extends Error{constructor(e=""){super(e)}}const vt={Err:om,_tlv:{encode:(r,e)=>{const{Err:t}=vt;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const n=e.length/2,s=_n(n);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const i=n>127?_n(s.length/2|128):"";return _n(r)+i+s+e},decode(r,e){const{Err:t}=vt;let n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");const s=e[n++],i=!!(s&128);let o=0;if(!i)o=s;else{const c=s&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const l=e.subarray(n,n+c);if(l.length!==c)throw new t("tlv.decode: length bytes not complete");if(l[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const u of l)o=o<<8|u;if(n+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(n,n+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+o)}}},_int:{encode(r){const{Err:e}=vt;if(r<Et)throw new e("integer: negative integers are not allowed");let t=_n(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(r){const{Err:e}=vt;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return Gt(r)}},toSig(r){const{Err:e,_int:t,_tlv:n}=vt,s=de("signature",r),{v:i,l:o}=n.decode(48,s);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,i),{v:l,l:u}=n.decode(2,c);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(l)}},hexFromSig(r){const{_tlv:e,_int:t}=vt,n=e.encode(2,t.encode(r.r)),s=e.encode(2,t.encode(r.s)),i=n+s;return e.encode(48,i)}};function ai(r,e){return mr(yn(r,e))}const Et=BigInt(0),Se=BigInt(1);BigInt(2);const ci=BigInt(3),am=BigInt(4);function cm(r){const e=im(r),{Fp:t}=e,n=wn(e.n,e.nBitLength),s=e.toBytes||((b,w,E)=>{const P=w.toAffine();return yr(Uint8Array.from([4]),t.toBytes(P.x),t.toBytes(P.y))}),i=e.fromBytes||(b=>{const w=b.subarray(1),E=t.fromBytes(w.subarray(0,t.BYTES)),P=t.fromBytes(w.subarray(t.BYTES,2*t.BYTES));return{x:E,y:P}});function o(b){const{a:w,b:E}=e,P=t.sqr(b),x=t.mul(P,b);return t.add(t.add(x,t.mul(b,w)),E)}function a(b,w){const E=t.sqr(w),P=o(b);return t.eql(E,P)}if(!a(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const c=t.mul(t.pow(e.a,ci),am),l=t.mul(t.sqr(e.b),BigInt(27));if(t.is0(t.add(c,l)))throw new Error("bad curve params: a or b");function u(b){return Mo(b,Se,e.n)}function d(b){const{allowedPrivateKeyLengths:w,nByteLength:E,wrapPrivateKey:P,n:x}=e;if(w&&typeof b!="bigint"){if(mn(b)&&(b=mr(b)),typeof b!="string"||!w.includes(b.length))throw new Error("invalid private key");b=b.padStart(E*2,"0")}let _;try{_=typeof b=="bigint"?b:Gt(de("private key",b,E))}catch{throw new Error("invalid private key, expected hex or "+E+" bytes, got "+typeof b)}return P&&(_=ce(_,x)),Ye("private key",_,Se,x),_}function h(b){if(!(b instanceof g))throw new Error("ProjectivePoint expected")}const p=ss((b,w)=>{const{px:E,py:P,pz:x}=b;if(t.eql(x,t.ONE))return{x:E,y:P};const _=b.is0();w==null&&(w=_?t.ONE:t.inv(x));const D=t.mul(E,w),F=t.mul(P,w),L=t.mul(x,w);if(_)return{x:t.ZERO,y:t.ZERO};if(!t.eql(L,t.ONE))throw new Error("invZ was invalid");return{x:D,y:F}}),f=ss(b=>{if(b.is0()){if(e.allowInfinityPoint&&!t.is0(b.py))return;throw new Error("bad point: ZERO")}const{x:w,y:E}=b.toAffine();if(!t.isValid(w)||!t.isValid(E))throw new Error("bad point: x or y not FE");if(!a(w,E))throw new Error("bad point: equation left != right");if(!b.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(w,E,P){if(w==null||!t.isValid(w))throw new Error("x required");if(E==null||!t.isValid(E)||t.is0(E))throw new Error("y required");if(P==null||!t.isValid(P))throw new Error("z required");this.px=w,this.py=E,this.pz=P,Object.freeze(this)}static fromAffine(w){const{x:E,y:P}=w||{};if(!w||!t.isValid(E)||!t.isValid(P))throw new Error("invalid affine point");if(w instanceof g)throw new Error("projective point not allowed");const x=_=>t.eql(_,t.ZERO);return x(E)&&x(P)?g.ZERO:new g(E,P,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(w){const E=Oo(t,w.map(P=>P.pz));return w.map((P,x)=>P.toAffine(E[x])).map(g.fromAffine)}static fromHex(w){const E=g.fromAffine(i(de("pointHex",w)));return E.assertValidity(),E}static fromPrivateKey(w){return g.BASE.multiply(d(w))}static msm(w,E){return yu(g,n,w,E)}_setWindowSize(w){k.setWindowSize(this,w)}assertValidity(){f(this)}hasEvenY(){const{y:w}=this.toAffine();if(t.isOdd)return!t.isOdd(w);throw new Error("Field doesn't support isOdd")}equals(w){h(w);const{px:E,py:P,pz:x}=this,{px:_,py:D,pz:F}=w,L=t.eql(t.mul(E,F),t.mul(_,x)),N=t.eql(t.mul(P,F),t.mul(D,x));return L&&N}negate(){return new g(this.px,t.neg(this.py),this.pz)}double(){const{a:w,b:E}=e,P=t.mul(E,ci),{px:x,py:_,pz:D}=this;let F=t.ZERO,L=t.ZERO,N=t.ZERO,R=t.mul(x,x),$=t.mul(_,_),C=t.mul(D,D),I=t.mul(x,_);return I=t.add(I,I),N=t.mul(x,D),N=t.add(N,N),F=t.mul(w,N),L=t.mul(P,C),L=t.add(F,L),F=t.sub($,L),L=t.add($,L),L=t.mul(F,L),F=t.mul(I,F),N=t.mul(P,N),C=t.mul(w,C),I=t.sub(R,C),I=t.mul(w,I),I=t.add(I,N),N=t.add(R,R),R=t.add(N,R),R=t.add(R,C),R=t.mul(R,I),L=t.add(L,R),C=t.mul(_,D),C=t.add(C,C),R=t.mul(C,I),F=t.sub(F,R),N=t.mul(C,$),N=t.add(N,N),N=t.add(N,N),new g(F,L,N)}add(w){h(w);const{px:E,py:P,pz:x}=this,{px:_,py:D,pz:F}=w;let L=t.ZERO,N=t.ZERO,R=t.ZERO;const $=e.a,C=t.mul(e.b,ci);let I=t.mul(E,_),M=t.mul(P,D),A=t.mul(x,F),y=t.add(E,P),S=t.add(_,D);y=t.mul(y,S),S=t.add(I,M),y=t.sub(y,S),S=t.add(E,x);let T=t.add(_,F);return S=t.mul(S,T),T=t.add(I,A),S=t.sub(S,T),T=t.add(P,x),L=t.add(D,F),T=t.mul(T,L),L=t.add(M,A),T=t.sub(T,L),R=t.mul($,S),L=t.mul(C,A),R=t.add(L,R),L=t.sub(M,R),R=t.add(M,R),N=t.mul(L,R),M=t.add(I,I),M=t.add(M,I),A=t.mul($,A),S=t.mul(C,S),M=t.add(M,A),A=t.sub(I,A),A=t.mul($,A),S=t.add(S,A),I=t.mul(M,S),N=t.add(N,I),I=t.mul(T,S),L=t.mul(y,L),L=t.sub(L,I),I=t.mul(y,M),R=t.mul(T,R),R=t.add(R,I),new g(L,N,R)}subtract(w){return this.add(w.negate())}is0(){return this.equals(g.ZERO)}wNAF(w){return k.wNAFCached(this,w,g.normalizeZ)}multiplyUnsafe(w){const{endo:E,n:P}=e;Ye("scalar",w,Et,P);const x=g.ZERO;if(w===Et)return x;if(this.is0()||w===Se)return this;if(!E||k.hasPrecomputes(this))return k.wNAFCachedUnsafe(this,w,g.normalizeZ);let{k1neg:_,k1:D,k2neg:F,k2:L}=E.splitScalar(w),N=x,R=x,$=this;for(;D>Et||L>Et;)D&Se&&(N=N.add($)),L&Se&&(R=R.add($)),$=$.double(),D>>=Se,L>>=Se;return _&&(N=N.negate()),F&&(R=R.negate()),R=new g(t.mul(R.px,E.beta),R.py,R.pz),N.add(R)}multiply(w){const{endo:E,n:P}=e;Ye("scalar",w,Se,P);let x,_;if(E){const{k1neg:D,k1:F,k2neg:L,k2:N}=E.splitScalar(w);let{p:R,f:$}=this.wNAF(F),{p:C,f:I}=this.wNAF(N);R=k.constTimeNegate(D,R),C=k.constTimeNegate(L,C),C=new g(t.mul(C.px,E.beta),C.py,C.pz),x=R.add(C),_=$.add(I)}else{const{p:D,f:F}=this.wNAF(w);x=D,_=F}return g.normalizeZ([x,_])[0]}multiplyAndAddUnsafe(w,E,P){const x=g.BASE,_=(F,L)=>L===Et||L===Se||!F.equals(x)?F.multiplyUnsafe(L):F.multiply(L),D=_(this,E).add(_(w,P));return D.is0()?void 0:D}toAffine(w){return p(this,w)}isTorsionFree(){const{h:w,isTorsionFree:E}=e;if(w===Se)return!0;if(E)return E(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:w,clearCofactor:E}=e;return w===Se?this:E?E(g,this):this.multiplyUnsafe(e.h)}toRawBytes(w=!0){return Ot("isCompressed",w),this.assertValidity(),s(g,this,w)}toHex(w=!0){return Ot("isCompressed",w),mr(this.toRawBytes(w))}}g.BASE=new g(e.Gx,e.Gy,t.ONE),g.ZERO=new g(t.ZERO,t.ONE,t.ZERO);const{endo:m,nBitLength:v}=e,k=mu(g,m?Math.ceil(v/2):v);return{CURVE:e,ProjectivePoint:g,normPrivateKeyToScalar:d,weierstrassEquation:o,isWithinCurveOrder:u}}function lm(r){const e=No(r);return Lr(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function um(r){const e=lm(r),{Fp:t,n,nByteLength:s,nBitLength:i}=e,o=t.BYTES+1,a=2*t.BYTES+1;function c(C){return ce(C,n)}function l(C){return Yi(C,n)}const{ProjectivePoint:u,normPrivateKeyToScalar:d,weierstrassEquation:h,isWithinCurveOrder:p}=cm({...e,toBytes(C,I,M){const A=I.toAffine(),y=t.toBytes(A.x),S=yr;return Ot("isCompressed",M),M?S(Uint8Array.from([I.hasEvenY()?2:3]),y):S(Uint8Array.from([4]),y,t.toBytes(A.y))},fromBytes(C){const I=C.length,M=C[0],A=C.subarray(1);if(I===o&&(M===2||M===3)){const y=Gt(A);if(!Mo(y,Se,t.ORDER))throw new Error("Point is not on curve");const S=h(y);let T;try{T=t.sqrt(S)}catch(z){const K=z instanceof Error?": "+z.message:"";throw new Error("Point is not on curve"+K)}const O=(T&Se)===Se;return(M&1)===1!==O&&(T=t.neg(T)),{x:y,y:T}}else if(I===a&&M===4){const y=t.fromBytes(A.subarray(0,t.BYTES)),S=t.fromBytes(A.subarray(t.BYTES,2*t.BYTES));return{x:y,y:S}}else{const y=o,S=a;throw new Error("invalid Point, expected length of "+y+", or uncompressed "+S+", got "+I)}}});function f(C){const I=n>>Se;return C>I}function g(C){return f(C)?c(-C):C}const m=(C,I,M)=>Gt(C.slice(I,M));class v{constructor(I,M,A){Ye("r",I,Se,n),Ye("s",M,Se,n),this.r=I,this.s=M,A!=null&&(this.recovery=A),Object.freeze(this)}static fromCompact(I){const M=s;return I=de("compactSignature",I,M*2),new v(m(I,0,M),m(I,M,2*M))}static fromDER(I){const{r:M,s:A}=vt.toSig(de("DER",I));return new v(M,A)}assertValidity(){}addRecoveryBit(I){return new v(this.r,this.s,I)}recoverPublicKey(I){const{r:M,s:A,recovery:y}=this,S=x(de("msgHash",I));if(y==null||![0,1,2,3].includes(y))throw new Error("recovery id invalid");const T=y===2||y===3?M+e.n:M;if(T>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const O=(y&1)===0?"02":"03",B=u.fromHex(O+ai(T,t.BYTES)),z=l(T),K=c(-S*z),W=c(A*z),H=u.BASE.multiplyAndAddUnsafe(B,K,W);if(!H)throw new Error("point at infinify");return H.assertValidity(),H}hasHighS(){return f(this.s)}normalizeS(){return this.hasHighS()?new v(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return ns(this.toDERHex())}toDERHex(){return vt.hexFromSig(this)}toCompactRawBytes(){return ns(this.toCompactHex())}toCompactHex(){const I=s;return ai(this.r,I)+ai(this.s,I)}}const k={isValidPrivateKey(C){try{return d(C),!0}catch{return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{const C=fu(e.n);return ng(e.randomBytes(C),e.n)},precompute(C=8,I=u.BASE){return I._setWindowSize(C),I.multiply(BigInt(3)),I}};function b(C,I=!0){return u.fromPrivateKey(C).toRawBytes(I)}function w(C){if(typeof C=="bigint")return!1;if(C instanceof u)return!0;const M=de("key",C).length,A=t.BYTES,y=A+1,S=2*A+1;if(!(e.allowedPrivateKeyLengths||s===y))return M===y||M===S}function E(C,I,M=!0){if(w(C)===!0)throw new Error("first arg must be private key");if(w(I)===!1)throw new Error("second arg must be public key");return u.fromHex(I).multiply(d(C)).toRawBytes(M)}const P=e.bits2int||function(C){if(C.length>8192)throw new Error("input is too large");const I=Gt(C),M=C.length*8-i;return M>0?I>>BigInt(M):I},x=e.bits2int_modN||function(C){return c(P(C))},_=Ns(i);function D(C){return Ye("num < 2^"+i,C,Et,_),yn(C,s)}function F(C,I,M=L){if(["recovered","canonical"].some(ee=>ee in M))throw new Error("sign() legacy options not supported");const{hash:A,randomBytes:y}=e;let{lowS:S,prehash:T,extraEntropy:O}=M;S==null&&(S=!0),C=de("msgHash",C),$a(M),T&&(C=de("prehashed msgHash",A(C)));const B=x(C),z=d(I),K=[D(z),D(B)];if(O!=null&&O!==!1){const ee=O===!0?y(t.BYTES):O;K.push(de("extraEntropy",ee))}const W=yr(...K),H=B;function te(ee){const xe=P(ee);if(!p(xe))return;const ze=l(xe),Ee=u.BASE.multiply(xe).toAffine(),Pe=c(Ee.x);if(Pe===Et)return;const He=c(ze*c(H+Pe*z));if(He===Et)return;let et=(Ee.x===Pe?0:2)|Number(Ee.y&Se),Or=He;return S&&f(He)&&(Or=g(He),et^=1),new v(Pe,Or,et)}return{seed:W,k2sig:te}}const L={lowS:e.lowS,prehash:!1},N={lowS:e.lowS,prehash:!1};function R(C,I,M=L){const{seed:A,k2sig:y}=F(C,I,M),S=e;return Gp(S.hash.outputLen,S.nByteLength,S.hmac)(A,y)}u.BASE._setWindowSize(8);function $(C,I,M,A=N){const y=C;I=de("msgHash",I),M=de("publicKey",M);const{lowS:S,prehash:T,format:O}=A;if($a(A),"strict"in A)throw new Error("options.strict was renamed to lowS");if(O!==void 0&&O!=="compact"&&O!=="der")throw new Error("format must be compact or der");const B=typeof y=="string"||mn(y),z=!B&&!O&&typeof y=="object"&&y!==null&&typeof y.r=="bigint"&&typeof y.s=="bigint";if(!B&&!z)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let K,W;try{if(z&&(K=new v(y.r,y.s)),B){try{O!=="compact"&&(K=v.fromDER(y))}catch(et){if(!(et instanceof vt.Err))throw et}!K&&O!=="der"&&(K=v.fromCompact(y))}W=u.fromHex(M)}catch{return!1}if(!K||S&&K.hasHighS())return!1;T&&(I=e.hash(I));const{r:H,s:te}=K,ee=x(I),xe=l(te),ze=c(ee*xe),Ee=c(H*xe),Pe=u.BASE.multiplyAndAddUnsafe(W,ze,Ee)?.toAffine();return Pe?c(Pe.x)===H:!1}return{CURVE:e,getPublicKey:b,getSharedSecret:E,sign:R,verify:$,ProjectivePoint:u,Signature:v,utils:k}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function dm(r){return{hash:r,hmac:(e,...t)=>Fs(r,e,Tp(...t)),randomBytes:Os}}function hm(r,e){const t=n=>um({...r,...dm(n)});return{...t(e),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _u=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),za=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),fm=BigInt(0),pm=BigInt(1),Ji=BigInt(2),Ka=(r,e)=>(r+e/Ji)/e;function gm(r){const e=_u,t=BigInt(3),n=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),l=r*r*r%e,u=l*l*r%e,d=ue(u,t,e)*u%e,h=ue(d,t,e)*u%e,p=ue(h,Ji,e)*l%e,f=ue(p,s,e)*p%e,g=ue(f,i,e)*f%e,m=ue(g,a,e)*g%e,v=ue(m,c,e)*m%e,k=ue(v,a,e)*g%e,b=ue(k,t,e)*u%e,w=ue(b,o,e)*f%e,E=ue(w,n,e)*l%e,P=ue(E,Ji,e);if(!eo.eql(eo.sqr(P),r))throw new Error("Cannot find square root");return P}const eo=wn(_u,void 0,void 0,{sqrt:gm}),as=hm({a:fm,b:BigInt(7),Fp:eo,n:za,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{const e=za,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-pm*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=t,o=BigInt("0x100000000000000000000000000000000"),a=Ka(i*r,e),c=Ka(-n*r,e);let l=ce(r-a*t-c*s,e),u=ce(-a*n-c*i,e);const d=l>o,h=u>o;if(d&&(l=e-l),h&&(u=e-u),l>o||u>o)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:d,k1:l,k2neg:h,k2:u}}}},su);function mm(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}function ym(r,e,t){const n=Xl.digest(t instanceof Uint8Array?t:t.subarray());if(mm(n))return n.then(({digest:s})=>as.verify(e,s,r)).catch(s=>{throw new Ua(String(s))});try{return as.verify(e,n.digest,r)}catch(s){throw new Ua(String(s))}}class wm{type="secp256k1";raw;_key;constructor(e){this._key=vm(e),this.raw=bm(this._key)}toMultihash(){return fn.digest(xt(this))}toCID(){return ae.createV1(114,this.toMultihash())}toString(){return ye.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Oe(this.raw,e.raw)}verify(e,t){return ym(this._key,t,e)}}function Pu(r){return new wm(r)}function bm(r){return as.ProjectivePoint.fromHex(r).toRawBytes(!0)}function vm(r){try{return as.ProjectivePoint.fromHex(r),r}catch(e){throw new Rl(String(e))}}async function Em(r,e){return xg()}function Bt(r,e){const{Type:t,Data:n}=wr.decode(r),s=n??new Uint8Array;switch(t){case Te.RSA:return rm(s,e);case Te.Ed25519:return xu(s);case Te.secp256k1:return Pu(s);case Te.ECDSA:return Jl(s);default:throw new To}}function Sm(r){const{Type:e,Data:t}=wr.decode(r.digest),n=t??new Uint8Array;switch(e){case Te.Ed25519:return xu(n);case Te.secp256k1:return Pu(n);case Te.ECDSA:return Jl(n);default:throw new To}}function xt(r){return wr.encode({Type:Te[r.type],Data:r.raw})}const Lu=Symbol.for("nodejs.util.inspect.custom"),xm=114;class Vo{type;multihash;publicKey;string;constructor(e){this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}[Eo]=!0;toString(){return this.string==null&&(this.string=ye.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ae.createV1(xm,this.multihash)}toJSON(){return this.toString()}equals(e){if(e==null)return!1;if(e instanceof Uint8Array)return Oe(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(e?.toMultihash()?.bytes!=null)return Oe(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[Lu](){return`PeerId(${this.toString()})`}}class Du extends Vo{type="RSA";publicKey;constructor(e){super({...e,type:"RSA"}),this.publicKey=e.publicKey}}class Ru extends Vo{type="Ed25519";publicKey;constructor(e){super({...e,type:"Ed25519"}),this.publicKey=e.publicKey}}class Mu extends Vo{type="secp256k1";publicKey;constructor(e){super({...e,type:"secp256k1"}),this.publicKey=e.publicKey}}const Am=2336;class Ou{type="url";multihash;publicKey;url;constructor(e){this.url=e.toString(),this.multihash=fn.digest(q(this.url))}[Lu](){return`PeerId(${this.url})`}[Eo]=!0;toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return ae.createV1(Am,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=Y(e)),e.toString()===this.toString())}}const Cm=114,qa=2336;function pt(r,e){let t;if(r.charAt(0)==="1"||r.charAt(0)==="Q")t=er(ye.decode(`z${r}`));else{if(r.startsWith("k51qzi5uqu5")||r.startsWith("kzwfwjn5ji4")||r.startsWith("k2k4r8")||r.startsWith("bafz"))return vn(ae.parse(r));throw new V('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return bn(t)}function tn(r){if(r.type==="Ed25519")return new Ru({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new Mu({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new Du({multihash:r.toCID().multihash,publicKey:r});throw new To}function Im(r){return tn(r.publicKey)}function bn(r){if(km(r))return new Du({multihash:r});if(Tm(r))try{const e=Sm(r);if(e.type==="Ed25519")return new Ru({multihash:r,publicKey:e});if(e.type==="secp256k1")return new Mu({multihash:r,publicKey:e})}catch{const t=Y(r.digest);return new Ou(new URL(t))}throw new Fh("Supplied PeerID Multihash is invalid")}function vn(r){if(r?.multihash==null||r.version==null||r.version===1&&r.code!==Cm&&r.code!==qa)throw new Nh("Supplied PeerID CID is invalid");if(r.code===qa){const e=Y(r.multihash.digest);return new Ou(new URL(e))}return bn(r.multihash)}function Tm(r){return r.code===fn.code}function km(r){return r.code===Xl.code}const _m=8,Ho=1024*1024*4;let Pm=class extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"},Nu=class extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"},Lm=class extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"},Wa=class extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"};function Fu(r){return r[Symbol.asyncIterator]!=null}function Uu(r,e){if(r.byteLength>e)throw new Nu("Message length too long")}const Us=r=>{const e=Ie(r),t=ft(e);return dt(r,t),Us.bytes=e,t};Us.bytes=0;function cs(r,e){e=e??{};const t=e.lengthEncoder??Us,n=e?.maxDataLength??Ho;function*s(i){Uu(i,n);const o=t(i.byteLength);o instanceof Uint8Array?yield o:yield*o,i instanceof Uint8Array?yield i:yield*i}return Fu(r)?async function*(){for await(const i of r)yield*s(i)}():function*(){for(const i of r)yield*s(i)}()}cs.single=(r,e)=>{e=e??{};const t=e.lengthEncoder??Us,n=e?.maxDataLength??Ho;return Uu(r,n),new J(t(r.byteLength),r)};var qt;(function(r){r[r.LENGTH=0]="LENGTH",r[r.DATA=1]="DATA"})(qt||(qt={}));const Go=r=>{const e=tr(r);return Go.bytes=Ie(e),e};Go.bytes=0;function ls(r,e){const t=new J;let n=qt.LENGTH,s=-1;const i=e?.lengthDecoder??Go,o=e?.maxLengthLength??_m,a=e?.maxDataLength??Ho;function*c(){for(;t.byteLength>0;){if(n===qt.LENGTH)try{if(s=i(t),s<0)throw new Pm("Invalid message length");if(s>a)throw new Nu("Message length too long");const l=i.bytes;t.consume(l),e?.onLength!=null&&e.onLength(s),n=qt.DATA}catch(l){if(l instanceof RangeError){if(t.byteLength>o)throw new Lm("Message length length too long");break}throw l}if(n===qt.DATA){if(t.byteLength<s)break;const l=t.sublist(0,s);t.consume(s),e?.onData!=null&&e.onData(l),yield l,n=qt.LENGTH}}}return Fu(r)?async function*(){for await(const l of r)t.append(l),yield*c();if(t.byteLength>0)throw new Wa("Unexpected end of input")}():function*(){for(const l of r)t.append(l),yield*c();if(t.byteLength>0)throw new Wa("Unexpected end of input")}()}ls.fromReader=(r,e)=>{let t=1;const n=async function*(){for(;;)try{const{done:i,value:o}=await r.next(t);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{t=1}}();return ls(n,{...e??{},onLength:i=>{t=i}})};function he(){const r={};return r.promise=new Promise((e,t)=>{r.resolve=e,r.reject=t}),r}let Va=class extends Error{type;code;constructor(e,t,n){super(e??"The operation was aborted"),this.type="aborted",this.name=n??"AbortError",this.code=t??"ABORT_ERR"}};async function Je(r,e,t){if(e==null)return r;if(e.aborted)return r.catch(()=>{}),Promise.reject(new Va(t?.errorMessage,t?.errorCode,t?.errorName));let n;const s=new Va(t?.errorMessage,t?.errorCode,t?.errorName);try{return await Promise.race([r,new Promise((i,o)=>{n=()=>{o(s)},e.addEventListener("abort",n)})])}finally{n!=null&&e.removeEventListener("abort",n)}}class Dm{readNext;haveNext;ended;nextResult;error;constructor(){this.ended=!1,this.readNext=he(),this.haveNext=he()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=he(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=he(),await Je(this.readNext.promise,t?.signal,t)}}function Bu(){return new Dm}class Rm extends Error{name="UnexpectedEOFError";code="ERR_UNEXPECTED_EOF"}function us(r,e){const t=Bu();r.sink(t).catch(async o=>{await t.end(o)}),r.sink=async o=>{for await(const a of o)await t.push(a);await t.end()};let n=r.source;r.source[Symbol.iterator]!=null?n=r.source[Symbol.iterator]():r.source[Symbol.asyncIterator]!=null&&(n=r.source[Symbol.asyncIterator]());const s=new J;return{read:async o=>{if(o?.signal?.throwIfAborted(),o?.bytes==null){const{done:c,value:l}=await Je(n.next(),o?.signal);return c===!0?null:l}for(;s.byteLength<o.bytes;){const{value:c,done:l}=await Je(n.next(),o?.signal);if(l===!0)throw new Rm("unexpected end of input");s.append(c)}const a=s.sublist(0,o.bytes);return s.consume(o.bytes),a},write:async(o,a)=>{a?.signal?.throwIfAborted(),o instanceof Uint8Array?await t.push(o,a):await t.push(o.subarray(),a)},unwrap:()=>{if(s.byteLength>0){const o=r.source;r.source=async function*(){e?.yieldBytes===!1?yield s:yield*s,yield*o}()}return r}}}class Mm extends Error{name="InvalidMessageLengthError";code="ERR_INVALID_MSG_LENGTH"}class Om extends Error{name="InvalidDataLengthError";code="ERR_MSG_DATA_TOO_LONG"}class Nm extends Error{name="InvalidDataLengthLengthError";code="ERR_MSG_LENGTH_TOO_LONG"}function br(r,e={}){const t=us(r,e);e.maxDataLength!=null&&e.maxLengthLength==null&&(e.maxLengthLength=Ie(e.maxDataLength));const n=e?.lengthDecoder??tr,s=e?.lengthEncoder??dt;return{read:async o=>{let a=-1;const c=new J;for(;;){c.append(await t.read({...o,bytes:1}));try{a=n(c)}catch(l){if(l instanceof RangeError)continue;throw l}if(a<0)throw new Mm("Invalid message length");if(e?.maxLengthLength!=null&&c.byteLength>e.maxLengthLength)throw new Nm("message length length too long");if(a>-1)break}if(e?.maxDataLength!=null&&a>e.maxDataLength)throw new Om("message length too long");return t.read({...o,bytes:a})},write:async(o,a)=>{await t.write(new J(s(o.byteLength),o),a)},writeV:async(o,a)=>{const c=new J(...o.flatMap(l=>[s(l.byteLength),l]));await t.write(c,a)},unwrap:()=>t.unwrap()}}function Ha(){const r=he();let e=!1;return{sink:async t=>{if(e)throw new Error("already piped");e=!0,r.resolve(t)},source:async function*(){yield*await r.promise}()}}function Fm(){const r=Ha(),e=Ha();return[{source:r.source,sink:e.sink},{source:e.source,sink:r.sink}]}class Ga{buffer;mask;top;btm;next;constructor(e){if(!(e>0)||(e-1&e)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}}class li{size;hwm;head;tail;constructor(e={}){this.hwm=e.splitLimit??16,this.head=new Ga(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return e?.byteLength!=null?e.byteLength:1}push(e){if(e?.value!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new Ga(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return e?.value!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}let Um=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.code=t??"ABORT_ERR"}};function En(r={}){return Bm(t=>{const n=t.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function Bm(r,e){e=e??{};let t=e.onEnd,n=new li,s,i,o,a=he();const c=async()=>{try{return n.isEmpty()?o?{done:!0}:await new Promise((m,v)=>{i=k=>{i=null,n.push(k);try{m(r(n))}catch(b){v(b)}return s}}):r(n)}finally{n.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=he()})}},l=m=>i!=null?i(m):(n.push(m),s),u=m=>(n=new li,i!=null?i({error:m}):(n.push({error:m}),s)),d=m=>{if(o)return s;if(e?.objectMode!==!0&&m?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:m})},h=m=>o?s:(o=!0,m!=null?u(m):l({done:!0})),p=()=>(n=new li,h(),{done:!0}),f=m=>(h(m),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:c,return:p,throw:f,push:d,end:h,get readableLength(){return n.size},onEmpty:async m=>{const v=m?.signal;if(v?.throwIfAborted(),n.isEmpty())return;let k,b;v!=null&&(k=new Promise((w,E)=>{b=()=>{E(new Um)},v.addEventListener("abort",b)}));try{await Promise.race([a.promise,k])}finally{b!=null&&v!=null&&v?.removeEventListener("abort",b)}}},t==null)return s;const g=s;return s={[Symbol.asyncIterator](){return this},next(){return g.next()},throw(m){return g.throw(m),t!=null&&(t(m),t=void 0),{done:!0}},return(){return g.return(),t!=null&&(t(),t=void 0),{done:!0}},push:d,end(m){return g.end(m),t!=null&&(t(m),t=void 0),s},get readableLength(){return g.readableLength},onEmpty:m=>g.onEmpty(m)},s}function $m(r){return r[Symbol.asyncIterator]!=null}async function zm(r,e,t){try{await Promise.all(r.map(async n=>{for await(const s of n)await e.push(s,{signal:t}),t.throwIfAborted()})),await e.end(void 0,{signal:t})}catch(n){await e.end(n,{signal:t}).catch(()=>{})}}async function*Km(r){const e=new AbortController,t=Bu();zm(r,t,e.signal).catch(()=>{});try{yield*t}finally{e.abort()}}function*qm(r){for(const e of r)yield*e}function ds(...r){const e=[];for(const t of r)$m(t)||e.push(t);return e.length===r.length?qm(e):Km(r)}function $u(r,...e){if(r==null)throw new Error("Empty pipeline");if(ui(r)){const n=r;r=()=>n.source}else if(Ku(r)||zu(r)){const n=r;r=()=>n}const t=[r,...e];if(t.length>1&&ui(t[t.length-1])&&(t[t.length-1]=t[t.length-1].sink),t.length>2)for(let n=1;n<t.length-1;n++)ui(t[n])&&(t[n]=Vm(t[n]));return Wm(...t)}const Wm=(...r)=>{let e;for(;r.length>0;)e=r.shift()(e);return e},zu=r=>r?.[Symbol.asyncIterator]!=null,Ku=r=>r?.[Symbol.iterator]!=null,ui=r=>r==null?!1:r.sink!=null&&r.source!=null,Vm=r=>e=>{const t=r.sink(e);if(t?.then!=null){const n=En({objectMode:!0});t.then(()=>{n.end()},o=>{n.end(o)});let s;const i=r.source;if(zu(i))s=async function*(){yield*i,n.end()};else if(Ku(i))s=function*(){yield*i,n.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return ds(n,s())}return r.source};var Hm={};const rn=65535,Ya=rn-16,Sn=!!Hm?.DUMP_SESSION_KEYS;/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function qu(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function to(r){if(typeof r!="boolean")throw new Error(`boolean expected, not ${r}`)}function di(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function qe(r,...e){if(!qu(r))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(r.length))throw new Error("Uint8Array expected of length "+e+", got length="+r.length)}function Xa(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Gm(r,e){qe(r);const t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function Nt(r){return new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength/4))}function vr(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function Ym(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}const Xm=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Qm(r){if(typeof r!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(r))}function ro(r){if(typeof r=="string")r=Qm(r);else if(qu(r))r=no(r);else throw new Error("Uint8Array expected, got "+typeof r);return r}function jm(r,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(r,e)}function Zm(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}const Jm=(r,e)=>{function t(n,...s){if(qe(n),!Xm)throw new Error("Non little-endian hardware is not yet supported");if(r.nonceLength!==void 0){const u=s[0];if(!u)throw new Error("nonce / iv required");r.varSizeNonce?qe(u):qe(u,r.nonceLength)}const i=r.tagLength;i&&s[1]!==void 0&&qe(s[1]);const o=e(n,...s),a=(u,d)=>{if(d!==void 0){if(u!==2)throw new Error("cipher output not supported");qe(d)}};let c=!1;return{encrypt(u,d){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,qe(u),a(o.encrypt.length,d),o.encrypt(u,d)},decrypt(u,d){if(qe(u),i&&u.length<i)throw new Error("invalid ciphertext length: smaller than tagLength="+i);return a(o.decrypt.length,d),o.decrypt(u,d)}}}return Object.assign(t,r),t};function Qa(r,e,t=!0){if(e===void 0)return new Uint8Array(r);if(e.length!==r)throw new Error("invalid output length, expected "+r+", got: "+e.length);if(t&&!ty(e))throw new Error("invalid output, must be aligned");return e}function ja(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const s=BigInt(32),i=BigInt(4294967295),o=Number(t>>s&i),a=Number(t&i),c=4,l=0;r.setUint32(e+c,o,n),r.setUint32(e+l,a,n)}function ey(r,e,t){to(t);const n=new Uint8Array(16),s=Ym(n);return ja(s,0,BigInt(e),t),ja(s,8,BigInt(r),t),n}function ty(r){return r.byteOffset%4===0}function no(r){return Uint8Array.from(r)}const Wu=r=>Uint8Array.from(r.split("").map(e=>e.charCodeAt(0))),ry=Wu("expand 16-byte k"),ny=Wu("expand 32-byte k"),sy=Nt(ry),iy=Nt(ny);function Z(r,e){return r<<e|r>>>32-e}function so(r){return r.byteOffset%4===0}const Mn=64,oy=16,Vu=2**32-1,Za=new Uint32Array;function ay(r,e,t,n,s,i,o,a){const c=s.length,l=new Uint8Array(Mn),u=Nt(l),d=so(s)&&so(i),h=d?Nt(s):Za,p=d?Nt(i):Za;for(let f=0;f<c;o++){if(r(e,t,n,u,o,a),o>=Vu)throw new Error("arx: counter overflow");const g=Math.min(Mn,c-f);if(d&&g===Mn){const m=f/4;if(f%4!==0)throw new Error("arx: invalid block position");for(let v=0,k;v<oy;v++)k=m+v,p[k]=h[k]^u[v];f+=Mn;continue}for(let m=0,v;m<g;m++)v=f+m,i[v]=s[v]^l[m];f+=g}}function cy(r,e){const{allowShortKeys:t,extendNonceFn:n,counterLength:s,counterRight:i,rounds:o}=jm({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof r!="function")throw new Error("core must be a function");return di(s),di(o),to(i),to(t),(a,c,l,u,d=0)=>{qe(a),qe(c),qe(l);const h=l.length;if(u===void 0&&(u=new Uint8Array(h)),qe(u),di(d),d<0||d>=Vu)throw new Error("arx: counter overflow");if(u.length<h)throw new Error(`arx: output (${u.length}) is shorter than data (${h})`);const p=[];let f=a.length,g,m;if(f===32)p.push(g=no(a)),m=iy;else if(f===16&&t)g=new Uint8Array(32),g.set(a),g.set(a,16),m=sy,p.push(g);else throw new Error(`arx: invalid 32-byte key, got length=${f}`);so(c)||p.push(c=no(c));const v=Nt(g);if(n){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");n(m,v,Nt(c.subarray(0,16)),v),c=c.subarray(16)}const k=16-s;if(k!==c.length)throw new Error(`arx: nonce must be ${k} or 16 bytes`);if(k!==12){const w=new Uint8Array(12);w.set(c,i?0:12-c.length),c=w,p.push(c)}const b=Nt(c);return ay(r,m,v,b,l,u,d,o),vr(...p),u}}const Ae=(r,e)=>r[e++]&255|(r[e++]&255)<<8;class ly{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=ro(e),qe(e,32);const t=Ae(e,0),n=Ae(e,2),s=Ae(e,4),i=Ae(e,6),o=Ae(e,8),a=Ae(e,10),c=Ae(e,12),l=Ae(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|n<<3)&8191,this.r[2]=(n>>>10|s<<6)&7939,this.r[3]=(s>>>7|i<<9)&8191,this.r[4]=(i>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|l<<8)&8191,this.r[9]=l>>>5&127;for(let u=0;u<8;u++)this.pad[u]=Ae(e,16+2*u)}process(e,t,n=!1){const s=n?0:2048,{h:i,r:o}=this,a=o[0],c=o[1],l=o[2],u=o[3],d=o[4],h=o[5],p=o[6],f=o[7],g=o[8],m=o[9],v=Ae(e,t+0),k=Ae(e,t+2),b=Ae(e,t+4),w=Ae(e,t+6),E=Ae(e,t+8),P=Ae(e,t+10),x=Ae(e,t+12),_=Ae(e,t+14);let D=i[0]+(v&8191),F=i[1]+((v>>>13|k<<3)&8191),L=i[2]+((k>>>10|b<<6)&8191),N=i[3]+((b>>>7|w<<9)&8191),R=i[4]+((w>>>4|E<<12)&8191),$=i[5]+(E>>>1&8191),C=i[6]+((E>>>14|P<<2)&8191),I=i[7]+((P>>>11|x<<5)&8191),M=i[8]+((x>>>8|_<<8)&8191),A=i[9]+(_>>>5|s),y=0,S=y+D*a+F*(5*m)+L*(5*g)+N*(5*f)+R*(5*p);y=S>>>13,S&=8191,S+=$*(5*h)+C*(5*d)+I*(5*u)+M*(5*l)+A*(5*c),y+=S>>>13,S&=8191;let T=y+D*c+F*a+L*(5*m)+N*(5*g)+R*(5*f);y=T>>>13,T&=8191,T+=$*(5*p)+C*(5*h)+I*(5*d)+M*(5*u)+A*(5*l),y+=T>>>13,T&=8191;let O=y+D*l+F*c+L*a+N*(5*m)+R*(5*g);y=O>>>13,O&=8191,O+=$*(5*f)+C*(5*p)+I*(5*h)+M*(5*d)+A*(5*u),y+=O>>>13,O&=8191;let B=y+D*u+F*l+L*c+N*a+R*(5*m);y=B>>>13,B&=8191,B+=$*(5*g)+C*(5*f)+I*(5*p)+M*(5*h)+A*(5*d),y+=B>>>13,B&=8191;let z=y+D*d+F*u+L*l+N*c+R*a;y=z>>>13,z&=8191,z+=$*(5*m)+C*(5*g)+I*(5*f)+M*(5*p)+A*(5*h),y+=z>>>13,z&=8191;let K=y+D*h+F*d+L*u+N*l+R*c;y=K>>>13,K&=8191,K+=$*a+C*(5*m)+I*(5*g)+M*(5*f)+A*(5*p),y+=K>>>13,K&=8191;let W=y+D*p+F*h+L*d+N*u+R*l;y=W>>>13,W&=8191,W+=$*c+C*a+I*(5*m)+M*(5*g)+A*(5*f),y+=W>>>13,W&=8191;let H=y+D*f+F*p+L*h+N*d+R*u;y=H>>>13,H&=8191,H+=$*l+C*c+I*a+M*(5*m)+A*(5*g),y+=H>>>13,H&=8191;let te=y+D*g+F*f+L*p+N*h+R*d;y=te>>>13,te&=8191,te+=$*u+C*l+I*c+M*a+A*(5*m),y+=te>>>13,te&=8191;let ee=y+D*m+F*g+L*f+N*p+R*h;y=ee>>>13,ee&=8191,ee+=$*d+C*u+I*l+M*c+A*a,y+=ee>>>13,ee&=8191,y=(y<<2)+y|0,y=y+S|0,S=y&8191,y=y>>>13,T+=y,i[0]=S,i[1]=T,i[2]=O,i[3]=B,i[4]=z,i[5]=K,i[6]=W,i[7]=H,i[8]=te,i[9]=ee}finalize(){const{h:e,pad:t}=this,n=new Uint16Array(10);let s=e[1]>>>13;e[1]&=8191;for(let a=2;a<10;a++)e[a]+=s,s=e[a]>>>13,e[a]&=8191;e[0]+=s*5,s=e[0]>>>13,e[0]&=8191,e[1]+=s,s=e[1]>>>13,e[1]&=8191,e[2]+=s,n[0]=e[0]+5,s=n[0]>>>13,n[0]&=8191;for(let a=1;a<10;a++)n[a]=e[a]+s,s=n[a]>>>13,n[a]&=8191;n[9]-=8192;let i=(s^1)-1;for(let a=0;a<10;a++)n[a]&=i;i=~i;for(let a=0;a<10;a++)e[a]=e[a]&i|n[a];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let o=e[0]+t[0];e[0]=o&65535;for(let a=1;a<8;a++)o=(e[a]+t[a]|0)+(o>>>16)|0,e[a]=o&65535;vr(n)}update(e){Xa(this),e=ro(e),qe(e);const{buffer:t,blockLen:n}=this,s=e.length;for(let i=0;i<s;){const o=Math.min(n-this.pos,s-i);if(o===n){for(;n<=s-i;i+=n)this.process(e,i);continue}t.set(e.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===n&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){vr(this.h,this.r,this.buffer,this.pad)}digestInto(e){Xa(this),Gm(e,this),this.finished=!0;const{buffer:t,h:n}=this;let{pos:s}=this;if(s){for(t[s++]=1;s<16;s++)t[s]=0;this.process(t,0,!0)}this.finalize();let i=0;for(let o=0;o<8;o++)e[i++]=n[o]>>>0,e[i++]=n[o]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}}function uy(r){const e=(n,s)=>r(s).update(ro(n)).digest(),t=r(new Uint8Array(32));return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=n=>r(n),e}const dy=uy(r=>new ly(r));function hy(r,e,t,n,s,i=20){let o=r[0],a=r[1],c=r[2],l=r[3],u=e[0],d=e[1],h=e[2],p=e[3],f=e[4],g=e[5],m=e[6],v=e[7],k=s,b=t[0],w=t[1],E=t[2],P=o,x=a,_=c,D=l,F=u,L=d,N=h,R=p,$=f,C=g,I=m,M=v,A=k,y=b,S=w,T=E;for(let B=0;B<i;B+=2)P=P+F|0,A=Z(A^P,16),$=$+A|0,F=Z(F^$,12),P=P+F|0,A=Z(A^P,8),$=$+A|0,F=Z(F^$,7),x=x+L|0,y=Z(y^x,16),C=C+y|0,L=Z(L^C,12),x=x+L|0,y=Z(y^x,8),C=C+y|0,L=Z(L^C,7),_=_+N|0,S=Z(S^_,16),I=I+S|0,N=Z(N^I,12),_=_+N|0,S=Z(S^_,8),I=I+S|0,N=Z(N^I,7),D=D+R|0,T=Z(T^D,16),M=M+T|0,R=Z(R^M,12),D=D+R|0,T=Z(T^D,8),M=M+T|0,R=Z(R^M,7),P=P+L|0,T=Z(T^P,16),I=I+T|0,L=Z(L^I,12),P=P+L|0,T=Z(T^P,8),I=I+T|0,L=Z(L^I,7),x=x+N|0,A=Z(A^x,16),M=M+A|0,N=Z(N^M,12),x=x+N|0,A=Z(A^x,8),M=M+A|0,N=Z(N^M,7),_=_+R|0,y=Z(y^_,16),$=$+y|0,R=Z(R^$,12),_=_+R|0,y=Z(y^_,8),$=$+y|0,R=Z(R^$,7),D=D+F|0,S=Z(S^D,16),C=C+S|0,F=Z(F^C,12),D=D+F|0,S=Z(S^D,8),C=C+S|0,F=Z(F^C,7);let O=0;n[O++]=o+P|0,n[O++]=a+x|0,n[O++]=c+_|0,n[O++]=l+D|0,n[O++]=u+F|0,n[O++]=d+L|0,n[O++]=h+N|0,n[O++]=p+R|0,n[O++]=f+$|0,n[O++]=g+C|0,n[O++]=m+I|0,n[O++]=v+M|0,n[O++]=k+A|0,n[O++]=b+y|0,n[O++]=w+S|0,n[O++]=E+T|0}const fy=cy(hy,{counterRight:!1,counterLength:4,allowShortKeys:!1}),py=new Uint8Array(16),Ja=(r,e)=>{r.update(e);const t=e.length%16;t&&r.update(py.subarray(t))},gy=new Uint8Array(32);function ec(r,e,t,n,s){const i=r(e,t,gy),o=dy.create(i);s&&Ja(o,s),Ja(o,n);const a=ey(n.length,s?s.length:0,!0);o.update(a);const c=o.digest();return vr(i,a),c}const my=r=>(e,t,n)=>({encrypt(i,o){const a=i.length;o=Qa(a+16,o,!1),o.set(i);const c=o.subarray(0,-16);r(e,t,c,c,1);const l=ec(r,e,t,c,n);return o.set(l,a),vr(l),o},decrypt(i,o){o=Qa(i.length-16,o,!1);const a=i.subarray(0,-16),c=i.subarray(-16),l=ec(r,e,t,a,n);if(!Zm(c,l))throw new Error("invalid tag");return o.set(i.subarray(0,-16)),r(e,t,o,o,1),vr(l),o}}),tc=Jm({blockSize:64,nonceLength:12,tagLength:16},my(fy));function yy(r,e,t){return Lo(r),t===void 0&&(t=new Uint8Array(r.outputLen)),Fs(r,Zr(t),Zr(e))}const hi=Uint8Array.from([0]),rc=Uint8Array.of();function wy(r,e,t,n=32){Lo(r),ts(n);const s=r.outputLen;if(n>255*s)throw new Error("Length should be <= 255*HashLen");const i=Math.ceil(n/s);t===void 0&&(t=rc);const o=new Uint8Array(i*s),a=Fs.create(r,e),c=a._cloneInto(),l=new Uint8Array(a.outputLen);for(let u=0;u<i;u++)hi[0]=u+1,c.update(u===0?rc:l).update(t).update(hi).digestInto(l),o.set(l,s*u),a._cloneInto(c);return a.destroy(),c.destroy(),jt(l,hi),o.slice(0,n)}const by={hashSHA256(r){return Yn(r.subarray())},getHKDF(r,e){const t=yy(Yn,e,r),s=wy(Yn,t,void 0,96),i=s.subarray(0,32),o=s.subarray(32,64),a=s.subarray(64,96);return[i,o,a]},generateX25519KeyPair(){const r=Ln.utils.randomPrivateKey();return{publicKey:Ln.getPublicKey(r),privateKey:r}},generateX25519KeyPairFromSeed(r){return{publicKey:Ln.getPublicKey(r),privateKey:r}},generateX25519SharedKey(r,e){return Ln.getSharedSecret(r.subarray(),e.subarray())},chaCha20Poly1305Encrypt(r,e,t,n){return tc(n,e,t).encrypt(r.subarray())},chaCha20Poly1305Decrypt(r,e,t,n,s){return tc(n,e,t).decrypt(r.subarray(),s)}},vy=by;function Ey(r){return{generateKeypair:r.generateX25519KeyPair,dh:(e,t)=>r.generateX25519SharedKey(e.privateKey,t).subarray(0,32),encrypt:r.chaCha20Poly1305Encrypt,decrypt:r.chaCha20Poly1305Decrypt,hash:r.hashSHA256,hkdf:r.getHKDF}}const hs=r=>{const e=ft(2);return e[0]=r>>8,e[1]=r,e};hs.bytes=2;const Xn=r=>{if(r.length<2)throw RangeError("Could not decode int16BE");if(r instanceof Uint8Array){let e=0;return e+=r[0]<<8,e+=r[1],e}return r.getUint16(0)};Xn.bytes=2;function Sy(r){return{xxHandshakeSuccesses:r.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:r.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:r.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:r.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:r.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}function Hu(r,e){!e.enabled||!Sn||(r?(e(`LOCAL_STATIC_PUBLIC_KEY ${Y(r.publicKey,"hex")}`),e(`LOCAL_STATIC_PRIVATE_KEY ${Y(r.privateKey,"hex")}`)):e("Missing local static keys."))}function Gu(r,e){!e.enabled||!Sn||(r?(e(`LOCAL_PUBLIC_EPHEMERAL_KEY ${Y(r.publicKey,"hex")}`),e(`LOCAL_PRIVATE_EPHEMERAL_KEY ${Y(r.privateKey,"hex")}`)):e("Missing local ephemeral keys."))}function xy(r,e){!e.enabled||!Sn||e(r?`REMOTE_STATIC_PUBLIC_KEY ${Y(r.subarray(),"hex")}`:"Missing remote static public key.")}function Yu(r,e){!e.enabled||!Sn||e(r?`REMOTE_EPHEMERAL_PUBLIC_KEY ${Y(r.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function Xu(r,e,t){!t.enabled||!Sn||(t(`CIPHER_STATE_1 ${r.n.getUint64()} ${r.k&&Y(r.k,"hex")}`),t(`CIPHER_STATE_2 ${e.n.getUint64()} ${e.k&&Y(e.k,"hex")}`))}class Gr extends Error{code;constructor(e="Invalid crypto exchange"){super(e),this.code=Gr.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"}const Ay=0,Cy=4294967295,Iy="Cipherstate has reached maximum n, a new handshake must be performed";class Ty{n;bytes;view;constructor(e=Ay){this.n=e,this.bytes=se(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,e,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>Cy)throw new Error(Iy)}}const hr=se(0);class On{k;n;crypto;constructor(e,t=void 0,n=0){this.crypto=e,this.k=t,this.n=new Ty(n)}hasKey(){return!!this.k}encryptWithAd(e,t){if(!this.hasKey())return t;this.n.assertValue();const n=this.crypto.encrypt(t,this.n.getBytes(),e,this.k);return this.n.increment(),n}decryptWithAd(e,t,n){if(!this.hasKey())return t;this.n.assertValue();const s=this.crypto.decrypt(t,this.n.getBytes(),e,this.k,n);return this.n.increment(),s}}class ky{cs;ck;h;crypto;constructor(e,t){this.crypto=e;const n=q(t,"utf-8");this.h=Py(e,n),this.ck=this.h,this.cs=new On(e)}mixKey(e){const[t,n]=this.crypto.hkdf(this.ck,e);this.ck=t,this.cs=new On(this.crypto,n)}mixHash(e){this.h=this.crypto.hash(new J(this.h,e))}encryptAndHash(e){const t=this.cs.encryptWithAd(this.h,e);return this.mixHash(t),t}decryptAndHash(e){const t=this.cs.decryptWithAd(this.h,e);return this.mixHash(e),t}split(){const[e,t]=this.crypto.hkdf(this.ck,hr);return[new On(this.crypto,e),new On(this.crypto,t)]}}class _y{ss;s;e;rs;re;initiator;crypto;constructor(e){const{crypto:t,protocolName:n,prologue:s,initiator:i,s:o,e:a,rs:c,re:l}=e;this.crypto=t,this.ss=new ky(t,n),this.ss.mixHash(s),this.initiator=i,this.s=o,this.e=a,this.rs=c,this.re=l}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const e=this.crypto.generateKeypair();return this.ss.mixHash(e.publicKey),this.e=e,e.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(e,t=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(e.byteLength<t+32)throw new Error("message is not long enough");this.re=e.sublist(t,t+32),this.ss.mixHash(this.re)}readS(e,t=0){if(this.rs)throw new Error("remote static public key is already set");const n=32+(this.ss.cs.hasKey()?16:0);if(e.byteLength<t+n)throw new Error("message is not long enough");const s=e.sublist(t,t+n);return this.rs=this.ss.decryptAndHash(s),n}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class Qu extends _y{writeMessageA(e){return new J(this.writeE(),this.ss.encryptAndHash(e))}writeMessageB(e){const t=this.writeE();this.writeEE();const n=this.writeS();return this.writeES(),new J(t,n,this.ss.encryptAndHash(e))}writeMessageC(e){const t=this.writeS();return this.writeSE(),new J(t,this.ss.encryptAndHash(e))}readMessageA(e){try{return this.readE(e),this.ss.decryptAndHash(e.sublist(32))}catch(t){throw new Gr(`handshake stage 0 validation fail: ${t.message}`)}}readMessageB(e){try{this.readE(e),this.readEE();const t=this.readS(e,32);return this.readES(),this.ss.decryptAndHash(e.sublist(32+t))}catch(t){throw new Gr(`handshake stage 1 validation fail: ${t.message}`)}}readMessageC(e){try{const t=this.readS(e);return this.readSE(),this.ss.decryptAndHash(e.sublist(t))}catch(t){throw new Gr(`handshake stage 2 validation fail: ${t.message}`)}}}function Py(r,e){if(e.length<=32){const t=se(32);return t.set(e),t}else return r.hash(e)}var fs;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.webtransportCerthashes!=null)for(const i of t.webtransportCerthashes)n.uint32(10),n.bytes(i);if(t.streamMuxers!=null)for(const i of t.streamMuxers)n.uint32(18),n.string(i);s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={webtransportCerthashes:[],streamMuxers:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(s.limits?.webtransportCerthashes!=null&&i.webtransportCerthashes.length===s.limits.webtransportCerthashes)throw new Ct('Decode error - map field "webtransportCerthashes" had too many elements');i.webtransportCerthashes.push(t.bytes());break}case 2:{if(s.limits?.streamMuxers!=null&&i.streamMuxers.length===s.limits.streamMuxers)throw new Ct('Decode error - map field "streamMuxers" had too many elements');i.streamMuxers.push(t.string());break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(fs||(fs={}));var ps;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.identityKey!=null&&t.identityKey.byteLength>0&&(n.uint32(10),n.bytes(t.identityKey)),t.identitySig!=null&&t.identitySig.byteLength>0&&(n.uint32(18),n.bytes(t.identitySig)),t.extensions!=null&&(n.uint32(34),fs.codec().encode(t.extensions,n)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={identityKey:se(0),identitySig:se(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.identityKey=t.bytes();break}case 2:{i.identitySig=t.bytes();break}case 4:{i.extensions=fs.codec().decode(t,t.uint32(),{limits:s.limits?.extensions});break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(ps||(ps={}));async function ju(r,e,t){const n=await r.sign(Ju(e));return ps.encode({identityKey:xt(r.publicKey),identitySig:n,extensions:t})}async function Zu(r,e,t){try{const n=ps.decode(r),s=Bt(n.identityKey);if(t?.equals(s)===!1)throw new Error(`Payload identity key ${s} does not match expected remote identity key ${t}`);if(!e)throw new Error("Remote static does not exist");const i=Ju(e);if(!await s.verify(i,n.identitySig))throw new Error("Invalid payload signature");return n}catch(n){throw new Dh(n.message)}}function Ju(r){const e=q("noise-libp2p-static-key:");return r instanceof Uint8Array?ot([e,r],e.length+r.length):(r.prepend(e),r)}async function Ly(r,e){const{log:t,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=r,u=await ju(i,a.publicKey,l),d=new Qu({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});Hu(d.s,t),t.trace("Stage 0 - Initiator starting to send first message."),await n.write(d.writeMessageA(hr),e),t.trace("Stage 0 - Initiator finished sending first message."),Gu(d.e,t),t.trace("Stage 1 - Initiator waiting to receive first message from responder...");const h=d.readMessageB(await n.read(e));t.trace("Stage 1 - Initiator received the message."),Yu(d.re,t),xy(d.rs,t),t.trace("Initiator going to check remote's signature...");const p=await Zu(h,d.rs,c);t.trace("All good with the signature!"),t.trace("Stage 2 - Initiator sending third handshake message."),await n.write(d.writeMessageC(u),e),t.trace("Stage 2 - Initiator sent message with signed payload.");const[f,g]=d.ss.split();return Xu(f,g,t),{payload:p,encrypt:m=>f.encryptWithAd(hr,m),decrypt:(m,v)=>g.decryptWithAd(hr,m,v)}}async function Dy(r,e){const{log:t,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:l}=r,u=await ju(i,a.publicKey,l),d=new Qu({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});Hu(d.s,t),t.trace("Stage 0 - Responder waiting to receive first message."),d.readMessageA(await n.read(e)),t.trace("Stage 0 - Responder received first message."),Yu(d.re,t),t.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await n.write(d.writeMessageB(u),e),t.trace("Stage 1 - Responder sent the second handshake message with signed payload."),Gu(d.e,t),t.trace("Stage 2 - Responder waiting for third handshake message...");const h=d.readMessageC(await n.read(e));t.trace("Stage 2 - Responder received the message, finished handshake.");const p=await Zu(h,d.rs,c),[f,g]=d.ss.split();return Xu(f,g,t),{payload:p,encrypt:m=>g.encryptWithAd(hr,m),decrypt:(m,v)=>f.decryptWithAd(hr,m,v)}}const nc=16;function Ry(r,e){return async function*(t){for await(const n of t)for(let s=0;s<n.length;s+=Ya){let i=s+Ya;i>n.length&&(i=n.length);let o;n instanceof Uint8Array?o=r.encrypt(n.subarray(s,i)):o=r.encrypt(n.sublist(s,i)),e?.encryptedPackets.increment(),yield new J(hs(o.byteLength),o)}}}function My(r,e){return async function*(t){for await(const n of t)for(let s=0;s<n.length;s+=rn){let i=s+rn;if(i>n.length&&(i=n.length),i-nc<s)throw new Error("Invalid chunk");const o=n.sublist(s,i),a=n.subarray(s,i-nc);try{const c=r.decrypt(o,a);e?.decryptedPackets.increment(),yield c}catch(c){throw e?.decryptErrors.increment(),c}}}}class Oy{protocol="/noise";crypto;prologue;staticKey;extensions;metrics;components;constructor(e,t={}){const{staticNoiseKey:n,extensions:s,crypto:i,prologueBytes:o}=t,{metrics:a}=e;this.components=e;const c=i??vy;this.crypto=Ey(c),this.extensions={webtransportCerthashes:[],...s},this.metrics=a?Sy(a):void 0,n?this.staticKey=c.generateX25519KeyPairFromSeed(n):this.staticKey=c.generateX25519KeyPair(),this.prologue=o??se(0)}[Symbol.toStringTag]="@chainsafe/libp2p-noise";[it]=["@libp2p/connection-encryption","@chainsafe/libp2p-noise"];async secureOutbound(e,t){const n=br(e,{lengthEncoder:hs,lengthDecoder:Xn,maxDataLength:rn}),s=await this.performHandshakeInitiator(n,this.components.privateKey,t?.remotePeer?.publicKey,t),i=await this.createSecureConnection(n,s);e.source=i.source,e.sink=i.sink;const o=Bt(s.payload.identityKey);return{conn:e,remoteExtensions:s.payload.extensions,remotePeer:tn(o),streamMuxer:t?.skipStreamMuxerNegotiation===!0?void 0:this.getStreamMuxer(s.payload.extensions?.streamMuxers)}}getStreamMuxer(e){if(e==null||e.length===0)return;const t=this.components.upgrader.getStreamMuxers();if(t!=null)for(const n of e){const s=t.get(n);if(s!=null)return s}if(e.length)throw new Rh("Early muxer negotiation was requested but the initiator and responder had no common muxers")}async secureInbound(e,t){const n=br(e,{lengthEncoder:hs,lengthDecoder:Xn,maxDataLength:rn}),s=await this.performHandshakeResponder(n,this.components.privateKey,t?.remotePeer?.publicKey,t),i=await this.createSecureConnection(n,s);e.source=i.source,e.sink=i.sink;const o=Bt(s.payload.identityKey);return{conn:e,remoteExtensions:s.payload.extensions,remotePeer:tn(o),streamMuxer:t?.skipStreamMuxerNegotiation===!0?void 0:this.getStreamMuxer(s.payload.extensions?.streamMuxers)}}async performHandshakeInitiator(e,t,n,s){let i;const o=s?.skipStreamMuxerNegotiation===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{i=await Ly({connection:e,privateKey:t,remoteIdentityKey:n,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:o,webtransportCerthashes:[],...this.extensions}},s),this.metrics?.xxHandshakeSuccesses.increment()}catch(a){throw this.metrics?.xxHandshakeErrors.increment(),a}return i}async performHandshakeResponder(e,t,n,s){let i;const o=s?.skipStreamMuxerNegotiation===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{i=await Dy({connection:e,privateKey:t,remoteIdentityKey:n,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:o,webtransportCerthashes:[],...this.extensions}},s),this.metrics?.xxHandshakeSuccesses.increment()}catch(a){throw this.metrics?.xxHandshakeErrors.increment(),a}return i}async createSecureConnection(e,t){const[n,s]=Fm(),i=e.unwrap();return await $u(n,Ry(t,this.metrics),i,o=>ls(o,{lengthDecoder:Xn}),My(t,this.metrics),n),s}}function Ny(r={}){return e=>new Oy(e,r)}function ed(r){if(r!=null){if(typeof r[Symbol.iterator]=="function")return r[Symbol.iterator]();if(typeof r[Symbol.asyncIterator]=="function")return r[Symbol.asyncIterator]();if(typeof r.next=="function")return r}throw new Error("argument is not an iterator or iterable")}class ur extends Error{static name="InvalidFrameError";constructor(e="The frame was invalid"){super(e),this.name="InvalidFrameError"}}class td extends Error{static name="UnrequestedPingError";constructor(e="Unrequested ping error"){super(e),this.name="UnrequestedPingError"}}class rd extends Error{static name="NotMatchingPingError";constructor(e="Unrequested ping error"){super(e),this.name="NotMatchingPingError"}}class Fy extends Error{static name="InvalidStateError";constructor(e="Invalid state"){super(e),this.name="InvalidStateError"}}class Uy extends Error{static name="StreamAlreadyExistsError";constructor(e="Strean already exists"){super(e),this.name="StreamAlreadyExistsError"}}class By extends Error{static name="DecodeInvalidVersionError";constructor(e="Decode invalid version"){super(e),this.name="DecodeInvalidVersionError"}}class $y extends Error{static name="BothClientsError";constructor(e="Both clients"){super(e),this.name="BothClientsError"}}class nd extends Error{static name="ReceiveWindowExceededError";constructor(e="Receive window exceeded"){super(e),this.name="ReceiveWindowExceededError"}}const zy=new Set([ur.name,td.name,rd.name,Uy.name,By.name,$y.name,nd.name]),Yo=256*1024,Ky=16*1024*1024,qy={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:Yo,maxStreamWindowSize:Ky,maxMessageSize:64*1024};function Wy(r){if(r.keepAliveInterval<=0)throw new V("keep-alive interval must be positive");if(r.maxInboundStreams<0)throw new V("max inbound streams must be larger or equal 0");if(r.maxOutboundStreams<0)throw new V("max outbound streams must be larger or equal 0");if(r.initialStreamWindowSize<Yo)throw new V("InitialStreamWindowSize must be larger or equal 256 kB");if(r.maxStreamWindowSize<r.initialStreamWindowSize)throw new V("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(r.maxStreamWindowSize>2**32-1)throw new V("MaxStreamWindowSize must be less than equal MAX_UINT32");if(r.maxMessageSize<1024)throw new V("MaxMessageSize must be greater than a kilobyte")}var be;(function(r){r[r.Data=0]="Data",r[r.WindowUpdate=1]="WindowUpdate",r[r.Ping=2]="Ping",r[r.GoAway=3]="GoAway"})(be||(be={}));var fe;(function(r){r[r.SYN=1]="SYN",r[r.ACK=2]="ACK",r[r.FIN=4]="FIN",r[r.RST=8]="RST"})(fe||(fe={}));Object.values(fe).filter(r=>typeof r!="string");const Vy=0;var lt;(function(r){r[r.NormalTermination=0]="NormalTermination",r[r.ProtocolError=1]="ProtocolError",r[r.InternalError=2]="InternalError"})(lt||(lt={}));const Yr=12,sc=2**24;function Hy(r){if(r[0]!==Vy)throw new ur("Invalid frame version");return{type:r[1],flag:(r[2]<<8)+r[3],streamID:r[4]*sc+(r[5]<<16)+(r[6]<<8)+r[7],length:r[8]*sc+(r[9]<<16)+(r[10]<<8)+r[11]}}class Gy{source;buffer;frameInProgress;constructor(e){this.source=Yy(e),this.buffer=new J,this.frameInProgress=!1}async*emitFrames(){for await(const e of this.source)for(this.buffer.append(e);;){const t=this.readHeader();if(t===void 0)break;const{type:n,length:s}=t;n===be.Data?(this.frameInProgress=!0,yield{header:t,readData:this.readBytes.bind(this,s)}):yield{header:t}}}readHeader(){if(this.frameInProgress)throw new Fy("decoding frame already in progress");if(this.buffer.length<Yr)return;const e=Hy(this.buffer.subarray(0,Yr));return this.buffer.consume(Yr),e}async readBytes(e){if(this.buffer.length<e){for await(const n of this.source)if(this.buffer.append(n),this.buffer.length>=e)break}const t=this.buffer.sublist(0,e);return this.buffer.consume(e),this.frameInProgress=!1,t}}function Yy(r){if(r[Symbol.iterator]!==void 0){const e=r[Symbol.iterator]();return e.return=void 0,{[Symbol.iterator](){return e}}}else if(r[Symbol.asyncIterator]!==void 0){const e=r[Symbol.asyncIterator]();return e.return=void 0,{[Symbol.asyncIterator](){return e}}}else throw new Error("a source must be either an iterable or an async iterable")}function ic(r){const e=new Uint8Array(Yr);return e[1]=r.type,e[2]=r.flag>>>8,e[3]=r.flag,e[4]=r.streamID>>>24,e[5]=r.streamID>>>16,e[6]=r.streamID>>>8,e[7]=r.streamID,e[8]=r.length>>>24,e[9]=r.length>>>16,e[10]=r.length>>>8,e[11]=r.length,e}function Xy(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}function Qy(r,e){const t=ed(r).return?.();Xy(t)&&t.catch(n=>{e.error("could not cause iterator to return",n)})}const jy=5e3;function fi(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class sd{id;direction;timeline;protocol;metadata;source;status;readStatus;writeStatus;log;sinkController;sinkEnd;closed;endErr;streamSource;onEnd;onCloseRead;onCloseWrite;onReset;onAbort;sendCloseWriteTimeout;sendingData;constructor(e){this.sinkController=new AbortController,this.sinkEnd=he(),this.closed=he(),this.log=e.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=e.id,this.metadata=e.metadata??{},this.direction=e.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=e.sendCloseWriteTimeout??jy,this.onEnd=e.onEnd,this.onCloseRead=e.onCloseRead,this.onCloseWrite=e.onCloseWrite,this.onReset=e.onReset,this.onAbort=e.onAbort,this.source=this.streamSource=En({onEnd:t=>{t!=null?this.log.trace("source ended with error",t):this.log.trace("source ended"),this.onSourceEnd(t)}}),this.sink=this.sink.bind(this)}async sink(e){if(this.writeStatus!=="ready")throw new Ui(`writable end state is "${this.writeStatus}" not "ready"`);try{this.writeStatus="writing";const t={signal:this.sinkController.signal};if(this.direction==="outbound"){const s=this.sendNewStream(t);fi(s)&&await s}const n=()=>{Qy(e,this.log)};try{this.sinkController.signal.addEventListener("abort",n),this.log.trace("sink reading from source");for await(let s of e){s=s instanceof Uint8Array?new J(s):s;const i=this.sendData(s,t);fi(i)&&(this.sendingData=he(),await i,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",n)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),this.writeStatus==="writing"&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(t){throw this.log.trace("sink ended with error, calling abort with error",t),this.abort(t),t}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(e){this.timeline.closeRead==null&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),this.onCloseRead?.(),this.timeline.closeWrite!=null?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(e){this.timeline.closeWrite==null&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),this.onCloseWrite?.(),this.timeline.closeRead!=null?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(e){this.status==="open"&&(this.log.trace("closing gracefully"),this.status="closing",await Je(Promise.all([this.closeWrite(e),this.closeRead(e),this.closed.promise]),e?.signal),this.status="closed",this.log.trace("closed gracefully"))}async closeRead(e={}){if(this.readStatus==="closing"||this.readStatus==="closed")return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);const t=this.readStatus;this.readStatus="closing",this.status!=="reset"&&this.status!=="aborted"&&this.timeline.closeRead==null&&(this.log.trace("send close read to remote"),await this.sendCloseRead(e)),t==="ready"&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(e={}){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),this.writeStatus==="ready"&&(this.log.trace("sink was never sunk, sink an empty array"),await Je(this.sink([]),e.signal)),this.writeStatus==="writing"&&(this.sendingData!=null&&await Je(this.sendingData.promise,e.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await Je(this.sinkEnd.promise,e.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(e){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;this.log("abort with error",e),this.log("try to send reset to remote");const t=this.sendReset();fi(t)&&t.catch(n=>{this.log.error("error sending reset message",n)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(e),this.onAbort?.(e)}reset(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;const e=new Oh("stream reset");this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(e),this.onReset?.()}_closeSinkAndSource(e){this._closeSink(e),this._closeSource(e)}_closeSink(e){this.writeStatus==="writing"&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(e)}_closeSource(e){this.readStatus!=="closing"&&this.readStatus!=="closed"&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(e))}remoteCloseWrite(){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("received remote close write but local source is already closed");return}this.log.trace("remote close write"),this._closeSource()}remoteCloseRead(){if(this.writeStatus==="closing"||this.writeStatus==="closed"){this.log("received remote close read but local sink is already closed");return}this.log.trace("remote close read"),this._closeSink()}destroy(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset"){this.log("received destroy but we are already closed");return}this.log.trace("stream destroyed"),this._closeSinkAndSource()}sourcePush(e){this.streamSource.push(e)}sourceReadableLength(){return this.streamSource.readableLength}}function id(r){const[e,t]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>e.next(),push:s=>{n.push(s)},next:()=>n.length>0?{done:!1,value:n.shift()}:e.next(),[t](){return this}}}function Zy(r){return r[Symbol.asyncIterator]!=null}function oc(r){return r?.then!=null}function od(r,e){let t=0;if(Zy(r))return async function*(){for await(const c of r){const l=e(c,t++);oc(l)&&await l,yield c}}();const n=id(r),{value:s,done:i}=n.next();if(i===!0)return function*(){}();if(typeof e(s,t++)?.then=="function")return async function*(){yield s;for await(const c of n){const l=e(c,t++);oc(l)&&await l,yield c}}();const a=e;return function*(){yield s;for(const c of n)a(c,t++),yield c}()}var nt;(function(r){r[r.Init=0]="Init",r[r.SYNSent=1]="SYNSent",r[r.SYNReceived=2]="SYNReceived",r[r.Established=3]="Established",r[r.Finished=4]="Finished"})(nt||(nt={}));class Jy extends sd{name;state;config;_id;sendWindowCapacity;sendWindowCapacityUpdate;recvWindow;recvWindowCapacity;epochStart;getRTT;sendFrame;constructor(e){super({...e,onEnd:t=>{this.state=nt.Finished,e.onEnd?.(t)}}),this.config=e.config,this._id=parseInt(e.id,10),this.name=e.name,this.state=e.state,this.sendWindowCapacity=Yo,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=e.getRTT,this.sendFrame=e.sendFrame,this.source=od(this.source,()=>{this.sendWindowUpdate()})}async sendNewStream(){}async sendData(e,t={}){for(e=e.sublist();e.byteLength!==0;){if(this.sendWindowCapacity===0&&(this.log?.trace("wait for send window capacity, status %s",this.status),await this.waitForSendWindowCapacity(t),this.status==="closed"||this.status==="aborted"||this.status==="reset")){this.log?.trace("%s while waiting for send window capacity",this.status);return}const n=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-Yr,e.length),s=this.getSendFlags();this.sendFrame({type:be.Data,flag:s,streamID:this._id,length:n},e.sublist(0,n)),this.sendWindowCapacity-=n,e.consume(n)}}async sendReset(){this.sendFrame({type:be.WindowUpdate,flag:fe.RST,streamID:this._id,length:0})}async sendCloseWrite(){const e=this.getSendFlags()|fe.FIN;this.sendFrame({type:be.WindowUpdate,flag:e,streamID:this._id,length:0})}async sendCloseRead(){}async waitForSendWindowCapacity(e={}){if(this.sendWindowCapacity>0)return;let t,n;const s=()=>{this.status==="open"||this.status==="closing"?n(new Qt("Stream aborted")):t()};e.signal?.addEventListener("abort",s);try{await new Promise((i,o)=>{this.sendWindowCapacityUpdate=()=>{i()},n=o,t=i})}finally{e.signal?.removeEventListener("abort",s)}}handleWindowUpdate(e){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(e.flag);const t=this.sendWindowCapacity;this.sendWindowCapacity+=e.length,t===0&&e.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(e,t){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(e.flag),this.recvWindowCapacity<e.length)throw new nd("Receive window exceeded");const n=await t();this.recvWindowCapacity-=e.length,this.sourcePush(n)}processFlags(e){(e&fe.ACK)===fe.ACK&&this.state===nt.SYNSent&&(this.state=nt.Established),(e&fe.FIN)===fe.FIN&&this.remoteCloseWrite(),(e&fe.RST)===fe.RST&&this.reset()}getSendFlags(){switch(this.state){case nt.Init:return this.state=nt.SYNSent,fe.SYN;case nt.SYNReceived:return this.state=nt.Established,fe.ACK;default:return 0}}sendWindowUpdate(){const e=this.getSendFlags(),t=Date.now(),n=this.getRTT();if(e===0&&n>-1&&t-this.epochStart<n*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&e===0)return;const s=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=t,this.sendFrame({type:be.WindowUpdate,flag:e,streamID:this._id,length:s})}}const ad="/yamux/1.0.0",ew=500;class tw{protocol=ad;_components;_init;constructor(e,t={}){this._components=e,this._init=t}[Symbol.toStringTag]="@chainsafe/libp2p-yamux";[it]=["@libp2p/stream-multiplexing"];createStreamMuxer(e){return new rw(this._components,{...this._init,...e})}}class rw{protocol=ad;source;sink;config;log;logger;closeController;nextStreamID;_streams;nextPingID;activePing;rtt;client;localGoAway;remoteGoAway;numInboundStreams;numOutboundStreams;onIncomingStream;onStreamEnd;constructor(e,t){this.client=t.direction==="outbound",this.config={...qy,...t},this.logger=e.logger,this.log=this.logger.forComponent("libp2p:yamux"),Wy(this.config),this.closeController=new AbortController,this.closeController.signal,this.onIncomingStream=t.onIncomingStream,this.onStreamEnd=t.onStreamEnd,this._streams=new Map,this.source=En({onEnd:()=>{this.log?.trace("muxer source ended"),this._streams.forEach(n=>{n.destroy()})}}),this.sink=async n=>{const s=()=>{const a=ed(n);if(a.return!=null){const c=a.return();nw(c)&&c.catch(l=>{this.log?.("could not cause sink source to return",l)})}};let i,o;try{const a=new Gy(n);try{this.closeController.signal.addEventListener("abort",s);for await(const c of a.emitFrames())await this.handleFrame(c.header,c.readData)}finally{this.closeController.signal.removeEventListener("abort",s)}i=lt.NormalTermination}catch(a){zy.has(a.name)?(this.log?.error("protocol error in sink",a),i=lt.ProtocolError):(this.log?.error("internal error in sink",a),i=lt.InternalError),o=a}this.log?.trace("muxer sink ended"),o!=null?this.abort(o,i):await this.close({reason:i})},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(n=>this.log?.error("keepalive error: %s",n)),this.ping().catch(n=>this.log?.error("ping error: %s",n))}get streams(){return Array.from(this._streams.values())}newStream(e){if(this.remoteGoAway!==void 0)throw new Nr("Muxer closed remotely");if(this.localGoAway!==void 0)throw new Nr("Muxer closed locally");const t=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new Ul("max outbound streams exceeded");this.log?.trace("new outgoing stream id=%s",t);const n=this._newStream(t,e,nt.Init,"outbound");return this._streams.set(t,n),this.numOutboundStreams++,n.sendWindowUpdate(),n}async ping(){if(this.remoteGoAway!==void 0)throw new Nr("Muxer closed remotely");if(this.localGoAway!==void 0)throw new Nr("Muxer closed locally");if(this.activePing===void 0){let e=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((s,i)=>{const o=()=>{i(new Nr("Muxer closed locally"))};this.closeController.signal.addEventListener("abort",o,{once:!0}),e=()=>{this.closeController.signal.removeEventListener("abort",o),s()}}),resolve:e};const t=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}const n=Date.now();this.rtt=n-t}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}async close(e={}){if(this.closeController.signal.aborted)return;const t=e?.reason??lt.NormalTermination;if(this.log?.trace("muxer close reason=%s",t),e.signal==null){const n=AbortSignal.timeout(ew);e={...e,signal:n}}try{await Promise.all([...this._streams.values()].map(async n=>n.close(e))),this.sendGoAway(t),this._closeMuxer()}catch(n){this.abort(n)}}abort(e,t){if(!this.closeController.signal.aborted){t=t??lt.InternalError,this.log?.error("muxer abort reason=%s error=%s",t,e);for(const n of this._streams.values())n.abort(e);this.sendGoAway(t),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(e,t,n,s){if(this._streams.get(e)!=null)throw new V("Stream already exists with that id");const i=new Jy({id:e.toString(),name:t,state:n,direction:s,sendFrame:this.sendFrame.bind(this),onEnd:()=>{this.closeStream(e),this.onStreamEnd?.(i)},log:this.logger.forComponent(`libp2p:yamux:${s}:${e}`),config:this.config,getRTT:this.getRTT.bind(this)});return i}closeStream(e){this.client===(e%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(e)}async keepAliveLoop(){const e=new Promise((t,n)=>{this.closeController.signal.addEventListener("abort",n,{once:!0})});for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let t;try{await Promise.race([e,new Promise(n=>{t=setTimeout(n,this.config.keepAliveInterval)})]),this.ping().catch(n=>this.log?.error("ping error: %s",n))}catch{clearInterval(t);return}}}async handleFrame(e,t){const{streamID:n,type:s,length:i}=e;if(this.log?.trace("received frame %o",e),n===0)switch(s){case be.Ping:{this.handlePing(e);return}case be.GoAway:{this.handleGoAway(i);return}default:throw new ur("Invalid frame type")}else switch(e.type){case be.Data:case be.WindowUpdate:{await this.handleStreamMessage(e,t);return}default:throw new ur("Invalid frame type")}}handlePing(e){if(e.flag===fe.SYN)this.log?.trace("received ping request pingId=%s",e.length),this.sendPing(e.length,fe.ACK);else if(e.flag===fe.ACK)this.log?.trace("received ping response pingId=%s",e.length),this.handlePingResponse(e.length);else throw new ur("Invalid frame flag")}handlePingResponse(e){if(this.activePing===void 0)throw new td("ping not requested");if(this.activePing.id!==e)throw new rd("ping doesn't match our id");this.activePing.resolve()}handleGoAway(e){this.log?.trace("received GoAway reason=%s",lt[e]??"unknown"),this.remoteGoAway=e;for(const t of this._streams.values())t.reset();this._closeMuxer()}async handleStreamMessage(e,t){const{streamID:n,flag:s,type:i}=e;(s&fe.SYN)===fe.SYN&&this.incomingStream(n);const o=this._streams.get(n);if(o===void 0){if(i===be.Data){if(this.log?.("discarding data for stream id=%s",n),t===void 0)throw new Error("unreachable");await t()}else this.log?.trace("frame for missing stream id=%s",n);return}switch(i){case be.WindowUpdate:{o.handleWindowUpdate(e);return}case be.Data:{if(t===void 0)throw new Error("unreachable");await o.handleData(e,t);return}default:throw new Error("unreachable")}}incomingStream(e){if(this.client!==(e%2===0))throw new V("Both endpoints are clients");if(this._streams.has(e))return;if(this.log?.trace("new incoming stream id=%s",e),this.localGoAway!==void 0){this.sendFrame({type:be.WindowUpdate,flag:fe.RST,streamID:e,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){this.log?.("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:be.WindowUpdate,flag:fe.RST,streamID:e,length:0});return}const t=this._newStream(e,void 0,nt.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(e,t),this.onIncomingStream?.(t)}sendFrame(e,t){if(this.log?.trace("sending frame %o",e),e.type===be.Data){if(t===void 0)throw new ur("Invalid frame");this.source.push(new J(ic(e),t))}else this.source.push(ic(e))}sendPing(e,t=fe.SYN){t===fe.SYN?this.log?.trace("sending ping request pingId=%s",e):this.log?.trace("sending ping response pingId=%s",e),this.sendFrame({type:be.Ping,flag:t,streamID:0,length:e})}sendGoAway(e=lt.NormalTermination){this.log?.("sending GoAway reason=%s",lt[e]),this.localGoAway=e,this.sendFrame({type:be.GoAway,flag:0,streamID:0,length:e})}}function nw(r){return r!=null&&typeof r.then=="function"}function sw(r={}){return e=>new tw(e,r)}var gs;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&t.payload.byteLength>0&&(n.uint32(26),n.bytes(t.payload)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={publicKey:se(0),payloadType:se(0),payload:se(0),signature:se(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=t.bytes();break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(gs||(gs={}));class iw extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}}class ht{static createFromProtobuf=async e=>{const t=gs.decode(e),n=Bt(t.publicKey);return new ht({publicKey:n,payloadType:t.payloadType,payload:t.payload,signature:t.signature})};static seal=async(e,t)=>{if(t==null)throw new Error("Missing private key");const n=e.domain,s=e.codec,i=e.marshal(),o=ac(n,s,i),a=await t.sign(o.subarray());return new ht({publicKey:t.publicKey,payloadType:s,payload:i,signature:a})};static openAndCertify=async(e,t)=>{const n=await ht.createFromProtobuf(e);if(!await n.validate(t))throw new iw("Envelope signature is not valid for the given domain");return n};publicKey;payloadType;payload;signature;marshaled;constructor(e){const{publicKey:t,payloadType:n,payload:s,signature:i}=e;this.publicKey=t,this.payloadType=n,this.payload=s,this.signature=i}marshal(){return this.marshaled==null&&(this.marshaled=gs.encode({publicKey:xt(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return e==null?!1:Oe(this.marshal(),e.marshal())}async validate(e){const t=ac(e,this.payloadType,this.payload);return this.publicKey.verify(t.subarray(),this.signature)}}const ac=(r,e,t)=>{const n=q(r),s=dt(n.byteLength),i=dt(e.length),o=dt(t.length);return new J(s,n,i,e,o,t)};function ow(r,e){const t=(n,s)=>n.toString().localeCompare(s.toString());return r.length!==e.length?!1:(e.sort(t),r.sort(t).every((n,s)=>e[s].equals(n)))}class aw{index=0;input="";new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,n=e();return n===void 0&&(this.index=t),n}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{const t=this.readChar();if(t===e)return t})}readSeparator(e,t,n){return this.readAtomically(()=>{if(!(t>0&&this.readGivenChar(e)===void 0))return n()})}readNumber(e,t,n,s){return this.readAtomically(()=>{let i=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",l=2**(8*s)-1;for(;;){const u=this.readAtomically(()=>{const d=this.readChar();if(d===void 0)return;const h=Number.parseInt(d,e);if(!Number.isNaN(h))return h});if(u===void 0)break;if(i*=e,i+=u,i>l||(o+=1,t!==void 0&&o>t))return}if(o!==0)return!n&&c&&o>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const n=this.readSeparator(".",t,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;e[t]=n}return e})}readIPv6Addr(){const e=t=>{for(let n=0;n<t.length/2;n++){const s=n*2;if(n<t.length-3){const o=this.readSeparator(":",n,()=>this.readIPv4Addr());if(o!==void 0)return t[s]=o[0],t[s+1]=o[1],t[s+2]=o[2],t[s+3]=o[3],[s+4,!0]}const i=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(i===void 0)return[s,!1];t[s]=i>>8,t[s+1]=i&255}return[t.length,!1]};return this.readAtomically(()=>{const t=new Uint8Array(16),[n,s]=e(t);if(n===16)return t;if(s||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const i=new Uint8Array(14),o=16-(n+2),[a]=e(i.subarray(0,o));return t.set(i.subarray(0,a),16-a),t})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const cd=45,cw=15,Er=new aw;function ld(r){if(!(r.length>cw))return Er.new(r).parseWith(()=>Er.readIPv4Addr())}function ud(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>cd))return Er.new(r).parseWith(()=>Er.readIPv6Addr())}function ms(r,e=!1){if(r.includes("%")&&(r=r.split("%")[0]),r.length>cd)return;const t=Er.new(r).parseWith(()=>Er.readIPAddr());if(t)return e&&t.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,t[0],t[1],t[2],t[3]]):t}function lw(r,e,t){let n=0;for(const s of r)if(!(n<e)){if(n>t)break;if(s!==255)return!1;n++}return!0}function uw(r,e,t,n){let s=0;for(const i of r)if(!(s<t)){if(s>n)break;if(i!==e[s])return!1;s++}return!0}function dw(r){switch(r.length){case nn:return r.join(".");case sn:{const e=[];for(let t=0;t<r.length;t++)t%2===0&&e.push(r[t].toString(16).padStart(2,"0")+r[t+1].toString(16).padStart(2,"0"));return e.join(":")}default:throw new Error("Invalid ip length")}}function hw(r){let e=0;for(let[t,n]of r.entries()){if(n===255){e+=8;continue}for(;(n&128)!=0;)e++,n=n<<1;if((n&128)!=0)return-1;for(let s=t+1;s<r.length;s++)if(r[s]!=0)return-1;break}return e}function fw(r){let e="0x";for(const t of r)e+=(t>>4).toString(16)+(t&15).toString(16);return e}const nn=4,sn=16,pw=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function dd(r,e){e.length===sn&&r.length===nn&&lw(e,0,11)&&(e=e.slice(12)),e.length===nn&&r.length===sn&&uw(r,pw,0,11)&&(r=r.slice(12));const t=r.length;if(t!=e.length)throw new Error("Failed to mask ip");const n=new Uint8Array(t);for(let s=0;s<t;s++)n[s]=r[s]&e[s];return n}function gw(r,e){if(typeof e=="string"&&(e=ms(e)),e==null)throw new Error("Invalid ip");if(e.length!==r.network.length)return!1;for(let t=0;t<e.length;t++)if((r.network[t]&r.mask[t])!==(e[t]&r.mask[t]))return!1;return!0}function mw(r){const[e,t]=r.split("/");if(!e||!t)throw new Error("Failed to parse given CIDR: "+r);let n=nn,s=ld(e);if(s==null&&(n=sn,s=ud(e),s==null))throw new Error("Failed to parse given CIDR: "+r);const i=parseInt(t,10);if(Number.isNaN(i)||String(i).length!==t.length||i<0||i>n*8)throw new Error("Failed to parse given CIDR: "+r);const o=hd(i,8*n);return{network:dd(s,o),mask:o}}function hd(r,e){if(e!==8*nn&&e!==8*sn)throw new Error("Invalid CIDR mask");if(r<0||r>e)throw new Error("Invalid CIDR mask");const t=e/8,n=new Uint8Array(t);for(let s=0;s<t;s++){if(r>=8){n[s]=255,r-=8;continue}n[s]=255-(255>>r),r=0}return n}class fd{constructor(e,t){if(t==null)({network:this.network,mask:this.mask}=mw(e));else{const n=ms(e);if(n==null)throw new Error("Failed to parse network");t=String(t);const s=parseInt(t,10);if(Number.isNaN(s)||String(s).length!==t.length||s<0||s>n.length*8){const i=ms(t);if(i==null)throw new Error("Failed to parse mask");this.mask=i}else this.mask=hd(s,8*n.length);this.network=dd(n,this.mask)}}contains(e){return gw({network:this.network,mask:this.mask},e)}toString(){const e=hw(this.mask),t=e!==-1?String(e):fw(this.mask);return dw(this.network)+"/"+t}}function yw(r,e){return new fd(r).contains(e)}function Sr(r){return!!ld(r)}function Xo(r){return!!ud(r)}function pd(r){return!!ms(r)}const cc=Sr,ww=Xo,gd=function(r){let e=0;if(r=r.toString().trim(),cc(r)){const t=new Uint8Array(e+4);return r.split(/\./g).forEach(n=>{t[e++]=parseInt(n,10)&255}),t}if(ww(r)){const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const i=cc(t[n]);let o;i&&(o=gd(t[n]),t[n]=Y(o.slice(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,Y(o.slice(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const i=[n,1];for(n=9-t.length;n>0;n--)i.push("0");t.splice.apply(t,i)}const s=new Uint8Array(e+16);for(n=0;n<t.length;n++){const i=parseInt(t[n],16);s[e++]=i>>8&255,s[e++]=i&255}return s}throw new Error("invalid ip address")},bw=function(r,e=0,t){e=~~e,t=t??r.length-e;const n=new DataView(r.buffer);if(t===4){const s=[];for(let i=0;i<t;i++)s.push(r[e+i]);return s.join(".")}if(t===16){const s=[];for(let i=0;i<t;i+=2)s.push(n.getUint16(e+i).toString(16));return s.join(":").replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}return""},Ge=-1,on={},io={},vw=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,Ge,"ip6zone"],[43,8,"ipcidr"],[53,Ge,"dns",!0],[54,Ge,"dns4",!0],[55,Ge,"dns6",!0],[56,Ge,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,Ge,"unix",!1,!0],[421,Ge,"ipfs"],[421,Ge,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,Ge,"garlic64"],[448,0,"tls"],[449,Ge,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,Ge,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[481,Ge,"http-path"],[777,Ge,"memory"]];vw.forEach(r=>{const e=Ew(...r);io[e.code]=e,on[e.name]=e});function Ew(r,e,t,n,s){return{code:r,size:e,name:t,resolvable:!!n,path:!!s}}function G(r){if(typeof r=="number"){if(io[r]!=null)return io[r];throw new Error(`no protocol with code: ${r}`)}else if(typeof r=="string"){if(on[r]!=null)return on[r];throw new Error(`no protocol with name: ${r}`)}throw new Error(`invalid protocol id type: ${typeof r}`)}const Sw=G("ip4"),xw=G("ip6"),Aw=G("ipcidr");function md(r,e){switch(G(r).code){case 4:case 41:return Tw(e);case 42:return mi(e);case 43:return Y(e,"base10");case 6:case 273:case 33:case 132:return yd(e).toString();case 53:case 54:case 55:case 56:case 400:case 449:case 777:return mi(e);case 421:return Lw(e);case 444:return dc(e);case 445:return dc(e);case 466:return Pw(e);case 481:return globalThis.encodeURIComponent(mi(e));default:return Y(e,"base16")}}function lc(r,e){switch(G(r).code){case 4:return uc(e);case 41:return uc(e);case 42:return gi(e);case 43:return q(e,"base10");case 6:case 273:case 33:case 132:return Qo(parseInt(e,10));case 53:case 54:case 55:case 56:case 400:case 449:case 777:return gi(e);case 421:return kw(e);case 444:return Dw(e);case 445:return Rw(e);case 466:return _w(e);case 481:return gi(globalThis.decodeURIComponent(e));default:return q(e,"base16")}}function Cw(r){let e,t;if(r.stringTuples().forEach(([n,s])=>{(n===Sw.code||n===xw.code)&&(t=s),n===Aw.code&&(e=s)}),e==null||t==null)throw new Error("Invalid multiaddr");return new fd(t,e)}const pi=Object.values(Wi).map(r=>r.decoder),Iw=function(){let r=pi[0].or(pi[1]);return pi.slice(2).forEach(e=>r=r.or(e)),r}();function uc(r){if(!pd(r))throw new Error("invalid ip address");return gd(r)}function Tw(r){const e=bw(r,0,r.length);if(e==null)throw new Error("ipBuff is required");if(!pd(e))throw new Error("invalid ip address");return e}function Qo(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,r),new Uint8Array(e)}function yd(r){return new DataView(r.buffer).getUint16(r.byteOffset)}function gi(r){const e=q(r),t=Uint8Array.from(dt(e.length));return ot([t,e],t.length+e.length)}function mi(r){const e=tr(r);if(r=r.slice(Ie(e)),r.length!==e)throw new Error("inconsistent lengths");return Y(r)}function kw(r){let e;r[0]==="Q"||r[0]==="1"?e=er(ye.decode(`z${r}`)).bytes:e=ae.parse(r).multihash.bytes;const t=Uint8Array.from(dt(e.length));return ot([t,e],t.length+e.length)}function _w(r){const e=Iw.decode(r),t=Uint8Array.from(dt(e.length));return ot([t,e],t.length+e.length)}function Pw(r){const e=tr(r),t=r.slice(Ie(e));if(t.length!==e)throw new Error("inconsistent lengths");return"u"+Y(t,"base64url")}function Lw(r){const e=tr(r),t=r.slice(Ie(e));if(t.length!==e)throw new Error("inconsistent lengths");return Y(t,"base58btc")}function Dw(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=St.decode("b"+e[0]),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=Qo(n);return ot([t,s],t.length+s.length)}function Rw(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=St.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=Qo(n);return ot([t,s],t.length+s.length)}function dc(r){const e=r.slice(0,r.length-2),t=r.slice(r.length-2),n=Y(e,"base32"),s=yd(t);return`${n}:${s}`}function Mw(r){r=oo(r);const e=[],t=[];let n=null;const s=r.split("/").slice(1);if(s.length===1&&s[0]==="")return{bytes:new Uint8Array,string:"/",tuples:[],stringTuples:[],path:null};for(let i=0;i<s.length;i++){const o=s[i],a=G(o);if(a.size===0){e.push([a.code]),t.push([a.code]);continue}if(i++,i>=s.length)throw new vd("invalid address: "+r);if(a.path===!0){n=oo(s.slice(i).join("/")),e.push([a.code,lc(a.code,n)]),t.push([a.code,n]);break}const c=lc(a.code,s[i]);e.push([a.code,c]),t.push([a.code,md(a.code,c)])}return{string:wd(t),bytes:bd(e),tuples:e,stringTuples:t,path:n}}function hc(r){const e=[],t=[];let n=null,s=0;for(;s<r.length;){const i=tr(r,s),o=Ie(i),a=G(i),c=Ow(a,r.slice(s+o));if(c===0){e.push([i]),t.push([i]),s+=o;continue}const l=r.slice(s+o,s+o+c);if(s+=c+o,s>r.length)throw new vd("Invalid address Uint8Array: "+Y(r,"base16"));e.push([i,l]);const u=md(i,l);if(t.push([i,u]),a.path===!0){n=u;break}}return{bytes:Uint8Array.from(r),string:wd(t),tuples:e,stringTuples:t,path:n}}function wd(r){const e=[];return r.map(t=>{const n=G(t[0]);return e.push(n.name),t.length>1&&t[1]!=null&&e.push(t[1]),null}),oo(e.join("/"))}function bd(r){return ot(r.map(e=>{const t=G(e[0]);let n=Uint8Array.from(dt(t.code));return e.length>1&&e[1]!=null&&(n=ot([n,e[1]])),n}))}function Ow(r,e){if(r.size>0)return r.size/8;if(r.size===0)return 0;{const t=tr(e instanceof Uint8Array?e:Uint8Array.from(e));return t+Ie(t)}}function oo(r){return"/"+r.trim().split("/").filter(e=>e).join("/")}class vd extends Error{static name="ParseError";name="ParseError";constructor(e){super(`Error parsing address: ${e}`)}}const Nw=Symbol.for("nodejs.util.inspect.custom"),Ed=Symbol.for("@multiformats/js-multiaddr/multiaddr"),Fw=[G("dns").code,G("dns4").code,G("dns6").code,G("dnsaddr").code];class Uw extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}}class dr{bytes;#e;#t;#r;#a;[Ed]=!0;constructor(e){e==null&&(e="");let t;if(e instanceof Uint8Array)t=hc(e);else if(typeof e=="string"){if(e.length>0&&e.charAt(0)!=="/")throw new Error(`multiaddr "${e}" must start with a "/"`);t=Mw(e)}else if(Bs(e))t=hc(e.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr");this.bytes=t.bytes,this.#e=t.string,this.#t=t.tuples,this.#r=t.stringTuples,this.#a=t.path}toString(){return this.#e}toJSON(){return this.toString()}toOptions(){let e,t,n,s,i="";const o=G("tcp"),a=G("udp"),c=G("ip4"),l=G("ip6"),u=G("dns6"),d=G("ip6zone");for(const[p,f]of this.stringTuples())p===d.code&&(i=`%${f??""}`),Fw.includes(p)&&(t=o.name==="tcp"?"tcp":"udp",s=443,n=`${f??""}${i}`,e=p===u.code?6:4),(p===o.code||p===a.code)&&(t=G(p).name==="tcp"?"tcp":"udp",s=parseInt(f??"")),(p===c.code||p===l.code)&&(t=G(p).name==="tcp"?"tcp":"udp",n=`${f??""}${i}`,e=p===l.code?6:4);if(e==null||t==null||n==null||s==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:n,transport:t,port:s}}protos(){return this.#t.map(([e])=>Object.assign({},G(e)))}protoCodes(){return this.#t.map(([e])=>e)}protoNames(){return this.#t.map(([e])=>G(e).name)}tuples(){return this.#t.map(([e,t])=>t==null?[e]:[e,t])}stringTuples(){return this.#r.map(([e,t])=>t==null?[e]:[e,t])}encapsulate(e){return e=new dr(e),new dr(this.toString()+e.toString())}decapsulate(e){const t=e.toString(),n=this.toString(),s=n.lastIndexOf(t);if(s<0)throw new Error(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new dr(n.slice(0,s))}decapsulateCode(e){const t=this.tuples();for(let n=t.length-1;n>=0;n--)if(t[n][0]===e)return new dr(bd(t.slice(0,n)));return this}getPeerId(){try{let e=[];this.stringTuples().forEach(([n,s])=>{n===on.p2p.code&&e.push([n,s]),n===on["p2p-circuit"].code&&(e=[])});const t=e.pop();if(t?.[1]!=null){const n=t[1];return n[0]==="Q"||n[0]==="1"?Y(ye.decode(`z${n}`),"base58btc"):Y(ae.parse(n).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){return this.#a}equals(e){return Oe(this.bytes,e.bytes)}async resolve(e){const t=this.protos().find(i=>i.resolvable);if(t==null)return[this];const n=jo.get(t.name);if(n==null)throw new Uw(`no available resolver for ${t.name}`);return(await n(this,e)).map(i=>Q(i))}nodeAddress(){const e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(e){const t=(e??this).protos();return!(t.length!==2||t[0].code!==4&&t[0].code!==41||t[1].code!==6&&t[1].code!==273)}[Nw](){return`Multiaddr(${this.#e})`}}const jo=new Map;function Bs(r){return!!r?.[Ed]}function Q(r){return new dr(r)}const Bw="libp2p-peer-record",$w=Uint8Array.from([3,1]);var ys;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=me((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.multiaddr!=null&&s.multiaddr.byteLength>0&&(i.uint32(10),i.bytes(s.multiaddr)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={multiaddr:se(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.multiaddr=s.bytes();break}default:{s.skipType(l&7);break}}}return a})),n),t.encode=s=>ge(s,t.codec()),t.decode=(s,i)=>pe(s,t.codec(),i)})(r.AddressInfo||(r.AddressInfo={}));let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.peerId!=null&&t.peerId.byteLength>0&&(n.uint32(10),n.bytes(t.peerId)),t.seq!=null&&t.seq!==0n&&(n.uint32(16),n.uint64(t.seq)),t.addresses!=null)for(const i of t.addresses)n.uint32(26),r.AddressInfo.codec().encode(i,n);s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={peerId:se(0),seq:0n,addresses:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.peerId=t.bytes();break}case 2:{i.seq=t.uint64();break}case 3:{if(s.limits?.addresses!=null&&i.addresses.length===s.limits.addresses)throw new Ct('Decode error - map field "addresses" had too many elements');i.addresses.push(r.AddressInfo.codec().decode(t,t.uint32(),{limits:s.limits?.addresses$}));break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(ys||(ys={}));class Qe{static createFromProtobuf=e=>{const t=ys.decode(e),n=bn(er(t.peerId)),s=(t.addresses??[]).map(o=>Q(o.multiaddr)),i=t.seq;return new Qe({peerId:n,multiaddrs:s,seqNumber:i})};static DOMAIN=Bw;static CODEC=$w;peerId;multiaddrs;seqNumber;domain=Qe.DOMAIN;codec=Qe.CODEC;marshaled;constructor(e){const{peerId:t,multiaddrs:n,seqNumber:s}=e;this.peerId=t,this.multiaddrs=n??[],this.seqNumber=s??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=ys.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(e=>({multiaddr:e.bytes}))})),this.marshaled}equals(e){return!(!(e instanceof Qe)||!this.peerId.equals(e.peerId)||this.seqNumber!==e.seqNumber||!ow(this.multiaddrs,e.multiaddrs))}}function It(r,e){const t=br(r,e),n={read:async(s,i)=>{const o=await t.read(i);return s.decode(o)},write:async(s,i,o)=>{await t.write(i.encode(s),o)},writeV:async(s,i,o)=>{await t.writeV(s.map(a=>i.encode(a)),o)},pb:s=>({read:async i=>n.read(s,i),write:async(i,o)=>n.write(i,s,o),writeV:async(i,o)=>n.writeV(i,s,o),unwrap:()=>n}),unwrap:()=>t.unwrap()};return n}const zw=290,Kw=1,Sd=2e3,qw=100,Nn=`${So}-circuit-relay`;BigInt(1<<17);const ws="/libp2p/circuit/relay/0.2.0/hop",fc="/libp2p/circuit/relay/0.2.0/stop",pc=300,Ww=4096,Vw=.001;var xr;(function(r){(function(n){n.RESERVE="RESERVE",n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let e;(function(n){n[n.RESERVE=0]="RESERVE",n[n.CONNECT=1]="CONNECT",n[n.STATUS=2]="STATUS"})(e||(e={})),function(n){n.codec=()=>Dr(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=me((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.peer!=null&&(s.uint32(18),Ar.codec().encode(n.peer,s)),n.reservation!=null&&(s.uint32(26),bs.codec().encode(n.reservation,s)),n.limit!=null&&(s.uint32(34),Cr.codec().encode(n.limit,s)),n.status!=null&&(s.uint32(40),Be.codec().encode(n.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=Ar.codec().decode(n,n.uint32(),{limits:i.limits?.peer});break}case 3:{o.reservation=bs.codec().decode(n,n.uint32(),{limits:i.limits?.reservation});break}case 4:{o.limit=Cr.codec().decode(n,n.uint32(),{limits:i.limits?.limit});break}case 5:{o.status=Be.codec().decode(n);break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>ge(n,r.codec()),r.decode=(n,s)=>pe(n,r.codec(),s)})(xr||(xr={}));var bt;(function(r){(function(n){n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let e;(function(n){n[n.CONNECT=0]="CONNECT",n[n.STATUS=1]="STATUS"})(e||(e={})),function(n){n.codec=()=>Dr(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=me((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.peer!=null&&(s.uint32(18),Ar.codec().encode(n.peer,s)),n.limit!=null&&(s.uint32(26),Cr.codec().encode(n.limit,s)),n.status!=null&&(s.uint32(32),Be.codec().encode(n.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=Ar.codec().decode(n,n.uint32(),{limits:i.limits?.peer});break}case 3:{o.limit=Cr.codec().decode(n,n.uint32(),{limits:i.limits?.limit});break}case 4:{o.status=Be.codec().decode(n);break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>ge(n,r.codec()),r.decode=(n,s)=>pe(n,r.codec(),s)})(bt||(bt={}));var Ar;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.id!=null&&t.id.byteLength>0&&(n.uint32(10),n.bytes(t.id)),t.addrs!=null)for(const i of t.addrs)n.uint32(18),n.bytes(i);s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={id:se(0),addrs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.id=t.bytes();break}case 2:{if(s.limits?.addrs!=null&&i.addrs.length===s.limits.addrs)throw new Ct('Decode error - map field "addrs" had too many elements');i.addrs.push(t.bytes());break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(Ar||(Ar={}));var bs;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.expire!=null&&t.expire!==0n&&(n.uint32(8),n.uint64(t.expire)),t.addrs!=null)for(const i of t.addrs)n.uint32(18),n.bytes(i);t.voucher!=null&&(n.uint32(26),Es.codec().encode(t.voucher,n)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={expire:0n,addrs:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.expire=t.uint64();break}case 2:{if(s.limits?.addrs!=null&&i.addrs.length===s.limits.addrs)throw new Ct('Decode error - map field "addrs" had too many elements');i.addrs.push(t.bytes());break}case 3:{i.voucher=Es.codec().decode(t,t.uint32(),{limits:s.limits?.voucher});break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(bs||(bs={}));var Cr;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.duration!=null&&(n.uint32(8),n.uint32(t.duration)),t.data!=null&&(n.uint32(16),n.uint64(t.data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.duration=t.uint32();break}case 2:{i.data=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(Cr||(Cr={}));var Be;(function(r){r.UNUSED="UNUSED",r.OK="OK",r.RESERVATION_REFUSED="RESERVATION_REFUSED",r.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",r.PERMISSION_DENIED="PERMISSION_DENIED",r.CONNECTION_FAILED="CONNECTION_FAILED",r.NO_RESERVATION="NO_RESERVATION",r.MALFORMED_MESSAGE="MALFORMED_MESSAGE",r.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(Be||(Be={}));var ao;(function(r){r[r.UNUSED=0]="UNUSED",r[r.OK=100]="OK",r[r.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",r[r.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",r[r.PERMISSION_DENIED=202]="PERMISSION_DENIED",r[r.CONNECTION_FAILED=203]="CONNECTION_FAILED",r[r.NO_RESERVATION=204]="NO_RESERVATION",r[r.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",r[r.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(ao||(ao={}));(function(r){r.codec=()=>Dr(ao)})(Be||(Be={}));var vs;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.relay!=null&&t.relay.byteLength>0&&(n.uint32(10),n.bytes(t.relay)),t.peer!=null&&t.peer.byteLength>0&&(n.uint32(18),n.bytes(t.peer)),t.expiration!=null&&t.expiration!==0n&&(n.uint32(24),n.uint64(t.expiration)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={relay:se(0),peer:se(0),expiration:0n},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.relay=t.bytes();break}case 2:{i.peer=t.bytes();break}case 3:{i.expiration=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(vs||(vs={}));var Es;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&(n.uint32(26),vs.codec().encode(t.payload,n)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={publicKey:se(0),payloadType:se(0),signature:se(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=vs.codec().decode(t,t.uint32(),{limits:s.limits?.payload});break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(Es||(Es={}));const Hw=r=>r.toString().split("/").slice(1),xn=r=>({match:e=>e.length<1?!1:r(e[0])?e.slice(1):!1,pattern:"fn"}),X=r=>({match:e=>xn(t=>t===r).match(e),pattern:r}),Rr=()=>({match:r=>xn(e=>typeof e=="string").match(r),pattern:"{string}"}),an=()=>({match:r=>xn(e=>!isNaN(parseInt(e))).match(r),pattern:"{number}"}),oe=()=>({match:r=>{if(r.length<2||r[0]!=="p2p"&&r[0]!=="ipfs")return!1;if(r[1].startsWith("Q")||r[1].startsWith("1"))try{ye.decode(`z${r[1]}`)}catch{return!1}else return!1;return r.slice(2)},pattern:"/p2p/{peerid}"}),Ss=()=>({match:r=>{if(r.length<2||r[0]!=="certhash")return!1;try{Yl.decode(r[1])}catch{return!1}return r.slice(2)},pattern:"/certhash/{certhash}"}),ne=r=>({match:e=>{const t=r.match(e);return t===!1?e:t},pattern:`optional(${r.pattern})`}),$e=(...r)=>({match:e=>{let t;for(const n of r){const s=n.match(e);s!==!1&&(t==null||s.length<t.length)&&(t=s)}return t??!1},pattern:`or(${r.map(e=>e.pattern).join(", ")})`}),j=(...r)=>({match:e=>{for(const t of r){const n=t.match(e);if(n===!1)return!1;e=n}return e},pattern:`and(${r.map(e=>e.pattern).join(", ")})`});function le(...r){function e(s){let i=Hw(s);for(const o of r){const a=o.match(i);if(a===!1)return!1;i=a}return i}function t(s){return e(s)!==!1}function n(s){const i=e(s);return i===!1?!1:i.length===0}return{matchers:r,matches:t,exactMatch:n}}const Gw=oe(),Yw=le(Gw),$s=j(X("dns4"),Rr()),zs=j(X("dns6"),Rr()),Ks=j(X("dnsaddr"),Rr()),Zo=j(X("dns"),Rr());le($s,ne(oe()));le(zs,ne(oe()));le(Ks,ne(oe()));le($e(Zo,Ks,$s,zs),ne(oe()));const xd=j(X("ip4"),xn(Sr)),Ad=j(X("ip6"),xn(Xo)),Jo=$e(xd,Ad),At=$e(Jo,Zo,$s,zs,Ks),Xw=le($e(Jo,j($e(Zo,Ks,$s,zs),ne(oe())))),gc=le(xd),mc=le(Ad);le(Jo);const ea=j(At,X("tcp"),an()),An=j(At,X("udp"),an()),xs=le(j(ea,ne(oe())));le(An);const ta=j(An,X("quic"),ne(oe())),qs=j(An,X("quic-v1"),ne(oe())),Qw=$e(ta,qs);le(ta);const jw=le(qs),co=$e(At,ea,An,ta,qs),Cd=$e(j(co,X("ws"),ne(oe()))),cn=le(Cd),Id=$e(j(co,X("wss"),ne(oe())),j(co,X("tls"),ne(j(X("sni"),Rr())),X("ws"),ne(oe()))),As=le(Id),Td=j(An,X("webrtc-direct"),ne(Ss()),ne(Ss()),ne(oe())),yc=le(Td),kd=j(qs,X("webtransport"),ne(Ss()),ne(Ss()),ne(oe())),wc=le(kd),Cs=$e(Cd,Id,j(ea,ne(oe())),j(Qw,ne(oe())),j(At,ne(oe())),Td,kd,oe()),_d=le(Cs),Zw=j(Cs,X("p2p-circuit"),oe()),ln=le(Zw),Jw=$e(j(Cs,X("p2p-circuit"),X("webrtc"),ne(oe())),j(Cs,X("webrtc"),ne(oe())),j(X("webrtc"),ne(oe()))),lo=le(Jw),eb=$e(j(At,X("tcp"),an(),X("http"),ne(oe())),j(At,X("http"),ne(oe())));le(eb);const tb=$e(j(At,X("tcp"),$e(j(X("443"),X("http")),j(an(),X("https")),j(an(),X("tls"),X("http"))),ne(oe())),j(At,X("tls"),X("http"),ne(oe())),j(At,X("https"),ne(oe())));le(tb);const rb=$e(j(X("memory"),Rr(),ne(oe())));le(rb);function $t(r){const e=new globalThis.AbortController;function t(){e.abort();for(const i of r)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}for(const i of r){if(i?.aborted===!0){t();break}i?.addEventListener!=null&&i.addEventListener("abort",t)}function n(){for(const i of r)i?.removeEventListener!=null&&i.removeEventListener("abort",t)}const s=e.signal;return s.clear=n,s}class bc extends Error{static name="HadEnoughRelaysError";name="HadEnoughRelaysError"}class nb extends Error{static name="DoubleRelayError";name="DoubleRelayError"}class sb extends Error{static name="RelayQueueFullError";name="RelayQueueFullError"}function vc(r){const e=r*BigInt(1e3),t=new Date().getTime();return Number(e-BigInt(t))}class Ec{expires;bytes;constructor(e){e?.duration!=null&&e?.duration!==0&&(this.expires=Date.now()+e.duration*1e3),this.bytes=e?.data,this.bytes===0n&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(e){this.bytes!=null&&(this.bytes-=BigInt(e.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(this.expires==null&&this.bytes==null)return;const e={};if(this.bytes!=null){const t=this;Object.defineProperty(e,"bytes",{get(){return t.bytes}})}if(this.expires!=null){const t=this;Object.defineProperty(e,"seconds",{get(){return Math.round(((t.expires??0)-Date.now())/1e3)}})}return e}}const Pd=le(j(_d.matchers[0],X("p2p-circuit"))),Ld=le(X("p2p-circuit"));function Xr(r,e){const t={[Symbol.iterator]:()=>t,next:()=>{const n=r.next(),s=n.value;return n.done===!0||s==null?{done:!0,value:void 0}:{done:!1,value:e(s)}}};return t}function yi(r){const e=er(ye.decode(`z${r}`));return bn(e)}class Ws{map;constructor(e){if(this.map=new Map,e!=null)for(const[t,n]of e.entries())this.map.set(t.toString(),{key:t,value:n})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return Xr(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach((t,n)=>{e(t.value,t.key,this)})}get(e){return this.map.get(e.toString())?.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return Xr(this.map.values(),e=>e.key)}values(){return Xr(this.map.values(),e=>e.value)}get size(){return this.map.size}}class fr{set;constructor(e){if(this.set=new Set,e!=null)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return Xr(this.set.entries(),e=>{const t=yi(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const n=yi(t);e(n,n,this)})}has(e){return this.set.has(e.toString())}values(){return Xr(this.set.values(),e=>yi(e))}intersection(e){const t=new fr;for(const n of e)this.has(n)&&t.add(n);return t}difference(e){const t=new fr;for(const n of this)e.has(n)||t.add(n);return t}union(e){const t=new fr;for(const n of e)t.add(n);for(const n of this)t.add(n);return t}}const ra={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},Dd={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},Rd=new globalThis.TextEncoder;function ib(r,e){const t=ra[e];let n=Dd[e];for(let s=0;s<r.length;s++)n^=BigInt(r[s]),n=BigInt.asUintN(e,n*t);return n}function ob(r,e,t){if(t.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const n=ra[e];let s=Dd[e],i=r;for(;i.length>0;){const o=Rd.encodeInto(i,t);i=i.slice(o.read);for(let a=0;a<o.written;a++)s^=BigInt(t[a]),s=BigInt.asUintN(e,s*n)}return s}function ab(r,{size:e=32,utf8Buffer:t}={}){if(!ra[e])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof r=="string"){if(t)return ob(r,e,t);r=Rd.encode(r)}return ib(r,e)}const na={hash:r=>Number(ab(r,{size:32})),hashV:(r,e)=>cb(na.hash(r,e))};function cb(r){let e=r.toString(16);return e.length%2===1&&(e=`0${e}`),q(e,"base16")}const Md=64;class Vt{fp;h;seed;constructor(e,t,n,s=2){if(s>Md)throw new TypeError("Invalid Fingerprint Size");const i=t.hashV(e,n),o=se(s);for(let a=0;a<o.length;a++)o[a]=i[a];o.length===0&&(o[0]=7),this.fp=o,this.h=t,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return e?.fp instanceof Uint8Array?Oe(this.fp,e.fp):!1}}function Is(r,e){return Math.floor(Math.random()*(e-r))+r}class Fn{contents;constructor(e){this.contents=new Array(e).fill(null)}has(e){if(!(e instanceof Vt))throw new TypeError("Invalid Fingerprint");return this.contents.some(t=>e.equals(t))}add(e){if(!(e instanceof Vt))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(this.contents[t]==null)return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof Vt))throw new TypeError("Invalid Fingerprint");const t=Is(0,this.contents.length-1),n=this.contents[t];return this.contents[t]=e,n}remove(e){if(!(e instanceof Vt))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex(n=>e.equals(n));return t>-1?(this.contents[t]=null,!0):!1}}const lb=500;class Sc{bucketSize;filterSize;fingerprintSize;buckets;count;hash;seed;constructor(e){this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??na,this.seed=e.seed??Is(0,Math.pow(2,10))}add(e){typeof e=="string"&&(e=q(e));const t=new Vt(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=(n^t.hash())%this.filterSize;if(this.buckets[n]==null&&(this.buckets[n]=new Fn(this.bucketSize)),this.buckets[s]==null&&(this.buckets[s]=new Fn(this.bucketSize)),this.buckets[n].add(t)||this.buckets[s].add(t))return this.count++,!0;const i=[n,s];let o=i[Is(0,i.length-1)];this.buckets[o]==null&&(this.buckets[o]=new Fn(this.bucketSize));for(let a=0;a<lb;a++){const c=this.buckets[o].swap(t);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new Fn(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(e){typeof e=="string"&&(e=q(e));const t=new Vt(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=this.buckets[n]?.has(t)??!1;if(s)return s;const i=(n^t.hash())%this.filterSize;return this.buckets[i]?.has(t)??!1}remove(e){typeof e=="string"&&(e=q(e));const t=new Vt(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=this.buckets[n]?.remove(t)??!1;if(s)return this.count--,s;const i=(n^t.hash())%this.filterSize,o=this.buckets[i]?.remove(t)??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const ub={1:.5,2:.84,4:.95,8:.98};function db(r=.001){return r>.002?2:r>1e-5?4:8}function hb(r,e=.001){const t=db(e),n=ub[t],s=Math.round(r/n),i=Math.min(Math.ceil(Math.log2(1/e)+Math.log2(2*t)),Md);return{filterSize:s,bucketSize:t,fingerprintSize:i}}class fb{filterSize;bucketSize;fingerprintSize;scale;filterSeries;hash;seed;constructor(e){this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??na,this.seed=e.seed??Is(0,Math.pow(2,10)),this.filterSeries=[new Sc({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if(typeof e=="string"&&(e=q(e)),this.has(e))return!0;let t=this.filterSeries.find(n=>n.reliable);if(t==null){const n=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new Sc({filterSize:n,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){typeof e=="string"&&(e=q(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){typeof e=="string"&&(e=q(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce((e,t)=>e+t.count,0)}}function un(r,e=.001,t){return new fb({...hb(r,e)})}class pb{filter;constructor(e,t){this.filter=un(e,t)}has(e){return this.filter.has(e.toMultihash().bytes)}add(e){this.filter.add(e.toMultihash().bytes)}remove(e){this.filter.remove?.(e.toMultihash().bytes)}}function gb(r,e=.001){return new pb(r,e)}function xc(r){const{stream:e,remoteAddr:t,logger:n,onDataRead:s,onDataWrite:i}=r,o=n.forComponent("libp2p:stream:converter");let a=!1,c=!1;const l=e.close.bind(e);e.close=async f=>{await l(f),p(!0)};const u=e.abort.bind(e);e.abort=f=>{u(f),p(!0)};const d=e.sink.bind(e);e.sink=async f=>{try{await d($u(f,g=>od(g,m=>i?.(m))))}catch(g){g.type!=="aborted"&&o.error("%s error in sink",t,g)}finally{c=!0,p()}};const h={log:o,sink:e.sink,source:async function*(){try{for await(const f of e.source)s?.(f),yield f}finally{a=!0,p()}}(),remoteAddr:t,timeline:{open:Date.now(),close:void 0},close:e.close,abort:e.abort};function p(f){f===!0&&(a=!0,c=!0),a&&c&&h.timeline.close==null&&(h.timeline.close=Date.now())}return h}class ie extends Event{type;detail;constructor(e,t){super(e),this.type=e,this.detail=t}}let mb=class extends Error{type;code;constructor(e,t){super(e??"The operation was aborted"),this.type="aborted",this.name="AbortError",this.code=t??"ABORT_ERR"}};async function pr(r,e,t,n){const s=new mb(n?.errorMessage,n?.errorCode);return t?.aborted===!0?Promise.reject(s):new Promise((i,o)=>{function a(){t?.removeEventListener("abort",u),r.removeEventListener(e,c),n?.errorEvent!=null&&r.removeEventListener(n.errorEvent,l)}const c=d=>{try{if(n?.filter?.(d)===!1)return}catch(h){a(),o(h);return}a(),i(d)},l=d=>{a(),o(d.detail)},u=()=>{a(),o(s)};t?.addEventListener("abort",u),r.addEventListener(e,c),n?.errorEvent!=null&&r.addEventListener(n.errorEvent,l)})}function uo(r,e){let t;const n=function(){const s=function(){t=void 0,r()};clearTimeout(t),t=setTimeout(s,e)};return n.start=()=>{},n.stop=()=>{clearTimeout(t)},n}class yb extends Error{remainingPoints;msBeforeNext;consumedPoints;isFirstInDuration;constructor(e="Rate limit exceeded",t){super(e),this.name="RateLimitError",this.remainingPoints=t.remainingPoints,this.msBeforeNext=t.msBeforeNext,this.consumedPoints=t.consumedPoints,this.isFirstInDuration=t.isFirstInDuration}}class wb extends Error{static name="QueueFullError";constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}class bb{deferred;signal;constructor(e){this.signal=e,this.deferred=he(),this.onAbort=this.onAbort.bind(this),this.signal?.addEventListener("abort",this.onAbort)}onAbort(){this.deferred.reject(this.signal?.reason??new Qt)}cleanup(){this.signal?.removeEventListener("abort",this.onAbort)}}function vb(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class Eb{id;fn;options;recipients;status;timeline;controller;constructor(e,t){this.id=vb(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,n)=>t&&n.signal?.aborted===!0,!0)&&(this.controller.abort(new Qt),this.cleanup())}async join(e={}){const t=new bb(e.signal);return this.recipients.push(t),e.signal?.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await Je(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{e.cleanup(),e.signal?.removeEventListener("abort",this.onAbort)})}}class Od extends Ut{concurrency;maxSize;queue;pending;sort;constructor(e={}){super(),this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,e.metricName!=null&&e.metrics?.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})}),this.sort=e.sort,this.queue=[],this.emitEmpty=uo(this.emitEmpty.bind(this),1),this.emitIdle=uo(this.emitIdle.bind(this),1)}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const t of this.queue)if(t.status==="queued"){e=t;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let t=0;t<this.queue.length;t++)if(this.queue[t]===e){this.queue.splice(t,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}async add(e,t){if(t?.signal?.throwIfAborted(),this.size===this.maxSize)throw new wb;const n=new Eb(e,t);return this.enqueue(n),this.safeDispatchEvent("add"),this.tryToStartAnother(),n.join(t).then(s=>(this.safeDispatchEvent("completed",{detail:s}),this.safeDispatchEvent("success",{detail:{job:n,result:s}}),s)).catch(s=>{if(n.status==="queued"){for(let i=0;i<this.queue.length;i++)if(this.queue[i]===n){this.queue.splice(i,1);break}}throw this.safeDispatchEvent("error",{detail:s}),this.safeDispatchEvent("failure",{detail:{job:n,error:s}}),s})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new Qt)}),this.clear()}async onEmpty(e){this.size!==0&&await pr(this,"empty",e?.signal)}async onSizeLessThan(e,t){this.size<e||await pr(this,"next",t?.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await pr(this,"idle",e?.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){e?.signal?.throwIfAborted();const t=En({objectMode:!0}),n=c=>{c!=null?this.abort():this.clear(),t.end(c)},s=c=>{c.detail!=null&&t.push(c.detail)},i=c=>{n(c.detail)},o=()=>{n()},a=()=>{n(new Qt("Queue aborted"))};this.addEventListener("completed",s),this.addEventListener("error",i),this.addEventListener("idle",o),e?.signal?.addEventListener("abort",a);try{yield*t}finally{this.removeEventListener("completed",s),this.removeEventListener("error",i),this.removeEventListener("idle",o),e?.signal?.removeEventListener("abort",a),n()}}}class sa extends Od{has(e){return this.find(e)!=null}find(e){return this.queue.find(t=>e.equals(t.options.peerId))}}class Sb extends Ut{peerStore;registrar;connectionManager;randomWalk;started;running;topologyId;log;discoveryController;filter;queue;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.started=!1,this.running=!1,this.peerStore=e.peerStore,this.registrar=e.registrar,this.connectionManager=e.connectionManager,this.randomWalk=e.randomWalk,this.filter=t.filter,this.discoveryController=new AbortController,this.discoveryController.signal}isStarted(){return this.started}async start(){this.topologyId=await this.registrar.register(ws,{filter:this.filter,onConnect:e=>{this.log.trace("discovered relay %p queue (length: %d, active %d)",e,this.queue?.size,this.queue?.running),this.safeDispatchEvent("relay:discover",{detail:e})}}),this.started=!0}stop(){this.topologyId!=null&&this.registrar.unregister(this.topologyId),this.discoveryController?.abort(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,this.discoveryController.signal,Promise.resolve().then(async()=>{this.log("searching peer store for relays");const e=await this.peerStore.all({filters:[n=>n.protocols.includes(ws)],orders:[()=>Math.random()<.5?1:-1,(n,s)=>{const i=Ac(n),o=Ac(s);return i>o?-1:o>i?1:0}]});for(const n of e)this.log.trace("found relay peer %p in peer store",n.id),this.safeDispatchEvent("relay:discover",{detail:n.id});this.log("found %d relay peers in peer store",e.length);const t=this.queue=new sa({concurrency:5});this.log("start random walk");for await(const n of this.randomWalk.walk({signal:this.discoveryController.signal})){if(this.log.trace("found random peer %p",n.id),t.has(n.id)){this.log.trace("random peer %p was already in queue",n.id);continue}if(this.connectionManager.getConnections(n.id)?.length>0){this.log.trace("random peer %p was already connected",n.id);continue}if(!await this.connectionManager.isDialable(n.multiaddrs)){this.log.trace("random peer %p was not dialable",n.id,n.multiaddrs.map(s=>s.toString()));continue}t.queued>10&&(this.log.trace("wait for space in queue for %p",n.id),await t.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",n.id,t.size,t.running),t.add(async()=>{const s=$t([this.discoveryController.signal,AbortSignal.timeout(5e3)]);try{await this.connectionManager.openConnection(n.id,{signal:s})}finally{s.clear()}},{peerId:n.id,signal:this.discoveryController.signal}).catch(s=>{this.log.error("error opening connection to random peer %p",n.id,s)})}this.log("stop random walk"),await t.onIdle()}).catch(e=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network",e)}))}stopDiscovery(){this.log("stop discovery"),this.running=!1,this.discoveryController?.abort()}}function Ac(r){const e=r.metadata.get("last-dial-success");return e==null?0:new Date(Y(e)).getTime()}class xb extends Ut{connectionManager;addressManager;reservationStore;listeningAddrs;log;listenTimeout;reservationId;relay;constructor(e,t={}){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.connectionManager=e.connectionManager,this.addressManager=e.addressManager,this.reservationStore=e.reservationStore,this.listeningAddrs=[],this.listenTimeout=t.listenTimeout??Sd,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}_onRemoveRelayPeer=e=>{this.log("relay removed %p our relay %p",e.detail.relay,this.relay,this.relay?.equals(e.detail.relay)),this.relay?.equals(e.detail.relay)===!0&&(this.log("relay peer removed %p",e.detail.relay),this.listeningAddrs.forEach(t=>{this.addressManager.removeObservedAddr(t)}),this.listeningAddrs=[],this.safeDispatchEvent("listening"))};_onAddRelayPeer=e=>{const{details:t}=e.detail;t.type!=="configured"&&t.id===this.reservationId&&this.addedRelay(e.detail)};async listen(e){if(Ld.exactMatch(e))this.log("searching for circuit relay servers"),this.reservationId=this.reservationStore.reserveRelay();else if(Pd.exactMatch(e)){this.log("listen on specific relay server %a",e);const t=AbortSignal.timeout(this.listenTimeout),n=e.decapsulate("/p2p-circuit"),s=await this.connectionManager.openConnection(n,{signal:t});if(!this.reservationStore.hasReservation(s.remotePeer)){this.log("making reservation on peer %p",s.remotePeer);const i=await this.reservationStore.addRelay(s.remotePeer,"configured");this.addedRelay(i)}}else throw new $i(`Could not listen on p2p-circuit address "${e}"`)}getAddrs(){return[...this.listeningAddrs.values()].flat()}updateAnnounceAddrs(){}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask(()=>{this.safeDispatchEvent("close")})}addedRelay(e){this.log("relay peer added %p",e.relay),this.relay=e.relay,this.listeningAddrs=e.details.reservation.addrs.map(t=>Q(t).encapsulate("/p2p-circuit")),this.listeningAddrs.forEach(t=>{this.addressManager.confirmObservedAddr(t,{type:"transport"})}),queueMicrotask(()=>{this.safeDispatchEvent("listening")})}}function Ab(r){return new xb(r)}const Cb="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";let Ib=(r=21)=>{let e="",t=crypto.getRandomValues(new Uint8Array(r|=0));for(;r--;)e+=Cb[t[r]&63];return e};const Tb=60*1e3*10,kb=60*1e3*5,_b=30*1e3;class Pb extends Ut{peerId;connectionManager;peerStore;events;reserveQueue;reservations;pendingReservations;maxReservationQueueLength;reservationCompletionTimeout;started;log;relayFilter;constructor(e,t){super(),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.reservations=new Ws,this.pendingReservations=[],this.maxReservationQueueLength=t?.maxReservationQueueLength??qw,this.reservationCompletionTimeout=t?.reservationCompletionTimeout??Sd,this.started=!1,this.relayFilter=un(100),this.reserveQueue=new sa({concurrency:t?.reservationConcurrency??Kw,metricName:"libp2p_relay_reservation_queue",metrics:e.metrics}),this.events.addEventListener("connection:close",n=>{[...this.reservations.values()].find(i=>i.connection===n.detail.id)!=null&&this.#t(n.detail.remotePeer).catch(i=>{this.log("could not remove relay %p - %e",n.detail,i)})})}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>t.tags.has(Nn)]});this.log("removing tag from %d old relays",e.length),await Promise.all(e.map(async t=>{await this.peerStore.merge(t.id,{tags:{[Nn]:void 0}})})),this.log("redialing %d old relays",e.length),await Promise.all(e.map(async t=>this.addRelay(t.id,"discovered"))),this.#r()}).catch(e=>{this.log.error(e)})}stop(){this.reserveQueue.clear(),this.reservations.forEach(({timeout:e})=>{clearTimeout(e)}),this.reservations.clear(),this.started=!1}reserveRelay(){const e=Ib();return this.pendingReservations.push(e),this.#r(),e}async addRelay(e,t){if(this.peerId.equals(e))throw this.log.trace("not trying to use self as relay"),new $i("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new sb("The reservation queue is full");const n=this.reserveQueue.find(e);if(n!=null)return this.log.trace("potential relay peer %p is already in the reservation queue",e),n.join();if(this.relayFilter.has(e.toMultihash().bytes))throw new $i("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",e),this.reserveQueue.add(async()=>{const s=Date.now();try{const i=this.reservations.get(e);if(i!=null){const f=this.connectionManager.getConnections(e);let g=!1;if(f.length===0&&this.log("already have relay reservation with %p but we are no longer connected",e),f.map(m=>m.id).includes(i.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",e),g=!0),g&&vc(i.reservation.expire)>Tb)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",e),{relay:e,details:i};await this.#t(e)}if(t==="discovered"&&this.pendingReservations.length===0)throw new bc("Not making reservation on discovered relay because we do not need any more relays");const o=AbortSignal.timeout(this.reservationCompletionTimeout);const a=await this.connectionManager.openConnection(e,{signal:o});if(ln.matches(a.remoteAddr))throw new nb("not creating reservation over relayed connection");const c=await this.#e(a,{signal:o}),l=vc(c.expire);this.log("created reservation on relay peer %p, expiry date is %s",e,new Date(Date.now()+l).toString());const u=Math.min(Math.max(l-kb,_b),Math.pow(2,31)-1),d=setTimeout(()=>{this.log("refresh reservation to relay %p",e),this.addRelay(e,t).catch(async f=>{this.log.error("could not refresh reservation to relay %p - %e",e,f),await this.#t(e)}).catch(f=>{this.log.error("could not remove expired reservation to relay %p - %e",e,f)})},u);let h;if(t==="discovered"){const f=this.pendingReservations.pop();if(f==null)throw new bc("Made reservation on relay but did not need any more discovered relays");h={timeout:d,reservation:c,type:t,connection:a.id,id:f}}else h={timeout:d,reservation:c,type:t,connection:a.id};this.reservations.set(e,h),await this.peerStore.merge(e,{tags:{[Nn]:{value:1,ttl:l}}}),this.#r();const p={relay:e,details:h};return this.safeDispatchEvent("relay:created-reservation",{detail:p}),p}catch(i){throw t==="discovered"&&i.name==="HadEnoughRelaysError"||this.log.error("could not reserve slot on %p after %dms - %e",e,Date.now()-s,i),(i.name==="DialError"||i.name==="UnsupportedProtocolError")&&this.relayFilter.add(e.toMultihash().bytes),this.#t(e).catch(o=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",e,o)}),i}},{peerId:e})}hasReservation(e){return this.reservations.has(e)}getReservation(e){return this.reservations.get(e)?.reservation}reservationCount(e){return e==null?this.reservations.size:[...this.reservations.values()].reduce((t,n)=>(n.type===e&&t++,t),0)}cancelReservations(){[...this.reservations.values()].forEach(e=>{clearTimeout(e.timeout)}),this.reservations.clear()}async#e(e,t){t.signal?.throwIfAborted(),this.log("requesting reservation from %p",e.remotePeer);const n=await e.newStream(ws,t),i=It(n).pb(xr);this.log.trace("send RESERVE to %p",e.remotePeer),await i.write({type:xr.Type.RESERVE},t);let o;try{this.log.trace("reading response from %p",e.remotePeer),o=await i.read(t)}catch(c){throw n.abort(c),c}finally{n.status!=="closed"&&await n.close(t)}if(this.log.trace("read response %o",o),o.status===Be.OK&&o.reservation!=null){const c=new Set;c.add(e.remoteAddr.toString());for(const l of o.reservation.addrs){let u=Q(l);u.getPeerId()==null&&(u=u.encapsulate(`/p2p/${e.remotePeer}`)),u=Q(u.toString().replace(`/p2p/${e.remotePeer}/p2p/${e.remotePeer}`,`/p2p/${e.remotePeer}`)),c.add(u.toString())}return o.reservation.addrs=[...c].map(l=>Q(l).bytes),o.reservation}const a=`reservation failed with status ${o.status??"undefined"}`;throw this.log.error(a),new Error(a)}async#t(e){const t=this.reservations.get(e);t!=null&&(this.log("removing relay reservation with %p from local store",e),clearTimeout(t.timeout),this.reservations.delete(e),t.type==="discovered"&&this.pendingReservations.push(t.id),await this.peerStore.merge(e,{tags:{[Nn]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:e,details:t}}),this.#r())}#r(){if(this.pendingReservations.length===0){this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),this.safeDispatchEvent("relay:found-enough-relays");return}this.relayFilter=un(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")}}const Lb=r=>{if(r.peer==null)return!1;try{r.peer.addrs.forEach(Q)}catch{return!1}return!0},Cc={maxInboundStopStreams:pc,maxOutboundStopStreams:pc};class Db{discovery;registrar;peerStore;connectionManager;transportManager;peerId;upgrader;addressManager;connectionGater;reservationStore;logger;maxInboundStopStreams;maxOutboundStopStreams;started;log;shutdownController;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:circuit-relay:transport"),this.registrar=e.registrar,this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.transportManager=e.transportManager,this.logger=e.logger,this.peerId=e.peerId,this.upgrader=e.upgrader,this.addressManager=e.addressManager,this.connectionGater=e.connectionGater,this.maxInboundStopStreams=t.maxInboundStopStreams??Cc.maxInboundStopStreams,this.maxOutboundStopStreams=t.maxOutboundStopStreams??Cc.maxOutboundStopStreams,this.shutdownController=new AbortController,this.discovery=new Sb(e,{filter:t.discoveryFilter??gb(Ww,Vw)}),this.discovery.addEventListener("relay:discover",n=>{this.reservationStore.addRelay(n.detail,"discovered").catch(s=>{s.name!=="HadEnoughRelaysError"&&s.name!=="RelayQueueFullError"&&this.log.error("could not add discovered relay %p",n.detail,s)})}),this.reservationStore=new Pb(e,t),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{this.discovery?.startDiscovery()}),this.reservationStore.addEventListener("relay:found-enough-relays",()=>{this.discovery?.stopDiscovery()}),this.started=!1}[Symbol.toStringTag]="@libp2p/circuit-relay-v2-transport";[it]=["@libp2p/transport","@libp2p/circuit-relay-v2-transport"];get[jn](){return this.discovery!=null?["@libp2p/identify"]:[]}[xo]=!0;isStarted(){return this.started}async start(){this.shutdownController=new AbortController,this.shutdownController.signal,await this.registrar.handle(fc,e=>{const t=this.upgrader.createInboundAbortSignal(this.shutdownController.signal);this.onStop(e,t).catch(n=>{this.log.error("error while handling STOP protocol",n),e.stream.abort(n)}).finally(()=>{t.clear()})},{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await Bl(this.discovery,this.reservationStore),this.started=!0}async stop(){this.shutdownController.abort(),await $l(this.discovery,this.reservationStore),await this.registrar.unhandle(fc),this.started=!1}async dial(e,t){if(e.protoCodes().filter(p=>p===zw).length!==1){const p="Invalid circuit relay address";throw this.log.error(p,e),new Vr(p)}const n=e.toString().split("/p2p-circuit"),s=Q(n[0]),i=Q(n[n.length-1]),o=s.getPeerId(),a=i.getPeerId();if(o==null||a==null){const p=`ircuit relay dial to ${e.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${p}`),new Vr(`C${p}`)}const c=pt(o),l=pt(a);let d=this.connectionManager.getConnections(c)[0];d==null?(await this.peerStore.merge(c,{multiaddrs:[s]}),t.onProgress?.(new ie("circuit-relay:open-connection")),d=await this.connectionManager.openConnection(c,t)):t.onProgress?.(new ie("circuit-relay:reuse-connection"));let h;try{t.onProgress?.(new ie("circuit-relay:open-hop-stream")),h=await d.newStream(ws,t);const p=It(h),f=p.pb(xr);t.onProgress?.(new ie("circuit-relay:write-connect-message")),await f.write({type:xr.Type.CONNECT,peer:{id:l.toMultihash().bytes,addrs:[Q(i).bytes]}},t),t.onProgress?.(new ie("circuit-relay:read-connect-response"));const g=await f.read(t);if(g.status!==Be.OK)throw new ut(`failed to connect via relay with status ${g?.status?.toString()??"undefined"}`);const m=new Ec(g.limit),v=xc({stream:p.unwrap(),remoteAddr:e,localAddr:s.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),logger:this.logger,onDataRead:m.onData,onDataWrite:m.onData});return this.log("new outbound relayed connection %a",v.remoteAddr),await this.upgrader.upgradeOutbound(v,{...t,limits:m.getLimits()})}catch(p){throw this.log.error("circuit relay dial to destination %p via relay %p failed",l,c,p),h?.abort(p),p}}createListener(e){return Ab({peerId:this.peerId,connectionManager:this.connectionManager,addressManager:this.addressManager,reservationStore:this.reservationStore,logger:this.logger})}listenFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>Pd.exactMatch(t)||Ld.exactMatch(t))}dialFilter(e){return e=Array.isArray(e)?e:[e],e.filter(t=>ln.exactMatch(t))}async onStop({connection:e,stream:t},n){if(!this.reservationStore.hasReservation(e.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.transportManager.listen([e.remoteAddr.encapsulate("/p2p-circuit")])}catch(u){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on",u)}const s=It(t).pb(bt),i=await s.read({signal:n});if(this.log("new circuit relay v2 stop stream from %p with type %s",e.remotePeer,i.type),i?.type===void 0){this.log.error("type was missing from circuit v2 stop protocol request from %s",e.remotePeer),await s.write({type:bt.Type.STATUS,status:Be.MALFORMED_MESSAGE},{signal:n}),await t.close();return}if(i.type!==bt.Type.CONNECT){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await s.write({type:bt.Type.STATUS,status:Be.UNEXPECTED_MESSAGE},{signal:n}),await t.close();return}if(!Lb(i)){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await s.write({type:bt.Type.STATUS,status:Be.MALFORMED_MESSAGE},{signal:n}),await t.close({signal:n});return}const o=bn(er(i.peer.id));if(await this.connectionGater.denyInboundRelayedConnection?.(e.remotePeer,o)===!0){this.log.error("connection gater denied inbound relayed connection from %p",e.remotePeer),await s.write({type:bt.Type.STATUS,status:Be.PERMISSION_DENIED},{signal:n}),await t.close({signal:n});return}this.log.trace("sending success response to %p",e.remotePeer),await s.write({type:bt.Type.STATUS,status:Be.OK},{signal:n});const a=new Ec(i.limit),c=e.remoteAddr.encapsulate(`/p2p-circuit/p2p/${o.toString()}`);this.addressManager.getAddresses()[0];const l=xc({stream:s.unwrap().unwrap(),remoteAddr:c,logger:this.logger,onDataRead:a.onData,onDataWrite:a.onData});this.log("new inbound relayed connection %a",l.remoteAddr),await this.upgrader.upgradeInbound(l,{limits:a.getLimits(),signal:n}),this.log("%s connection %a upgraded","inbound",l.remoteAddr)}}function Rb(r={}){return e=>new Db(e,r)}function Mb(r){return r[Symbol.asyncIterator]!=null}function ho(r){if(Mb(r))return(async()=>{for await(const e of r);})();for(const e of r);}const Un=globalThis.CustomEvent??Event;async function*Nd(r,e={}){let t=e.concurrency??1/0;t<1&&(t=1/0);const n=e.ordered??!1,s=new EventTarget,i=[];let o=he(),a=he(),c=!1,l,u=!1;s.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const f of r){if(i.length===t&&(o=he(),await o.promise),u)break;const g={done:!1};i.push(g),f().then(m=>{g.done=!0,g.ok=!0,g.value=m,s.dispatchEvent(new Un("task-complete"))},m=>{g.done=!0,g.err=m,s.dispatchEvent(new Un("task-complete"))})}c=!0,s.dispatchEvent(new Un("task-complete"))}catch(f){l=f,s.dispatchEvent(new Un("task-complete"))}});function d(){return n?i[0]?.done:!!i.find(f=>f.done)}function*h(){for(;i.length>0&&i[0].done;){const f=i[0];if(i.shift(),f.ok)yield f.value;else throw u=!0,o.resolve(),f.err;o.resolve()}}function*p(){for(;d();)for(let f=0;f<i.length;f++)if(i[f].done){const g=i[f];if(i.splice(f,1),f--,g.ok)yield g.value;else throw u=!0,o.resolve(),g.err;o.resolve()}}for(;;){if(d()||(a=he(),await a.promise),l!=null||(n?yield*h():yield*p(),l!=null))throw l;if(c&&i.length===0)break}}const Ob="0.1.0",Nb="id",Fb="id/push",Ub="1.0.0",Bb="1.0.0",$b=1024*8,zb=32;var Ir;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.protocolVersion!=null&&(n.uint32(42),n.string(t.protocolVersion)),t.agentVersion!=null&&(n.uint32(50),n.string(t.agentVersion)),t.publicKey!=null&&(n.uint32(10),n.bytes(t.publicKey)),t.listenAddrs!=null)for(const i of t.listenAddrs)n.uint32(18),n.bytes(i);if(t.observedAddr!=null&&(n.uint32(34),n.bytes(t.observedAddr)),t.protocols!=null)for(const i of t.protocols)n.uint32(26),n.string(i);t.signedPeerRecord!=null&&(n.uint32(66),n.bytes(t.signedPeerRecord)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={listenAddrs:[],protocols:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 5:{i.protocolVersion=t.string();break}case 6:{i.agentVersion=t.string();break}case 1:{i.publicKey=t.bytes();break}case 2:{if(s.limits?.listenAddrs!=null&&i.listenAddrs.length===s.limits.listenAddrs)throw new Ct('Decode error - map field "listenAddrs" had too many elements');i.listenAddrs.push(t.bytes());break}case 4:{i.observedAddr=t.bytes();break}case 3:{if(s.limits?.protocols!=null&&i.protocols.length===s.limits.protocols)throw new Ct('Decode error - map field "protocols" had too many elements');i.protocols.push(t.string());break}case 8:{i.signedPeerRecord=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(Ir||(Ir={}));const Ze={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:$b,runOnConnectionOpen:!0,runOnSelfUpdate:!0,runOnLimitedConnection:!0,concurrency:zb};function Kb(r){if(r!=null&&r.length>0)try{return Q(r)}catch{}}function qb(r,e){return e??r.userAgent}async function Fd(r,e,t,n,s){if(t("received identify from %p",n.remotePeer),s==null)throw new ut("message was null or undefined");const i={};if(s.listenAddrs.length>0&&(i.addresses=s.listenAddrs.map(c=>({isCertified:!1,multiaddr:Q(c)}))),s.protocols.length>0&&(i.protocols=s.protocols),s.publicKey!=null){const c=Bt(s.publicKey);if(!tn(c).equals(n.remotePeer))throw new ut("public key did not match remote PeerId");i.publicKey=c}let o;if(s.signedPeerRecord!=null){t.trace("received signedPeerRecord from %p",n.remotePeer);let c=s.signedPeerRecord;const l=await ht.openAndCertify(c,Qe.DOMAIN);let u=Qe.createFromProtobuf(l.payload);const d=vn(l.publicKey.toCID());if(!u.peerId.equals(d))throw new ut("signing key does not match PeerId in the PeerRecord");if(!n.remotePeer.equals(u.peerId))throw new ut("signing key does not match remote PeerId");let h;try{h=await r.get(u.peerId)}catch(p){if(p.name!=="NotFoundError")throw p}if(h!=null&&(i.metadata=h.metadata,h.peerRecordEnvelope!=null)){const p=await ht.createFromProtobuf(h.peerRecordEnvelope),f=Qe.createFromProtobuf(p.payload);f.seqNumber>=u.seqNumber&&(t("sequence number was lower or equal to existing sequence number - stored: %d received: %d",f.seqNumber,u.seqNumber),u=f,c=h.peerRecordEnvelope)}i.peerRecordEnvelope=c,i.addresses=u.multiaddrs.map(p=>({isCertified:!0,multiaddr:p})),o={seq:u.seqNumber,addresses:u.multiaddrs}}else t("%p did not send a signed peer record",n.remotePeer);if(t.trace("patching %p with",n.remotePeer,i),await r.patch(n.remotePeer,i),s.agentVersion!=null||s.protocolVersion!=null){const c={};s.agentVersion!=null&&(c.AgentVersion=q(s.agentVersion)),s.protocolVersion!=null&&(c.ProtocolVersion=q(s.protocolVersion)),t.trace("merging %p metadata",n.remotePeer,c),await r.merge(n.remotePeer,{metadata:c})}const a={peerId:n.remotePeer,protocolVersion:s.protocolVersion,agentVersion:s.agentVersion,publicKey:s.publicKey,listenAddrs:s.listenAddrs.map(c=>Q(c)),observedAddr:s.observedAddr==null?void 0:Q(s.observedAddr),protocols:s.protocols,signedPeerRecord:o,connection:n};return e.safeDispatchEvent("peer:identify",{detail:a}),a}class Ud{host;protocol;started;timeout;peerId;privateKey;peerStore;registrar;addressManager;maxInboundStreams;maxOutboundStreams;maxMessageSize;maxObservedAddresses;events;runOnLimitedConnection;log;constructor(e,t){this.protocol=t.protocol,this.started=!1,this.peerId=e.peerId,this.privateKey=e.privateKey,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.events=e.events,this.log=t.log,this.timeout=t.timeout??Ze.timeout,this.maxInboundStreams=t.maxInboundStreams??Ze.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??Ze.maxOutboundStreams,this.maxMessageSize=t.maxMessageSize??Ze.maxMessageSize,this.maxObservedAddresses=t.maxObservedAddresses??Ze.maxObservedAddresses,this.runOnLimitedConnection=t.runOnLimitedConnection??Ze.runOnLimitedConnection,this.host={protocolVersion:`${t.protocolPrefix??Ze.protocolPrefix}/${Ob}`,agentVersion:qb(e.nodeInfo,t.agentVersion)}}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:q(this.host.agentVersion),ProtocolVersion:q(this.host.protocolVersion)}}),await this.registrar.handle(this.protocol,e=>{this.handleProtocol(e).catch(t=>{this.log.error(t)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.registrar.unhandle(this.protocol),this.started=!1}}class Wb extends Ud{connectionManager;concurrency;constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??Ze.protocolPrefix}/${Fb}/${Bb}`,log:e.logger.forComponent("libp2p:identify-push")}),this.connectionManager=e.connectionManager,this.concurrency=t.concurrency??Ze.concurrency,(t.runOnSelfUpdate??Ze.runOnSelfUpdate)&&e.events.addEventListener("self:peer:update",n=>{this.push().catch(s=>{this.log.error(s)})})}[it]=["@libp2p/identify-push"];async push(){if(!this.isStarted())return;const e=this.addressManager.getAddresses().map(u=>u.decapsulateCode(G("p2p").code)),t=new Qe({peerId:this.peerId,multiaddrs:e}),n=await ht.seal(t,this.privateKey),s=this.registrar.getProtocols(),i=await this.peerStore.get(this.peerId),o=Y(i.metadata.get("AgentVersion")??q(this.host.agentVersion)),a=Y(i.metadata.get("ProtocolVersion")??q(this.host.protocolVersion)),c=this;async function*l(){for(const u of c.connectionManager.getConnections())(await c.peerStore.get(u.remotePeer)).protocols.includes(c.protocol)&&(yield async()=>{let h;const p=AbortSignal.timeout(c.timeout);try{h=await u.newStream(c.protocol,{signal:p,runOnLimitedConnection:c.runOnLimitedConnection}),await It(h,{maxDataLength:c.maxMessageSize}).pb(Ir).write({listenAddrs:e.map(g=>g.bytes),signedPeerRecord:n.marshal(),protocols:s,agentVersion:o,protocolVersion:a},{signal:p}),await h.close({signal:p})}catch(f){c.log.error("could not push identify update to peer",f),h?.abort(f)}})}await ho(Nd(l(),{concurrency:this.concurrency}))}async handleProtocol(e){const{connection:t,stream:n}=e;try{if(this.peerId.equals(t.remotePeer))throw new Error("received push from ourselves?");const s={signal:AbortSignal.timeout(this.timeout)},o=await It(n,{maxDataLength:this.maxMessageSize}).pb(Ir).read(s);await n.close(s),await Fd(this.peerStore,this.events,this.log,t,o)}catch(s){this.log.error("received invalid message",s),n.abort(s);return}this.log.trace("handled push from %p",t.remotePeer)}}const Vb=41;function Hb(r){try{const[[e,t]]=r.stringTuples();if(t==null)return!1;if(e===Vb)return yw("2000::/3",t)}catch{}return!1}function ia(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var or={},Ic;function Gb(){return Ic||(Ic=1,function(){var r,e,t,n,s,i,o,a;a=function(c){var l,u,d,h;return l=(c&255<<24)>>>24,u=(c&255<<16)>>>16,d=(c&65280)>>>8,h=c&255,[l,u,d,h].join(".")},o=function(c){var l,u,d,h,p,f;for(l=[],d=h=0;h<=3&&c.length!==0;d=++h){if(d>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}f=e(c),p=f[0],u=f[1],c=c.substring(u),l.push(p)}if(c.length!==0)throw new Error("Invalid IP");switch(l.length){case 1:if(l[0]>4294967295)throw new Error("Invalid IP");return l[0]>>>0;case 2:if(l[0]>255||l[1]>16777215)throw new Error("Invalid IP");return(l[0]<<24|l[1])>>>0;case 3:if(l[0]>255||l[1]>255||l[2]>65535)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2])>>>0;case 4:if(l[0]>255||l[1]>255||l[2]>255||l[3]>255)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2]<<8|l[3])>>>0;default:throw new Error("Invalid IP")}},t=function(c){return c.charCodeAt(0)},n=t("0"),i=t("a"),s=t("A"),e=function(c){var l,u,d,h,p;for(h=0,l=10,u="9",d=0,c.length>1&&c[d]==="0"&&(c[d+1]==="x"||c[d+1]==="X"?(d+=2,l=16):"0"<=c[d+1]&&c[d+1]<="9"&&(d++,l=8,u="7")),p=d;d<c.length;){if("0"<=c[d]&&c[d]<=u)h=h*l+(t(c[d])-n)>>>0;else if(l===16)if("a"<=c[d]&&c[d]<="f")h=h*l+(10+t(c[d])-i)>>>0;else if("A"<=c[d]&&c[d]<="F")h=h*l+(10+t(c[d])-s)>>>0;else break;else break;if(h>4294967295)throw new Error("too large");d++}if(d===p)throw new Error("empty octet");return[h,d]},r=function(){function c(l,u){var d,h,p;if(typeof l!="string")throw new Error("Missing `net' parameter");if(u||(p=l.split("/",2),l=p[0],u=p[1]),u||(u=32),typeof u=="string"&&u.indexOf(".")>-1){try{this.maskLong=o(u)}catch{throw new Error("Invalid mask: "+u)}for(d=h=32;h>=0;d=--h)if(this.maskLong===4294967295<<32-d>>>0){this.bitmask=d;break}}else if(u||u===0)this.bitmask=parseInt(u,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(l)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+l)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+u);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(l){return typeof l=="string"&&(l.indexOf("/")>0||l.split(".").length!==4)&&(l=new c(l)),l instanceof c?this.contains(l.base)&&this.contains(l.broadcast||l.last):(o(l)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(l){return l==null&&(l=1),new c(a(this.netLong+this.size*l),this.mask)},c.prototype.forEach=function(l){var u,d,h;for(h=o(this.first),d=o(this.last),u=0;h<=d;)l(a(h),h,u),u++,h++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),or.ip2long=o,or.long2ip=a,or.Netmask=r}.call(or)),or}var Yb=Gb();const Xb=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],Qb=Xb.map(r=>new Yb.Netmask(r));function oa(r){for(const e of Qb)if(e.contains(r))return!0;return!1}function jb(r){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(r)}function Zb(r){const e=r.split(":");if(e.length<2)return!1;const t=e[e.length-1].padStart(4,"0"),n=e[e.length-2].padStart(4,"0"),s=`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(t.substring(0,2),16)}.${parseInt(t.substring(2),16)}`;return oa(s)}function Jb(r){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)}function e0(r){const e=r.split(":"),t=e[e.length-1];return oa(t)}function t0(r){return/^::$/.test(r)||/^::1$/.test(r)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(r)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(r)||/^ff([0-9a-fA-F]{2,2}):/i.test(r)}function Vs(r){return Sr(r)?oa(r):jb(r)?Zb(r):Jb(r)?e0(r):Xo(r)?t0(r):void 0}const r0=4,n0=41;function Bd(r){try{const[[e]]=r.stringTuples();return e===r0||e===n0}catch{}return!1}function dn(r){try{if(!Bd(r))return!1;const[[,e]]=r.stringTuples();return e==null?!1:Vs(e)??!1}catch{}return!0}const s0=41;class i0 extends Ud{constructor(e,t={}){super(e,{...t,protocol:`/${t.protocolPrefix??Ze.protocolPrefix}/${Nb}/${Ub}`,log:e.logger.forComponent("libp2p:identify")}),(t.runOnConnectionOpen??Ze.runOnConnectionOpen)&&e.events.addEventListener("connection:open",n=>{const s=n.detail;this.identify(s).catch(i=>{i.name!==Co.name&&this.log.error("error during identify trigged by connection:open",i)})})}[it]=["@libp2p/identify"];async _identify(e,t={}){let n;if(t.signal==null){const s=AbortSignal.timeout(this.timeout);t={...t,signal:s}}try{n=await e.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const i=await It(n,{maxDataLength:this.maxMessageSize}).pb(Ir).read(t);return await n.close(t),i}catch(s){throw n?.abort(s),s}}async identify(e,t={}){const n=await this._identify(e,t),{publicKey:s,protocols:i,observedAddr:o}=n;if(s==null)throw new ut("public key was missing from identify message");const a=Bt(s),c=vn(a.toCID());if(!e.remotePeer.equals(c))throw new ut("identified peer does not match the expected peer");if(this.peerId.equals(c))throw new ut("identified peer is our own peer id?");return this.maybeAddObservedAddress(o),this.log("identify completed for peer %p and protocols %o",c,i),Fd(this.peerStore,this.events,this.log,e,n)}maybeAddObservedAddress(e){const t=Kb(e);if(t==null)return;if(this.log.trace("our observed address was %a",t),dn(t)){this.log.trace("our observed address was private");return}if(t.stringTuples()[0][0]===s0&&!Hb(t)){this.log.trace("our observed address was IPv6 but not a global unicast address");return}xs.exactMatch(t)||(this.log.trace("storing the observed address"),this.addressManager.addObservedAddr(t))}async handleProtocol(e){const{connection:t,stream:n}=e,s=AbortSignal.timeout(this.timeout);try{const i=await this.peerStore.get(this.peerId),o=this.addressManager.getAddresses().map(u=>u.decapsulateCode(G("p2p").code));let a=i.peerRecordEnvelope;if(o.length>0&&a==null){const u=new Qe({peerId:this.peerId,multiaddrs:o});a=(await ht.seal(u,this.privateKey)).marshal().subarray()}let c=t.remoteAddr.bytes;Xw.matches(t.remoteAddr)||(c=void 0),await It(n).pb(Ir).write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:xt(this.privateKey.publicKey),listenAddrs:o.map(u=>u.bytes),signedPeerRecord:a,observedAddr:c,protocols:i.protocols},{signal:s}),await n.close({signal:s})}catch(i){this.log.error("could not respond to identify request",i),n.abort(i)}}}function o0(r={}){return e=>new i0(e,r)}function a0(r={}){return e=>new Wb(e,r)}const wi=32,c0="1.0.0",l0="ping",u0="ipfs",d0=1e4,h0=2,f0=1;class p0{protocol;components;started;timeout;maxInboundStreams;maxOutboundStreams;runOnLimitedConnection;log;constructor(e,t={}){this.components=e,this.log=e.logger.forComponent("libp2p:ping"),this.started=!1,this.protocol=`/${t.protocolPrefix??u0}/${l0}/${c0}`,this.timeout=t.timeout??d0,this.maxInboundStreams=t.maxInboundStreams??h0,this.maxOutboundStreams=t.maxOutboundStreams??f0,this.runOnLimitedConnection=t.runOnLimitedConnection??!0,this.handleMessage=this.handleMessage.bind(this)}[Symbol.toStringTag]="@libp2p/ping";[it]=["@libp2p/ping"];async start(){await this.components.registrar.handle(this.protocol,this.handleMessage,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}handleMessage(e){this.log("incoming ping from %p",e.connection.remotePeer);const{stream:t}=e,n=Date.now(),s=us(t);let i=!1;Promise.resolve().then(async()=>{for(;;){const o=AbortSignal.timeout(this.timeout);o.addEventListener("abort",()=>{t?.abort(new Io("ping timeout"))});const a=await s.read({bytes:wi,signal:o});await s.write(a,{signal:o}),i=!0}}).catch(o=>{i&&o.name==="UnexpectedEOFError"&&t.readStatus!=="ready"||(this.log.error("incoming ping from %p failed with error - %e",e.connection.remotePeer,o),t?.abort(o))}).finally(()=>{const o=Date.now()-n;this.log("incoming ping from %p complete in %dms",e.connection.remotePeer,o);const a=AbortSignal.timeout(this.timeout);t.close({signal:a}).catch(c=>{this.log.error("error closing ping stream from %p - %e",e.connection.remotePeer,c),t?.abort(c)})})}async ping(e,t={}){this.log("pinging %p",e);const n=Date.now(),s=Wo(wi),i=await this.components.connectionManager.openConnection(e,t);let o;if(t.signal==null){const a=AbortSignal.timeout(this.timeout);t={...t,signal:a}}try{o=await i.newStream(this.protocol,{...t,runOnLimitedConnection:this.runOnLimitedConnection});const a=us(o),[,c]=await Promise.all([a.write(s,t),a.read({...t,bytes:wi})]),l=Date.now()-n;if(!Oe(s,c.subarray()))throw new Uh(`Received wrong ping ack after ${l}ms`);return this.log("ping %p complete in %dms",i.remotePeer,l),l}catch(a){throw this.log.error("error while pinging %p",i.remotePeer,a),o?.abort(a),a}finally{o!=null&&await o.close(t)}}}function g0(r={}){return e=>new p0(e,r)}var Ke;(function(r){(function(n){n.FIN="FIN",n.STOP_SENDING="STOP_SENDING",n.RESET="RESET",n.FIN_ACK="FIN_ACK"})(r.Flag||(r.Flag={}));let e;(function(n){n[n.FIN=0]="FIN",n[n.STOP_SENDING=1]="STOP_SENDING",n[n.RESET=2]="RESET",n[n.FIN_ACK=3]="FIN_ACK"})(e||(e={})),function(n){n.codec=()=>Dr(e)}(r.Flag||(r.Flag={}));let t;r.codec=()=>(t==null&&(t=me((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.flag!=null&&(s.uint32(8),r.Flag.codec().encode(n.flag,s)),n.message!=null&&(s.uint32(18),s.bytes(n.message)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.flag=r.Flag.codec().decode(n);break}case 2:{o.message=n.bytes();break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>ge(n,r.codec()),r.decode=(n,s)=>pe(n,r.codec(),s)})(Ke||(Ke={}));const m0=["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478","stun:stun.cloudflare.com:3478","stun:stun.services.mozilla.com:3478"];Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");const y0=2*1024*1024,w0=30*1e3,$d=16*1024;function b0(r=$d){const e=Ie(r-Ie(r)),t=1+Ie(Object.keys(Ke.Flag).length-1),n=1,s=r-e-t-n,i=Ie(s);return e+t+n+i}const v0=b0(),E0=5e3,S0=5e3,x0=3e4,zd="/webrtc",fo="/webrtc-signaling/0.0.1";var Tc=function(r,e,t){if(t||arguments.length===2)for(var n=0,s=e.length,i;n<s;n++)(i||!(n in e))&&(i||(i=Array.prototype.slice.call(e,0,n)),i[n]=e[n]);return r.concat(i||Array.prototype.slice.call(e))},A0=function(){function r(e,t,n){this.name=e,this.version=t,this.os=n,this.type="browser"}return r}(),C0=function(){function r(e){this.version=e,this.type="node",this.name="node",this.os=process.platform}return r}(),I0=function(){function r(e,t,n,s){this.name=e,this.version=t,this.os=n,this.bot=s,this.type="bot-device"}return r}(),T0=function(){function r(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return r}(),k0=function(){function r(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return r}(),_0=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,P0=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,kc=3,L0=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",_0]],_c=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function D0(r){return typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new k0:typeof navigator<"u"?M0(navigator.userAgent):N0()}function R0(r){return r!==""&&L0.reduce(function(e,t){var n=t[0],s=t[1];if(e)return e;var i=s.exec(r);return!!i&&[n,i]},!1)}function M0(r){var e=R0(r);if(!e)return null;var t=e[0],n=e[1];if(t==="searchbot")return new T0;var s=n[1]&&n[1].split(".").join("_").split("_").slice(0,3);s?s.length<kc&&(s=Tc(Tc([],s,!0),F0(kc-s.length),!0)):s=[];var i=s.join("."),o=O0(r),a=P0.exec(r);return a&&a[1]?new I0(t,i,o,a[1]):new A0(t,i,o)}function O0(r){for(var e=0,t=_c.length;e<t;e++){var n=_c[e],s=n[0],i=n[1],o=i.exec(r);if(o)return s}return null}function N0(){var r=typeof process<"u"&&process.version;return r?new C0(process.version.slice(1)):null}function F0(r){for(var e=[],t=0;t<r;t++)e.push("0");return e}class Kd extends Error{constructor(e){super(e),this.name="TimeoutError"}}let U0=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}};const Pc=r=>globalThis.DOMException===void 0?new U0(r):new DOMException(r),Lc=r=>{const e=r.reason===void 0?Pc("This operation was aborted."):r.reason;return e instanceof Error?e:Pc(e)};function aa(r,e){const{milliseconds:t,fallback:n,message:s,customTimers:i={setTimeout,clearTimeout}}=e;let o,a;const l=new Promise((u,d)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(e.signal){const{signal:p}=e;p.aborted&&d(Lc(p)),a=()=>{d(Lc(p))},p.addEventListener("abort",a,{once:!0})}if(t===Number.POSITIVE_INFINITY){r.then(u,d);return}const h=new Kd;o=i.setTimeout.call(void 0,()=>{if(n){try{u(n())}catch(p){d(p)}return}typeof r.cancel=="function"&&r.cancel(),s===!1?u():s instanceof Error?d(s):(h.message=s??`Promise timed out after ${t} milliseconds`,d(h))},t),(async()=>{try{u(await r)}catch(p){d(p)}})()}).finally(()=>{l.clear(),a&&e.signal&&e.signal.removeEventListener("abort",a)});return l.clear=()=>{i.clearTimeout.call(void 0,o),o=void 0},l}const Dc=D0(),qd=Dc!=null&&Dc.name==="firefox",Wd=async function*(){},Vd=async r=>{};function B0(r,e,t=x0,n){r.readyState==="open"&&Promise.resolve().then(async()=>{if(r.bufferedAmount>0){n.log("%s drain channel with %d buffered bytes",e,r.bufferedAmount);const s=he();let i=!1;r.bufferedAmountLowThreshold=0;const o=()=>{i||(n.log("%s drain channel closed before drain",e),s.resolve())};r.addEventListener("close",o,{once:!0}),r.addEventListener("bufferedamountlow",()=>{i=!0,r.removeEventListener("close",o),s.resolve()}),await aa(s.promise,{milliseconds:t})}}).then(async()=>{r.readyState==="open"&&r.close()}).catch(s=>{n.log.error("error closing outbound stream",s)})}async function Rc(r){return r=r??{},typeof r=="function"&&(r=await r()),r.iceServers=r.iceServers??m0.map(e=>({urls:[e]})),r}class Mc{log;peerConnection;remoteAddr;timeline;metrics;source=Wd();sink=Vd;constructor(e,t){this.log=e.logger.forComponent("libp2p:webrtc:maconn"),this.remoteAddr=t.remoteAddr,this.timeline=t.timeline,this.peerConnection=t.peerConnection;const n=this.peerConnection,s=n.connectionState;this.peerConnection.onconnectionstatechange=()=>{this.log.trace("peer connection state change",n.connectionState,"initial state",s),(n.connectionState==="disconnected"||n.connectionState==="failed"||n.connectionState==="closed")&&(this.timeline.close=Date.now())}}async close(e){this.log.trace("closing connection"),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({close:!0})}abort(e){this.log.error("closing connection due to error",e),this.peerConnection.close(),this.timeline.close=Date.now(),this.metrics?.increment({abort:!0})}}class $0 extends sd{channel;incomingData;maxBufferedAmount;bufferedAmountLowEventTimeout;maxMessageSize;receiveFinAck;finAckTimeout;openTimeout;closeController;constructor(e){const t=e.onEnd;switch(e.onEnd=s=>{this.log.trace('readable and writeable ends closed with status "%s"',this.status),Promise.resolve(async()=>{if(!(this.timeline.abort!=null||this.timeline.reset!==null))try{await aa(this.receiveFinAck.promise,{milliseconds:this.finAckTimeout})}catch(i){this.log.error("error receiving FIN_ACK",i)}}).then(()=>{this.incomingData.end(),t?.(s)}).catch(i=>{this.log.error("error ending stream",i)}).finally(()=>{this.channel.close()})},super(e),this.channel=e.channel,this.channel.binaryType="arraybuffer",this.incomingData=En(),this.bufferedAmountLowEventTimeout=e.bufferedAmountLowEventTimeout??w0,this.maxBufferedAmount=e.maxBufferedAmount??y0,this.maxMessageSize=(e.maxMessageSize??$d)-v0,this.receiveFinAck=he(),this.finAckTimeout=e.closeTimeout??E0,this.openTimeout=e.openTimeout??S0,this.closeController=new AbortController,this.channel.readyState){case"open":this.timeline.open=new Date().getTime();break;case"closed":case"closing":(this.timeline.close===void 0||this.timeline.close===0)&&(this.timeline.close=Date.now());break;case"connecting":break;default:throw this.log.error("unknown datachannel state %s",this.channel.readyState),new Ui("Unknown datachannel state")}this.channel.onopen=s=>{this.timeline.open=new Date().getTime()},this.channel.onclose=s=>{this.log.trace("received onclose event"),this.closeController.abort(),this.receiveFinAck.resolve(),this.close().catch(i=>{this.log.error("error closing stream after channel closed",i)})},this.channel.onerror=s=>{this.log.trace("received onerror event"),this.closeController.abort();const i=s.error;this.abort(i)},this.channel.onmessage=async s=>{const{data:i}=s;i===null||i.byteLength===0||this.incomingData.push(new Uint8Array(i,0,i.byteLength))};const n=this;Promise.resolve().then(async()=>{for await(const s of ls(this.incomingData)){const i=n.processIncomingProtobuf(s);i!=null&&n.sourcePush(new J(i))}}).catch(s=>{this.log.error("error processing incoming data channel messages",s)})}sendNewStream(){}async _sendMessage(e,t=!0){if(this.channel.readyState==="closed"||this.channel.readyState==="closing")throw new Ui(`Invalid datachannel state - ${this.channel.readyState}`);if(this.channel.readyState!=="open"){const n=AbortSignal.timeout(this.openTimeout),s=$t([this.closeController.signal,n]);try{this.log('channel state is "%s" and not "open", waiting for "open" event before sending data',this.channel.readyState),await pr(this.channel,"open",s)}finally{s.clear()}this.log('channel state is now "%s", sending data',this.channel.readyState)}if(t&&this.channel.bufferedAmount>this.maxBufferedAmount){const n=AbortSignal.timeout(this.bufferedAmountLowEventTimeout),s=$t([this.closeController.signal,n]);try{this.log('channel buffer is %d, wait for "bufferedamountlow" event',this.channel.bufferedAmount),await pr(this.channel,"bufferedamountlow",s)}catch(i){throw n.aborted?new Io(`Timed out waiting for DataChannel buffer to clear after ${this.bufferedAmountLowEventTimeout}ms`):i}finally{s.clear()}}try{this.log.trace('sending message, channel state "%s"',this.channel.readyState),this.channel.send(e.subarray())}catch(n){this.log.error("error while sending message",n)}}async sendData(e){const t=e.byteLength;for(e=e.sublist();e.byteLength>0;){const n=Math.min(e.byteLength,this.maxMessageSize),s=e.subarray(0,n),i=Ke.encode({message:s}),o=cs.single(i);this.log.trace("sending %d/%d bytes on channel",s.byteLength,t),await this._sendMessage(o),e.consume(n)}this.log.trace('finished sending data, channel state "%s"',this.channel.readyState)}async sendReset(){try{await this._sendFlag(Ke.Flag.RESET)}catch(e){this.log.error("failed to send reset - %e",e)}finally{this.channel.close()}}async sendCloseWrite(e){if(this.channel.readyState!=="open"){this.receiveFinAck.resolve();return}if(await this._sendFlag(Ke.Flag.FIN)){this.log.trace("awaiting FIN_ACK");try{await Je(this.receiveFinAck.promise,e?.signal,{errorMessage:"sending close-write was aborted before FIN_ACK was received",errorName:"FinAckNotReceivedError"})}catch(n){this.log.error("failed to await FIN_ACK",n)}}else this.log.trace("sending FIN failed, not awaiting FIN_ACK");this.receiveFinAck.resolve()}async sendCloseRead(){this.channel.readyState==="open"&&await this._sendFlag(Ke.Flag.STOP_SENDING)}processIncomingProtobuf(e){const t=Ke.decode(e);if(t.flag!==void 0&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',t.flag,this.writeStatus,this.readStatus),t.flag===Ke.Flag.FIN&&(this.remoteCloseWrite(),this.log.trace("sending FIN_ACK"),this._sendFlag(Ke.Flag.FIN_ACK).catch(n=>{this.log.error("error sending FIN_ACK immediately",n)})),t.flag===Ke.Flag.RESET&&this.reset(),t.flag===Ke.Flag.STOP_SENDING&&this.remoteCloseRead(),t.flag===Ke.Flag.FIN_ACK&&(this.log.trace("received FIN_ACK"),this.receiveFinAck.resolve())),this.readStatus==="ready")return t.message}async _sendFlag(e){if(this.channel.readyState!=="open")return this.log.trace('not sending flag %s because channel is "%s" and not "open"',e.toString(),this.channel.readyState),!1;this.log.trace("sending flag %s",e.toString());const t=Ke.encode({flag:e}),n=cs.single(t);try{return await this._sendMessage(n,!1),!0}catch(s){this.log.error("could not send flag %s - %e",e.toString(),s)}return!1}}function po(r){const{channel:e,direction:t,handshake:n}=r;return new $0({id:`${e.id}`,log:r.logger.forComponent(`libp2p:webrtc:stream:${n===!0?"handshake":t}:${e.id}`),...r})}class Hd{protocol;peerConnection;bufferedStreams=[];metrics;dataChannelOptions;components;log;constructor(e,t){this.components=e,this.peerConnection=t.peerConnection,this.metrics=t.metrics,this.protocol=t.protocol??zd,this.dataChannelOptions=t.dataChannelOptions??{},this.log=e.logger.forComponent("libp2p:webrtc:muxerfactory"),this.peerConnection.ondatachannel=({channel:n})=>{if(this.log.trace('incoming early datachannel with channel id %d and label "%s"',n.id),n.label==="init"){this.log.trace("closing early init channel"),n.close();return}const s={},i=po({channel:n,direction:"inbound",onEnd:o=>{s.onEnd(o)},logger:e.logger,...this.dataChannelOptions});s.stream=i,s.channel=n,s.onEnd=()=>{this.bufferedStreams=this.bufferedStreams.filter(o=>o.stream.id!==i.id)},this.bufferedStreams.push(s)}}createStreamMuxer(e){return new z0(this.components,{...e,peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,streams:this.bufferedStreams,protocol:this.protocol})}}class z0{init;streams;protocol;log;peerConnection;dataChannelOptions;metrics;logger;constructor(e,t){this.init=t,this.log=e.logger.forComponent("libp2p:webrtc:muxer"),this.logger=e.logger,this.streams=t.streams.map(n=>n.stream),this.peerConnection=t.peerConnection,this.protocol=t.protocol??zd,this.metrics=t.metrics,this.dataChannelOptions=t.dataChannelOptions??{},this.peerConnection.ondatachannel=({channel:n})=>{if(this.log.trace("incoming datachannel with channel id %d",n.id),n.label==="init"){this.log.trace("closing init channel"),n.close();return}const s=n.id,i=po({channel:n,direction:"inbound",onEnd:()=>{this.#e(i,n),this.log("incoming channel %s ended",s)},logger:this.logger,...this.dataChannelOptions});this.streams.push(i),this.metrics?.increment({incoming_stream:!0}),t?.onIncomingStream?.(i)},this.init.streams.length>0&&queueMicrotask(()=>{this.init.streams.forEach(n=>{n.onEnd=()=>{this.log("incoming early channel %s ended with state %s",n.channel.id,n.channel.readyState),this.#e(n.stream,n.channel)},this.metrics?.increment({incoming_stream:!0}),this.init?.onIncomingStream?.(n.stream)})})}#e(e,t){this.log.trace("stream %s %s %s onEnd",e.direction,e.id,e.protocol),B0(t,`${e.direction} ${e.id} ${e.protocol}`,this.dataChannelOptions.drainTimeout,{log:this.log}),this.streams=this.streams.filter(n=>n.id!==e.id),this.metrics?.increment({stream_end:!0}),this.init?.onStreamEnd?.(e)}async close(e){try{await Promise.all(this.streams.map(async t=>t.close(e)))}catch(t){this.abort(t)}}abort(e){for(const t of this.streams)t.abort(e)}source=Wd();sink=Vd;newStream(){const e=this.peerConnection.createDataChannel(""),t=e.id;this.log.trace("opened outgoing datachannel with channel id %s",t);const n=po({channel:e,direction:"outbound",onEnd:()=>{this.#e(n,e),this.log("outgoing channel %s ended",t)},logger:this.logger,...this.dataChannelOptions});return this.streams.push(n),this.metrics?.increment({outgoing_stream:!0}),n}}const Gd=globalThis.RTCPeerConnection,Yd=globalThis.RTCSessionDescription,K0=globalThis.RTCIceCandidate;class q0 extends Error{constructor(e){super(`WebRTC transport error: ${e}`),this.name="WebRTCTransportError"}}class Mt extends q0{constructor(e="SDP handshake failed"){super(e),this.name="SDPHandshakeFailedError"}}var st;(function(r){(function(n){n.SDP_OFFER="SDP_OFFER",n.SDP_ANSWER="SDP_ANSWER",n.ICE_CANDIDATE="ICE_CANDIDATE"})(r.Type||(r.Type={}));let e;(function(n){n[n.SDP_OFFER=0]="SDP_OFFER",n[n.SDP_ANSWER=1]="SDP_ANSWER",n[n.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(e||(e={})),function(n){n.codec=()=>Dr(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=me((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.data!=null&&(s.uint32(18),s.string(n.data)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.data=n.string();break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>ge(n,r.codec()),r.decode=(n,s)=>pe(n,r.codec(),s)})(st||(st={}));const Xd=async(r,e,t)=>{try{const n=he();for(W0(r,n);;){const s=await Promise.race([n.promise,e.read({signal:t.signal}).catch(()=>{})]);if(s==null){t.signal?.throwIfAborted();break}if(s.type!==st.Type.ICE_CANDIDATE)throw new ut("ICE candidate message expected");const i=JSON.parse(s.data??"null");if(i===""||i===null){t.onProgress?.(new ie("webrtc:end-of-ice-candidates")),t.log.trace("end-of-candidates received");continue}const o=new K0(i);t.log.trace("%s received new ICE candidate %o",t.direction,i);try{t.onProgress?.(new ie("webrtc:add-ice-candidate",o.candidate)),await r.addIceCandidate(o)}catch(a){t.log.error("%s bad candidate received",t.direction,i,a)}}}catch(n){if(t.log.error("%s error parsing ICE candidate",t.direction,n),t.signal?.aborted===!0&&ca(r)!=="connected")throw n}};function ca(r){return qd?r.iceConnectionState:r.connectionState}function W0(r,e){r[qd?"oniceconnectionstatechange":"onconnectionstatechange"]=t=>{switch(ca(r)){case"connected":e.resolve();break;case"failed":case"disconnected":case"closed":e.reject(new Ol("RTCPeerConnection was closed"));break}}}async function V0({rtcConfiguration:r,dataChannel:e,signal:t,metrics:n,multiaddr:s,connectionManager:i,transportManager:o,log:a,logger:c,onProgress:l}){const{baseAddr:u}=Y0(s);n?.dialerEvents.increment({open:!0}),a.trace("dialing base address: %a",u);const d=u.getPeerId();if(d==null)throw new V("Relay peer was missing");const h=i.getConnections(pt(d));let p,f=!1;h.length===0?(l?.(new ie("webrtc:dial-relay")),p=await o.dial(u,{signal:t,onProgress:l}),f=!0):(l?.(new ie("webrtc:reuse-relay-connection")),p=h[0]);try{l?.(new ie("webrtc:open-signaling-stream"));const g=await p.newStream(fo,{signal:t,runOnLimitedConnection:!0}),m=It(g).pb(st),v=new Gd(r),k=new Hd({logger:c},{peerConnection:v,dataChannelOptions:e});try{const b=v.createDataChannel("init");v.onicecandidate=({candidate:x})=>{const _=JSON.stringify(x?.toJSON()??null);a.trace("initiator sending ICE candidate %o",x),m.write({type:st.Type.ICE_CANDIDATE,data:_},{signal:t}).catch(D=>{a.error("error sending ICE candidate",D)})},v.onicecandidateerror=x=>{a.error("initiator ICE candidate error",x)};const w=await v.createOffer().catch(x=>{throw a.error("could not execute createOffer",x),new Mt("Failed to set createOffer")});a.trace("initiator send SDP offer %s",w.sdp),l?.(new ie("webrtc:send-sdp-offer")),await m.write({type:st.Type.SDP_OFFER,data:w.sdp},{signal:t}),await v.setLocalDescription(w).catch(x=>{throw a.error("could not execute setLocalDescription",x),new Mt("Failed to set localDescription")}),l?.(new ie("webrtc:read-sdp-answer")),a.trace("initiator read SDP answer");const E=await m.read({signal:t});if(E.type!==st.Type.SDP_ANSWER)throw new Mt("Remote should send an SDP answer");a.trace("initiator received SDP answer %s",E.data);const P=new Yd({type:"answer",sdp:E.data});return await v.setRemoteDescription(P).catch(x=>{throw a.error("could not execute setRemoteDescription",x),new Mt("Failed to set remoteDescription")}),a.trace("initiator read candidates until connected"),l?.(new ie("webrtc:read-ice-candidates")),await Xd(v,m,{direction:"initiator",signal:t,log:a,onProgress:l}),a.trace("initiator connected, closing init channel"),b.close(),l?.(new ie("webrtc:close-signaling-stream")),a.trace("closing signaling channel"),await g.close({signal:t}),a.trace("initiator connected to remote address %s",s),{remoteAddress:s,peerConnection:v,muxerFactory:k}}catch(b){throw a.error("outgoing signaling error",b),v.close(),g.abort(b),b}finally{v.onicecandidate=null,v.onicecandidateerror=null}}finally{if(f)try{await p.close({signal:t})}catch(g){p.abort(g)}}}const Oc=le(_d.matchers[0],X("p2p-circuit"));class la extends Ut{transportManager;shutdownController;events;constructor(e,t){super(),this.transportManager=e.transportManager,this.events=e.events,this.shutdownController=t.shutdownController,this.onTransportListening=this.onTransportListening.bind(this)}async listen(){this.events.addEventListener("transport:listening",this.onTransportListening)}onTransportListening(e){e.detail.getAddrs().filter(n=>Oc.exactMatch(n)).map(n=>n.encapsulate("/webrtc")).length>0&&this.safeDispatchEvent("listening")}getAddrs(){return this.transportManager.getListeners().filter(e=>!(e instanceof la)).map(e=>e.getAddrs().filter(t=>Oc.exactMatch(t)).map(t=>t.encapsulate("/webrtc"))).flat()}updateAnnounceAddrs(){}async close(){this.events.removeEventListener("transport:listening",this.onTransportListening),this.shutdownController.abort(),queueMicrotask(()=>{this.safeDispatchEvent("close")})}}async function H0({peerConnection:r,stream:e,signal:t,connection:n,log:s}){s.trace("new inbound signaling stream");const i=It(e).pb(st);try{r.onicecandidate=({candidate:u})=>{const d=JSON.stringify(u?.toJSON()??null);s.trace("recipient sending ICE candidate %s",d),i.write({type:st.Type.ICE_CANDIDATE,data:d},{signal:t}).catch(h=>{s.error("error sending ICE candidate",h)})},s.trace("recipient read SDP offer");const a=await i.read({signal:t});if(a.type!==st.Type.SDP_OFFER)throw new Mt(`expected message type SDP_OFFER, received: ${a.type??"undefined"} `);s.trace("recipient received SDP offer %s",a.data);const c=new Yd({type:"offer",sdp:a.data});await r.setRemoteDescription(c).catch(u=>{throw s.error("could not execute setRemoteDescription",u),new Mt("Failed to set remoteDescription")});const l=await r.createAnswer().catch(u=>{throw s.error("could not execute createAnswer",u),new Mt("Failed to create answer")});s.trace("recipient send SDP answer %s",l.sdp),await i.write({type:st.Type.SDP_ANSWER,data:l.sdp},{signal:t}),await r.setLocalDescription(l).catch(u=>{throw s.error("could not execute setLocalDescription",u),new Mt("Failed to set localDescription")}),s.trace("recipient read candidates until connected"),await Xd(r,i,{direction:"recipient",signal:t,log:s})}catch(a){if(ca(r)!=="connected")throw s.error("error while handling signaling stream from peer %a",n.remoteAddr,a),r.close(),a;s("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",n.remoteAddr,a)}const o=Q(`/webrtc/p2p/${n.remoteAddr.getPeerId()}`);return s.trace("recipient connected to remote address %s",o),{remoteAddress:o}}class G0{components;init;log;_started=!1;metrics;shutdownController;constructor(e,t={}){this.components=e,this.init=t,this.log=e.logger.forComponent("libp2p:webrtc"),this.shutdownController=new AbortController,this.shutdownController.signal,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}[xo]=!0;[Symbol.toStringTag]="@libp2p/webrtc";[it]=["@libp2p/transport"];[jn]=["@libp2p/identify","@libp2p/circuit-relay-v2-transport"];isStarted(){return this._started}async start(){await this.components.registrar.handle(fo,e=>{const t=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);this._onProtocol(e,t).catch(n=>{this.log.error("failed to handle incoming connect from %p",e.connection.remotePeer,n)}).finally(()=>{t.clear()})},{runOnLimitedConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(fo),this._started=!1}createListener(e){return new la(this.components,{shutdownController:this.shutdownController})}listenFilter(e){return e.filter(lo.exactMatch)}dialFilter(e){return this.listenFilter(e)}async dial(e,t){this.log.trace("dialing address: %a",e);const{remoteAddress:n,peerConnection:s,muxerFactory:i}=await V0({rtcConfiguration:await Rc(this.init.rtcConfiguration),dataChannel:this.init.dataChannel,multiaddr:e,dataChannelOptions:this.init.dataChannel,signal:t.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager,log:this.log,logger:this.components.logger,onProgress:t.onProgress}),o=new Mc(this.components,{peerConnection:s,timeline:{open:Date.now()},remoteAddr:n,metrics:this.metrics?.dialerEvents}),a=await t.upgrader.upgradeOutbound(o,{skipProtection:!0,skipEncryption:!0,muxerFactory:i,onProgress:t.onProgress,signal:t.signal});return this._closeOnShutdown(s,o),a}async _onProtocol({connection:e,stream:t},n){const s=new Gd(await Rc(this.init.rtcConfiguration)),i=new Hd(this.components,{peerConnection:s,dataChannelOptions:this.init.dataChannel});try{const{remoteAddress:o}=await H0({peerConnection:s,connection:e,stream:t,signal:n,log:this.log});await t.close({signal:n});const a=new Mc(this.components,{peerConnection:s,timeline:{open:new Date().getTime()},remoteAddr:o,metrics:this.metrics?.listenerEvents});await this.components.upgrader.upgradeInbound(a,{skipEncryption:!0,skipProtection:!0,muxerFactory:i,signal:n}),this._closeOnShutdown(s,a)}catch(o){throw this.log.error("incoming signaling error",o),s.close(),t.abort(o),o}}_closeOnShutdown(e,t){const n=()=>{t.close().catch(s=>{this.log.error("could not close WebRTCMultiaddrConnection",s)})};this.shutdownController.signal.addEventListener("abort",n),e.addEventListener("close",()=>{this.shutdownController.signal.removeEventListener("abort",n)})}}function Y0(r){const e=r.toString().split("/webrtc/");if(e.length!==2)throw new V("webrtc protocol was not present in multiaddr");if(!e[0].includes("/p2p-circuit"))throw new V("p2p-circuit protocol was not present in multiaddr");let t=Q(e[0]);const s=Q("/"+e[1]).getPeerId();if(s==null)throw new V("destination peer id was missing");const i=t.protos().pop();if(i===void 0)throw new V("invalid multiaddr");return i.name!=="p2p"&&(t=t.encapsulate(`/p2p/${s}`)),{baseAddr:t,peerId:pt(s)}}const wt="/",Qd=new TextEncoder().encode(wt),Bn=Qd[0];class Ue{_buf;constructor(e,t){if(typeof e=="string")this._buf=q(e);else if(e instanceof Uint8Array)this._buf=e;else throw new Error("Invalid key, should be String of Uint8Array");if(t==null&&(t=!0),t&&this.clean(),this._buf.byteLength===0||this._buf[0]!==Bn)throw new Error("Invalid key")}toString(e="utf8"){return Y(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new Ue(e.join(wt))}static random(){return new Ue(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||typeof e=="string"?new Ue(e):typeof e.uint8Array=="function"?new Ue(e.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=Qd),this._buf[0]!==Bn){const e=new Uint8Array(this._buf.byteLength+1);e.fill(Bn,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===Bn;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),n=e.list();for(let s=0;s<t.length;s++){if(n.length<s+1)return!1;const i=t[s],o=n[s];if(i<o)return!0;if(i>o)return!1}return t.length<n.length}reverse(){return Ue.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(wt).slice(1)}type(){return X0(this.baseNamespace())}name(){return Q0(this.baseNamespace())}instance(e){return new Ue(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(wt)||(e+=wt),e+=this.type(),new Ue(e)}parent(){const e=this.list();return e.length===1?new Ue(wt):new Ue(e.slice(0,-1).join(wt))}child(e){return this.toString()===wt?e:e.toString()===wt?this:new Ue(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()===this.toString()?!1:e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()===this.toString()?!1:this.toString().startsWith(e.toString())}isTopLevel(){return this.list().length===1}concat(...e){return Ue.withNamespaces([...this.namespaces(),...j0(e.map(t=>t.namespaces()))])}}function X0(r){const e=r.split(":");return e.length<2?"":e.slice(0,-1).join(":")}function Q0(r){const e=r.split(":");return e[e.length-1]}function j0(r){return[].concat(...r)}function Z0(r){return e=>new G0(e,r)}const J0=[G("tcp").code,G("dns").code,G("dnsaddr").code,G("dns4").code,G("dns6").code];function Nc(r){return jd("sni",r)?.[1]}function Fc(r){const e=jd("tcp",r)?.[1];return e==null?"":`:${e}`}function jd(r,e){let t;try{t=G(r).code}catch{return}for(const[n,s]of e)if(n===t&&s!=null)return[n,s]}function Uc(r){return r.some(([e,t])=>e===G("tls").code)}function rt(r,e,t){const n=Zd[G(r).name];if(n==null)throw new Error(`Can't interpret protocol ${G(r).name}`);const s=n(e,t);return r===G("ip6").code?`[${s}]`:s}const Zd={ip4:(r,e)=>r,ip6:(r,e)=>e.length===0?r:`[${r}]`,tcp:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`tcp://${rt(t[0],t[1]??"",e)}:${r}`},udp:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`udp://${rt(t[0],t[1]??"",e)}:${r}`},dnsaddr:(r,e)=>r,dns4:(r,e)=>r,dns6:(r,e)=>r,dns:(r,e)=>r,ipfs:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${rt(t[0],t[1]??"",e)}`},p2p:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return`${rt(t[0],t[1]??"",e)}`},http:(r,e)=>{const t=Uc(e),n=Nc(e),s=Fc(e);if(t&&n!=null)return`https://${n}${s}`;const i=t?"https://":"http://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=rt(o[0],o[1]??"",e);return a=a.replace("tcp://",""),`${i}${a}`},"http-path":(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");const n=rt(t[0],t[1]??"",e),s=decodeURIComponent(r);return`${n}/${s}`},tls:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return rt(t[0],t[1]??"",e)},sni:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");return rt(t[0],t[1]??"",e)},https:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let n=rt(t[0],t[1]??"",e);return n=n.replace("tcp://",""),`https://${n}`},ws:(r,e)=>{const t=Uc(e),n=Nc(e),s=Fc(e);if(t&&n!=null)return`wss://${n}${s}`;const i=t?"wss://":"ws://",o=e.pop();if(o==null)throw new Error("Unexpected end of multiaddr");let a=rt(o[0],o[1]??"",e);return a=a.replace("tcp://",""),`${i}${a}`},wss:(r,e)=>{const t=e.pop();if(t==null)throw new Error("Unexpected end of multiaddr");let n=rt(t[0],t[1]??"",e);return n=n.replace("tcp://",""),`wss://${n}`}};function ev(r,e){const n=Q(r).stringTuples(),s=n.pop();if(s==null)throw new Error("Unexpected end of multiaddr");const i=G(s[0]),o=Zd[i.name];if(o==null)throw new Error(`No interpreter found for ${i.name}`);let a=o(s[1]??"",n);return J0.includes(s[0])&&(a=a.replace(/^.*:\/\//,""),s[1]==="443"?a=`https://${a}`:a=`http://${a}`),(a.startsWith("http://")||a.startsWith("https://")||a.startsWith("ws://")||a.startsWith("wss://"))&&(a=new URL(a).toString(),a.endsWith("/")&&(a=a.substring(0,a.length-1))),a}const tv=async r=>{if(r.readyState>=2)throw new Error("socket closed");r.readyState!==1&&await new Promise((e,t)=>{function n(){r.removeEventListener("open",s),r.removeEventListener("error",i)}function s(){n(),e()}function i(o){n(),t(o.error??new Error(`connect ECONNREFUSED ${r.url}`))}r.addEventListener("open",s),r.addEventListener("error",i)})},rv=(r,e)=>(e=e??{},e.closeOnEnd=e.closeOnEnd!==!1,async n=>{for await(const s of n){try{await tv(r)}catch(i){if(i.message==="socket closed")break;throw i}if(r.readyState===r.CLOSING||r.readyState===r.CLOSED)break;r.send(s)}e.closeOnEnd!=null&&r.readyState<=1&&await new Promise((s,i)=>{r.addEventListener("close",o=>{if(o.wasClean||o.code===1006)s();else{const a=Object.assign(new Error("ws error"),{event:o});i(a)}}),setTimeout(()=>{r.close()})})});var ar={},zr={},Bc;function nv(){if(Bc)return zr;Bc=1,Object.defineProperty(zr,"__esModule",{value:!0});class r{constructor(){this.pullQueue=[],this.pushQueue=[],this.eventHandlers={},this.isPaused=!1,this.isStopped=!1}push(n){if(this.isStopped)return;const s={value:n,done:!1};if(this.pullQueue.length){const i=this.pullQueue.shift();i&&i.resolve(s)}else this.pushQueue.push(Promise.resolve(s)),this.highWaterMark!==void 0&&this.pushQueue.length>=this.highWaterMark&&!this.isPaused&&(this.isPaused=!0,this.eventHandlers.highWater?this.eventHandlers.highWater():console&&console.warn(`EventIterator queue reached ${this.pushQueue.length} items`))}stop(){if(!this.isStopped){this.isStopped=!0,this.remove();for(const n of this.pullQueue)n.resolve({value:void 0,done:!0});this.pullQueue.length=0}}fail(n){if(!this.isStopped)if(this.isStopped=!0,this.remove(),this.pullQueue.length){for(const s of this.pullQueue)s.reject(n);this.pullQueue.length=0}else{const s=Promise.reject(n);s.catch(()=>{}),this.pushQueue.push(s)}}remove(){Promise.resolve().then(()=>{this.removeCallback&&this.removeCallback()})}[Symbol.asyncIterator](){return{next:n=>{const s=this.pushQueue.shift();return s?(this.lowWaterMark!==void 0&&this.pushQueue.length<=this.lowWaterMark&&this.isPaused&&(this.isPaused=!1,this.eventHandlers.lowWater&&this.eventHandlers.lowWater()),s):this.isStopped?Promise.resolve({value:void 0,done:!0}):new Promise((i,o)=>{this.pullQueue.push({resolve:i,reject:o})})},return:()=>(this.isStopped=!0,this.pushQueue.length=0,this.remove(),Promise.resolve({value:void 0,done:!0}))}}}class e{constructor(n,{highWaterMark:s=100,lowWaterMark:i=1}={}){const o=new r;o.highWaterMark=s,o.lowWaterMark=i,o.removeCallback=n({push:a=>o.push(a),stop:()=>o.stop(),fail:a=>o.fail(a),on:(a,c)=>{o.eventHandlers[a]=c}})||(()=>{}),this[Symbol.asyncIterator]=()=>o[Symbol.asyncIterator](),Object.freeze(this)}}return zr.EventIterator=e,zr.default=e,zr}var $c;function sv(){if($c)return ar;$c=1,Object.defineProperty(ar,"__esModule",{value:!0});const r=nv();ar.EventIterator=r.EventIterator;function e(t,n,s){return new r.EventIterator(({push:i})=>(this.addEventListener(t,i,n),()=>this.removeEventListener(t,i,n)),s)}return ar.subscribe=e,ar.default=r.EventIterator,ar}var iv=sv();function zc(r){return r instanceof ArrayBuffer||r?.constructor?.name==="ArrayBuffer"&&typeof r?.byteLength=="number"}const ov=r=>{r.binaryType="arraybuffer";const e=async()=>{await new Promise((i,o)=>{if(n){i();return}if(s!=null){o(s);return}const a=u=>{r.removeEventListener("open",c),r.removeEventListener("error",l),u()},c=()=>{a(i)},l=u=>{a(()=>{o(u.error??new Error(`connect ECONNREFUSED ${r.url}`))})};r.addEventListener("open",c),r.addEventListener("error",l)})},t=async function*(){const i=new iv.EventIterator(({push:o,stop:a,fail:c})=>{const l=d=>{let h=null;typeof d.data=="string"&&(h=q(d.data)),zc(d.data)&&(h=new Uint8Array(d.data)),d.data instanceof Uint8Array&&(h=d.data),h!=null&&o(h)},u=d=>{c(d.error??new Error("Socket error"))};return r.addEventListener("message",l),r.addEventListener("error",u),r.addEventListener("close",a),()=>{r.removeEventListener("message",l),r.removeEventListener("error",u),r.removeEventListener("close",a)}},{highWaterMark:1/0});await e();for await(const o of i)yield zc(o)?new Uint8Array(o):o}();let n=r.readyState===1,s;return r.addEventListener("open",()=>{n=!0,s=null}),r.addEventListener("close",()=>{n=!1,s=null}),r.addEventListener("error",i=>{n||(s=i.error??new Error(`connect ECONNREFUSED ${r.url}`))}),Object.assign(t,{connected:e})},av=(r,e)=>{e=e??{};const t=ov(r);let n=e.remoteAddress,s=e.remotePort;if(r.url!=null)try{const o=new URL(r.url);n=o.hostname,s=parseInt(o.port,10)}catch{}if(n==null||s==null)throw new Error("Remote connection did not have address and/or port");return{sink:rv(r,e),source:t,connected:async()=>{await t.connected()},close:async()=>{(r.readyState===r.CONNECTING||r.readyState===r.OPEN)&&await new Promise(o=>{r.addEventListener("close",()=>{o()}),r.close()})},destroy:()=>{r.terminate!=null?r.terminate():r.close()},remoteAddress:n,remotePort:s,socket:r}},cv=WebSocket,lv={"http:":"ws:","https:":"wss:"},Kc="ws:",uv=(r,e)=>{if(r.startsWith("//")&&(r=`${e?.protocol??Kc}${r}`),r.startsWith("/")&&e!=null){const n=e.protocol??Kc,s=e.host,i=e.port!=null&&s?.endsWith(`:${e.port}`)!==!0?`:${e.port}`:"";r=`${n}//${s}${i}${r}`}const t=new URL(r);for(const[n,s]of Object.entries(lv))t.protocol===n&&(t.protocol=s);return t};function dv(r,e){const t=typeof window>"u"?void 0:window.location;e=e??{};const n=uv(r,t),s=new cv(n.toString(),e.websocket);return av(s,e)}function Jd(r){return r.filter(e=>As.exactMatch(e)||cn.exactMatch(e))}function hv(){throw new Error("WebSocket Servers can not be created in the browser!")}const fv=500;function pv(r,e,t){const n=t.logger.forComponent("libp2p:websockets:maconn"),s=t.metrics,i=t.metricPrefix??"",o={log:n,async sink(a){try{await r.sink(async function*(){for await(const c of a)c instanceof Uint8Array?yield c:yield c.subarray()}())}catch(c){c.type!=="aborted"&&n.error(c)}},source:r.source,remoteAddr:e,timeline:{open:Date.now()},async close(a={}){const c=Date.now();if(a.signal==null){const u=AbortSignal.timeout(fv);a={...a,signal:u}}const l=()=>{const{host:u,port:d}=o.remoteAddr.toOptions();n("timeout closing stream to %s:%s after %dms, destroying it manually",u,d,Date.now()-c),this.abort(new Qt("Socket close timeout"))};a.signal?.addEventListener("abort",l);try{await r.close()}catch(u){n.error("error closing WebSocket gracefully",u),this.abort(u)}finally{a.signal?.removeEventListener("abort",l),o.timeline.close=Date.now()}},abort(a){const{host:c,port:l}=o.remoteAddr.toOptions();n("timeout closing stream to %s:%s due to error",c,l,a),r.destroy(),o.timeline.close=Date.now(),s?.increment({[`${i}error`]:!0})}};return r.socket.addEventListener("close",()=>{s?.increment({[`${i}close`]:!0}),o.timeline.close==null&&(o.timeline.close=Date.now())},{once:!0}),o}class gv{log;init;logger;metrics;components;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:websockets"),this.logger=e.logger,this.components=e,this.init=t,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total",{label:"event",help:"Total count of WebSockets dialer events by type"})})}[xo]=!0;[Symbol.toStringTag]="@libp2p/websockets";[it]=["@libp2p/transport"];async dial(e,t){this.log("dialing %s",e),t=t??{};const n=await this._connect(e,t),s=pv(n,e,{logger:this.logger,metrics:this.metrics?.dialerEvents});this.log("new outbound connection %s",s.remoteAddr);const i=await t.upgrader.upgradeOutbound(s,t);return this.log("outbound connection %s upgraded",s.remoteAddr),i}async _connect(e,t){t?.signal?.throwIfAborted();const n=e.toOptions();this.log("dialing %s:%s",n.host,n.port);const s=he(),i=dv(ev(e),this.init);i.socket.addEventListener("error",()=>{const o=new Ol(`Could not connect to ${e.toString()}`);this.log.error("connection error:",o),this.metrics?.dialerEvents.increment({error:!0}),s.reject(o)});try{t.onProgress?.(new ie("websockets:open-connection")),await Je(Promise.race([i.connected(),s.promise]),t.signal)}catch(o){throw t.signal?.aborted&&this.metrics?.dialerEvents.increment({abort:!0}),i.close().catch(a=>{this.log.error("error closing raw socket",a)}),o}return this.log("connected %s",e),this.metrics?.dialerEvents.increment({connect:!0}),i}createListener(e){return hv({logger:this.logger,events:this.components.events,metrics:this.components.metrics},{...this.init,...e})}listenFilter(e){return e=Array.isArray(e)?e:[e],this.init?.filter!=null?this.init?.filter(e):Jd(e)}dialFilter(e){return this.listenFilter(e)}}function mv(r={}){return e=>new gv(e,r)}function Ts(r){if(typeof r!="object"||r===null)return!1;const e=Object.getPrototypeOf(r);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in r)&&!(Symbol.iterator in r)}const{hasOwnProperty:eh}=Object.prototype,{propertyIsEnumerable:yv}=Object,Tr=(r,e,t)=>{Object.defineProperty(r,e,{value:t,writable:!0,enumerable:!0,configurable:!0})},wv=void 0,qc={concatArrays:!1,ignoreUndefined:!1},Hs=r=>{const e=[];for(const t in r)eh.call(r,t)&&e.push(t);if(Object.getOwnPropertySymbols){const t=Object.getOwnPropertySymbols(r);for(const n of t)yv.call(r,n)&&e.push(n)}return e};function Mr(r){return Array.isArray(r)?bv(r):Ts(r)?vv(r):r}function bv(r){const e=r.slice(0,0);return Hs(r).forEach(t=>{Tr(e,t,Mr(r[t]))}),e}function vv(r){const e=Object.getPrototypeOf(r)===null?Object.create(null):{};return Hs(r).forEach(t=>{Tr(e,t,Mr(r[t]))}),e}const th=(r,e,t,n)=>(t.forEach(s=>{typeof e[s]>"u"&&n.ignoreUndefined||(s in r&&r[s]!==Object.getPrototypeOf(r)?Tr(r,s,go(r[s],e[s],n)):Tr(r,s,Mr(e[s])))}),r),Ev=(r,e,t)=>{let n=r.slice(0,0),s=0;return[r,e].forEach(i=>{const o=[];for(let a=0;a<i.length;a++)eh.call(i,a)&&(o.push(String(a)),i===r?Tr(n,s++,i[a]):Tr(n,s++,Mr(i[a])));n=th(n,i,Hs(i).filter(a=>!o.includes(a)),t)}),n};function go(r,e,t){return t.concatArrays&&Array.isArray(r)&&Array.isArray(e)?Ev(r,e,t):!Ts(e)||!Ts(r)?Mr(e):th(r,e,Hs(e),t)}function rh(...r){const e=go(Mr(qc),this!==wv&&this||{},qc);let t={_:{}};for(const n of r)if(n!==void 0){if(!Ts(n))throw new TypeError("`"+n+"` is not an Option Object");t=go(t,{_:n},e)}return t._}var bi={exports:{}},Wc;function Sv(){return Wc||(Wc=1,function(r){var e=Object.prototype.hasOwnProperty,t="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(t=!1));function s(c,l,u){this.fn=c,this.context=l,this.once=u||!1}function i(c,l,u,d,h){if(typeof u!="function")throw new TypeError("The listener must be a function");var p=new s(u,d||c,h),f=t?t+l:l;return c._events[f]?c._events[f].fn?c._events[f]=[c._events[f],p]:c._events[f].push(p):(c._events[f]=p,c._eventsCount++),c}function o(c,l){--c._eventsCount===0?c._events=new n:delete c._events[l]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var l=[],u,d;if(this._eventsCount===0)return l;for(d in u=this._events)e.call(u,d)&&l.push(t?d.slice(1):d);return Object.getOwnPropertySymbols?l.concat(Object.getOwnPropertySymbols(u)):l},a.prototype.listeners=function(l){var u=t?t+l:l,d=this._events[u];if(!d)return[];if(d.fn)return[d.fn];for(var h=0,p=d.length,f=new Array(p);h<p;h++)f[h]=d[h].fn;return f},a.prototype.listenerCount=function(l){var u=t?t+l:l,d=this._events[u];return d?d.fn?1:d.length:0},a.prototype.emit=function(l,u,d,h,p,f){var g=t?t+l:l;if(!this._events[g])return!1;var m=this._events[g],v=arguments.length,k,b;if(m.fn){switch(m.once&&this.removeListener(l,m.fn,void 0,!0),v){case 1:return m.fn.call(m.context),!0;case 2:return m.fn.call(m.context,u),!0;case 3:return m.fn.call(m.context,u,d),!0;case 4:return m.fn.call(m.context,u,d,h),!0;case 5:return m.fn.call(m.context,u,d,h,p),!0;case 6:return m.fn.call(m.context,u,d,h,p,f),!0}for(b=1,k=new Array(v-1);b<v;b++)k[b-1]=arguments[b];m.fn.apply(m.context,k)}else{var w=m.length,E;for(b=0;b<w;b++)switch(m[b].once&&this.removeListener(l,m[b].fn,void 0,!0),v){case 1:m[b].fn.call(m[b].context);break;case 2:m[b].fn.call(m[b].context,u);break;case 3:m[b].fn.call(m[b].context,u,d);break;case 4:m[b].fn.call(m[b].context,u,d,h);break;default:if(!k)for(E=1,k=new Array(v-1);E<v;E++)k[E-1]=arguments[E];m[b].fn.apply(m[b].context,k)}}return!0},a.prototype.on=function(l,u,d){return i(this,l,u,d,!1)},a.prototype.once=function(l,u,d){return i(this,l,u,d,!0)},a.prototype.removeListener=function(l,u,d,h){var p=t?t+l:l;if(!this._events[p])return this;if(!u)return o(this,p),this;var f=this._events[p];if(f.fn)f.fn===u&&(!h||f.once)&&(!d||f.context===d)&&o(this,p);else{for(var g=0,m=[],v=f.length;g<v;g++)(f[g].fn!==u||h&&!f[g].once||d&&f[g].context!==d)&&m.push(f[g]);m.length?this._events[p]=m.length===1?m[0]:m:o(this,p)}return this},a.prototype.removeAllListeners=function(l){var u;return l?(u=t?t+l:l,this._events[u]&&o(this,u)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,r.exports=a}(bi)),bi.exports}var xv=Sv();const Av=ia(xv);function Cv(r,e,t){let n=0,s=r.length;for(;s>0;){const i=Math.trunc(s/2);let o=n+i;t(r[o],e)<=0?(n=++o,s-=i+1):s=i}return n}let Iv=class{#e=[];enqueue(e,t){t={priority:0,...t};const n={priority:t.priority,id:t.id,run:e};if(this.size===0||this.#e[this.size-1].priority>=t.priority){this.#e.push(n);return}const s=Cv(this.#e,n,(i,o)=>o.priority-i.priority);this.#e.splice(s,0,n)}setPriority(e,t){const n=this.#e.findIndex(i=>i.id===e);if(n===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[s]=this.#e.splice(n,1);this.enqueue(s.run,{priority:t,id:e})}dequeue(){return this.#e.shift()?.run}filter(e){return this.#e.filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return this.#e.length}};class mo extends Av{#e;#t;#r=0;#a;#c;#p=0;#s;#l;#n;#g;#i=0;#u;#o;#m;#b=1n;timeout;constructor(e){if(super(),e={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:Iv,...e},!(typeof e.intervalCap=="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString()??""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString()??""}\` (${typeof e.interval})`);this.#e=e.carryoverConcurrencyCount,this.#t=e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0,this.#a=e.intervalCap,this.#c=e.interval,this.#n=new e.queueClass,this.#g=e.queueClass,this.concurrency=e.concurrency,this.timeout=e.timeout,this.#m=e.throwOnTimeout===!0,this.#o=e.autoStart===!1}get#v(){return this.#t||this.#r<this.#a}get#E(){return this.#i<this.#u}#S(){this.#i--,this.#d(),this.emit("next")}#x(){this.#w(),this.#y(),this.#l=void 0}get#A(){const e=Date.now();if(this.#s===void 0){const t=this.#p-e;if(t<0)this.#r=this.#e?this.#i:0;else return this.#l===void 0&&(this.#l=setTimeout(()=>{this.#x()},t)),!0}return!1}#d(){if(this.#n.size===0)return this.#s&&clearInterval(this.#s),this.#s=void 0,this.emit("empty"),this.#i===0&&this.emit("idle"),!1;if(!this.#o){const e=!this.#A;if(this.#v&&this.#E){const t=this.#n.dequeue();return t?(this.emit("active"),t(),e&&this.#y(),!0):!1}}return!1}#y(){this.#t||this.#s!==void 0||(this.#s=setInterval(()=>{this.#w()},this.#c),this.#p=Date.now()+this.#c)}#w(){this.#r===0&&this.#i===0&&this.#s&&(clearInterval(this.#s),this.#s=void 0),this.#r=this.#e?this.#i:0,this.#h()}#h(){for(;this.#d(););}get concurrency(){return this.#u}set concurrency(e){if(!(typeof e=="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);this.#u=e,this.#h()}async#C(e){return new Promise((t,n)=>{e.addEventListener("abort",()=>{n(e.reason)},{once:!0})})}setPriority(e,t){this.#n.setPriority(e,t)}async add(e,t={}){return t.id??=(this.#b++).toString(),t={timeout:this.timeout,throwOnTimeout:this.#m,...t},new Promise((n,s)=>{this.#n.enqueue(async()=>{this.#i++,this.#r++;try{t.signal?.throwIfAborted();let i=e({signal:t.signal});t.timeout&&(i=aa(Promise.resolve(i),{milliseconds:t.timeout})),t.signal&&(i=Promise.race([i,this.#C(t.signal)]));const o=await i;n(o),this.emit("completed",o)}catch(i){if(i instanceof Kd&&!t.throwOnTimeout){n();return}s(i),this.emit("error",i)}finally{this.#S()}},t),this.emit("add"),this.#d()})}async addAll(e,t){return Promise.all(e.map(async n=>this.add(n,t)))}start(){return this.#o?(this.#o=!1,this.#h(),this):this}pause(){this.#o=!0}clear(){this.#n=new this.#g}async onEmpty(){this.#n.size!==0&&await this.#f("empty")}async onSizeLessThan(e){this.#n.size<e||await this.#f("next",()=>this.#n.size<e)}async onIdle(){this.#i===0&&this.#n.size===0||await this.#f("idle")}async#f(e,t){return new Promise(n=>{const s=()=>{t&&!t()||(this.off(e,s),n())};this.on(e,s)})}get size(){return this.#n.size}sizeBy(e){return this.#n.filter(e).length}get pending(){return this.#i}get isPaused(){return this.#o}}function nh(r){const e=[zt.A];return r==null?e:Array.isArray(r)?r.length===0?e:r:[r]}const sh=60;function ih(r){return{Status:r.Status??0,TC:r.TC??r.flag_tc??!1,RD:r.RD??r.flag_rd??!1,RA:r.RA??r.flag_ra??!1,AD:r.AD??r.flag_ad??!1,CD:r.CD??r.flag_cd??!1,Question:(r.Question??r.questions??[]).map(e=>({name:e.name,type:zt[e.type]})),Answer:(r.Answer??r.answers??[]).map(e=>({name:e.name,type:zt[e.type],TTL:e.TTL??e.ttl??sh,data:e.data instanceof Uint8Array?Y(e.data):e.data}))}}const Tv=4;function Vc(r,e={}){const t=new mo({concurrency:e.queryConcurrency??Tv});return async(n,s={})=>{const i=new URLSearchParams;i.set("name",n),nh(s.types).forEach(a=>{i.append("type",zt[a])}),s.onProgress?.(new ie("dns:query",{detail:n}));const o=await t.add(async()=>{const a=await fetch(`${r}?${i}`,{headers:{accept:"application/dns-json"},signal:s?.signal});if(a.status!==200)throw new Error(`Unexpected HTTP status: ${a.status} - ${a.statusText}`);const c=ih(await a.json());return s.onProgress?.(new ie("dns:response",{detail:c})),c},{signal:s.signal});if(o==null)throw new Error("No DNS response received");return o}}function kv(){return[Vc("https://cloudflare-dns.com/dns-query"),Vc("https://dns.google/resolve")]}var vi,Hc;function _v(){return Hc||(Hc=1,vi=function(r){if(!r)throw Error("hashlru must have a max value, of type number, greater than 0");var e=0,t=Object.create(null),n=Object.create(null);function s(i,o){t[i]=o,e++,e>=r&&(e=0,n=t,t=Object.create(null))}return{has:function(i){return t[i]!==void 0||n[i]!==void 0},remove:function(i){t[i]!==void 0&&(t[i]=void 0),n[i]!==void 0&&(n[i]=void 0)},get:function(i){var o=t[i];if(o!==void 0)return o;if((o=n[i])!==void 0)return s(i,o),o},set:function(i,o){t[i]!==void 0?t[i]=o:s(i,o)},clear:function(){t=Object.create(null),n=Object.create(null)}}}),vi}var Pv=_v();const Lv=ia(Pv);class Dv{lru;constructor(e){this.lru=Lv(e)}get(e,t){let n=!0;const s=[];for(const i of t){const o=this.getAnswers(e,i);if(o.length===0){n=!1;break}s.push(...o)}if(n)return ih({answers:s})}getAnswers(e,t){const n=`${e.toLowerCase()}-${t}`,s=this.lru.get(n);if(s!=null){const i=s.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:zt[a.type]}));return i.length===0&&this.lru.remove(n),i}return[]}add(e,t){const n=`${e.toLowerCase()}-${t.type}`,s=this.lru.get(n)??[];s.push({expires:Date.now()+(t.TTL??sh)*1e3,value:t}),this.lru.set(n,s)}remove(e,t){const n=`${e.toLowerCase()}-${t}`;this.lru.remove(n)}clear(){this.lru.clear()}}function Rv(r){return new Dv(r)}const Mv=1e3;class Ov{resolvers;cache;constructor(e){this.resolvers={},this.cache=Rv(e.cacheSize??Mv),Object.entries(e.resolvers??{}).forEach(([t,n])=>{Array.isArray(n)||(n=[n]),t.endsWith(".")||(t=`${t}.`),this.resolvers[t]=n}),this.resolvers["."]==null&&(this.resolvers["."]=kv())}async query(e,t={}){const n=nh(t.types),s=t.cached!==!1?this.cache.get(e,n):void 0;if(s!=null)return t.onProgress?.(new ie("dns:cache",{detail:s})),s;const i=`${e.split(".").pop()}.`,o=(this.resolvers[i]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const c of o){if(t.signal?.aborted===!0)break;try{const l=await c(e,{...t,types:n});for(const u of l.Answer)this.cache.add(e,u);return l}catch(l){a.push(l),t.onProgress?.(new ie("dns:error",{detail:l}))}}throw a.length===1?a[0]:new AggregateError(a,`DNS lookup of ${e} ${n} failed`)}}var zt;(function(r){r[r.A=1]="A",r[r.CNAME=5]="CNAME",r[r.TXT=16]="TXT",r[r.AAAA=28]="AAAA"})(zt||(zt={}));function Nv(r={}){return new Ov(r)}const Fv=32,{code:Uv}=G("dnsaddr");class Bv extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}const oh=async function(e,t={}){const n=t.maxRecursiveDepth??Fv;if(n===0)throw new Bv("Max recursive depth reached");const[,s]=e.stringTuples().find(([l])=>l===Uv)??[],o=await(t?.dns??Nv()).query(`_dnsaddr.${s}`,{signal:t?.signal,types:[zt.TXT]}),a=e.getPeerId(),c=[];for(const l of o.Answer){const u=l.data.replace(/["']/g,"").trim().split("=")[1];if(u==null||a!=null&&!u.includes(a))continue;const d=Q(u);if(u.startsWith("/dnsaddr")){const h=await d.resolve({...t,maxRecursiveDepth:n-1});c.push(...h.map(p=>p.toString()))}else c.push(d.toString())}return c};var $v={};const zv={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter:r=>r},connectionManager:{resolvers:{dnsaddr:oh}},transportManager:{faultTolerance:Qr.FATAL_ALL}};async function Kv(r){const e=rh(zv,r);if(e.connectionProtector===null&&$v?.LIBP2P_FORCE_PNET!=null)throw new V("Private network is enforced, but no protector was provided");return e}const kr=1e3,_r=kr*60,Pr=_r*60,Zt=Pr*24,qv=Zt*7,Wv=Zt*365.25;function ah(r,e){try{if(typeof r=="string"&&r.length>0)return Vv(r);if(typeof r=="number"&&isFinite(r))return e?.long?Gv(r):Hv(r);throw new Error("Value is not a string or number.")}catch(t){const n=Yv(t)?`${t.message}. value=${JSON.stringify(r)}`:"An unknown error has occured.";throw new Error(n)}}function Vv(r){if(r=String(r),r.length>100)throw new Error("Value exceeds the maximum length of 100 characters.");const e=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(r);if(!e)return NaN;const t=parseFloat(e[1]),n=(e[2]||"ms").toLowerCase();switch(n){case"years":case"year":case"yrs":case"yr":case"y":return t*Wv;case"weeks":case"week":case"w":return t*qv;case"days":case"day":case"d":return t*Zt;case"hours":case"hour":case"hrs":case"hr":case"h":return t*Pr;case"minutes":case"minute":case"mins":case"min":case"m":return t*_r;case"seconds":case"second":case"secs":case"sec":case"s":return t*kr;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:throw new Error(`The unit ${n} was matched, but no matching case exists.`)}}function Hv(r){const e=Math.abs(r);return e>=Zt?`${Math.round(r/Zt)}d`:e>=Pr?`${Math.round(r/Pr)}h`:e>=_r?`${Math.round(r/_r)}m`:e>=kr?`${Math.round(r/kr)}s`:`${r}ms`}function Gv(r){const e=Math.abs(r);return e>=Zt?$n(r,e,Zt,"day"):e>=Pr?$n(r,e,Pr,"hour"):e>=_r?$n(r,e,_r,"minute"):e>=kr?$n(r,e,kr,"second"):`${r} ms`}function $n(r,e,t,n){const s=e>=t*1.5;return`${Math.round(r/t)} ${n}${s?"s":""}`}function Yv(r){return typeof r=="object"&&r!==null&&"message"in r}function Xv(r){t.debug=t,t.default=t,t.coerce=c,t.disable=i,t.enable=s,t.enabled=o,t.humanize=ah,t.destroy=l,Object.keys(r).forEach(u=>{t[u]=r[u]}),t.names=[],t.skips=[],t.formatters={};function e(u){let d=0;for(let h=0;h<u.length;h++)d=(d<<5)-d+u.charCodeAt(h),d|=0;return t.colors[Math.abs(d)%t.colors.length]}t.selectColor=e;function t(u){let d,h=null,p,f;function g(...m){if(!g.enabled)return;const v=g,k=Number(new Date),b=k-(d||k);v.diff=b,v.prev=d,v.curr=k,d=k,m[0]=t.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");let w=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,(P,x)=>{if(P==="%%")return"%";w++;const _=t.formatters[x];if(typeof _=="function"){const D=m[w];P=_.call(v,D),m.splice(w,1),w--}return P}),t.formatArgs.call(v,m),(v.log||t.log).apply(v,m)}return g.namespace=u,g.useColors=t.useColors(),g.color=t.selectColor(u),g.extend=n,g.destroy=t.destroy,Object.defineProperty(g,"enabled",{enumerable:!0,configurable:!1,get:()=>h!==null?h:(p!==t.namespaces&&(p=t.namespaces,f=t.enabled(u)),f),set:m=>{h=m}}),typeof t.init=="function"&&t.init(g),g}function n(u,d){const h=t(this.namespace+(typeof d>"u"?":":d)+u);return h.log=this.log,h}function s(u){t.save(u),t.namespaces=u,t.names=[],t.skips=[];let d;const h=(typeof u=="string"?u:"").split(/[\s,]+/),p=h.length;for(d=0;d<p;d++)h[d]&&(u=h[d].replace(/\*/g,".*?"),u[0]==="-"?t.skips.push(new RegExp("^"+u.substr(1)+"$")):t.names.push(new RegExp("^"+u+"$")))}function i(){const u=[...t.names.map(a),...t.skips.map(a).map(d=>"-"+d)].join(",");return t.enable(""),u}function o(u){if(u[u.length-1]==="*")return!0;let d,h;for(d=0,h=t.skips.length;d<h;d++)if(t.skips[d].test(u))return!1;for(d=0,h=t.names.length;d<h;d++)if(t.names[d].test(u))return!0;return!1}function a(u){return u.toString().substring(2,u.toString().length-2).replace(/\.\*\?$/,"*")}function c(u){return u instanceof Error?u.stack??u.message:u}function l(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.setupFormatters(t.formatters),t.enable(t.load()),t}var Qv={};const ks=nE(),jv=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function Zv(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/)!=null?!1:typeof document<"u"&&document.documentElement?.style?.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/)!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/)}function Jv(r){if(r[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+r[0]+(this.useColors?"%c ":" ")+"+"+ah(this.diff),!this.useColors)return;const e="color: "+this.color;r.splice(1,0,e,"color: inherit");let t=0,n=0;r[0].replace(/%[a-zA-Z%]/g,s=>{s!=="%%"&&(t++,s==="%c"&&(n=t))}),r.splice(n,0,e)}const eE=console.debug??console.log??(()=>{});function tE(r){try{r?ks?.setItem("debug",r):ks?.removeItem("debug")}catch{}}function rE(){let r;try{r=ks?.getItem("debug")}catch{}return!r&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(r=Qv.DEBUG),r}function nE(){try{return localStorage}catch{}}function sE(r){r.j=function(e){try{return JSON.stringify(e)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}}const Xe=Xv({formatArgs:Jv,save:tE,load:rE,useColors:Zv,setupFormatters:sE,colors:jv,storage:ks,log:eE});Xe.formatters.b=r=>r==null?"undefined":ye.baseEncode(r);Xe.formatters.t=r=>r==null?"undefined":St.baseEncode(r);Xe.formatters.m=r=>r==null?"undefined":Gl.baseEncode(r);Xe.formatters.p=r=>r==null?"undefined":r.toString();Xe.formatters.c=r=>r==null?"undefined":r.toString();Xe.formatters.k=r=>r==null?"undefined":r.toString();Xe.formatters.a=r=>r==null?"undefined":r.toString();Xe.formatters.e=r=>r==null?"undefined":Gc(r.stack)??Gc(r.message)??r.toString();function iE(r){const e=()=>{};return e.enabled=!1,e.color="",e.diff=0,e.log=()=>{},e.namespace=r,e.destroy=()=>!0,e.extend=()=>e,e}function ch(){return{forComponent(r){return oE(r)}}}function oE(r){let e=iE(`${r}:trace`);return Xe.enabled(`${r}:trace`)&&Xe.names.map(t=>t.toString()).find(t=>t.includes(":trace"))!=null&&(e=Xe(`${r}:trace`)),Object.assign(Xe(r),{error:Xe(`${r}:error`),trace:e})}function Gc(r){if(r!=null&&(r=r.trim(),r.length!==0))return r}function aE(r){return r[Symbol.asyncIterator]!=null}function yo(r){if(aE(r))return(async()=>{const t=[];for await(const n of r)t.push(n);return t})();const e=[];for(const t of r)e.push(t);return e}let lh=class extends Error{static name="AbortError";name="AbortError";constructor(e="The operation was aborted",...t){super(e,...t)}};const Ft={},Jt=r=>{r.addEventListener("message",e=>{Jt.dispatchEvent("message",r,e)}),r.port!=null&&r.port.addEventListener("message",e=>{Jt.dispatchEvent("message",r,e)})};Jt.addEventListener=(r,e)=>{Ft[r]==null&&(Ft[r]=[]),Ft[r].push(e)};Jt.removeEventListener=(r,e)=>{Ft[r]!=null&&(Ft[r]=Ft[r].filter(t=>t===e))};Jt.dispatchEvent=function(r,e,t){Ft[r]!=null&&Ft[r].forEach(n=>n(e,t))};const Yc="lock:worker:request-read",Xc="lock:worker:abort-read-request",Qc="lock:worker:release-read",jc="lock:master:grant-read",Zc="lock:worker:request-write",Jc="lock:worker:abort-write-request",el="lock:worker:release-write",tl="lock:master:grant-write",cE=(r=10)=>Math.random().toString().substring(2,r+2),rl=(r,e,t,n,s,i,o)=>(a,c)=>{if(c.data==null)return;const l={type:c.data.type,name:c.data.name,identifier:c.data.identifier};c.data.type===n&&r.dispatchEvent(new MessageEvent(e,{data:{name:l.name,handler:async()=>{a.postMessage({type:o,name:l.name,identifier:l.identifier}),await new Promise(u=>{const d=h=>{if(h?.data==null)return;const p={type:h.data.type,name:h.data.name,identifier:h.data.identifier};p.type===i&&p.identifier===l.identifier&&(a.removeEventListener("message",d),u())};a.addEventListener("message",d)})}}})),l.type===s&&(a.postMessage({type:s,name:l.name,identifier:l.identifier}),r.dispatchEvent(new MessageEvent(t,{data:{name:l.name}})))},nl=(r,e,t,n,s)=>async i=>{i?.signal?.throwIfAborted();const o=cE();return globalThis.postMessage({type:e,identifier:o,name:r}),new Promise((a,c)=>{const l=()=>{process.send?.({type:t,identifier:o,name:r}),c(new lh)};i?.signal?.addEventListener("abort",l,{once:!0});const u=d=>{if(d?.data==null)return;const h={type:d.data.type,identifier:d.data.identifier};h.type===n&&h.identifier===o&&(globalThis.removeEventListener("message",u),i?.signal?.removeEventListener("abort",l),a(()=>{globalThis.postMessage({type:s,identifier:o,name:r})}))};globalThis.addEventListener("message",u)})},lE={singleProcess:!1},uE=r=>{if(r=Object.assign({},lE,r),!!globalThis.document||r.singleProcess){const t=new EventTarget;return Jt.addEventListener("message",rl(t,"requestReadLock","abortReadLockRequest",Yc,Xc,Qc,jc)),Jt.addEventListener("message",rl(t,"requestWriteLock","abortWriteLockRequest",Zc,Jc,el,tl)),t}return{isWorker:!0,readLock:t=>nl(t,Yc,Xc,jc,Qc),writeLock:t=>nl(t,Zc,Jc,tl,el)}},Kt={};let je;async function Ei(r,e){let t,n;const s=new Promise((o,a)=>{t=o,n=a}),i=()=>{n(new lh)};return e?.signal?.addEventListener("abort",i,{once:!0}),r.add(async()=>{await new Promise(o=>{t(()=>{e?.signal?.removeEventListener("abort",i),o()})})},{signal:e?.signal}).catch(o=>{n(o)}),s}const dE=(r,e)=>{if(je.isWorker===!0)return{readLock:je.readLock(r,e),writeLock:je.writeLock(r,e)};const t=new mo({concurrency:1});let n;return{async readLock(s){if(n!=null)return Ei(n,s);n=new mo({concurrency:e.concurrency,autoStart:!1});const i=n,o=Ei(n,s);return t.add(async()=>{i.start(),await i.onIdle().then(()=>{n===i&&(n=null)})}),o},async writeLock(s){return n=null,Ei(t,s)}}},hE={name:"lock",concurrency:1/0,singleProcess:!1};function fE(r){const e=Object.assign({},hE,r);return je==null&&(je=uE(e),je.isWorker!==!0&&(je.addEventListener("requestReadLock",t=>{const n=t.data.name;if(Kt[n]==null)return;const s=new AbortController,i=o=>{o.data.name===n&&s.abort()};je.addEventListener("abortReadLockRequest",i),Kt[n].readLock({signal:s.signal}).then(async o=>t.data.handler().finally(()=>{o()})).finally(()=>{je.removeEventListener("abortReadLockRequest",i)})}),je.addEventListener("requestWriteLock",async t=>{const n=t.data.name;if(Kt[n]==null)return;const s=new AbortController,i=o=>{o.data.name===n&&s.abort()};je.addEventListener("abortWriteLockRequest",i),Kt[t.data.name].writeLock({signal:s.signal}).then(async o=>t.data.handler().finally(()=>{o()})).finally(()=>{je.removeEventListener("abortWriteLockRequest",i)})}))),Kt[e.name]==null&&(Kt[e.name]=dE(e.name,e)),Kt[e.name]}const pE=36e5,gE=216e5;var Ht;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=me((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&s.value.byteLength>0&&(i.uint32(18),i.bytes(s.value)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:"",value:se(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.key=s.string();break}case 2:{a.value=s.bytes();break}default:{s.skipType(l&7);break}}}return a})),n),t.encode=s=>ge(s,t.codec()),t.decode=(s,i)=>pe(s,t.codec(),i)})(r.Peer$metadataEntry||(r.Peer$metadataEntry={})),function(t){let n;t.codec=()=>(n==null&&(n=me((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&(i.uint32(18),Ps.codec().encode(s.value,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:""},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const l=s.uint32();switch(l>>>3){case 1:{a.key=s.string();break}case 2:{a.value=Ps.codec().decode(s,s.uint32(),{limits:o.limits?.value});break}default:{s.skipType(l&7);break}}}return a})),n),t.encode=s=>ge(s,t.codec()),t.decode=(s,i)=>pe(s,t.codec(),i)}(r.Peer$tagsEntry||(r.Peer$tagsEntry={}));let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.addresses!=null)for(const i of t.addresses)n.uint32(10),_s.codec().encode(i,n);if(t.protocols!=null)for(const i of t.protocols)n.uint32(18),n.string(i);if(t.publicKey!=null&&(n.uint32(34),n.bytes(t.publicKey)),t.peerRecordEnvelope!=null&&(n.uint32(42),n.bytes(t.peerRecordEnvelope)),t.metadata!=null&&t.metadata.size!==0)for(const[i,o]of t.metadata.entries())n.uint32(50),r.Peer$metadataEntry.codec().encode({key:i,value:o},n);if(t.tags!=null&&t.tags.size!==0)for(const[i,o]of t.tags.entries())n.uint32(58),r.Peer$tagsEntry.codec().encode({key:i,value:o},n);t.updated!=null&&(n.uint32(64),n.uint64Number(t.updated)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{if(s.limits?.addresses!=null&&i.addresses.length===s.limits.addresses)throw new Ct('Decode error - map field "addresses" had too many elements');i.addresses.push(_s.codec().decode(t,t.uint32(),{limits:s.limits?.addresses$}));break}case 2:{if(s.limits?.protocols!=null&&i.protocols.length===s.limits.protocols)throw new Ct('Decode error - map field "protocols" had too many elements');i.protocols.push(t.string());break}case 4:{i.publicKey=t.bytes();break}case 5:{i.peerRecordEnvelope=t.bytes();break}case 6:{if(s.limits?.metadata!=null&&i.metadata.size===s.limits.metadata)throw new Na('Decode error - map field "metadata" had too many elements');const c=r.Peer$metadataEntry.codec().decode(t,t.uint32());i.metadata.set(c.key,c.value);break}case 7:{if(s.limits?.tags!=null&&i.tags.size===s.limits.tags)throw new Na('Decode error - map field "tags" had too many elements');const c=r.Peer$tagsEntry.codec().decode(t,t.uint32(),{limits:{value:s.limits?.tags$value}});i.tags.set(c.key,c.value);break}case 8:{i.updated=t.uint64Number();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(Ht||(Ht={}));var _s;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.multiaddr!=null&&t.multiaddr.byteLength>0&&(n.uint32(10),n.bytes(t.multiaddr)),t.isCertified!=null&&(n.uint32(16),n.bool(t.isCertified)),t.observed!=null&&(n.uint32(24),n.uint64Number(t.observed)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={multiaddr:se(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.multiaddr=t.bytes();break}case 2:{i.isCertified=t.bool();break}case 3:{i.observed=t.uint64Number();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(_s||(_s={}));var Ps;(function(r){let e;r.codec=()=>(e==null&&(e=me((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.value!=null&&t.value!==0&&(n.uint32(8),n.uint32(t.value)),t.expiry!=null&&(n.uint32(16),n.uint64(t.expiry)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={value:0},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.value=t.uint32();break}case 2:{i.expiry=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>ge(t,r.codec()),r.decode=(t,n)=>pe(t,r.codec(),n)})(Ps||(Ps={}));function mE(r,e){if(r.publicKey!=null||e.publicKey==null)return r;let t;if(r.type==="RSA"){const s=ye.decode(`z${r}`);t=er(s)}const n=Bt(e.publicKey,t);return tn(n)}function wo(r,e,t){const n=Ht.decode(e);return bo(r,n,t)}function bo(r,e,t){const n=new Map,s=BigInt(Date.now());for(const[i,o]of e.tags.entries())o.expiry!=null&&o.expiry<s||n.set(i,o);return{...e,id:mE(r,e),addresses:e.addresses.filter(({observed:i})=>i!=null&&i>Date.now()-t).map(({multiaddr:i,isCertified:o})=>({multiaddr:Q(i),isCertified:o??!1})),metadata:e.metadata,peerRecordEnvelope:e.peerRecordEnvelope??void 0,tags:n}}function yE(r,e){return wE(r.addresses,e.addresses)&&bE(r.protocols,e.protocols)&&vE(r.publicKey,e.publicKey)&&EE(r.peerRecordEnvelope,e.peerRecordEnvelope)&&SE(r.metadata,e.metadata)&&xE(r.tags,e.tags)}function wE(r,e){return dh(r,e,(t,n)=>!(t.isCertified!==n.isCertified||!Oe(t.multiaddr,n.multiaddr)))}function bE(r,e){return dh(r,e,(t,n)=>t===n)}function vE(r,e){return uh(r,e)}function EE(r,e){return uh(r,e)}function SE(r,e){return hh(r,e,(t,n)=>Oe(t,n))}function xE(r,e){return hh(r,e,(t,n)=>t.value===n.value&&t.expiry===n.expiry)}function uh(r,e){return r==null&&e==null?!0:r!=null&&e!=null?Oe(r,e):!1}function dh(r,e,t){if(r.length!==e.length)return!1;for(let n=0;n<r.length;n++)if(!t(r[n],e[n]))return!1;return!0}function hh(r,e,t){if(r.size!==e.size)return!1;for(const[n,s]of r.entries()){const i=e.get(n);if(i==null||!t(s,i))return!1}return!0}const fh="/peers/";function zn(r){if(!Dl(r)||r.type==null)throw new V("Invalid PeerId");const e=r.toCID().toString();return new Ue(`${fh}${e}`)}async function AE(r,e,t,n){const s=new Map;for(const i of t){if(i==null)continue;if(i.multiaddr instanceof Uint8Array&&(i.multiaddr=Q(i.multiaddr)),!Bs(i.multiaddr))throw new V("Multiaddr was invalid");if(!await e(r,i.multiaddr))continue;const o=i.isCertified??!1,a=i.multiaddr.toString(),c=s.get(a);c!=null?i.isCertified=c.isCertified||o:s.set(a,{multiaddr:i.multiaddr,isCertified:o})}return[...s.values()].sort((i,o)=>i.multiaddr.toString().localeCompare(o.multiaddr.toString())).map(({isCertified:i,multiaddr:o})=>{const a=o.getPeerId();return r.equals(a)&&(o=o.decapsulate(Q(`/p2p/${r}`))),{isCertified:i,multiaddr:o.bytes}})}async function Si(r,e,t,n){if(e==null)throw new V("Invalid PeerData");if(e.publicKey!=null&&r.publicKey!=null&&!e.publicKey.equals(r.publicKey))throw new V("publicKey bytes do not match peer id publicKey bytes");const s=n.existingPeer?.peer;if(s!=null&&!r.equals(s.id))throw new V("peer id did not match existing peer id");let i=s?.addresses??[],o=new Set(s?.protocols??[]),a=s?.metadata??new Map,c=s?.tags??new Map,l=s?.peerRecordEnvelope;if(t==="patch"){if((e.multiaddrs!=null||e.addresses!=null)&&(i=[],e.multiaddrs!=null&&i.push(...e.multiaddrs.map(h=>({isCertified:!1,multiaddr:h}))),e.addresses!=null&&i.push(...e.addresses)),e.protocols!=null&&(o=new Set(e.protocols)),e.metadata!=null){const h=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);a=Kn(h,{validate:sl})}if(e.tags!=null){const h=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags);c=Kn(h,{validate:il,map:ol})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}if(t==="merge"){if(e.multiaddrs!=null&&i.push(...e.multiaddrs.map(h=>({isCertified:!1,multiaddr:h}))),e.addresses!=null&&i.push(...e.addresses),e.protocols!=null&&(o=new Set([...o,...e.protocols])),e.metadata!=null){const h=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);for(const[p,f]of h)f==null?a.delete(p):a.set(p,f);a=Kn([...a.entries()],{validate:sl})}if(e.tags!=null){const h=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags),p=new Map(c);for(const[f,g]of h)g==null?p.delete(f):p.set(f,g);c=Kn([...p.entries()],{validate:il,map:ol})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}let u;s?.id.publicKey!=null?u=xt(s.id.publicKey):e.publicKey!=null?u=xt(e.publicKey):r.publicKey!=null&&(u=xt(r.publicKey));const d={addresses:await AE(r,n.addressFilter??(async()=>!0),i,n.existingPeer?.peerPB.addresses),protocols:[...o.values()].sort((h,p)=>h.localeCompare(p)),metadata:a,tags:c,publicKey:u,peerRecordEnvelope:l};return d.addresses.forEach(h=>{h.observed=n.existingPeer?.peerPB.addresses?.find(p=>Oe(p.multiaddr,p.multiaddr))?.observed??Date.now()}),r.type!=="RSA"&&delete d.publicKey,d}function Kn(r,e){const t=new Map;for(const[n,s]of r)s!=null&&e.validate(n,s);for(const[n,s]of r.sort(([i],[o])=>i.localeCompare(o)))s!=null&&t.set(n,e.map?.(n,s)??s);return t}function sl(r,e){if(typeof r!="string")throw new V("Metadata key must be a string");if(!(e instanceof Uint8Array))throw new V("Metadata value must be a Uint8Array")}function il(r,e){if(typeof r!="string")throw new V("Tag name must be a string");if(e.value!=null){if(parseInt(`${e.value}`,10)!==e.value)throw new V("Tag value must be an integer");if(e.value<0||e.value>100)throw new V("Tag value must be between 0-100")}if(e.ttl!=null){if(parseInt(`${e.ttl}`,10)!==e.ttl)throw new V("Tag ttl must be an integer");if(e.ttl<0)throw new V("Tag ttl must be between greater than 0")}}function ol(r,e){let t;return e.expiry!=null&&(t=e.expiry),e.ttl!=null&&(t=BigInt(Date.now()+Number(e.ttl))),{value:e.value??0,expiry:t}}function ph(r){const e=r.toString().split("/")[2],t=ae.parse(e,St);return vn(t)}function xi(r,e,t){const n=ph(r);return wo(n,e,t)}function CE(r,e){return{prefix:fh,filters:(r.filters??[]).map(t=>({key:n,value:s})=>t(xi(n,s,e))),orders:(r.orders??[]).map(t=>(n,s)=>t(xi(n.key,n.value,e),xi(s.key,s.value,e)))}}class IE{peerId;datastore;lock;addressFilter;log;maxAddressAge;maxPeerAge;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.lock=fE({name:"peer-store",singleProcess:!0}),this.maxAddressAge=t.maxAddressAge??pE,this.maxPeerAge=t.maxPeerAge??gE}async has(e){try{return await this.load(e),!0}catch(t){if(t.name!=="NotFoundError")throw t}return!1}async delete(e){this.peerId.equals(e)||await this.datastore.delete(zn(e))}async load(e){const t=zn(e),n=await this.datastore.get(t),s=Ht.decode(n);if(this.#r(e,s))throw await this.datastore.delete(t),new Bi;return bo(e,s,this.peerId.equals(e)?1/0:this.maxAddressAge)}async save(e,t){const n=await this.#e(e),s=await Si(e,t,"patch",{addressFilter:this.addressFilter});return this.#t(e,s,n)}async patch(e,t){const n=await this.#e(e),s=await Si(e,t,"patch",{addressFilter:this.addressFilter,existingPeer:n});return this.#t(e,s,n)}async merge(e,t){const n=await this.#e(e),s=await Si(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:n});return this.#t(e,s,n)}async*all(e){for await(const{key:t,value:n}of this.datastore.query(CE(e??{},this.maxAddressAge))){const s=ph(t);if(s.equals(this.peerId))continue;const i=Ht.decode(n);if(this.#r(s,i)){await this.datastore.delete(t);continue}yield bo(s,i,this.peerId.equals(s)?1/0:this.maxAddressAge)}}async#e(e){try{const t=zn(e),n=await this.datastore.get(t),s=Ht.decode(n);if(this.#r(e,s))throw await this.datastore.delete(t),new Bi;return{peerPB:s,peer:wo(e,n,this.maxAddressAge)}}catch(t){t.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",t)}}async#t(e,t,n){t.updated=Date.now();const s=Ht.encode(t);return await this.datastore.put(zn(e),s),{peer:wo(e,s,this.maxAddressAge),previous:n?.peer,updated:n==null||!yE(t,n.peerPB)}}#r(e,t){if(t.updated==null)return!0;if(this.peerId.equals(e))return!1;const n=t.updated<Date.now()-this.maxPeerAge,s=Date.now()-this.maxAddressAge,i=t.addresses.filter(o=>o.observed!=null&&o.observed>s);return n&&i.length===0}}class TE{store;events;peerId;log;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new IE(e,t)}[Symbol.toStringTag]="@libp2p/peer-store";async forEach(e,t){this.log.trace("forEach await read lock");const n=await this.store.lock.readLock();this.log.trace("forEach got read lock");try{for await(const s of this.store.all(t))e(s)}finally{this.log.trace("forEach release read lock"),n()}}async all(e){this.log.trace("all await read lock");const t=await this.store.lock.readLock();this.log.trace("all got read lock");try{return await yo(this.store.all(e))}finally{this.log.trace("all release read lock"),t()}}async delete(e){this.log.trace("delete await write lock");const t=await this.store.lock.writeLock();this.log.trace("delete got write lock");try{await this.store.delete(e)}finally{this.log.trace("delete release write lock"),t()}}async has(e){this.log.trace("has await read lock");const t=await this.store.lock.readLock();this.log.trace("has got read lock");try{return await this.store.has(e)}finally{this.log.trace("has release read lock"),t()}}async get(e){this.log.trace("get await read lock");const t=await this.store.lock.readLock();this.log.trace("get got read lock");try{return await this.store.load(e)}finally{this.log.trace("get release read lock"),t()}}async getInfo(e){const t=await this.get(e);return{id:t.id,multiaddrs:t.addresses.map(({multiaddr:n})=>n)}}async save(e,t){this.log.trace("save await write lock");const n=await this.store.lock.writeLock();this.log.trace("save got write lock");try{const s=await this.store.save(e,t);return this.#e(e,s),s.peer}finally{this.log.trace("save release write lock"),n()}}async patch(e,t){this.log.trace("patch await write lock");const n=await this.store.lock.writeLock();this.log.trace("patch got write lock");try{const s=await this.store.patch(e,t);return this.#e(e,s),s.peer}finally{this.log.trace("patch release write lock"),n()}}async merge(e,t){this.log.trace("merge await write lock");const n=await this.store.lock.writeLock();this.log.trace("merge got write lock");try{const s=await this.store.merge(e,t);return this.#e(e,s),s.peer}finally{this.log.trace("merge release write lock"),n()}}async consumePeerRecord(e,t){const n=await ht.openAndCertify(e,Qe.DOMAIN),s=vn(n.publicKey.toCID());if(t?.equals(s)===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",t,s),!1;const i=Qe.createFromProtobuf(n.payload);let o;try{o=await this.get(s)}catch(a){if(a.name!=="NotFoundError")throw a}if(o?.peerRecordEnvelope!=null){const a=await ht.createFromProtobuf(o.peerRecordEnvelope),c=Qe.createFromProtobuf(a.payload);if(c.seqNumber>=i.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",c.seqNumber,i.seqNumber),!1}return await this.patch(i.peerId,{peerRecordEnvelope:e,addresses:i.multiaddrs.map(a=>({isCertified:!0,multiaddr:a}))}),!0}#e(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))}}function kE(r,e={}){return new TE(r,e)}class Ls extends Error{static name="NotFoundError";static code="ERR_NOT_FOUND";name=Ls.name;code=Ls.code;constructor(e="Not Found"){super(e)}}function _E(r){return r[Symbol.asyncIterator]!=null}function cr(r,e){let t=0;if(_E(r))return async function*(){for await(const c of r)await e(c,t++)&&(yield c)}();const n=id(r),{value:s,done:i}=n.next();if(i===!0)return function*(){}();const o=e(s,t++);if(typeof o.then=="function")return async function*(){await o&&(yield s);for await(const c of n)await e(c,t++)&&(yield c)}();const a=e;return function*(){o===!0&&(yield s);for(const c of n)a(c,t++)&&(yield c)}()}function PE(r){return r[Symbol.asyncIterator]!=null}function al(r,e){return PE(r)?async function*(){yield*(await yo(r)).sort(e)}():function*(){yield*yo(r).sort(e)}()}function LE(r){return r[Symbol.asyncIterator]!=null}function cl(r,e){return LE(r)?async function*(){let t=0;if(!(e<1)){for await(const n of r)if(yield n,t++,t===e)return}}():function*(){let t=0;if(!(e<1)){for(const n of r)if(yield n,t++,t===e)return}}()}class DE{put(e,t,n){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:n,value:s}of e)await this.put(n,s,t),yield n}async*getMany(e,t={}){for await(const n of e)yield{key:n,value:await this.get(n,t)}}async*deleteMany(e,t={}){for await(const n of e)await this.delete(n,t),yield n}batch(){let e=[],t=[];return{put(n,s){e.push({key:n,value:s})},delete(n){t.push(n)},commit:async n=>{await ho(this.putMany(e,n)),e=[],await ho(this.deleteMany(t,n)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let n=this._all(e,t);if(e.prefix!=null){const s=e.prefix;n=cr(n,i=>i.key.toString().startsWith(s))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((s,i)=>cr(s,i),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((s,i)=>al(s,i),n)),e.offset!=null){let s=0;const i=e.offset;n=cr(n,()=>s++>=i)}return e.limit!=null&&(n=cl(n,e.limit)),n}queryKeys(e,t){let n=this._allKeys(e,t);if(e.prefix!=null){const s=e.prefix;n=cr(n,i=>i.toString().startsWith(s))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((s,i)=>cr(s,i),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((s,i)=>al(s,i),n)),e.offset!=null){const s=e.offset;let i=0;n=cr(n,()=>i++>=s)}return e.limit!=null&&(n=cl(n,e.limit)),n}}class RE extends DE{data;constructor(){super(),this.data=new Map}put(e,t,n){return n?.signal?.throwIfAborted(),this.data.set(e.toString(),t),e}get(e,t){t?.signal?.throwIfAborted();const n=this.data.get(e.toString());if(n==null)throw new Ls;return n}has(e,t){return t?.signal?.throwIfAborted(),this.data.has(e.toString())}delete(e,t){t?.signal?.throwIfAborted(),this.data.delete(e.toString())}*_all(e,t){t?.signal?.throwIfAborted();for(const[n,s]of this.data.entries())yield{key:new Ue(n),value:s},t?.signal?.throwIfAborted()}*_allKeys(e,t){t?.signal?.throwIfAborted();for(const n of this.data.keys())yield new Ue(n),t?.signal?.throwIfAborted()}}const ll=864e13,ME=448,Ai=449,OE=53,NE=54,FE=55,UE=56;class BE{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=new Map}has(e){const t=this.findHost(e);for(const n of this.mappings.values())if(n.domain===t)return!0;return!1}add(e,t){t.forEach(n=>{this.log("add DNS mapping %s to %s",n,e);const s=Vs(n)===!0;this.mappings.set(n,{domain:e,verified:s,expires:s?ll-Date.now():0,lastVerified:s?ll-Date.now():void 0})})}remove(e){const t=this.findHost(e);let n=!1;for(const[s,i]of this.mappings.entries())i.domain===t&&(this.log("removing %s to %s DNS mapping %e",s,i.domain,new Error("where")),this.mappings.delete(s),n=n||i.verified);return n}getAll(e){const t=[];for(let n=0;n<e.length;n++){const i=e[n].multiaddr.stringTuples(),o=i[0][1];if(o!=null)for(const[a,c]of this.mappings.entries()){if(o!==a)continue;this.maybeAddSNITuple(i,c.domain)&&(e.splice(n,1),n--,t.push({multiaddr:Q(`/${i.map(u=>[G(u[0]).name,u[1]].join("/")).join("/")}`),verified:c.verified,type:"dns-mapping",expires:c.expires,lastVerified:c.lastVerified}))}}return t}maybeAddSNITuple(e,t){for(let n=0;n<e.length;n++)if(e[n][0]===ME&&e[n+1]?.[0]!==Ai)return e.splice(n+1,0,[Ai,t]),!0;return!1}confirm(e,t){const n=this.findHost(e);let s=!1;for(const[i,o]of this.mappings.entries())o.domain===n&&(this.log("marking %s to %s DNS mapping as verified",i,o.domain),s=o.verified,o.verified=!0,o.expires=Date.now()+t,o.lastVerified=Date.now());return s}unconfirm(e,t){const n=this.findHost(e);let s=!1;for(const[i,o]of this.mappings.entries())o.domain===n&&(this.log("removing verification of %s to %s DNS mapping",i,o.domain),s=s||o.verified,o.verified=!1,o.expires=Date.now()+t);return s}findHost(e){for(const t of e.stringTuples())if(t[0]===Ai||t[0]===OE||t[0]===NE||t[0]===FE||t[0]===UE)return t[1]}}const Ci=4,Ii=41,Ti=6,$E=273;class zE{log;mappings;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=new Map}has(e){const t=e.stringTuples();for(const n of this.mappings.values())for(const s of n)if(s.externalIp===t[0][1])return!0;return!1}add(e,t,n,s=t,i="tcp"){const o=`${e}-${t}-${i}`,a=this.mappings.get(o)??[],c={internalIp:e,internalPort:t,externalIp:n,externalPort:s,externalFamily:Sr(n)?4:6,protocol:i,verified:!1,expires:0};a.push(c),this.mappings.set(o,a)}remove(e){const t=e.stringTuples(),n=t[0][1]??"",s=t[1][0]===Ti?"tcp":"udp",i=parseInt(t[1][1]??"0");let o=!1;for(const[a,c]of this.mappings.entries()){for(let l=0;l<c.length;l++){const u=c[l];u.externalIp===n&&u.externalPort===i&&u.protocol===s&&(this.log("removing %s:%s to %s:%s %s IP mapping",u.externalIp,u.externalPort,n,i,s),o=o||u.verified,c.splice(l,1),l--)}c.length===0&&this.mappings.delete(a)}return o}getAll(e){const t=[];for(const{multiaddr:n}of e){const s=n.stringTuples();let i;if((s[0][0]===Ci||s[0][0]===Ii)&&s[1][0]===Ti?i=`${s[0][1]}-${s[1][1]}-tcp`:(s[0][0]===Ci||s[0][0]===Ii)&&s[1][0]===$E&&(i=`${s[0][1]}-${s[1][1]}-udp`),i==null)continue;const o=this.mappings.get(i);if(o!=null)for(const a of o)s[0][0]=a.externalFamily===4?Ci:Ii,s[0][1]=a.externalIp,s[1][1]=`${a.externalPort}`,t.push({multiaddr:Q(`/${s.map(c=>[G(c[0]).name,c[1]].join("/")).join("/")}`),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return t}confirm(e,t){const s=e.stringTuples()[0][1];let i=!1;for(const o of this.mappings.values())for(const a of o)a.externalIp===s&&(this.log("marking %s to %s IP mapping as verified",a.internalIp,a.externalIp),i=a.verified,a.verified=!0,a.expires=Date.now()+t,a.lastVerified=Date.now());return i}unconfirm(e,t){const n=e.stringTuples(),s=n[0][1]??"",i=n[1][0]===Ti?"tcp":"udp",o=parseInt(n[1][1]??"0");let a=!1;for(const c of this.mappings.values())for(let l=0;l<c.length;l++){const u=c[l];u.externalIp===s&&u.externalPort===o&&u.protocol===i&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",u.externalIp,u.externalPort,s,o,i),a=a||u.verified,u.verified=!1,u.expires=Date.now()+t)}return a}}const KE=4,qE=41;function WE(r){try{const[[e,t]]=r.stringTuples();if(t==null)return!1;if(e===KE)return t.startsWith("169.254.");if(e===qE)return t.toLowerCase().startsWith("fe80")}catch{}return!1}const VE={maxObservedAddresses:10};class HE{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=new Map,this.maxObservedAddresses=t.maxObservedAddresses??VE.maxObservedAddresses}has(e){return this.addresses.has(e.toString())}removePrefixed(e){for(const t of this.addresses.keys())t.toString().startsWith(e)&&this.addresses.delete(t)}add(e){this.addresses.size!==this.maxObservedAddresses&&(dn(e)||WE(e)||(this.log("adding observed address %a",e),this.addresses.set(e.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([e,t])=>({multiaddr:Q(e),verified:t.verified,type:"observed",expires:t.expires,lastVerified:t.lastVerified}))}remove(e){const t=this.addresses.get(e.toString())?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(e.toString()),t}confirm(e,t){const n=e.toString(),s=this.addresses.get(n)??{verified:!1,expires:Date.now()+t,lastVerified:Date.now()},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.log("marking observed address %a as verified",n),this.addresses.set(n,s),i}}const GE=4,YE=41,XE=53,QE=54,jE=55,ZE=56,JE=[GE,YE,XE,QE,jE,ZE];function ul(r){try{const[[e]]=r.stringTuples();return JE.includes(e)}catch{}return!1}const e1={maxObservedAddresses:10};class t1{log;addresses;maxObservedAddresses;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=new Map,this.maxObservedAddresses=t.maxObservedAddresses??e1.maxObservedAddresses}get(e,t){if(dn(e))return{multiaddr:e,verified:!0,type:"transport",expires:Date.now()+t,lastVerified:Date.now()};const n=this.toKey(e);let s=this.addresses.get(n);return s==null&&(s={verified:!ul(e),expires:0},this.addresses.set(n,s)),{multiaddr:e,verified:s.verified,type:"transport",expires:s.expires,lastVerified:s.lastVerified}}has(e){const t=this.toKey(e);return this.addresses.has(t)}remove(e){const t=this.toKey(e),n=this.addresses.get(t)?.verified??!1;return this.log("removing observed address %a",e),this.addresses.delete(t),n}confirm(e,t){const n=this.toKey(e),s=this.addresses.get(n)??{verified:!1,expires:0,lastVerified:0},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.addresses.set(n,s),i}unconfirm(e,t){const n=this.toKey(e),s=this.addresses.get(n)??{verified:!1,expires:0},i=s.verified;return s.verified=!1,s.expires=Date.now()+t,this.addresses.set(n,s),i}toKey(e){if(ul(e)){const t=e.toOptions();return`${t.host}-${t.port}-${t.transport}`}return e.toString()}}const dl=6e4,hl={addressVerificationTTL:dl*10,addressVerificationRetry:dl*5},r1=r=>r;function ki(r,e){const t=r.getPeerId();return t!=null&&pt(t).equals(e)&&(r=r.decapsulate(Q(`/p2p/${e.toString()}`))),r}class n1{log;components;listen;announce;appendAnnounce;announceFilter;observed;dnsMappings;ipMappings;transportAddresses;observedAddressFilter;addressVerificationTTL;addressVerificationRetry;constructor(e,t={}){const{listen:n=[],announce:s=[],appendAnnounce:i=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=n.map(o=>o.toString()),this.announce=new Set(s.map(o=>o.toString())),this.appendAnnounce=new Set(i.map(o=>o.toString())),this.observed=new HE(e,t),this.dnsMappings=new BE(e,t),this.ipMappings=new zE(e,t),this.transportAddresses=new t1(e,t),this.announceFilter=t.announceFilter??r1,this.observedAddressFilter=un(1024),this.addressVerificationTTL=t.addressVerificationTTL??hl.addressVerificationTTL,this.addressVerificationRetry=t.addressVerificationRetry??hl.addressVerificationRetry,this._updatePeerStoreAddresses=uo(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),e.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}[Symbol.toStringTag]="@libp2p/address-manager";_updatePeerStoreAddresses(){const e=this.getAddresses().map(t=>t.getPeerId()===this.components.peerId.toString()?t.decapsulate(`/p2p/${this.components.peerId.toString()}`):t);this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch(t=>{this.log.error("error updating addresses",t)})}getListenAddrs(){return Array.from(this.listen).map(e=>Q(e))}getAnnounceAddrs(){return Array.from(this.announce).map(e=>Q(e))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(e=>Q(e))}getObservedAddrs(){return this.observed.getAll().map(e=>e.multiaddr)}addObservedAddr(e){const t=e.stringTuples(),n=`${t[0][1]}:${t[1][1]}`;this.observedAddressFilter.has(n)||(this.observedAddressFilter.add(n),e=ki(e,this.components.peerId),!this.ipMappings.has(e)&&(this.dnsMappings.has(e)||this.observed.add(e)))}confirmObservedAddr(e,t){e=ki(e,this.components.peerId);let n=!0;(t?.type==="transport"||this.transportAddresses.has(e))&&!this.transportAddresses.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="dns-mapping"||this.dnsMappings.has(e))&&!this.dnsMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="ip-mapping"||this.ipMappings.has(e))&&!this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1),(t?.type==="observed"||this.observed.has(e))&&(this.maybeUpgradeToIPMapping(e)?(this.ipMappings.confirm(e,t?.ttl??this.addressVerificationTTL),n=!1):!this.observed.confirm(e,t?.ttl??this.addressVerificationTTL)&&n&&(n=!1)),n||this._updatePeerStoreAddresses()}removeObservedAddr(e,t){e=ki(e,this.components.peerId),this.observed.has(e)&&this.observed.remove(e),this.transportAddresses.has(e)&&this.transportAddresses.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.dnsMappings.has(e)&&this.dnsMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry),this.ipMappings.has(e)&&this.ipMappings.unconfirm(e,t?.ttl??this.addressVerificationRetry)}getAddresses(){const e=new Set,t=this.getAddressesWithMetadata().filter(n=>{if(!n.verified)return!1;const s=n.multiaddr.toString();return e.has(s)?!1:(e.add(s),!0)}).map(n=>n.multiaddr);return this.announceFilter(t.map(n=>{const s=Q(n);return s.protos().pop()?.path===!0||s.getPeerId()===this.components.peerId.toString()?s:s.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const e=this.getAnnounceAddrs();if(e.length>0)return this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(e)}),e.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let t=[];t=t.concat(this.components.transportManager.getAddrs().map(s=>this.transportAddresses.get(s,this.addressVerificationTTL)));const n=this.getAppendAnnounceAddrs();return n.length>0&&(this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(n)}),t=t.concat(n.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),t=t.concat(this.observed.getAll()),t=t.concat(this.ipMappings.getAll(t)),t=t.concat(this.dnsMappings.getAll(t)),t}addDNSMapping(e,t){this.dnsMappings.add(e,t)}removeDNSMapping(e){this.dnsMappings.remove(Q(`/dns/${e}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(e,t,n,s=t,i="tcp"){this.ipMappings.add(e,t,n,s,i),this.observed.removePrefixed(`/ip${Sr(n)?4:6}/${n}/${i}/${s}`)}removePublicAddressMapping(e,t,n,s=t,i="tcp"){this.ipMappings.remove(Q(`/ip${Sr(n)?4:6}/${n}/${i}/${s}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(e){if(this.ipMappings.has(e))return!1;const t=e.toOptions();if(t.family===6||t.host==="127.0.0.1"||Vs(t.host)===!0)return!1;const n=this.components.transportManager.getListeners(),s=[i=>cn.exactMatch(i)||As.exactMatch(i),i=>xs.exactMatch(i),i=>jw.exactMatch(i)];for(const i of s){if(!i(e))continue;const o=n.filter(l=>l.getAddrs().filter(u=>u.toOptions().family===4&&i(u)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(l=>l.toOptions().host!=="127.0.0.1").pop();if(a==null)continue;const c=a.toOptions();return this.observed.remove(e),this.ipMappings.add(c.host,c.port,t.host,t.port,t.transport),!0}return!1}}var fl;(function(r){r.NOT_STARTED_YET="The libp2p node is not started yet",r.NOT_FOUND="Not found"})(fl||(fl={}));class s1 extends Error{constructor(e="Missing service"){super(e),this.name="MissingServiceError"}}class i1 extends Error{constructor(e="Unmet service dependencies"){super(e),this.name="UnmetServiceDependenciesError"}}class _i extends Error{constructor(e="No content routers available"){super(e),this.name="NoContentRoutersError"}}class pl extends Error{constructor(e="No peer routers available"){super(e),this.name="NoPeerRoutersError"}}class o1 extends Error{constructor(e="Should not try to find self"){super(e),this.name="QueriedForSelfError"}}class a1 extends Error{constructor(e="Unhandled protocol error"){super(e),this.name="UnhandledProtocolError"}}class c1 extends Error{constructor(e="Duplicate protocol handler error"){super(e),this.name="DuplicateProtocolHandlerError"}}class gl extends Error{constructor(e="Dial denied error"){super(e),this.name="DialDeniedError"}}class l1 extends Error{constructor(e="No transport was configured to listen on this address"){super(e),this.name="UnsupportedListenAddressError"}}class u1 extends Error{constructor(e="Configured listen addresses could not be listened on"){super(e),this.name="UnsupportedListenAddressesError"}}class d1 extends Error{constructor(e="No valid addresses"){super(e),this.name="NoValidAddressesError"}}class h1 extends Error{constructor(e="Connection intercepted"){super(e),this.name="ConnectionInterceptedError"}}class f1 extends Error{constructor(e="Connection denied"){super(e),this.name="ConnectionDeniedError"}}class qn extends Error{constructor(e="Stream is not multiplexed"){super(e),this.name="MuxerUnavailableError"}}class Wn extends Error{constructor(e="Encryption failed"){super(e),this.name="EncryptionFailedError"}}class p1 extends Error{constructor(e="Transport unavailable"){super(e),this.name="TransportUnavailableError"}}class g1{components={};_started=!1;constructor(e={}){this.components={};for(const[t,n]of Object.entries(e))this.components[t]=n;this.components.logger==null&&(this.components.logger=ch())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter(t=>ko(t)).map(async t=>{await t[e]?.()}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const m1=["metrics","connectionProtector","dns"],y1=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function w1(r={}){const e=new g1(r);return new Proxy(e,{get(n,s,i){if(typeof s=="string"&&!y1.includes(s)){const o=e.components[s];if(o==null&&!m1.includes(s))throw new s1(`${s} not set`);return o}return Reflect.get(n,s,i)},set(n,s,i){return typeof s=="string"?e.components[s]=i:Reflect.set(n,s,i),!0}})}function b1(r){const e={};for(const t of Object.values(r.components))for(const n of v1(t))e[n]=!0;for(const t of Object.values(r.components))for(const n of E1(t))if(e[n]!==!0)throw new i1(`Service "${S1(t)}" required capability "${n}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function v1(r){return Array.isArray(r?.[it])?r[it]:[]}function E1(r){return Array.isArray(r?.[jn])?r[jn]:[]}function S1(r){return r?.[Symbol.toStringTag]??r?.toString()??"unknown"}const x1=4,A1=41;function C1(r={}){return{denyDialPeer:async()=>!1,denyDialMultiaddr:async e=>{if(cn.matches(e))return!1;const t=e.stringTuples();return t[0][0]===x1||t[0][0]===A1?!!Vs(`${t[0][1]}`):!1},denyInboundConnection:async()=>!1,denyOutboundConnection:async()=>!1,denyInboundEncryptedConnection:async()=>!1,denyOutboundEncryptedConnection:async()=>!1,denyInboundUpgradedConnection:async()=>!1,denyOutboundUpgradedConnection:async()=>!1,filterMultiaddrForPeer:async()=>!0,...r}}const ml=()=>{const r=new Error("Delay aborted");return r.name="AbortError",r},I1=new WeakMap;function T1({clearTimeout:r,setTimeout:e}={}){return(t,{value:n,signal:s}={})=>{if(s?.aborted)return Promise.reject(ml());let i,o,a;const c=r??clearTimeout,l=()=>{c(i),a(ml())},u=()=>{s&&s.removeEventListener("abort",l)},d=new Promise((h,p)=>{o=()=>{u(),h(n)},a=p,i=(e??setTimeout)(o,t)});return s&&s.addEventListener("abort",l,{once:!0}),I1.set(d,()=>{c(i),i=null,o()}),d}}const k1=T1();class _1{memoryStorage;points;duration;blockDuration;execEvenly;execEvenlyMinDelayMs;keyPrefix;constructor(e={}){this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.execEvenly=e.execEvenly??!1,this.execEvenlyMinDelayMs=e.execEvenlyMinDelayMs??this.duration*1e3/this.points,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new P1}async consume(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n);let o=this.memoryStorage.incrby(s,t,i);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+t&&(o=this.memoryStorage.set(s,o.consumedPoints,this.blockDuration)),new yb("Rate limit exceeded",o);if(this.execEvenly&&o.msBeforeNext>0&&!o.isFirstInDuration){let a=Math.ceil(o.msBeforeNext/(o.remainingPoints+2));a<this.execEvenlyMinDelayMs&&(a=o.consumedPoints*this.execEvenlyMinDelayMs),await k1(a)}return o}penalty(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,-t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(e,t){const n=t*1e3,s=this.points+1;return this.memoryStorage.set(this.getKey(e),s,t),{remainingPoints:0,msBeforeNext:n===0?-1:n,consumedPoints:s,isFirstInDuration:!1}}set(e,t,n=0){const s=(n>=0?n:this.duration)*1e3;return this.memoryStorage.set(this.getKey(e),t,n),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return t!=null&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return e?.customDuration!=null&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class P1{storage;constructor(){this.storage=new Map}incrby(e,t,n){const s=this.storage.get(e);if(s!=null){const i=s.expiresAt!=null?s.expiresAt.getTime()-new Date().getTime():-1;return s.expiresAt==null||i>0?(s.value+=t,{remainingPoints:0,msBeforeNext:i,consumedPoints:s.value,isFirstInDuration:!1}):this.set(e,t,n)}return this.set(e,t,n)}set(e,t,n){const s=n*1e3,i=this.storage.get(e);i!=null&&clearTimeout(i.timeoutId);const o={value:t,expiresAt:s>0?new Date(Date.now()+s):void 0};return this.storage.set(e,o),s>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(e)},s),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:o.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(t!=null)return{remainingPoints:0,msBeforeNext:t.expiresAt!=null?t.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}delete(e){const t=this.storage.get(e);return t!=null?(t.timeoutId!=null&&clearTimeout(t.timeoutId),this.storage.delete(e),!0):!1}}function gh(r){if(Dl(r))return{peerId:r,multiaddrs:[]};let e=Array.isArray(r)?r:[r],t;if(e.length>0){const n=e[0].getPeerId();t=n==null?void 0:pt(n),e.forEach(s=>{if(!Bs(s))throw new Ao("Invalid multiaddr");const i=s.getPeerId();if(i==null){if(t!=null)throw new V("Multiaddrs must all have the same peer id or have no peer id")}else{const o=pt(i);if(t?.equals(o)!==!0)throw new V("Multiaddrs must all have the same peer id or have no peer id")}})}return e=e.filter(n=>!Yw.exactMatch(n)),{peerId:t,multiaddrs:e}}const L1=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function D1(r,e){const t=r?.streams?.map(s=>s.protocol)??[],n=e?.closableProtocols??L1;if(!(t.filter(s=>s!=null&&!n.includes(s)).length>0))try{await r?.close(e)}catch(s){r?.abort(s)}}const mh=1e4,R1=1e4,yl=1e4,yh=25,M1=5,O1=10,N1=5,F1="last-dial-failure",U1="last-dial-success",wh=500,bh=100,vh=50;async function B1(r,e){let t=!1;for(const s of jo.keys())if(t=r.protoNames().includes(s),t)break;if(!t)return[r];const n=await r.resolve(e);return e.log("resolved %s to",r,n.map(s=>s.toString())),n}function vo(r){try{let e;if(typeof r=="string"?e=Q(r):e=r,!e.protoNames().includes("ipcidr")){const n=e.protoNames().includes("ip6")?"/ipcidr/128":"/ipcidr/32";e=e.encapsulate(n)}return Cw(e)}catch{throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${r}`)}}const $1={maxConnections:bh};class z1{maxConnections;connectionManager;peerStore;allow;events;log;constructor(e,t={}){this.maxConnections=t.maxConnections??$1.maxConnections,this.allow=(t.allow??[]).map(n=>vo(n)),this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(e=>{this.log.error("error while pruning connections %e",e)})}async _maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length;if(this.log("checking max connections limit %d/%d",t,this.maxConnections),t<=this.maxConnections)return;const n=new Ws;for(const a of e){const c=a.remotePeer;if(!n.has(c)){n.set(c,0);try{const l=await this.peerStore.get(c);n.set(c,[...l.tags.values()].reduce((u,d)=>u+d.value,0))}catch(l){l.name!=="NotFoundError"&&this.log.error("error loading peer tags",l)}}}const s=this.sortConnections(e,n),i=Math.max(t-this.maxConnections,0),o=[];for(const a of s)if(this.log("too many connections open - closing a connection to %p",a.remotePeer),this.allow.some(l=>l.contains(a.remoteAddr.nodeAddress().address))||o.push(a),o.length===i)break;await Promise.all(o.map(async a=>{await D1(a,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:o})}sortConnections(e,t){return e.sort((n,s)=>{const i=n.timeline.open,o=s.timeline.open;return i<o?1:i>o?-1:0}).sort((n,s)=>n.direction==="outbound"&&s.direction==="inbound"?1:n.direction==="inbound"&&s.direction==="outbound"?-1:0).sort((n,s)=>n.streams.length>s.streams.length?1:n.streams.length<s.streams.length?-1:0).sort((n,s)=>{const i=t.get(n.remotePeer)??0,o=t.get(s.remotePeer)??0;return i>o?1:i<o?-1:0})}}class K1 extends Od{constructor(e={}){super({...e,sort:(t,n)=>t.options.priority>n.options.priority?-1:t.options.priority<n.options.priority?1:0})}}function q1(r){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(r)||/^::1$/.test(r)}function wl(r){if(!Bd(r))return!1;const{address:e}=r.nodeAddress();return q1(e)}function W1(r,e){const t=xs.exactMatch(r.multiaddr),n=xs.exactMatch(e.multiaddr);if(t&&!n)return-1;if(!t&&n)return 1;const s=As.exactMatch(r.multiaddr),i=As.exactMatch(e.multiaddr);if(s&&!i)return-1;if(!s&&i)return 1;const o=cn.exactMatch(r.multiaddr),a=cn.exactMatch(e.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=lo.exactMatch(r.multiaddr),l=lo.exactMatch(e.multiaddr);if(c&&!l)return-1;if(!c&&l)return 1;const u=yc.exactMatch(r.multiaddr),d=yc.exactMatch(e.multiaddr);if(u&&!d)return-1;if(!u&&d)return 1;const h=wc.exactMatch(r.multiaddr),p=wc.exactMatch(e.multiaddr);return h&&!p?-1:!h&&p?1:0}function V1(r,e){const t=wl(r.multiaddr),n=wl(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function H1(r,e){const t=dn(r.multiaddr),n=dn(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function G1(r,e){return r.isCertified&&!e.isCertified?-1:!r.isCertified&&e.isCertified?1:0}function Y1(r,e){const t=ln.exactMatch(r.multiaddr),n=ln.exactMatch(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function X1(r){return r.sort(W1).sort(G1).sort(Y1).sort(H1).sort(V1)}const Vn={maxParallelDials:vh,maxDialQueueLength:wh,maxPeerAddrsToDial:yh,dialTimeout:mh};class Q1{queue;components;addressSorter;maxPeerAddrsToDial;maxDialQueueLength;dialTimeout;shutDownController;connections;log;constructor(e,t={}){this.addressSorter=t.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??Vn.maxPeerAddrsToDial,this.maxDialQueueLength=t.maxDialQueueLength??Vn.maxDialQueueLength,this.dialTimeout=t.dialTimeout??Vn.dialTimeout,this.connections=t.connections??new Ws,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.shutDownController=new AbortController,this.shutDownController.signal;for(const[n,s]of Object.entries(t.resolvers??{}))jo.set(n,s);this.queue=new K1({concurrency:t.maxParallelDials??Vn.maxParallelDials,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("error",n=>{n.detail?.name!==Qt.name&&this.log.error("error in dial queue - %e",n.detail)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){const{peerId:n,multiaddrs:s}=gh(e),i=Array.from(this.connections.values()).flat().find(a=>t.force===!0?!1:a.remotePeer.equals(n)?!0:s.find(c=>c.equals(a.remoteAddr)));if(i?.status==="open")return this.log("already connected to %a",i.remoteAddr),t.onProgress?.(new ie("dial-queue:already-connected")),i;const o=this.queue.queue.find(a=>{if(n?.equals(a.options.peerId)===!0)return!0;const c=a.options.multiaddrs;if(c==null)return!1;for(const l of s)if(c.has(l.toString()))return!0;return!1});if(o!=null){this.log("joining existing dial target for %p",n);for(const a of s)o.options.multiaddrs.add(a.toString());return t.onProgress?.(new ie("dial-queue:already-in-dial-queue")),o.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new Vr("Dial queue is full");return this.log("creating dial target for %p",n,s.map(a=>a.toString())),t.onProgress?.(new ie("dial-queue:add-to-dial-queue")),this.queue.add(async a=>{a.onProgress?.(new ie("dial-queue:start-dial"));const c=$t([this.shutDownController.signal,a.signal]);try{return await this.dialPeer(a,c)}finally{c.clear()}},{peerId:n,priority:t.priority??Eh,multiaddrs:new Set(s.map(a=>a.toString())),signal:t.signal??AbortSignal.timeout(this.dialTimeout),onProgress:t.onProgress})}async dialPeer(e,t){const n=e.peerId,s=e.multiaddrs,i=new Set;let o=e.multiaddrs.size===0,a=0,c=0;const l=[];for(this.log("starting dial to %p",n);o||s.size>0;){c++,o=!1;const u=[],d=new Set(e.multiaddrs);s.clear(),this.log("calculating addrs to dial %p from %s",n,[...d]);const h=await this.calculateMultiaddrs(n,d,{...e,signal:t});for(const p of h){if(i.has(p.multiaddr.toString())){this.log.trace("skipping previously failed multiaddr %a while dialing %p",p.multiaddr,n);continue}u.push(p)}this.log("%s dial to %p with %s",c===1?"starting":"continuing",n,u.map(p=>p.multiaddr.toString())),e?.onProgress?.(new ie("dial-queue:calculated-addresses",u));for(const p of u){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,e.peerId),new Vr("Peer had more than maxPeerAddrsToDial");a++;try{const f=await this.components.transportManager.dial(p.multiaddr,{...e,signal:t});this.log("dial to %a succeeded",p.multiaddr);try{await this.components.peerStore.merge(f.remotePeer,{multiaddrs:[f.remoteAddr],metadata:{[U1]:q(Date.now().toString())}})}catch(g){this.log.error("could not update last dial failure key for %p",n,g)}return f}catch(f){if(this.log.error("dial failed to %a",p.multiaddr,f),i.add(p.multiaddr.toString()),n!=null)try{await this.components.peerStore.merge(n,{metadata:{[F1]:q(Date.now().toString())}})}catch(g){this.log.error("could not update last dial failure key for %p",n,g)}if(t.aborted)throw new Io(f.message);l.push(f)}}}throw l.length===1?l[0]:new AggregateError(l,"All multiaddr dials failed")}async calculateMultiaddrs(e,t=new Set,n={}){const s=[...t].map(d=>({multiaddr:Q(d),isCertified:!1}));if(e!=null){if(this.components.peerId.equals(e))throw new Vr("Tried to dial self");if(await this.components.connectionGater.denyDialPeer?.(e)===!0)throw new gl("The dial request is blocked by gater.allowDialPeer");if(s.length===0){this.log("loading multiaddrs for %p",e);try{const d=await this.components.peerStore.get(e);s.push(...d.addresses),this.log("loaded multiaddrs for %p",e,s.map(({multiaddr:h})=>h.toString()))}catch(d){if(d.name!=="NotFoundError")throw d}}if(s.length===0){this.log("looking up multiaddrs for %p in the peer routing",e);try{const d=await this.components.peerRouting.findPeer(e,n);this.log("found multiaddrs for %p in the peer routing",e,s.map(({multiaddr:h})=>h.toString())),s.push(...d.multiaddrs.map(h=>({multiaddr:h,isCertified:!1})))}catch(d){d.name==="NoPeerRoutersError"?this.log("no peer routers configured",e):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",e,d)}}}let i=(await Promise.all(s.map(async d=>{const h=await B1(d.multiaddr,{dns:this.components.dns,...n,log:this.log});return h.length===1&&h[0].equals(d.multiaddr)?d:h.map(p=>({multiaddr:p,isCertified:!1}))}))).flat();if(e!=null){const d=`/p2p/${e.toString()}`;i=i.map(h=>h.multiaddr.protos().pop()?.path===!0?h:h.multiaddr.getPeerId()==null?{multiaddr:h.multiaddr.encapsulate(d),isCertified:h.isCertified}:h)}const o=i.filter(d=>{if(this.components.transportManager.dialTransportForMultiaddr(d.multiaddr)==null)return!1;const h=d.multiaddr.getPeerId();return e!=null&&h!=null?e.equals(h):!0}),a=new Map;for(const d of o){const h=d.multiaddr.toString(),p=a.get(h);if(p!=null){p.isCertified=p.isCertified||d.isCertified||!1;continue}a.set(h,d)}const c=[...a.values()];if(c.length===0)throw new d1("The dial request has no valid addresses");const l=[];for(const d of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(d.multiaddr)||l.push(d);const u=this.addressSorter==null?X1(l):l.sort(this.addressSorter);if(u.length===0)throw new gl("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",e??"unknown peer",i.map(({multiaddr:d})=>d.toString())),this.log.trace("addresses for %p after filtering",e??"unknown peer",u.map(({multiaddr:d})=>d.toString())),u}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const n=await this.calculateMultiaddrs(void 0,new Set(e.map(s=>s.toString())),t);return t.runOnLimitedConnection===!1?n.find(s=>!ln.matches(s.multiaddr))!=null:!0}catch(n){this.log.trace("error calculating if multiaddr(s) were dialable",n)}return!1}}var Pi={},Li,bl;function j1(){if(bl)return Li;bl=1;function r(e,t){typeof t=="boolean"&&(t={forever:t}),this._originalTimeouts=JSON.parse(JSON.stringify(e)),this._timeouts=e,this._options=t||{},this._maxRetryTime=t&&t.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}return Li=r,r.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},r.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},r.prototype.retry=function(e){if(this._timeout&&clearTimeout(this._timeout),!e)return!1;var t=new Date().getTime();if(e&&t-this._operationStart>=this._maxRetryTime)return this._errors.push(e),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(e);var n=this._timeouts.shift();if(n===void 0)if(this._cachedTimeouts)this._errors.splice(0,this._errors.length-1),n=this._cachedTimeouts.slice(-1);else return!1;var s=this;return this._timer=setTimeout(function(){s._attempts++,s._operationTimeoutCb&&(s._timeout=setTimeout(function(){s._operationTimeoutCb(s._attempts)},s._operationTimeout),s._options.unref&&s._timeout.unref()),s._fn(s._attempts)},n),this._options.unref&&this._timer.unref(),!0},r.prototype.attempt=function(e,t){this._fn=e,t&&(t.timeout&&(this._operationTimeout=t.timeout),t.cb&&(this._operationTimeoutCb=t.cb));var n=this;this._operationTimeoutCb&&(this._timeout=setTimeout(function(){n._operationTimeoutCb()},n._operationTimeout)),this._operationStart=new Date().getTime(),this._fn(this._attempts)},r.prototype.try=function(e){console.log("Using RetryOperation.try() is deprecated"),this.attempt(e)},r.prototype.start=function(e){console.log("Using RetryOperation.start() is deprecated"),this.attempt(e)},r.prototype.start=r.prototype.try,r.prototype.errors=function(){return this._errors},r.prototype.attempts=function(){return this._attempts},r.prototype.mainError=function(){if(this._errors.length===0)return null;for(var e={},t=null,n=0,s=0;s<this._errors.length;s++){var i=this._errors[s],o=i.message,a=(e[o]||0)+1;e[o]=a,a>=n&&(t=i,n=a)}return t},Li}var vl;function Z1(){return vl||(vl=1,function(r){var e=j1();r.operation=function(t){var n=r.timeouts(t);return new e(n,{forever:t&&(t.forever||t.retries===1/0),unref:t&&t.unref,maxRetryTime:t&&t.maxRetryTime})},r.timeouts=function(t){if(t instanceof Array)return[].concat(t);var n={retries:10,factor:2,minTimeout:1*1e3,maxTimeout:1/0,randomize:!1};for(var s in t)n[s]=t[s];if(n.minTimeout>n.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var i=[],o=0;o<n.retries;o++)i.push(this.createTimeout(o,n));return t&&t.forever&&!i.length&&i.push(this.createTimeout(o,n)),i.sort(function(a,c){return a-c}),i},r.createTimeout=function(t,n){var s=n.randomize?Math.random()+1:1,i=Math.round(s*Math.max(n.minTimeout,1)*Math.pow(n.factor,t));return i=Math.min(i,n.maxTimeout),i},r.wrap=function(t,n,s){if(n instanceof Array&&(s=n,n=null),!s){s=[];for(var i in t)typeof t[i]=="function"&&s.push(i)}for(var o=0;o<s.length;o++){var a=s[o],c=t[a];t[a]=function(u){var d=r.operation(n),h=Array.prototype.slice.call(arguments,1),p=h.pop();h.push(function(f){d.retry(f)||(f&&(arguments[0]=d.mainError()),p.apply(this,arguments))}),d.attempt(function(){u.apply(t,h)})}.bind(t,c),t[a].options=n}}}(Pi)),Pi}var Di,El;function J1(){return El||(El=1,Di=Z1()),Di}var eS=J1();const tS=ia(eS),rS=Object.prototype.toString,nS=r=>rS.call(r)==="[object Error]",sS=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Load failed","Network request failed","fetch failed","terminated"]);function iS(r){return r&&nS(r)&&r.name==="TypeError"&&typeof r.message=="string"?r.message==="Load failed"?r.stack===void 0:sS.has(r.message):!1}class oS extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,{message:e}=e):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}const Sl=(r,e,t)=>{const n=t.retries-(e-1);return r.attemptNumber=e,r.retriesLeft=n,r};async function aS(r,e){return new Promise((t,n)=>{e={...e},e.onFailedAttempt??=()=>{},e.shouldRetry??=()=>!0,e.retries??=10;const s=tS.operation(e),i=()=>{s.stop(),n(e.signal?.reason)};e.signal&&!e.signal.aborted&&e.signal.addEventListener("abort",i,{once:!0});const o=()=>{e.signal?.removeEventListener("abort",i),s.stop()};s.attempt(async a=>{try{const c=await r(a);o(),t(c)}catch(c){try{if(!(c instanceof Error))throw new TypeError(`Non-error was thrown: "${c}". You should only throw errors.`);if(c instanceof oS)throw c.originalError;if(c instanceof TypeError&&!iS(c))throw c;if(Sl(c,a,e),await e.shouldRetry(c)||(s.stop(),n(c)),await e.onFailedAttempt(c),!s.retry(c))throw s.mainError()}catch(l){Sl(l,a,e),o(),n(l)}}})})}class cS{log;queue;started;peerStore;retries;retryInterval;backoffFactor;connectionManager;events;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.queue=new sa({concurrency:t.maxParallelReconnects??N1,metricName:"libp2p_reconnect_queue",metrics:e.metrics}),this.started=!1,this.retries=t.retries??5,this.backoffFactor=t.backoffFactor,this.retryInterval=t.retryInterval,this.events=e.events,e.events.addEventListener("peer:disconnect",n=>{this.maybeReconnect(n.detail).catch(s=>{this.log.error("failed to maybe reconnect to %p - %e",n.detail,s)})})}async maybeReconnect(e){if(!this.started)return;const t=await this.peerStore.get(e);xl(t)&&(this.queue.has(e)||this.queue.add(async n=>{await aS(async s=>{if(this.started)try{await this.connectionManager.openConnection(e,{signal:n?.signal})}catch(i){throw this.log("reconnecting to %p attempt %d of %d failed - %e",e,s,this.retries,i),i}},{signal:n?.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:e}).catch(async n=>{this.log.error("failed to reconnect to %p - %e",e,n);const s={};[...t.tags.keys()].forEach(i=>{i.startsWith(So)&&(s[i]=void 0)}),await this.peerStore.merge(e,{tags:s}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:e})}).catch(async n=>{this.log.error("failed to remove keep-alive tag from %p - %e",e,n)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>xl(t)]});await Promise.all(e.map(async t=>{await this.connectionManager.openConnection(t.id).catch(n=>{this.log.error(n)})}))}).catch(e=>{this.log.error(e)})}stop(){this.started=!1,this.queue.abort()}}function xl(r){for(const e of r.tags.keys())if(e.startsWith(So))return!0;return!1}const Eh=50,Ri={maxConnections:bh,inboundConnectionThreshold:M1,maxIncomingPendingConnections:O1};class lS{started;connections;allow;deny;maxIncomingPendingConnections;incomingPendingConnections;outboundPendingConnections;maxConnections;dialQueue;reconnectQueue;connectionPruner;inboundConnectionRateLimiter;peerStore;metrics;events;log;peerId;constructor(e,t={}){if(this.maxConnections=t.maxConnections??Ri.maxConnections,this.maxConnections<1)throw new V("Connection Manager maxConnections must be greater than 0");this.connections=new Ws,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(t.allow??[]).map(n=>vo(n)),this.deny=(t.deny??[]).map(n=>vo(n)),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??Ri.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new _1({points:t.inboundConnectionThreshold??Ri.inboundConnectionThreshold,duration:1}),this.connectionPruner=new z1({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{maxConnections:this.maxConnections,allow:t.allow?.map(n=>Q(n))}),this.dialQueue=new Q1(e,{addressSorter:t.addressSorter,maxParallelDials:t.maxParallelDials??vh,maxDialQueueLength:t.maxDialQueueLength??wh,maxPeerAddrsToDial:t.maxPeerAddrsToDial??yh,dialTimeout:t.dialTimeout??mh,resolvers:t.resolvers??{dnsaddr:oh},connections:this.connections}),this.reconnectQueue=new cS({events:e.events,peerStore:e.peerStore,logger:e.logger,connectionManager:this},{retries:t.reconnectRetries,retryInterval:t.reconnectRetryInterval,backoffFactor:t.reconnectBackoffFactor,maxParallelReconnects:t.maxParallelReconnects})}[Symbol.toStringTag]="@libp2p/connection-manager";async start(){this.metrics?.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const e={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const t of this.connections.values())for(const n of t)e[n.direction]++;return e}}),this.metrics?.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const e={};for(const t of this.connections.values())for(const n of t)for(const s of n.streams){const i=`${s.direction} ${s.protocol??"unnegotiated"}`;e[i]=(e[i]??0)+1}return e}}),this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const e={};for(const n of this.connections.values())for(const s of n){const i={};for(const o of s.streams){const a=`${o.direction} ${o.protocol??"unnegotiated"}`;i[a]=(i[a]??0)+1}for(const[o,a]of Object.entries(i))e[o]=e[o]??[],e[o].push(a)}const t={};for(let[n,s]of Object.entries(e)){s=s.sort((o,a)=>o-a);const i=Math.floor(s.length*.9);t[n]=s[i]}return t}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await Bl(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await $l(this.reconnectQueue,this.dialQueue,this.connectionPruner);const e=[];for(const t of this.connections.values())for(const n of t)e.push((async()=>{try{await n.close()}catch(s){this.log.error(s)}})());this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}onConnect(e){this._onConnect(e).catch(t=>{this.log.error(t)})}async _onConnect(e){const{detail:t}=e;if(!this.started){await t.close();return}if(t.status!=="open")return;const n=t.remotePeer,s=!this.connections.has(n),i=this.connections.get(n)??[];i.push(t),this.connections.set(n,i),n.publicKey!=null&&n.type==="RSA"&&await this.peerStore.patch(n,{publicKey:n.publicKey}),s&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e,n=t.remotePeer,i=(this.connections.get(n)??[]).filter(o=>o.id!==t.id);this.connections.set(n,i),i.length===0&&(this.log("onDisconnect remove all connections for peer %p",n),this.connections.delete(n),this.events.safeDispatchEvent("peer:disconnect",{detail:t.remotePeer}))}getConnections(e){if(e!=null)return this.connections.get(e)??[];let t=[];for(const n of this.connections.values())t=t.concat(n);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){if(!this.started)throw new Qn("Not started");this.outboundPendingConnections++;try{t.signal?.throwIfAborted();const{peerId:n}=gh(e);if(this.peerId.equals(n))throw new Nl("Can not dial self");if(n!=null&&t.force!==!0){this.log("dial %p",n);const a=this.getConnections(n).find(c=>c.limits==null);if(a!=null)return this.log("had an existing non-limited connection to %p",n),t.onProgress?.(new ie("dial-queue:already-connected")),a}const s=await this.dialQueue.dial(e,{...t,priority:t.priority??Eh});if(s.status!=="open")throw new Ml("Remote closed connection during opening");let i=this.connections.get(s.remotePeer);i==null&&(i=[],this.connections.set(s.remotePeer,i));let o=!1;for(const a of i)if(a.id===s.id&&(o=!0),t.force!==!0&&a.id!==s.id&&a.remoteAddr.equals(s.remoteAddr))return s.abort(new Ao("Duplicate multiaddr connection")),a;return o||i.push(s),s}finally{this.outboundPendingConnections--}}async closeConnections(e,t={}){const n=this.connections.get(e)??[];await Promise.all(n.map(async s=>{try{await s.close(t)}catch(i){s.abort(i)}}))}async acceptIncomingConnection(e){if(this.deny.some(s=>s.contains(e.remoteAddr.nodeAddress().address)))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some(s=>s.contains(e.remoteAddr.nodeAddress().address)))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(e.remoteAddr.isThinWaistAddress()){const s=e.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(s,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,s),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map(n=>Q(n))}))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}class Mi{movingAverage;variance;deviation;forecast;timeSpan;previousTime;constructor(e){this.timeSpan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timeSpan)}push(e,t=Date.now()){if(this.previousTime!=null){const n=this.alpha(t,this.previousTime),s=e-this.movingAverage,i=n*s;this.movingAverage=n*e+(1-n)*this.movingAverage,this.variance=(1-n)*(this.variance+s*i),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+n*s}else this.movingAverage=e;this.previousTime=t}}const uS=1.2,dS=2,hS=5e3;class fS{success;failure;next;metric;timeoutMultiplier;failureMultiplier;minTimeout;constructor(e={}){this.success=new Mi(e.interval??5e3),this.failure=new Mi(e.interval??5e3),this.next=new Mi(e.interval??5e3),this.failureMultiplier=e.failureMultiplier??dS,this.timeoutMultiplier=e.timeoutMultiplier??uS,this.minTimeout=e.minTimeout??hS,e.metricName!=null&&(this.metric=e.metrics?.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){const t=Math.max(Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier)),this.minTimeout),n=AbortSignal.timeout(t),s=$t([e.signal,n]);return s.start=Date.now(),s.timeout=t,s}cleanUp(e){const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),this.metric?.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),this.metric?.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}const pS=1e4,gS="1.0.0",mS="ping",yS="ipfs",Al=32,wS=!0;class bS{protocol;components;log;heartbeatInterval;pingIntervalMs;abortController;timeout;abortConnectionOnPingFailure;constructor(e,t={}){this.components=e,this.protocol=`/${t.protocolPrefix??yS}/${mS}/${gS}`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??pS,this.abortConnectionOnPingFailure=t.abortConnectionOnPingFailure??wS,this.timeout=new fS({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}[Symbol.toStringTag]="@libp2p/connection-monitor";[it]=["@libp2p/connection-monitor"];start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(e=>{Promise.resolve().then(async()=>{let t=Date.now();try{const n=this.timeout.getTimeoutSignal({signal:this.abortController?.signal}),s=await e.newStream(this.protocol,{signal:n,runOnLimitedConnection:!0}),i=us(s);t=Date.now(),await Promise.all([i.write(Wo(Al),{signal:n}),i.read({bytes:Al,signal:n})]),e.rtt=Date.now()-t,await i.unwrap().close({signal:n})}catch(n){if(n.name!=="UnsupportedProtocolError")throw n;e.rtt=(Date.now()-t)/2}}).catch(t=>{this.log.error("error during heartbeat",t),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),e.abort(t)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){this.abortController?.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}class vS{routers;started;components;constructor(e,t){this.routers=t.routers??[],this.started=!1,this.components=e,this.findProviders=e.metrics?.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,cid:n.toString()}),getAttributesFromYieldedValue:(n,s)=>({...s,providers:[...Array.isArray(s.providers)?s.providers:[],n.id.toString()]})})??this.findProviders,this.provide=e.metrics?.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,cid:n.toString()})})??this.provide,this.cancelReprovide=e.metrics?.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,cid:n.toString()})})??this.cancelReprovide,this.put=e.metrics?.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([n])=>({key:Y(n,"base36")})})??this.put,this.get=e.metrics?.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([n])=>({key:Y(n,"base36")})})??this.get}[Symbol.toStringTag]="@libp2p/content-routing";isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(this.routers.length===0)throw new _i("No content routers available");const n=this,s=new fr;for await(const i of ds(...n.routers.filter(o=>o.findProviders instanceof Function).map(o=>o.findProviders(e,t))))i!=null&&(i.multiaddrs.length>0&&await this.components.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),!s.has(i.id)&&(s.add(i.id),yield i))}async provide(e,t={}){if(this.routers.length===0)throw new _i("No content routers available");await Promise.all(this.routers.filter(n=>n.provide instanceof Function).map(async n=>{await n.provide(e,t)}))}async cancelReprovide(e,t={}){if(this.routers.length===0)throw new _i("No content routers available");await Promise.all(this.routers.filter(n=>n.cancelReprovide instanceof Function).map(async n=>{await n.cancelReprovide(e,t)}))}async put(e,t,n){if(!this.isStarted())throw new Qn;await Promise.all(this.routers.filter(s=>s.put instanceof Function).map(async s=>{await s.put(e,t,n)}))}async get(e,t){if(!this.isStarted())throw new Qn;return Promise.any(this.routers.filter(n=>n.get instanceof Function).map(async n=>n.get(e,t)))}}class ES{log;peerId;peerStore;routers;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[],this.findPeer=e.metrics?.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,peer:n.toString()})})??this.findPeer,this.getClosestPeers=e.metrics?.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([n],s)=>({...s,key:Y(n,"base36")}),getAttributesFromYieldedValue:(n,s)=>({...s,peers:[...Array.isArray(s.peers)?s.peers:[],n.id.toString()]})})??this.getClosestPeers}[Symbol.toStringTag]="@libp2p/peer-routing";async findPeer(e,t){if(this.routers.length===0)throw new pl("No peer routers available");if(e.toString()===this.peerId.toString())throw new o1("Should not try to find self");const n=this,s=ds(...this.routers.filter(i=>i.findPeer instanceof Function).map(i=>async function*(){try{yield await i.findPeer(e,t)}catch(o){n.log.error(o)}}()));for await(const i of s)if(i!=null)return i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),i;throw new Bi}async*getClosestPeers(e,t={}){if(this.routers.length===0)throw new pl("No peer routers available");const n=this,s=un(1024);for await(const i of Nd(async function*(){const o=ds(...n.routers.filter(a=>a.getClosestPeers instanceof Function).map(a=>a.getClosestPeers(e,t)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await n.findPeer(a.id,{...t,useCache:!1})}catch(c){n.log.error("could not find peer multiaddrs",c);return}return a}}()))i!=null&&(i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),!s.has(i.id.toMultihash().bytes)&&(s.add(i.id.toMultihash().bytes),yield i))}}class SS extends Ut{peerRouting;log;walking;walkers;shutdownController;walkController;needNext;constructor(e){super(),this.log=e.logger.forComponent("libp2p:random-walk"),this.peerRouting=e.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}[Symbol.toStringTag]="@libp2p/random-walk";start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(e){this.walking||this.startWalk(),this.walkers++;const t=$t([this.shutdownController.signal,e?.signal]);try{for(;;)this.needNext?.resolve(),this.needNext=he(),yield(await pr(this,"walk:peer",t,{errorEvent:"walk:error"})).detail}finally{t.clear(),this.walkers--,this.walkers===0&&(this.walkController?.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const e=$t([this.walkController.signal,this.shutdownController.signal]),t=Date.now();let n=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const s=Wo(32);let i=Date.now();for await(const o of this.peerRouting.getClosestPeers(s,{signal:e}))e.aborted&&this.log("aborting walk"),e.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",o.id,Date.now()-i,this.walkers),n++,this.safeDispatchEvent("walk:peer",{detail:o}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await Je(this.needNext.promise,e)),i=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",s,this.walkers,n)}catch(s){this.log.error("random walk errored",s),this.safeDispatchEvent("walk:error",{detail:s})}this.log("no walkers left, ended walk")}).catch(s=>{this.log.error("random walk errored",s)}).finally(()=>{this.log("finished walk, found %d peers after %dms",n,Date.now()-t),this.walking=!1})}}const Sh=32,xh=64;class xS{log;topologies;handlers;components;constructor(e){this.log=e.logger.forComponent("libp2p:registrar"),this.topologies=new Map,this.handlers=new Map,this.components=e,this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}[Symbol.toStringTag]="@libp2p/registrar";getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(t==null)throw new a1(`No handler registered for protocol ${e}`);return t}getTopologies(e){const t=this.topologies.get(e);return t==null?[]:[...t.values()]}async handle(e,t,n){if(this.handlers.has(e)&&n?.force!==!0)throw new c1(`Handler already registered for protocol ${e}`);const s=rh.bind({ignoreUndefined:!0})({maxInboundStreams:Sh,maxOutboundStreams:xh},n);this.handlers.set(e,{handler:t,options:s}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]})}async unhandle(e){(Array.isArray(e)?e:[e]).forEach(n=>{this.handlers.delete(n)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()})}async register(e,t){if(t==null)throw new V("invalid topology");const n=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let s=this.topologies.get(e);return s==null&&(s=new Map,this.topologies.set(e,s)),s.set(n,t),n}unregister(e){for(const[t,n]of this.topologies.entries())n.has(e)&&(n.delete(e),n.size===0&&this.topologies.delete(t))}_onDisconnect(e){const t=e.detail;this.components.peerStore.get(t).then(n=>{for(const s of n.protocols){const i=this.topologies.get(s);if(i!=null)for(const o of i.values())o.filter?.has(t)!==!1&&(o.filter?.remove(t),o.onDisconnect?.(t))}}).catch(n=>{n.name!=="NotFoundError"&&this.log.error("could not inform topologies of disconnecting peer %p",t,n)})}_onPeerUpdate(e){const{peer:t,previous:n}=e.detail,s=(n?.protocols??[]).filter(i=>!t.protocols.includes(i));for(const i of s){const o=this.topologies.get(i);if(o!=null)for(const a of o.values())a.filter?.has(t.id)!==!1&&(a.filter?.remove(t.id),a.onDisconnect?.(t.id))}}_onPeerIdentify(e){const t=e.detail.protocols,n=e.detail.connection,s=e.detail.peerId;for(const i of t){const o=this.topologies.get(i);if(o!=null)for(const a of o.values())n.limits!=null&&a.notifyOnLimitedConnection!==!0||a.filter?.has(s)!==!0&&(a.filter?.add(s),a.onConnect?.(s,n))}}}class AS extends Map{metric;constructor(e){super();const{name:t,metrics:n}=e;this.metric=n.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function CS(r){const{name:e,metrics:t}=r;let n;return t!=null?n=new AS({name:e,metrics:t}):n=new Map,n}class IS{log;components;transports;listeners;faultTolerance;started;constructor(e,t={}){this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=new Map,this.listeners=CS({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??Qr.FATAL_ALL}[Symbol.toStringTag]="@libp2p/transport-manager";add(e){const t=e[Symbol.toStringTag];if(t==null)throw new V("Transport must have a valid tag");if(this.transports.has(t))throw new V(`There is already a transport with the tag ${t}`);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,n]of this.listeners)for(this.log("closing listeners for %s",t);n.length>0;){const s=n.pop();s!=null&&e.push(s.close())}await Promise.all(e),this.log("all listeners closed");for(const t of this.listeners.keys())this.listeners.set(t,[]);this.started=!1}async dial(e,t){const n=this.dialTransportForMultiaddr(e);if(n==null)throw new p1(`No transport available for address ${String(e)}`);return t?.onProgress?.(new ie("transport-manager:selected-transport",n[Symbol.toStringTag])),n.dial(e,{...t,upgrader:this.components.upgrader})}getAddrs(){let e=[];for(const t of this.listeners.values())for(const n of t)e=[...e,...n.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values())if(t.dialFilter([e]).length>0)return t}listenTransportForMultiaddr(e){for(const t of this.transports.values())if(t.listenFilter([e]).length>0)return t}async listen(e){if(!this.isStarted())throw new Qn("Not started");if(e==null||e.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const t={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};e.forEach(i=>{t.errors.set(i.toString(),new l1)});const n=[];for(const[i,o]of this.transports.entries()){const a=o.listenFilter(e);for(const c of a){this.log("creating listener for %s on %a",i,c);const l=o.createListener({upgrader:this.components.upgrader});let u=this.listeners.get(i)??[];u==null&&(u=[],this.listeners.set(i,u)),u.push(l),l.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:l})}),l.addEventListener("close",()=>{const d=u.findIndex(h=>h===l);u.splice(d,1),this.components.events.safeDispatchEvent("transport:close",{detail:l})}),gc.matches(c)?t.ipv4.attempts++:mc.matches(c)&&t.ipv6.attempts++,n.push(l.listen(c).then(()=>{t.errors.delete(c.toString()),gc.matches(c)&&t.ipv4.success++,mc.matches(c)&&t.ipv6.success++},d=>{throw this.log.error("transport %s could not listen on address %a - %e",i,c,d),t.errors.set(c.toString(),d),d}))}}const s=await Promise.allSettled(n);if(!(s.length>0&&s.every(i=>i.status==="fulfilled"))){if(this.ipv6Unsupported(t)){this.log("all IPv4 addresses succeed but all IPv6 failed");return}if(this.faultTolerance===Qr.NO_FATAL){this.log("failed to listen on any address but fault tolerance allows this");return}throw new u1(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...t.errors.entries()].map(([i,o])=>`
  ${i}: ${`${o.stack??o}`.split(`
`).join(`
  `)}
`).join("")}`)}}ipv6Unsupported(e){if(e.ipv4.attempts===0||e.ipv6.attempts===0)return!1;const t=e.ipv4.attempts===e.ipv4.success,n=e.ipv6.success===0;return t&&n}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const n=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const s=t.pop();s!=null&&n.push(s.close())}await Promise.all(n),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}const We="/multistream/1.0.0",ua=1024,TS=q(`
`);async function Wr(r,e,t){await r.write(e,t)}async function kS(r,e,t){await r.writeV(e,t)}async function _S(r,e){const t=await r.read(e);if(t.byteLength===0||t.get(t.byteLength-1)!==TS[0])throw e.log.error("Invalid mss message - missing newline",t),new ut("Missing newline");return t.sublist(0,-1)}async function gr(r,e){const t=await _S(r,e);return Y(t.subarray())}async function Oi(r,e,t){if(e=Array.isArray(e)?[...e]:[e],e.length===1&&t.negotiateFully===!1)return PS(r,e[0],t);const n=br(r,{...t,maxDataLength:ua}),s=e.shift();if(s==null)throw new Error("At least one protocol must be specified");t.log.trace('select: write ["%s", "%s"]',We,s);const i=q(`${We}
`),o=q(`${s}
`);await kS(n,[i,o],t),t.log.trace("select: reading multistream-select header");let a=await gr(n,t);if(t.log.trace('select: read "%s"',a),a===We&&(t.log.trace("select: reading protocol response"),a=await gr(n,t),t.log.trace('select: read "%s"',a)),a===s)return{stream:n.unwrap(),protocol:s};for(const c of e){t.log.trace('select: write "%s"',c),await Wr(n,q(`${c}
`),t),t.log.trace("select: reading protocol response");const l=await gr(n,t);if(t.log.trace('select: read "%s" for "%s"',l,c),l===c)return{stream:n.unwrap(),protocol:c}}throw new Co("protocol selection failed")}function PS(r,e,t){const n=r.sink.bind(r),s=r.source;let i=!1,o=!1;const a=he();let c=!1,l=!1;const u=he();let d=!1,h=!1;const p=he(),f=br({sink:n,source:s},{...t,maxDataLength:ua});r.sink=async k=>{const{sink:b}=f.unwrap();await b(async function*(){let w=!1;for await(const E of k){if(l&&await u.promise,c)yield E;else{l=!0,t.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink',We,e,E.byteLength);const P=`${e}
`;yield new J(Uint8Array.from([19]),q(`${We}
`),dt(P.length),q(P),E).subarray(),t.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink',We,e,E.byteLength),c=!0,l=!1,u.resolve(),g().catch(x=>{t.log.error("could not finish optimistic protocol negotiation of %s",e,x)})}w=!0}w||await g()}())};async function g(){if(o){t.log.trace("optimistic: already negotiating %s stream",e),await a.promise;return}o=!0;try{c||(t.log.trace("optimistic: doing send protocol for %s stream",e),await m()),d||(t.log.trace("optimistic: doing read protocol for %s stream",e),await v())}finally{o=!1,i=!0,a.resolve()}}async function m(){if(l){await u.promise;return}l=!0;try{t.log.trace('optimistic: write ["%s", "%s", data] in source',We,e),await f.writeV([q(`${We}
`),q(`${e}
`)]),t.log.trace('optimistic: wrote ["%s", "%s", data] in source',We,e)}finally{c=!0,l=!1,u.resolve()}}async function v(){if(h){await p.promise;return}h=!0;try{t.log.trace("optimistic: reading multistream select header");let k=await gr(f,t);if(t.log.trace('optimistic: read multistream select header "%s"',k),k===We&&(k=await gr(f,t)),t.log.trace('optimistic: read protocol "%s", expecting "%s"',k,e),k!==e)throw new Co("protocol selection failed")}finally{d=!0,h=!1,p.resolve()}}if(r.source=async function*(){await g(),t.log.trace('optimistic: reading data from "%s" stream',e),yield*f.unwrap().source}(),r.closeRead!=null){const k=r.closeRead.bind(r);r.closeRead=async b=>{i||await g().catch(w=>{t.log.error("could not negotiate protocol before close read",w)}),await k(b)}}if(r.closeWrite!=null){const k=r.closeWrite.bind(r);r.closeWrite=async b=>{i||await g().catch(w=>{t.log.error("could not negotiate protocol before close write",w)}),await k(b)}}if(r.close!=null){const k=r.close.bind(r);r.close=async b=>{const w=[];l&&w.push(u.promise),h&&w.push(p.promise),w.length>0?await Je(Promise.all(w),b?.signal):(i=!0,o=!1,a.resolve()),await k(b)}}return{stream:r,protocol:e}}async function Ni(r,e,t){e=Array.isArray(e)?e:[e],t.log.trace("handle: available protocols %s",e);const n=br(r,{...t,maxDataLength:ua,maxLengthLength:2});for(;;){t.log.trace("handle: reading incoming string");const s=await gr(n,t);if(t.log.trace('handle: read "%s"',s),s===We){t.log.trace('handle: respond with "%s" for "%s"',We,s),await Wr(n,q(`${We}
`),t),t.log.trace('handle: responded with "%s" for "%s"',We,s);continue}if(e.includes(s))return t.log.trace('handle: respond with "%s" for "%s"',s,s),await Wr(n,q(`${s}
`),t),t.log.trace('handle: responded with "%s" for "%s"',s,s),{stream:n.unwrap(),protocol:s};if(s==="ls"){const i=new J(...e.map(o=>cs.single(q(`${o}
`))),q(`
`));t.log.trace('handle: respond with "%s" for %s',e,s),await Wr(n,i,t),t.log.trace('handle: responded with "%s" for %s',e,s);continue}t.log.trace('handle: respond with "na" for "%s"',s),await Wr(n,q(`na
`),t),t.log('handle: responded with "na" for "%s"',s)}}const LS=500;class DS{id;remoteAddr;remotePeer;direction;timeline;multiplexer;encryption;status;limits;log;tags;_newStream;_close;_abort;_getStreams;constructor(e){const{remoteAddr:t,remotePeer:n,newStream:s,close:i,abort:o,getStreams:a}=e;this.id=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`,this.remoteAddr=t,this.remotePeer=n,this.direction=e.direction,this.status="open",this.timeline=e.timeline,this.multiplexer=e.multiplexer,this.encryption=e.encryption,this.limits=e.limits,this.log=e.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`),this.remoteAddr.getPeerId()==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),this._newStream=s,this._close=i,this._abort=o,this._getStreams=a,this.tags=[]}[Symbol.toStringTag]="Connection";[Lh]=!0;get streams(){return this._getStreams()}async newStream(e,t){if(this.status==="closing")throw new Mh("the connection is being closed");if(this.status==="closed")throw new Ml("the connection is closed");if(Array.isArray(e)||(e=[e]),this.limits!=null&&t?.runOnLimitedConnection!==!0)throw new Fl("Cannot open protocol stream on limited connection");const n=await this._newStream(e,t);return n.direction="outbound",n}async close(e={}){if(!(this.status==="closed"||this.status==="closing")){if(this.log("closing connection to %a",this.remoteAddr),this.status="closing",e.signal==null){const t=AbortSignal.timeout(LS);e={...e,signal:t}}try{this.log.trace("closing underlying transport"),await this._close(e),this.log.trace("updating timeline with close time"),this.status="closed",this.timeline.close=Date.now()}catch(t){this.log.error("error encountered during graceful close of connection to %a",this.remoteAddr,t),this.abort(t)}}}abort(e){this.status!=="closed"&&(this.log.error("aborting connection to %a due to error",this.remoteAddr,e),this.status="closing",this._abort(e),this.status="closed",this.timeline.close=Date.now())}}function RS(r){return new DS(r)}function MS(r,e){try{const{options:t}=e.getHandler(r);return t.maxInboundStreams}catch(t){if(t.name!=="UnhandledProtocolError")throw t}return Sh}function OS(r,e,t={}){try{const{options:n}=e.getHandler(r);if(n.maxOutboundStreams!=null)return n.maxOutboundStreams}catch(n){if(n.name!=="UnhandledProtocolError")throw n}return t.maxOutboundStreams??xh}function Cl(r,e,t){let n=0;return t.streams.forEach(s=>{s.direction===e&&s.protocol===r&&n++}),n}class NS{components;connectionEncrypters;streamMuxers;inboundUpgradeTimeout;inboundStreamProtocolNegotiationTimeout;outboundStreamProtocolNegotiationTimeout;events;metrics;constructor(e,t){this.components=e,this.connectionEncrypters=new Map,t.connectionEncrypters.forEach(n=>{this.connectionEncrypters.set(n.protocol,n)}),this.streamMuxers=new Map,t.streamMuxers.forEach(n=>{this.streamMuxers.set(n.protocol,n)}),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??R1,this.inboundStreamProtocolNegotiationTimeout=t.inboundStreamProtocolNegotiationTimeout??yl,this.outboundStreamProtocolNegotiationTimeout=t.outboundStreamProtocolNegotiationTimeout??yl,this.events=e.events,this.metrics={dials:e.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:e.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total")}}[Symbol.toStringTag]="@libp2p/upgrader";async shouldBlockConnection(e,...t){const n=this.components.connectionGater[e];if(n==null)return;if(await n.apply(this.components.connectionGater,t)===!0)throw new h1(`The multiaddr connection is blocked by gater.${e}`)}createInboundAbortSignal(e){return $t([AbortSignal.timeout(this.inboundUpgradeTimeout),e])}async upgradeInbound(e,t){let n=!1;const s=this.createInboundAbortSignal(t.signal);try{if(this.metrics.dials?.increment({inbound:!0}),n=await this.components.connectionManager.acceptIncomingConnection(e),!n)throw new f1("Connection denied");await this.shouldBlockConnection("denyInboundConnection",e),await this._performUpgrade(e,"inbound",{...t,signal:s})}catch(i){throw this.metrics.errors?.increment({inbound:!0}),i}finally{s.clear(),n&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t){try{this.metrics.dials?.increment({outbound:!0});const n=e.remoteAddr.getPeerId();let s;n!=null&&(s=pt(n),await this.shouldBlockConnection("denyOutboundConnection",s,e));let i="outbound";return t.initiator===!1&&(i="inbound"),await this._performUpgrade(e,i,t)}catch(n){throw this.metrics.errors?.increment({outbound:!0}),n}}async _performUpgrade(e,t,n){let s,i,o,a,c;this.components.metrics?.trackMultiaddrConnection(e),e.log.trace("starting the %s connection upgrade",t);let l=e;if(n?.skipProtection!==!0){const u=this.components.connectionProtector;u!=null&&(e.log("protecting the %s connection",t),l=await u.protect(e,n))}try{if(s=l,n?.skipEncryption!==!0){n?.onProgress?.(new ie(`upgrader:encrypt-${t}-connection`)),{conn:s,remotePeer:i,protocol:c,streamMuxer:a}=await(t==="inbound"?this._encryptInbound(l,n):this._encryptOutbound(l,n));const u={...l,...s};await this.shouldBlockConnection(t==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",i,u)}else{const u=e.remoteAddr.getPeerId();if(u==null)throw new Ao(`${t} connection that skipped encryption must have a peer id`);const d=pt(u);c="native",i=d}if(i.equals(this.components.peerId)){const u=new Nl("Can not dial self");throw e.abort(u),u}if(o=s,n?.muxerFactory!=null)a=n.muxerFactory;else if(a==null&&this.streamMuxers.size>0){n?.onProgress?.(new ie(`upgrader:multiplex-${t}-connection`));const u=await(t==="inbound"?this._multiplexInbound({...l,...s},this.streamMuxers,n):this._multiplexOutbound({...l,...s},this.streamMuxers,n));a=u.muxerFactory,o=u.stream}}catch(u){throw e.log.error("failed to upgrade inbound connection %s %a - %e",t==="inbound"?"from":"to",e.remoteAddr,u),u}return await this.shouldBlockConnection(t==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",i,e),e.log("successfully upgraded %s connection",t),this._createConnection({cryptoProtocol:c,direction:t,maConn:e,upgradedConn:o,muxerFactory:a,remotePeer:i,limits:n?.limits})}_createConnection(e){const{cryptoProtocol:t,direction:n,maConn:s,upgradedConn:i,remotePeer:o,muxerFactory:a,limits:c}=e;let l,u,d;a!=null&&(l=a.createStreamMuxer({direction:n,onIncomingStream:f=>{d!=null&&Promise.resolve().then(async()=>{const g=this.components.registrar.getProtocols(),m=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout),{stream:v,protocol:k}=await Ni(f,g,{signal:m,log:f.log,yieldBytes:!1});if(d==null)return;d.log("incoming stream opened on %s",k);const b=MS(k,this.components.registrar);if(Cl(k,"inbound",d)===b){const E=new Bh(`Too many inbound protocol streams for protocol "${k}" - limit ${b}`);throw f.abort(E),E}f.source=v.source,f.sink=v.sink,f.protocol=k,v.closeWrite!=null&&(f.closeWrite=v.closeWrite),v.closeRead!=null&&(f.closeRead=v.closeRead),v.close!=null&&(f.close=v.close),await this.components.peerStore.merge(o,{protocols:[k]}),this.components.metrics?.trackProtocolStream(f,d),this._onStream({connection:d,stream:f,protocol:k})}).catch(async g=>{d.log.error("error handling incoming stream id %s - %e",f.id,g),f.timeline.close==null&&await f.close()})}}),u=async(f,g={})=>{if(l==null)throw new qn("Connection is not multiplexed");d.log.trace("starting new stream for protocols %s",f);const m=await l.newStream();d.log.trace("started new stream %s for protocols %s",m.id,f);try{if(g.signal==null){m.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",f);const E=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);g={...g,signal:E}}m.log.trace("selecting protocol from protocols %s",f);const{stream:v,protocol:k}=await Oi(m,f,{...g,log:m.log,yieldBytes:!0});m.log.trace("selected protocol %s",k);const b=OS(k,this.components.registrar,g),w=Cl(k,"outbound",d);if(w>=b){const E=new Ul(`Too many outbound protocol streams for protocol "${k}" - ${w}/${b}`);throw m.abort(E),E}return await this.components.peerStore.merge(o,{protocols:[k]}),m.source=v.source,m.sink=v.sink,m.protocol=k,v.closeWrite!=null&&(m.closeWrite=v.closeWrite),v.closeRead!=null&&(m.closeRead=v.closeRead),v.close!=null&&(m.close=v.close),this.components.metrics?.trackProtocolStream(m,d),m}catch(v){throw d.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",n==="inbound"?"from":"to",e.maConn.remoteAddr,f,v),m.timeline.close==null&&m.abort(v),v}},Promise.all([l.sink(i.source),i.sink(l.source)]).catch(f=>{d.log.error("error piping data through muxer - %e",f)}));const h=s.timeline;s.timeline=new Proxy(h,{set:(...f)=>(f[1]==="close"&&f[2]!=null&&h.close==null&&(async()=>{try{d.status==="open"&&await d.close()}catch(g){d.log.error("error closing connection after timeline close %e",g)}finally{this.events.safeDispatchEvent("connection:close",{detail:d})}})().catch(g=>{d.log.error("error thrown while dispatching connection:close event %e",g)}),Reflect.set(...f))}),s.timeline.upgraded=Date.now();const p=()=>{throw new qn("Connection is not multiplexed")};return d=RS({remoteAddr:s.remoteAddr,remotePeer:o,status:"open",direction:n,timeline:s.timeline,multiplexer:l?.protocol,encryption:t,limits:c,logger:this.components.logger,newStream:u??p,getStreams:()=>l?.streams??[],close:async f=>{await l?.close(f),await s.close(f)},abort:f=>{s.abort(f),l?.abort(f)}}),this.events.safeDispatchEvent("connection:open",{detail:d}),d.__maConnTimeline=h,d}_onStream(e){const{connection:t,stream:n,protocol:s}=e,{handler:i,options:o}=this.components.registrar.getHandler(s);if(t.limits!=null&&o.runOnLimitedConnection!==!0)throw new Fl("Cannot open protocol stream on limited connection");i({connection:t,stream:n})}async _encryptInbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{const{stream:s,protocol:i}=await Ni(e,n,{...t,log:e.log}),o=this.connectionEncrypters.get(i);if(o==null)throw new Wn(`no crypto module found for ${i}`);return e.log("encrypting inbound connection to %a using %s",e.remoteAddr,i),{...await o.secureInbound(s,t),protocol:i}}catch(s){throw e.log.error("encrypting inbound connection from %a failed",e.remoteAddr,s),new Wn(s.message)}}async _encryptOutbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{e.log.trace("selecting encrypter from %s",n);const{stream:s,protocol:i}=await Oi(e,n,{...t,log:e.log,yieldBytes:!0}),o=this.connectionEncrypters.get(i);if(o==null)throw new Wn(`no crypto module found for ${i}`);return e.log("encrypting outbound connection to %a using %s",e.remoteAddr,i),{...await o.secureOutbound(s,t),protocol:i}}catch(s){throw e.log.error("encrypting outbound connection to %a failed",e.remoteAddr,s),new Wn(s.message)}}async _multiplexOutbound(e,t,n){const s=Array.from(t.keys());e.log("outbound selecting muxer %s",s);try{e.log.trace("selecting stream muxer from %s",s);const{stream:i,protocol:o}=await Oi(e,s,{...n,log:e.log,yieldBytes:!0});e.log("selected %s as muxer protocol",o);const a=t.get(o);return{stream:i,muxerFactory:a}}catch(i){throw e.log.error("error multiplexing outbound connection",i),new qn(String(i))}}async _multiplexInbound(e,t,n){const s=Array.from(t.keys());e.log("inbound handling muxers %s",s);try{const{stream:i,protocol:o}=await Ni(e,s,{...n,log:e.log}),a=t.get(o);return{stream:i,muxerFactory:a}}catch(i){throw e.log.error("error multiplexing inbound connection",i),new qn(String(i))}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}const Ah="2.8.8",Ch="js-libp2p";function FS(r,e){return`${r??Ch}/${e??Ah} browser/${globalThis.navigator.userAgent}`}class US extends Ut{peerId;peerStore;contentRouting;peerRouting;metrics;services;logger;status;components;log;constructor(e){super(),this.status="stopped";const t=new Ut,n=t.dispatchEvent.bind(t);t.dispatchEvent=l=>{const u=n(l),d=this.dispatchEvent(new CustomEvent(l.type,{detail:l.detail}));return u||d},this.peerId=e.peerId,this.logger=e.logger??ch(),this.log=this.logger.forComponent("libp2p"),this.services={};const s=e.nodeInfo?.name??Ch,i=e.nodeInfo?.version??Ah,o=this.components=w1({peerId:e.peerId,privateKey:e.privateKey,nodeInfo:{name:s,version:i,userAgent:e.nodeInfo?.userAgent??FS(s,i)},logger:this.logger,events:t,datastore:e.datastore??new RE,connectionGater:C1(e.connectionGater),dns:e.dns});this.peerStore=this.configureComponent("peerStore",kE(o,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),e.metrics!=null&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),o.events.addEventListener("peer:update",l=>{if(l.detail.previous==null){const u={id:l.detail.peer.id,multiaddrs:l.detail.peer.addresses.map(d=>d.multiaddr)};o.events.safeDispatchEvent("peer:discovery",{detail:u})}}),e.connectionProtector!=null&&this.configureComponent("connectionProtector",e.connectionProtector(o)),this.components.upgrader=new NS(this.components,{connectionEncrypters:(e.connectionEncrypters??[]).map((l,u)=>this.configureComponent(`connection-encryption-${u}`,l(this.components))),streamMuxers:(e.streamMuxers??[]).map((l,u)=>this.configureComponent(`stream-muxers-${u}`,l(this.components))),inboundUpgradeTimeout:e.connectionManager?.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:e.connectionManager?.inboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:e.connectionManager?.outboundStreamProtocolNegotiationTimeout??e.connectionManager?.protocolNegotiationTimeout}),this.configureComponent("transportManager",new IS(this.components,e.transportManager)),this.configureComponent("connectionManager",new lS(this.components,e.connectionManager)),e.connectionMonitor?.enabled!==!1&&this.configureComponent("connectionMonitor",new bS(this.components,e.connectionMonitor)),this.configureComponent("registrar",new xS(this.components)),this.configureComponent("addressManager",new n1(this.components,e.addresses));const a=(e.peerRouters??[]).map((l,u)=>this.configureComponent(`peer-router-${u}`,l(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new ES(this.components,{routers:a}));const c=(e.contentRouters??[]).map((l,u)=>this.configureComponent(`content-router-${u}`,l(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new vS(this.components,{routers:c})),this.configureComponent("randomWalk",new SS(this.components)),(e.peerDiscovery??[]).forEach((l,u)=>{this.configureComponent(`peer-discovery-${u}`,l(this.components)).addEventListener("peer",h=>{this.#e(h)})}),e.transports?.forEach((l,u)=>{this.components.transportManager.add(this.configureComponent(`transport-${u}`,l(this.components)))}),e.services!=null)for(const l of Object.keys(e.services)){const u=e.services[l],d=u(this.components);if(d==null){this.log.error("service factory %s returned null or undefined instance",l);continue}this.services[l]=d,this.configureComponent(l,d),d[ha]!=null&&(this.log("registering service %s for content routing",l),c.push(d[ha])),d[pa]!=null&&(this.log("registering service %s for peer routing",l),a.push(d[pa])),d[fa]!=null&&(this.log("registering service %s for peer discovery",l),d[fa].addEventListener?.("peer",h=>{this.#e(h)}))}b1(o)}configureComponent(e,t){return t==null&&this.log.error("component %s was null or undefined",e),this.components[e]=t,t}async start(){if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await this.components.beforeStart?.(),await this.components.start(),await this.components.afterStart?.(),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started")}catch(e){throw this.log.error("An error occurred starting libp2p",e),this.status="started",await this.stop(),e}}}async stop(){this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await this.components.beforeStop?.(),await this.components.stop(),await this.components.afterStop?.(),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new fr;for(const t of this.components.connectionManager.getConnections())e.add(t.remotePeer);return Array.from(e)}async dial(e,t={}){return this.components.connectionManager.openConnection(e,{priority:75,...t})}async dialProtocol(e,t,n={}){if(t==null)throw new V("no protocols were provided to open a stream");if(t=Array.isArray(t)?t:[t],t.length===0)throw new V("no protocols were provided to open a stream");return(await this.dial(e,n)).newStream(t,n)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e,t={}){Bs(e)&&(e=pt(e.getPeerId()??"")),await this.components.connectionManager.closeConnections(e,t)}async getPublicKey(e,t={}){if(this.log("getPublicKey %p",e),e.publicKey!=null)return e.publicKey;try{const o=await this.peerStore.get(e);if(o.id.publicKey!=null)return o.id.publicKey}catch(o){if(o.name!=="NotFoundError")throw o}const n=ot([q("/pk/"),e.toMultihash().bytes]),s=await this.contentRouting.get(n,t),i=Bt(s);return await this.peerStore.patch(e,{publicKey:i}),i}async handle(e,t,n){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async s=>{await this.components.registrar.handle(s,t,n)}))}async unhandle(e){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async t=>{await this.components.registrar.unhandle(t)}))}async register(e,t){return this.components.registrar.register(e,t)}unregister(e){this.components.registrar.unregister(e)}async isDialable(e,t={}){return this.components.connectionManager.isDialable(e,t)}#e(e){const{detail:t}=e;if(t.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(t.id,{multiaddrs:t.multiaddrs}).catch(n=>{this.log.error(n)})}}async function BS(r={}){r.privateKey??=await Em();const e=new US({...await Kv(r),peerId:Im(r.privateKey)});return r.start!==!1&&await e.start(),e}var Hn={exports:{}},Il;function $S(){return Il||(Il=1,function(r,e){var t=globalThis.require&&e||{};(function(n,s){let i=globalThis.crypto;s._sep=/[\s,:-]+/,s._mword="mnemonic",s._normalize=function(o){return o.normalize("NFKD").trim().toLowerCase()},s.generate=async function(o=128){let a=o/8,c=i.getRandomValues(new Uint8Array(a));return await s.encode(c)},s.encode=async function(o){let a=8*o.length,c=a/32;o=new Uint8Array(o);let l=await i.subtle.digest("SHA-256",o),u=new Uint8Array(l),d="";o.forEach(function(v){let k=v.toString(2).padStart(8,"0");d+=k});let p=u[0].toString(2);p=p.padStart(8,"0");let f=p.slice(0,c);d+=f;let g=[];for(let v=0;v<a+c;v+=11){let k=parseInt(d.slice(v,v+11).padStart(8,"0"),2);g.push(k)}return g.map(function(v){return s.base2048[v]}).join(" ")},s.verify=async function(o){return await s.decode(o),!0},s.checksum=s.verify,s.decode=async function(o,a){o=s._normalize(o);let c=[];o.split(s._sep).forEach(function(b){let w=s.base2048.indexOf(b);if(w<0){let E=new Error(`dashphrase.js: decode failed: unknown word '${b}'`);throw E.code="E_UNKNOWN_WORD",E}c.push(w)});let u=c.map(function(b){return b.toString(2).padStart(11,"0")}).join(""),d=Math.floor(u.length/32),h=u.length-d,p=u.slice(-d),f=[];for(let b=0;b<h;b+=8){let w=u.slice(b,b+8),E=parseInt(w,2);E>=0&&f.push(E)}let g=Uint8Array.from(f),m=await i.subtle.digest("SHA-256",g),k=new Uint8Array(m)[0].toString(2).padStart(8,"0").slice(0,d);if(k!==p&&a?.verify!==!1){let b=new Error(`dashphrase.js: bad checksum: expected '${k}' but got '${p}'`);throw b.code="E_BAD_CHECKSUM",b}return g},s.toSeed=async function(o,a="",c={}){c.verify!==!1&&await s.verify(o),o=s._normalize(o),a=a.normalize("NFKD");let u=new TextEncoder().encode(o),d=new TextEncoder().encode(s._mword+a),g=await s._pbkdf2(u,d,2048,512,"SHA-512");return new Uint8Array(g)},s.pbkdf2=s.toSeed,s._pbkdf2=async function(a,c,l,u,d){let h=!1,p=await i.subtle.importKey("raw",a,{name:"PBKDF2"},h,["deriveKey"]);h=!0;let f=await i.subtle.deriveKey({name:"PBKDF2",salt:c,iterations:l,hash:d},p,{name:"HMAC",hash:d,length:u},h,["sign","verify"]),g=await i.subtle.exportKey("raw",f);return new Uint8Array(g)},s._sha256=async function(o,a=""){o=s._normalize(o),a=a.normalize("NFKD");let c=new TextEncoder().encode(o),l=new TextEncoder().encode(a),u=new Uint8Array(c.length+l.length),d=0;for(let p=0;p<c.length;p+=1)u[d]=c[p],d+=1;for(let p=0;p<l.length;p+=1)u[d]=l[p],d+=1;let h=await i.subtle.digest("SHA-256",u);return new Uint8Array(h)},s.CATMONIC="cat swing flag economy stadium alone churn speed unique patch report train",s.ZOOMONIC="zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong",s.ZECRET="TREZOR",s.ZEED="ac27495480225222079d7be181583751e86f571027b0497b5b5d11218e0a8a13332572917f0f8e5a589620c6f15b11c61dee327651a14c34e18231052e48c069",s.base2048="abandon ability able about above absent absorb abstract absurd abuse access accident account accuse achieve acid acoustic acquire across act action actor actress actual adapt add addict address adjust admit adult advance advice aerobic affair afford afraid again age agent agree ahead aim air airport aisle alarm album alcohol alert alien all alley allow almost alone alpha already also alter always amateur amazing among amount amused analyst anchor ancient anger angle angry animal ankle announce annual another answer antenna antique anxiety any apart apology appear apple approve april arch arctic area arena argue arm armed armor army around arrange arrest arrive arrow art artefact artist artwork ask aspect assault asset assist assume asthma athlete atom attack attend attitude attract auction audit august aunt author auto autumn average avocado avoid awake aware away awesome awful awkward axis baby bachelor bacon badge bag balance balcony ball bamboo banana banner bar barely bargain barrel base basic basket battle beach bean beauty because become beef before begin behave behind believe below belt bench benefit best betray better between beyond bicycle bid bike bind biology bird birth bitter black blade blame blanket blast bleak bless blind blood blossom blouse blue blur blush board boat body boil bomb bone bonus book boost border boring borrow boss bottom bounce box boy bracket brain brand brass brave bread breeze brick bridge brief bright bring brisk broccoli broken bronze broom brother brown brush bubble buddy budget buffalo build bulb bulk bullet bundle bunker burden burger burst bus business busy butter buyer buzz cabbage cabin cable cactus cage cake call calm camera camp can canal cancel candy cannon canoe canvas canyon capable capital captain car carbon card cargo carpet carry cart case cash casino castle casual cat catalog catch category cattle caught cause caution cave ceiling celery cement census century cereal certain chair chalk champion change chaos chapter charge chase chat cheap check cheese chef cherry chest chicken chief child chimney choice choose chronic chuckle chunk churn cigar cinnamon circle citizen city civil claim clap clarify claw clay clean clerk clever click client cliff climb clinic clip clock clog close cloth cloud clown club clump cluster clutch coach coast coconut code coffee coil coin collect color column combine come comfort comic common company concert conduct confirm congress connect consider control convince cook cool copper copy coral core corn correct cost cotton couch country couple course cousin cover coyote crack cradle craft cram crane crash crater crawl crazy cream credit creek crew cricket crime crisp critic crop cross crouch crowd crucial cruel cruise crumble crunch crush cry crystal cube culture cup cupboard curious current curtain curve cushion custom cute cycle dad damage damp dance danger daring dash daughter dawn day deal debate debris decade december decide decline decorate decrease deer defense define defy degree delay deliver demand demise denial dentist deny depart depend deposit depth deputy derive describe desert design desk despair destroy detail detect develop device devote diagram dial diamond diary dice diesel diet differ digital dignity dilemma dinner dinosaur direct dirt disagree discover disease dish dismiss disorder display distance divert divide divorce dizzy doctor document dog doll dolphin domain donate donkey donor door dose double dove draft dragon drama drastic draw dream dress drift drill drink drip drive drop drum dry duck dumb dune during dust dutch duty dwarf dynamic eager eagle early earn earth easily east easy echo ecology economy edge edit educate effort egg eight either elbow elder electric elegant element elephant elevator elite else embark embody embrace emerge emotion employ empower empty enable enact end endless endorse enemy energy enforce engage engine enhance enjoy enlist enough enrich enroll ensure enter entire entry envelope episode equal equip era erase erode erosion error erupt escape essay essence estate eternal ethics evidence evil evoke evolve exact example excess exchange excite exclude excuse execute exercise exhaust exhibit exile exist exit exotic expand expect expire explain expose express extend extra eye eyebrow fabric face faculty fade faint faith fall false fame family famous fan fancy fantasy farm fashion fat fatal father fatigue fault favorite feature february federal fee feed feel female fence festival fetch fever few fiber fiction field figure file film filter final find fine finger finish fire firm first fiscal fish fit fitness fix flag flame flash flat flavor flee flight flip float flock floor flower fluid flush fly foam focus fog foil fold follow food foot force forest forget fork fortune forum forward fossil foster found fox fragile frame frequent fresh friend fringe frog front frost frown frozen fruit fuel fun funny furnace fury future gadget gain galaxy gallery game gap garage garbage garden garlic garment gas gasp gate gather gauge gaze general genius genre gentle genuine gesture ghost giant gift giggle ginger giraffe girl give glad glance glare glass glide glimpse globe gloom glory glove glow glue goat goddess gold good goose gorilla gospel gossip govern gown grab grace grain grant grape grass gravity great green grid grief grit grocery group grow grunt guard guess guide guilt guitar gun gym habit hair half hammer hamster hand happy harbor hard harsh harvest hat have hawk hazard head health heart heavy hedgehog height hello helmet help hen hero hidden high hill hint hip hire history hobby hockey hold hole holiday hollow home honey hood hope horn horror horse hospital host hotel hour hover hub huge human humble humor hundred hungry hunt hurdle hurry hurt husband hybrid ice icon idea identify idle ignore ill illegal illness image imitate immense immune impact impose improve impulse inch include income increase index indicate indoor industry infant inflict inform inhale inherit initial inject injury inmate inner innocent input inquiry insane insect inside inspire install intact interest into invest invite involve iron island isolate issue item ivory jacket jaguar jar jazz jealous jeans jelly jewel job join joke journey joy judge juice jump jungle junior junk just kangaroo keen keep ketchup key kick kid kidney kind kingdom kiss kit kitchen kite kitten kiwi knee knife knock know lab label labor ladder lady lake lamp language laptop large later latin laugh laundry lava law lawn lawsuit layer lazy leader leaf learn leave lecture left leg legal legend leisure lemon lend length lens leopard lesson letter level liar liberty library license life lift light like limb limit link lion liquid list little live lizard load loan lobster local lock logic lonely long loop lottery loud lounge love loyal lucky luggage lumber lunar lunch luxury lyrics machine mad magic magnet maid mail main major make mammal man manage mandate mango mansion manual maple marble march margin marine market marriage mask mass master match material math matrix matter maximum maze meadow mean measure meat mechanic medal media melody melt member memory mention menu mercy merge merit merry mesh message metal method middle midnight milk million mimic mind minimum minor minute miracle mirror misery miss mistake mix mixed mixture mobile model modify mom moment monitor monkey monster month moon moral more morning mosquito mother motion motor mountain mouse move movie much muffin mule multiply muscle museum mushroom music must mutual myself mystery myth naive name napkin narrow nasty nation nature near neck need negative neglect neither nephew nerve nest net network neutral never news next nice night noble noise nominee noodle normal north nose notable note nothing notice novel now nuclear number nurse nut oak obey object oblige obscure observe obtain obvious occur ocean october odor off offer office often oil okay old olive olympic omit once one onion online only open opera opinion oppose option orange orbit orchard order ordinary organ orient original orphan ostrich other outdoor outer output outside oval oven over own owner oxygen oyster ozone pact paddle page pair palace palm panda panel panic panther paper parade parent park parrot party pass patch path patient patrol pattern pause pave payment peace peanut pear peasant pelican pen penalty pencil people pepper perfect permit person pet phone photo phrase physical piano picnic picture piece pig pigeon pill pilot pink pioneer pipe pistol pitch pizza place planet plastic plate play please pledge pluck plug plunge poem poet point polar pole police pond pony pool popular portion position possible post potato pottery poverty powder power practice praise predict prefer prepare present pretty prevent price pride primary print priority prison private prize problem process produce profit program project promote proof property prosper protect proud provide public pudding pull pulp pulse pumpkin punch pupil puppy purchase purity purpose purse push put puzzle pyramid quality quantum quarter question quick quit quiz quote rabbit raccoon race rack radar radio rail rain raise rally ramp ranch random range rapid rare rate rather raven raw razor ready real reason rebel rebuild recall receive recipe record recycle reduce reflect reform refuse region regret regular reject relax release relief rely remain remember remind remove render renew rent reopen repair repeat replace report require rescue resemble resist resource response result retire retreat return reunion reveal review reward rhythm rib ribbon rice rich ride ridge rifle right rigid ring riot ripple risk ritual rival river road roast robot robust rocket romance roof rookie room rose rotate rough round route royal rubber rude rug rule run runway rural sad saddle sadness safe sail salad salmon salon salt salute same sample sand satisfy satoshi sauce sausage save say scale scan scare scatter scene scheme school science scissors scorpion scout scrap screen script scrub sea search season seat second secret section security seed seek segment select sell seminar senior sense sentence series service session settle setup seven shadow shaft shallow share shed shell sheriff shield shift shine ship shiver shock shoe shoot shop short shoulder shove shrimp shrug shuffle shy sibling sick side siege sight sign silent silk silly silver similar simple since sing siren sister situate six size skate sketch ski skill skin skirt skull slab slam sleep slender slice slide slight slim slogan slot slow slush small smart smile smoke smooth snack snake snap sniff snow soap soccer social sock soda soft solar soldier solid solution solve someone song soon sorry sort soul sound soup source south space spare spatial spawn speak special speed spell spend sphere spice spider spike spin spirit split spoil sponsor spoon sport spot spray spread spring spy square squeeze squirrel stable stadium staff stage stairs stamp stand start state stay steak steel stem step stereo stick still sting stock stomach stone stool story stove strategy street strike strong struggle student stuff stumble style subject submit subway success such sudden suffer sugar suggest suit summer sun sunny sunset super supply supreme sure surface surge surprise surround survey suspect sustain swallow swamp swap swarm swear sweet swift swim swing switch sword symbol symptom syrup system table tackle tag tail talent talk tank tape target task taste tattoo taxi teach team tell ten tenant tennis tent term test text thank that theme then theory there they thing this thought three thrive throw thumb thunder ticket tide tiger tilt timber time tiny tip tired tissue title toast tobacco today toddler toe together toilet token tomato tomorrow tone tongue tonight tool tooth top topic topple torch tornado tortoise toss total tourist toward tower town toy track trade traffic tragic train transfer trap trash travel tray treat tree trend trial tribe trick trigger trim trip trophy trouble truck true truly trumpet trust truth try tube tuition tumble tuna tunnel turkey turn turtle twelve twenty twice twin twist two type typical ugly umbrella unable unaware uncle uncover under undo unfair unfold unhappy uniform unique unit universe unknown unlock until unusual unveil update upgrade uphold upon upper upset urban urge usage use used useful useless usual utility vacant vacuum vague valid valley valve van vanish vapor various vast vault vehicle velvet vendor venture venue verb verify version very vessel veteran viable vibrant vicious victory video view village vintage violin virtual virus visa visit visual vital vivid vocal voice void volcano volume vote voyage wage wagon wait walk wall walnut want warfare warm warrior wash wasp waste water wave way wealth weapon wear weasel weather web wedding weekend weird welcome west wet whale what wheat wheel when where whip whisper wide width wife wild will win window wine wing wink winner winter wire wisdom wise wish witness wolf woman wonder wood wool word work world worry worth wrap wreck wrestle wrist write wrong yard year yellow you young youth zebra zero zone zoo".normalize("NFKD").split(" "),n.DashPhrase=s})(globalThis.window||{},t),r.exports=t}(Hn,Hn.exports)),Hn.exports}$S();const zS=document.getElementById("output"),yt=document.getElementById("outputSend"),Dt=document.getElementById("outputReceive"),U=(r,e)=>{console.log(r)};let Fi=[];const Ih="";let Fe,Tl=null;const kl="/fileferry/filetransfer/1.0.0";let _l="",ve=null,we=null,Ce=null,Lt=!1,lr=!1,Kr=!1;function KS(r,e=3e4){return new Promise((t,n)=>{let s;const i=()=>{const c=r.getMultiaddrs().find(l=>l.toString().includes("/p2p-circuit"));c&&(r.removeEventListener("self:peer:update",i),clearTimeout(s),t(c))},o=r.getMultiaddrs().find(a=>a.toString().includes("/p2p-circuit"));if(o){t(o);return}s=setTimeout(()=>{r.removeEventListener("self:peer:update",i),n(new Error("Timeout: Could not obtain a circuit address via relay."))},e),r.addEventListener("self:peer:update",i)})}async function qS(){const r="https://raw.githubusercontent.com/pradt2/always-online-stun/master/valid_hosts.txt",e="https://ip-api.com/json/",t="userGeoData";let s;try{const i=localStorage.getItem(t);if(i){const d=JSON.parse(i);d.expiry&&d.expiry>Date.now()?(s=d.data,console.log("Using cached user geo data.")):(localStorage.removeItem(t),console.log("User geo cache expired or invalid."))}if(!s){console.log("Fetching user geo data from API.");const d=await fetch(e);if(!d.ok)throw new Error(`Failed to fetch user geo data: ${d.status} ${d.statusText}`);s=await d.json();const h={data:s,expiry:Date.now()+1728e5};localStorage.setItem(t,JSON.stringify(h)),console.log("User geo data fetched and cached.")}const o=s.lat,a=s.lon,u=(await(await fetch(r)).text()).trim().split(`
`).map(d=>{const h=d.split(":")[0];if(!geoLocs[h])return[d,1/0];const[p,f]=geoLocs[h];if(typeof p!="number"||typeof f!="number")return[d,1/0];const g=((o-p)**2+(a-f)**2)**.5;return[d,g]}).reduce(([d,h],[p,f])=>h<=f?[d,h]:[p,f])[0];return U("Closest STUN server found: "+u,zS),u}catch(i){console.error("Error in getClosestStunServer:",i),localStorage.removeItem(t);return}}async function WS(){const r=await qS().catch(t=>{U("Could not fetch closest STUN server: "+t.message)}),e=r!=null?`stun:${r}`:"stun:l.google.com:19302";Fe=await BS({addresses:{listen:["/p2p-circuit","/webrtc"]},transports:[mv({filter:Jd}),Z0({rtcConfiguration:{iceServers:[{urls:e},{urls:"turn:195.114.14.137:3478?transport=udp",username:"ferryCaptain",credential:"i^YV13eTPOHdVzWm#2t5"},{urls:"turn:195.114.14.137:3478?transport=tcp",username:"ferryCaptain",credential:"i^YV13eTPOHdVzWm#2t5"}]}}),Rb({discoverRelays:0})],connectionEncrypters:[Ny()],streamMuxers:[sw()],connectionGater:{denyDialMultiaddr:()=>!1},services:{identify:o0(),identifyPush:a0(),ping:g0()},connectionManager:{maxConnections:1/0,minConnections:0,pollInterval:5e3}}),await Fe.start(),U(`Node started with Peer ID: ${Fe.peerId.toString()}`),Fi=Fe.getMultiaddrs().map(t=>t.toString()),U("My addresses:"),Fi.forEach(t=>U(`  - ${t}`)),Fe.addEventListener("connection:open",async t=>{const n=t.detail,s=n.remotePeer,i=s.toString(),o=n.remoteAddr.toString(),a=n.remoteAddr.toString(),c=Lt?yt:Dt;let l="";if(U(`Connection OPENED with: ${i} on ${o}`),i===Tl){if(U("INFO: Connection to the relay server confirmed."),Lt&&!we)try{const u=await KS(Fe);U(`Obtained listen address: ${u.toString()}`,yt),U(`Registering passphrase '${_l}'...`,yt);const d=`${Ih}/phrase`,h=await fetch(d,{method:"POST",body:JSON.stringify({Maddr:u.toString(),Phrase:_l}),headers:{"Content-type":"application/json; charset=UTF-8"}});if(h.ok)U("Passphrase registered. Waiting for peer to connect...",yt);else{const p=await`Failed to register passphrase. Status: ${h.status}. Error: ${await h.text()}`;U(p,yt),l=p,Lt=!1}}catch(u){const d=`Error during sender setup after relay connect: ${u.message}`;U(d),l=d,Lt=!1}l!=""&&(Pl(l),l="");return}if(!we||we.toString()!==i?(U(`Peer connected: ${i}. Old activePeerId: ${we?.toString()}`),we=s):U(`Re-established or additional cohttps://fileferry.smp46.me/nnection to existing peer: ${i}`),Lt&&we&&we.toString()===i&&ve&&!Kr)if(a.includes("/webrtc")&&!a.includes("/p2p-circuit")){U(`Sender: Direct WebRTC connection to Peer ${we.toString()} active. Attempting file transfer.`);try{document.getElementById("fileInfoArea").style.display="none",document.getElementById("loadingIndicator").style.display="block";const u=await Fe.dialProtocol(we,kl,{signal:AbortSignal.timeout(1e4)}),d=await Fe.services.ping.ping(we);U("Successfully pinged peer: "+we.toString()+" with RTT: "+d+"ms",c),Ce=u,U("File transfer stream opened to peer (via WebRTC).",yt),U(`Sending file '${ve.name}' (${ve.size} bytes)...`,yt),Kr=!0;const h=JSON.stringify({name:ve.name,size:ve.size}),p=new TextEncoder().encode(h+`
`),f=await YS(ve),g=new J;g.append(p),g.append(f),await Ce.sink(g),U("Finished sending file data.",yt),await Ce.closeWrite(),U("File sent completely. Closed stream for writing.",yt),ve=null,Ce=null,Kr=!1,Lt=!1,document.getElementById("loadingIndicator").style.display="none",document.getElementById("completionMessage").style.display="block"}catch(u){l=`Opening/writing file transfer stream to peer failed: ${u.message}`,U(l),Ce=null}}else a.includes("/p2p-circuit")?U(`Sender: Relayed connection to Peer ${we.toString()} established (${a}). Waiting for potential direct WebRTC upgrade before transferring.`):U(`Sender: Peer connection via other transport (${a}). File transfer logic currently prioritizes direct WebRTC.`);else lr&&we&&we.toString()===i?U(`Receiver: Connected to sender peer (${a}). Waiting for incoming file stream.`):Lt&&we&&ve&&Kr&&Ce&&U(`Sender: File transfer already initiated for ${ve.name}. Current stream active.`);l!=""&&(Pl(l),document.getElementById("loadingIndicator").style.display="none",document.getElementById("errorMessage").style.display="block",l="")}),Fe.addEventListener("connection:close",t=>{const n=t.detail.remotePeer.toString();U(`Connection CLOSED with: ${n}`),we&&n&&!Kr===we.toString()?(U("Active peer connection closed."),we=null,Ce=null):n===Tl&&U("Connection to relay closed.")}),Fe.addEventListener("self:peer:update",()=>{Fi=Fe.getMultiaddrs().map(t=>t.toString())}),Fe.handle(kl,async({stream:t,connection:n})=>{const s=Dt;U(`Incoming file transfer stream from ${n.remotePeer.toString()}`),Ce&&Ce!==t&&U("Warning: A new stream is replacing an existing activeStream in receiver."),Ce=t,we=n.remotePeer,document.getElementById("initialReceiveUI").style.display="none",document.getElementById("receivingLoadingIndicator").style.display="block";let i="",o=[],a="downloaded_file",c=0,l="application/octet-stream",u=!1,d=0;try{for await(const h of Ce.source){if(!h||h.length===0){U("Received an empty or null chunk.",s);continue}const p=h.subarray();if(u)o.push(p),d+=p.length,U(`Received ${d} bytes... (Expected: ${c>0?c:"N/A"})`,s);else{let f="",g=0;try{const m=new TextDecoder("utf-8",{fatal:!1}).decode(p),v=m.indexOf(`
`);if(v!==-1){f=m.substring(0,v),g=new TextEncoder().encode(f+`
`).byteLength;try{const b=JSON.parse(f);a=b.name||a,c=b.size||c,l=b.type||l,U(`Receiving file: ${a} (Size: ${c} bytes, Type: ${l})`,s),u=!0}catch(b){U(`Could not parse file header JSON: "${f}". Error: ${b.message}. Treating chunk as data.`,s),u=!0,g=0}}else U("No newline for header in this chunk. Assuming no header or all data.",s),u=!0,g=0}catch(m){U(`Error decoding chunk for header: ${m.message}. Treating as raw data.`,s),u=!0,g=0}if(g<p.byteLength){const m=p.subarray(g);m.length>0&&(o.push(m),d+=m.length,U(`Received ${d} bytes (from first chunk's body)...`,s))}}}if(U(`File stream source ended. Total bytes received in buffer: ${d}`,s),d>0){const h=new Blob(o,{type:l}),p=URL.createObjectURL(h),f=document.createElement("a");f.href=p,f.download=a;const g=`${(d/1024/1024).toFixed(2)}`;f.textContent=`Download ${g} MB)`,f.style.display="hidden",document.getElementById("receivingLoadingIndicator").style.display="none",document.getElementById("receivedFileName").innerText=a,document.getElementById("receivedFileSize").innerText=`${g} MB`,document.getElementById("downloadReadyMessage").style.display="block",document.body.appendChild(f),f.click(),document.body.removeChild(f)}else i="No data received in file buffer. Download will be empty.",U(i,s)}catch(h){i=`Error reading from file stream: ${h.message}`,U(i)}finally{if(U("Closing incoming file stream processing."),Ce)try{typeof Ce.close=="function"?await Ce.close():typeof Ce.abort=="function"&&await Ce.abort()}catch(h){i=`Error closing stream: ${h.message}`,U("Error closing stream on receiver:")}Ce=null}}),errorMessage!=""&&U(errorMessage)}function VS(r){r.preventDefault()}function HS(r){if(r.preventDefault(),r.dataTransfer.items){const e=[...r.dataTransfer.items].find(t=>t.kind==="file");e&&(ve=e.getAsFile())}else r.dataTransfer.files&&r.dataTransfer.files.length>0&&(ve=r.dataTransfer.files[0]);ve?(U(`Selected file: ${ve.name} (Size: ${ve.size} bytes)`),document.getElementById("fileNameDisplay").textContent=ve.name,document.getElementById("fileSizeDisplay").textContent=`${(ve.size/1024/1024).toFixed(2)} MB`,window.actions.startSendProcess()):U("No file selected from drop.")}function GS(){var r=document.getElementById("generatedPhraseDisplay");navigator.clipboard.writeText(r.innerText)}document.addEventListener("DOMContentLoaded",()=>{document.getElementById("phraseInput").value="";const r=document.getElementById("drop_zone");r.addEventListener("dragover",VS),r.addEventListener("drop",HS),document.getElementById("fileInput").addEventListener("change",a=>{if(a.target.files&&a.target.files[0]){var c=a.target.files[0],l=new FileReader;l.readAsDataURL(c),l.onload=u=>{c=u.target.result},l.onerror=u=>{console.error("FileReader error: ",u)},ve=c,document.getElementById("fileNameDisplay").textContent=ve.name,document.getElementById("fileSizeDisplay").textContent=`${(ve.size/1024/1024).toFixed(2)} MB`,window.actions.startSendProcess()}else console.log("No file selected.")}),document.getElementById("copyPhraseButton").addEventListener("click",GS),U("handlers attached.");const n=document.getElementById("receiveModeButton");n.onclick=window.actions.startReceiveProcess;const s=document.getElementById("errorWindow"),i=document.getElementById("errorMessageContainer"),o=document.getElementById("closeErrorButton");s.addEventListener("click",function(a){a.target===s&&(goHome(),Ll())}),i.addEventListener("click",function(a){a.stopPropagation()}),o.addEventListener("click",function(){Ll(),goHome()})});window.actions={startSendProcess:async()=>{if(!Fe){U("Libp2p node not initialized yet.");return}{U("Relay address not configured.");return}},startReceiveProcess:async()=>{if(!Fe){U("Libp2p node not initialized yet.");return}lr=!0,Lt=!1,Dt&&(Dt.innerHTML=""),U("Receiver Mode Activated. Enter passphrase to connect.");const e=document.getElementById("phraseInput").value.trim();if(!e){U("Please enter a phrase to lookup."),lr=!1;return}U(`Looking up passphrase '${e}'...`);try{const t=`${Ih}/phrase/${encodeURIComponent(e)}`,n=await fetch(t);if(!n.ok){let a=`Failed to lookup phrase '${e}'. Status: ${n.status}`;try{const c=await n.json();a+=` - ${c.message||n.statusText}`}catch{a+=` - ${n.statusText}`}U(a,Dt),lr=!1;return}const i=(await n.json()).maddr;if(!i){U("Phrase found, but no multiaddress provided.",Dt),lr=!1;return}const o=Q(i);U(`Retrieved sender address: '${o.toString()}'. Attempting to connect...`,Dt),await Fe.dial(o,{signal:AbortSignal.timeout(1e4)}),U("Dialing sender initiated. Waiting for connection...",Dt)}catch(t){U(`Error in receive process: ${t.message||t}`),lr=!1}}};WS().catch(r=>{console.error("Failed to initialize libp2p node:",r),U(`Critical Error: Failed to initialize libp2p node - ${r.message}`)});function YS(r){return new Promise(function(e,t){let n=new FileReader;n.readAsArrayBuffer(r),n.onload=function(s){const i=new Uint8Array(s.target.result);e(i)},n.onerror=t})}function Pl(r){const e=document.getElementById("errorMessageText"),t=document.getElementById("errorWindow");e.textContent=r,t.classList.remove("hidden")}function Ll(){document.getElementById("errorWindow").classList.add("hidden")}
